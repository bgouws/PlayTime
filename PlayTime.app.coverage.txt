/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/ApiCall/ApiCallModel.swift:
    1|       |//
    2|       |//  ApiCallVM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class PTApiCall {
   11|       |    public static var artistArr = [String]()
   12|       |    public static var titleArr = [String]()
   13|       |    public static var artArr = [String]()
   14|       |    public static var previewURL = [String]()
   15|       |    
   16|      0|    public static func ptCallApi() {
   17|      0|        
   18|      0|    }
   19|       |    
   20|       |    public enum PTTracksError:Error {
   21|       |        case noData
   22|       |    }
   23|       |    public struct PTTrackRequest {
   24|       |        let resourceURL: URL
   25|       |        //let aPI_KEY = "//itunes.apple.com/search"
   26|      1|        init(trackTitle: String, trackArtist: String) {
   27|      1|            let currentTrackTitle = trackTitle.replacingOccurrences(of: " ", with: "+", options: .literal, range: nil)
   28|      1|            let currentTrackArtist = trackArtist.replacingOccurrences(of: " ", with: "+", options: .literal, range: nil)
   29|      1|            let apiQuery = "https://itunes.apple.com/search/media=music&entity=song&term=\(currentTrackTitle)+\(currentTrackArtist)"
   30|      1|            guard let resourceURL = URL(string: apiQuery) else {fatalError()}
   31|      1|            self.resourceURL = resourceURL
   32|      1|        }
   33|       |        
   34|      1|        public func ptGetData(completion: @escaping(Result<[PTTrackDetails], PTTracksError>) -> Void)  {
   35|      1|            let dataTask = URLSession.shared.dataTask(with: resourceURL) { data, _, _ in
   36|      1|                guard let jsonData = data else {
   37|      0|                    completion(.failure(.noData))
   38|      0|                    return
   39|      1|                }
   40|      1|                do {
   41|      1|                    let decoder = JSONDecoder()
   42|      1|                    let tracksResponse = try decoder.decode(PTTracks.self, from: jsonData)
   43|      1|                    let actualData = tracksResponse.results
   44|      1|                    (completion(.success(actualData)))
   45|      1|                } catch {
   46|      0|                    completion(.failure(.noData))
   47|      1|                }
   48|      1|            }
   49|      1|            dataTask.resume()
   50|      1|        }
   51|       |    }
   52|      1|    public static func ptPreparePlayList() {
   53|      1|        var list = [PTTrackDetails]()
   54|      1|        let myRequest = PTApiCall.PTTrackRequest.init(trackTitle: "Rock", trackArtist: "")
   55|      1|        myRequest.ptGetData { result in
   56|      1|            switch result {
   57|      1|            case .failure(let error): print(error)
   58|      1|            case .success(let actualData): list = actualData
   59|      1|            }
   60|      1|            //Creating textfile test
   61|      1|            let fileName = "Tracks"
   62|      1|            // swiftlint:disable all
   63|      1|            let DocumentDirURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask,
   64|      1|                                                              appropriateFor: nil, create: true)
   65|      1|            // swiftlint:enable all
   66|      1|            let fileURL = DocumentDirURL.appendingPathComponent(fileName).appendingPathExtension("txt")
   67|      1|            print("File Path: \(fileURL.path)")
   68|      1|            var writeString = ""
   69|     19|            for i in 0...18 {
   70|     19|                writeString += ("\(i)*\(list[i].artistName)*\(list[i].trackName)*\(list[i].artworkUrl100)*\(list[i].previewUrl)$")
   71|     19|            }
   72|      1|            do {
   73|      1|                //Write to file
   74|      1|                try writeString.write(to: fileURL, atomically: true, encoding: String.Encoding.utf8)
   75|      1|            } catch let error as NSError {
   76|      0|                print("Failed to write to URL ")
   77|      0|                print(error)
   78|      1|            }
   79|      1|            var readString = ""
   80|      1|            do {
   81|      1|                readString = try String(contentsOf: fileURL)
   82|      1|            } catch let error as NSError {
   83|      0|                print("Failed to read file")
   84|      0|                print(error)
   85|      1|            }
   86|      1|            print("Contents of the file: \n\(readString)")
   87|      1|            let everyTrackDetail = readString.components(separatedBy: "$")
   88|     19|            for track in 0...18 {
   89|     19|                let temp = everyTrackDetail[track]
   90|     19|                let data = temp.components(separatedBy: "*")
   91|     19|                artistArr.append(data[1])
   92|     19|                titleArr.append(data[2])
   93|     19|                artArr.append(data[3])
   94|     19|                previewURL.append(data[4])
   95|     19|            }
   96|      1|            //let myPTPlayMusic = PTPlayMusic()
   97|      1|            PTPlayMusic.setData(artist: artistArr, title: titleArr,previewURL: previewURL,artString: artArr)
   98|      1|            print("#############################")
   99|      1|            print("Successfully populated arrays")
  100|      1|            print("#############################")
  101|      1|        }
  102|      1|    }
  103|       |}
  104|       |

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/ApiCall/PlayMusicViewModel.swift:
    1|       |//
    2|       |//  PlayMusicVM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class PTPlayMusic {
   11|       |    public var ptArtwork: [UIImage] = []
   12|       |    public static var ptTitle: [String] = []
   13|       |    public static var ptArtist: [String] = []
   14|       |    public static var ptPreviewUrl: [String] = []
   15|       |    public static var ptArtString: [String] = []
   16|       |    public static var currentImage: [UIImage] = []
   17|       |    static var count = 0
   18|       |    
   19|      0|    public func readData() {
   20|      0|        PTApiCall.ptPreparePlayList()
   21|      0|    }
   22|      0|    public init() {
   23|      0|        
   24|      0|    }
   25|      1|    public static func setData(artist: [String], title: [String],previewURL: [String], artString: [String]){
   26|      1|        self.ptTitle = title
   27|      1|        self.ptArtist = artist
   28|      1|        self.ptPreviewUrl = previewURL
   29|      1|        self.ptArtString = artString
   30|      1|        prepareImage()
   31|      1|    }
   32|      1|    public static func prepareImage() {
   33|      1|        let url = ptArtString[count]
   34|      1|        let finalURL = URL(string: url)
   35|      1|        if let data = try? Data(contentsOf: finalURL!) {
   36|      0|            if let image = UIImage(data: data){
   37|      0|                DispatchQueue.main.async {
   38|      0|                    self.currentImage.append(image)
   39|      0|                }
   40|      0|            }
   41|      1|        }
   42|      1|        self.count += 1
   43|      1|    }
   44|      0|    public static func getImage(count: Int) -> UIImage {
   45|      0|        return currentImage[count]
   46|      0|    }
   47|      0|    public static func getTitle(count: Int) -> String {
   48|      0|        return ptTitle[count]
   49|      0|    }
   50|      0|    public static func getArtist(count: Int) -> String {
   51|      0|        return ptArtist[count]
   52|      0|    }
   53|      0|    public static func getPreviewuRL(count: Int) -> String {
   54|      0|        return ptPreviewUrl[count]
   55|      0|    }
   56|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Login/AccountManagementViewModel.swift:
    1|       |//
    2|       |//  AccountManagementVM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import FirebaseAuth
   10|       |
   11|       |public class PTAccountManagement {
   12|      5|    public init() {
   13|      5|    }
   14|      0|    public func ptSignIn(email: String, password: String, completion: @escaping (_ val: Bool) -> ()) {
   15|      0|        let myPTSignIn = PTSignIn()
   16|      0|        _ = myPTSignIn.ptSignIn(email, password) { (success) in
   17|      0|            print(success)
   18|      0|            completion(success)
   19|      0|        }
   20|      0|    }
   21|      0|    public func ptSignUp(email: String, password: String, conPassword: String, completion: @escaping (_ val: Bool) -> ()) {
   22|      0|        //var myPTValidation = PTValidation()
   23|      0|        //myPTValidation.ptValidationCheckSignUp(email: email, password: password, conPassword: conPassword)
   24|      0|         let myPTCreateUser = PTCreateUser()
   25|      0|        _ = myPTCreateUser.ptSignUpNow(email: email, password: password, completion: { (success) in
   26|      0|            print(success)
   27|      0|            completion(success)
   28|      0|        })
   29|      0|    }
   30|      0|    public func ptSignOut() {
   31|      0|        do {
   32|      0|            try Auth.auth().signOut()
   33|      0|        } catch let signOutError as NSError {
   34|      0|          print ("Error signing out: %@", signOutError)
   35|      0|        }
   36|      0|    }
   37|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Login/SignInModel.swift:
    1|       |//
    2|       |//  SignIn.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import FirebaseAuth
   10|       |import FirebaseDatabase
   11|       |
   12|       |public class PTSignIn {
   13|      0|    public func ptSignIn(_ email: String, _ password: String, completion: @escaping (_ val: Bool) -> ()) {
   14|      0|        _ = Auth.auth().signIn(withEmail: email, password: password) {
   15|      0|            (result, error) in let success = (error == nil)
   16|      0|            completion(success)
   17|      0|        }
   18|      0|    }
   19|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Login/SignOutModel.swift:
    1|       |//
    2|       |//  SignOutM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/03/02.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import FirebaseAuth
   10|       |
   11|       |public class PTSignOut {
   12|      0|    public func ptSignOutUser() {
   13|      0|        do {
   14|      0|            try Auth.auth().signOut()
   15|      0|        } catch let error {
   16|      0|            print("Failed to sign out with error: ", error.localizedDescription)
   17|      0|        }
   18|      0|    }
   19|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Login/SignUpModel.swift:
    1|       |//
    2|       |//  SignUp.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import FirebaseDatabase
   10|       |import FirebaseAuth
   11|       |
   12|       |public class PTCreateUser {
   13|      0|    public func ptSignUpNow(email: String, password: String, completion: @escaping (_ val: Bool) -> ()) {
   14|      0|        _ = Auth.auth().createUser(withEmail:  email, password: password) {
   15|      0|        (result, error) in let success = (error == nil)
   16|      0|        completion(success)
   17|      0|        }
   18|      0|    }
   19|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Login/ValidationViewModel.swift:
    1|       |//
    2|       |//  ValidationVM.swift
    3|       |//  Pods
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class PTValidation {
   11|      2|    public func ptValidationCheckSignIn(email: String, password: String) -> Bool {
   12|      2|        var flag = false
   13|      2|        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
   14|      2|        let emailPred = NSPredicate(format:"SELF MATCHES %@", emailRegEx)
   15|      2|        
   16|      2|        if (emailPred.evaluate(with: email) && password != "") {
   17|      1|            print("Passed Validation")
   18|      1|            flag = true
   19|      2|        } else {
   20|      1|            print("Failed Validation")
   21|      1|            flag = false
   22|      2|        }
   23|      2|        return flag
   24|      2|    }
   25|      2|    public func ptValidationCheckSignUp(email: String, password: String, conPassword: String) -> Bool {
   26|      2|        var flag =  false
   27|      2|        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
   28|      2|        let emailPred = NSPredicate(format:"SELF MATCHES %@", emailRegEx)
   29|      2|        
   30|      2|        if (emailPred.evaluate(with: email) && password != "" && password == conPassword) {
   31|      1|            flag =  true
   32|      2|        } else {
   33|      1|            flag = false
   34|      2|        }
   35|      2|        return flag
   36|      2|    }
   37|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Tasks/TaskM.swift:
    1|       |//
    2|       |//  Task.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/03/02.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import UIKit
   10|       |
   11|       |public class PTTask {
   12|       |    public var title: String
   13|       |    public var  hour: String
   14|       |    public var  minute: String
   15|       |    public var  second: String
   16|      5|    public init(title: String, hour: String, minute: String, second: String) {
   17|      5|        self.title = title
   18|      5|        self.hour = hour
   19|      5|        self.minute = minute
   20|      5|        self.second = second
   21|      5|    }
   22|       |}
   23|       |
   24|       |

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/TasteSelection/TasteM.swift:
    1|       |//
    2|       |//  TasteM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/28.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import FirebaseAuth
   10|       |import FirebaseDatabase
   11|       |
   12|       |public class PTTaste {
   13|      0|    public func ptStoreTaste(taste: [String]) {
   14|      0|        let ref = Database.database().reference()
   15|      0|        let user = Auth.auth().currentUser?.uid
   16|      0|        ref.child("users").child(user!).setValue(["Music Taste": taste])
   17|      0|        print("Music taste successfully saved - PTFramework")
   18|      0|        }
   19|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/TasteSelection/TasteSelectionVM.swift:
    1|       |//
    2|       |//  TasteSelectionVM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import FirebaseDatabase
   10|       |import FirebaseAuth
   11|       |
   12|       |public class PTTasteSelection {
   13|      0|    public init() {
   14|      0|        
   15|      0|    }
   16|      0|    public func ptSaveMusicTaste(taste: [String]) {
   17|      0|        //Calling Model
   18|      0|        let myPTTaste = PTTaste()
   19|      0|        myPTTaste.ptStoreTaste(taste: taste)
   20|      0|    }
   21|      0|    public func ptCheckList(value: String, taste: [String]) -> Bool {
   22|      0|        for genre in taste where genre == value {
   23|      0|            return true
   24|      0|        }
   25|      0|          return false
   26|      0|    }
   27|       |}

/Users/bgouws/Desktop/PTFramework/PTPod/PTFramework/Classes/Timer/TimerViewModel.swift:
    1|       |//
    2|       |//  TimerVM.swift
    3|       |//  PTFramework
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/03/02.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import AVFoundation
   10|       |import CoreMedia
   11|       |
   12|       |public class PTTimer {
   13|       |    var ptTitle = ""
   14|       |    var ptArtist = ""
   15|       |    var ptArt = UIImage()
   16|       |    var ptPreview = ""
   17|       |    var tCount = 0
   18|       |    var pCount = 0
   19|       |    var nextTrack: AVPlayerItem?
   20|       |    var finalTitle = "Default"
   21|       |    var finalArtist = "Default"
   22|       |    var player: AVPlayer?
   23|       |    var playerItem: AVPlayerItem?
   24|       |    var timer = Timer()
   25|       |    public var isTimerRunning = false
   26|       |    var counter = 0.0
   27|       |    var fHour = ""
   28|       |    var fMinute = ""
   29|       |    var fSecond = ""
   30|       |    var fTitle = ""
   31|       |    let myPTPlayMusic = PTPlayMusic()
   32|      0|    public init() {
   33|      0|        
   34|      0|    }
   35|      0|    public func ptInit() -> [Any] {
   36|      0|        ptTitle = PTPlayMusic.getTitle(count: tCount)
   37|      0|        ptArtist = PTPlayMusic.getArtist(count: tCount)
   38|      0|        ptPreview = PTPlayMusic.getPreviewuRL(count: tCount)
   39|      0|        nextTrack = loadNextTrack()
   40|      0|        
   41|      0|        ///Adding track data to an array of any (String, String, UIImage)
   42|      0|        var trackData = [Any]()
   43|      0|        trackData.append(ptTitle)
   44|      0|        trackData.append(ptArtist)
   45|      0|        trackData.append(ptArt)
   46|      0|        //ptInitialLoad()
   47|      0|        return trackData
   48|      0|    }
   49|      0|    public func ptInitialLoad() {
   50|      0|        let fUrl = URL(string: ptPreview)
   51|      0|        let fPlayerItem: AVPlayerItem = AVPlayerItem(url: fUrl!)
   52|      0|        player = AVPlayer(playerItem: fPlayerItem)
   53|      0|        //player?.pause()
   54|      0|    }
   55|      0|    public func ptStart() {
   56|      0|        print("Starting Player")
   57|      0|        player!.play()
   58|      0|    }
   59|       |    
   60|      0|    public func ptStopPlayback() {
   61|      0|        player!.pause()
   62|      0|    }
   63|      0|       public func timerSetUp() {
   64|      0|            isTimerRunning = true
   65|      0|        }
   66|      0|        public func setupTrack() {
   67|      0|            //Setting up tracks
   68|      0|            ptTitle = PTPlayMusic.getTitle(count: tCount)
   69|      0|            ptArtist = PTPlayMusic.getArtist(count: tCount)
   70|      0|            ptPreview = PTPlayMusic.getPreviewuRL(count: tCount)
   71|      0|            player?.play()
   72|      0|            //PTPlayMusic.prepareImage()
   73|      0|        }
   74|      0|        public func loadNextTrack() -> AVPlayerItem {
   75|      0|            let ptNextPreview = PTPlayMusic.getPreviewuRL(count: tCount)
   76|      0|            let url = URL(string: ptNextPreview)
   77|      0|            let nextTrack: AVPlayerItem = AVPlayerItem(url: url!)
   78|      0|            player = AVPlayer(playerItem: nextTrack)
   79|      0|            PTPlayMusic.prepareImage()
   80|      0|            tCount += 1
   81|      0|            return nextTrack
   82|      0|        }
   83|      0|        public func ptStop() {
   84|      0|            player?.pause()
   85|      0|            isTimerRunning = false
   86|      0|            timer.invalidate()
   87|      0|        }
   88|      0|        public func ptBackToList() {
   89|      0|            player!.pause()
   90|      0|            isTimerRunning = false
   91|      0|            counter = 0.0
   92|      0|        }
   93|      0|        public func ptResetTimer() {
   94|      0|            player?.pause()
   95|      0|            isTimerRunning = false
   96|      0|            timer.invalidate()
   97|      0|            counter = 0.0
   98|      0|        }
   99|       |    }

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/AppDelegate.swift:
    1|       |//
    2|       |//  AppDelegate.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/04.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |
   12|       |@UIApplicationMain
   13|       |class AppDelegate: UIResponder, UIApplicationDelegate {
   14|       |    func application(_ application: UIApplication,
   15|      1|                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
   16|      1|        // Override point for customization after application launch.
   17|      1|        FirebaseApp.configure()
   18|      1|        return true
   19|      1|    }
   20|       |
   21|       |    // MARK: UISceneSession Lifecycle
   22|       |
   23|       |    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession,
   24|      0|                     options: UIScene.ConnectionOptions) -> UISceneConfiguration {
   25|      0|        // Called when a new scene session is being created.
   26|      0|        // Use this method to select a configuration to create the new scene with.
   27|      0|        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
   28|      0|    }
   29|       |
   30|      0|    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
   31|      0|        // Called when the user discards a scene session.
   32|      0|        // If any sessions were discarded while the application was not running,
   33|      0|        // this will be called shortly after application:didFinishLaunchingWithOptions.
   34|      0|        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
   35|      0|    }
   36|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Extensions/CustomButton.swift:
    1|       |//
    2|       |//  File.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/04.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class CustomButton: UIButton {
   12|      0|    override init(frame: CGRect) {
   13|      0|        super.init(frame: frame)
   14|      0|    }
   15|      0|    required init?(coder aDecoder: NSCoder) {
   16|      0|        super.init(coder: aDecoder)
   17|      0|    }
   18|      0|    func setupButton() {
   19|      0|        setShadow()
   20|      0|        styleButton()
   21|      0|        shakeButton()
   22|      0|    }
   23|      0|    private func setShadow() {
   24|      0|        layer.shadowColor = UIColor.black.cgColor
   25|      0|        layer.shadowOffset = CGSize(width: 0.0, height: 6.0)
   26|      0|        layer.shadowRadius = 8
   27|      0|        layer.shadowOpacity = 0.5
   28|      0|        clipsToBounds = true
   29|      0|        layer.masksToBounds = false
   30|      0|    }
   31|      0|    func styleButton() {
   32|      0|        titleLabel?.font = UIFont(name: "AvenirNext-DemiBold", size: 20)
   33|      0|        layer.cornerRadius = 25
   34|      0|        layer.borderWidth = 3.0
   35|      0|        layer.borderColor = UIColor.darkGray.cgColor
   36|      0|    }
   37|      0|    func shakeButton() {
   38|      0|        let shake = CABasicAnimation(keyPath: "position")
   39|      0|        shake.duration = 0.1
   40|      0|        shake.repeatCount = 2
   41|      0|        shake.autoreverses = true
   42|      0|        let fromPoint = CGPoint(x: center.x - 8, y: center.y)
   43|      0|        let fromValue = NSValue(cgPoint: fromPoint)
   44|      0|        let toPoint = CGPoint(x: center.x - 8, y: center.y)
   45|      0|        let toValue = NSValue(cgPoint: toPoint)
   46|      0|        shake.fromValue = fromValue
   47|      0|        shake.toValue = toValue
   48|      0|        layer.add(shake, forKey: "position")
   49|      0|    }
   50|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Extensions/UIButtonExtension.swift:
    1|       |//
    2|       |//  UIButtonExtension.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/05.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |extension UIButton {
   13|      0|    func pulsate() {
   14|      0|        let pulse = CASpringAnimation(keyPath: "transform.scale")
   15|      0|        pulse.duration = 0.1
   16|      0|        pulse.fromValue = 0.95
   17|      0|        pulse.toValue = 1.0
   18|      0|        pulse.autoreverses = true
   19|      0|        pulse.repeatCount = 2
   20|      0|        pulse.initialVelocity = 0.5
   21|      0|        pulse.damping = 1.0
   22|      0|        layer.add(pulse, forKey: nil)
   23|      0|    }
   24|      0|    func uxButton() {
   25|      0|        layer.shadowColor = UIColor.black.cgColor
   26|      0|        layer.shadowOffset = CGSize(width: 0.0, height: 6.0)
   27|      0|        layer.shadowRadius = 8
   28|      0|        layer.shadowOpacity = 0.5
   29|      0|        clipsToBounds = true
   30|      0|        layer.masksToBounds = false
   31|      0|        titleLabel?.font = UIFont(name: "AvenirNext-DemiBold", size: 20)
   32|      0|        layer.cornerRadius = layer.frame.height/2
   33|      0|        layer.backgroundColor = UIColor.init(red: 52.0/255, green: 126.0/255, blue: 181.0/255, alpha: 1).cgColor
   34|      0|        layer.borderWidth = 1.0
   35|      0|        layer.masksToBounds = true
   36|      0|        layer.borderColor = UIColor.darkGray.cgColor
   37|      0|        layer.shadowColor = UIColor.black.cgColor
   38|      0|        layer.shadowOffset = CGSize(width: 0.0, height: 6.0)
   39|      0|        layer.shadowRadius = 8
   40|      0|        layer.shadowOpacity = 0.5
   41|      0|        clipsToBounds = true
   42|      0|        layer.masksToBounds = false
   43|      0|    }
   44|      0|    func uxButton2() {
   45|      0|        layer.shadowColor = UIColor.black.cgColor
   46|      0|        layer.shadowOffset = CGSize(width: 0.0, height: 6.0)
   47|      0|        layer.shadowRadius = 8
   48|      0|        layer.shadowOpacity = 0.5
   49|      0|        clipsToBounds = true
   50|      0|        layer.masksToBounds = false
   51|      0|        titleLabel?.font = UIFont(name: "AvenirNext-DemiBold", size: 20)
   52|      0|        layer.cornerRadius = layer.frame.height/2
   53|      0|        layer.backgroundColor = UIColor.init(red: 1, green: 1, blue: 1, alpha: 1).cgColor
   54|      0|        layer.borderWidth = 2.0
   55|      0|        layer.masksToBounds = true
   56|      0|        layer.borderColor = UIColor.systemRed.cgColor
   57|      0|        layer.shadowColor = UIColor.black.cgColor
   58|      0|        layer.shadowOffset = CGSize(width: 0.0, height: 6.0)
   59|      0|        layer.shadowRadius = 8
   60|      0|        layer.shadowOpacity = 0.5
   61|      0|        clipsToBounds = true
   62|      0|        layer.masksToBounds = false
   63|      0|    }
   64|      2|    func customButton() {
   65|      2|        layer.shadowColor = UIColor.black.cgColor
   66|      2|        layer.shadowOffset = CGSize(width: 0.0, height: 6.0)
   67|      2|        layer.shadowRadius = 8
   68|      2|        layer.shadowOpacity = 0.5
   69|      2|        clipsToBounds = true
   70|      2|        layer.masksToBounds = false
   71|      2|        titleLabel?.font = UIFont(name: "AvenirNext-DemiBold", size: 20)
   72|      2|        layer.cornerRadius = 10
   73|      2|        layer.borderWidth = 3.0
   74|      2|        layer.borderColor = UIColor.darkGray.cgColor
   75|      2|    }
   76|      0|    func customSelectButton() {
   77|      0|        backgroundColor = UIColor.gray
   78|      0|        clipsToBounds = true
   79|      0|        layer.masksToBounds = false
   80|      0|        layer.cornerRadius = 10
   81|      0|        layer.borderWidth = 3.0
   82|      0|        layer.borderColor = UIColor.darkGray.cgColor
   83|      0|        titleLabel!.font = UIFont(name: "AvenirNext-DemiBold", size: 10)
   84|      0|    }
   85|      0|    func colorChange(checker: Bool) {
   86|      0|        let greenColor = UIColor(red: 0.37, green: 0.58, blue: 0.33, alpha: 1.0)
   87|      0|        let yellowColor = UIColor(red: 0.95, green: 0.84, blue: 0.38, alpha: 1.0)
   88|      0|        var mainColor = UIColor(red: 0.5, green: 100/255, blue: 1, alpha: 0.5)
   89|      0|        if checker == true {
   90|      0|            mainColor = greenColor
   91|      0|        } else {
   92|      0|            mainColor = yellowColor
   93|      0|        }
   94|      0|        if backgroundColor == UIColor.lightGray {
   95|      0|            backgroundColor = mainColor
   96|      0|        } else {
   97|      0|            backgroundColor = UIColor.lightGray
   98|      0|        }
   99|      0|    }
  100|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Extensions/UITextFieldExtension.swift:
    1|       |//
    2|       |//  UITextFieldExtension.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/05.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |extension UITextField {
   13|      2|    func customTextBox() {
   14|      2|        layer.masksToBounds = true
   15|      2|        layer.masksToBounds = true
   16|      2|        layer.cornerRadius = 15.0
   17|      2|        layer.borderWidth = 1.0
   18|      2|        layer.borderColor = UIColor.black.cgColor
   19|      2|    }
   20|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Extensions/UITextViewExtension.swift:
    1|       |//
    2|       |//  File.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/14.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |extension UITextView {
   13|      0|    func customBio() {
   14|      0|        backgroundColor = UIColor.white
   15|      0|        clipsToBounds = true
   16|      0|        layer.masksToBounds = false
   17|      0|        layer.cornerRadius = 10
   18|      0|        layer.borderWidth = 1.0
   19|      0|        layer.borderColor = UIColor.black.cgColor
   20|      0|    }
   21|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/SceneDelegate.swift:
    1|       |//
    2|       |//  SceneDelegate.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/04.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SceneDelegate: UIResponder, UIWindowSceneDelegate {
   12|       |
   13|       |    var window: UIWindow?
   14|       |    func scene(_ scene: UIScene, willConnectTo session: UISceneSession,
   15|      1|               options connectionOptions: UIScene.ConnectionOptions) {
   16|      1|        // Use this method to optionally configure and attach
   17|      1|        // the UIWindow `window` to the provided UIWindowScene `scene`.
   18|      1|        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
   19|      1|        // This delegate does not imply the connecting scene or
   20|      1|        // session are new (see `application:configurationForConnectingSceneSession` instead).
   21|      1|        // swiftlint:disable all
   22|      1|        guard let _ = (scene as? UIWindowScene) else { return }
   23|      1|        // swiftlint:enable all
   24|      1|    }
   25|       |
   26|      0|    func sceneDidDisconnect(_ scene: UIScene) {
   27|      0|        // Called as the scene is being released by the system.
   28|      0|        // This occurs shortly after the scene enters the background, or when its session is discarded.
   29|      0|        // Release any resources associated with this scene that can be re-created the next time the scene connects.
   30|      0|        // The scene may re-connect later, as its session was not neccessarily
   31|      0|        //discarded (see `application:didDiscardSceneSessions` instead).
   32|      0|    }
   33|       |
   34|      1|    func sceneDidBecomeActive(_ scene: UIScene) {
   35|      1|        // Called when the scene has moved from an inactive state to an active state.
   36|      1|        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
   37|      1|    }
   38|       |
   39|      0|    func sceneWillResignActive(_ scene: UIScene) {
   40|      0|        // Called when the scene will move from an active state to an inactive state.
   41|      0|        // This may occur due to temporary interruptions (ex. an incoming phone call).
   42|      0|    }
   43|       |
   44|      1|    func sceneWillEnterForeground(_ scene: UIScene) {
   45|      1|        // Called as the scene transitions from the background to the foreground.
   46|      1|        // Use this method to undo the changes made on entering the background.
   47|      1|    }
   48|       |
   49|      0|    func sceneDidEnterBackground(_ scene: UIScene) {
   50|      0|        // Called as the scene transitions from the foreground to the background.
   51|      0|        // Use this method to save data, release shared resources, and store enough scene-specific state information
   52|      0|        // to restore the scene back to its current state.
   53|      0|    }
   54|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/CurrentTaskViewController.swift:
    1|       |//
    2|       |//  CreateTaskViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/18.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |//import MediaPlayer
   11|       |import PTFramework
   12|       |import AVFoundation
   13|       |import CoreMedia
   14|       |
   15|       |//Creating Variable
   16|       |var ptTitle = ""
   17|       |var ptArtist = ""
   18|       |var ptArt = UIImage()
   19|       |var ptPreview = ""
   20|       |var count = 0
   21|       |
   22|       |class CurrentTaskViewController: UIViewController {
   23|       |    @IBOutlet weak var lblSongTitle: UILabel!
   24|       |    @IBOutlet weak var lblSongArtist: UILabel!
   25|       |    @IBOutlet weak var txtHeaderTask: UILabel!
   26|       |    @IBOutlet weak var btnReset: UIButton!
   27|       |    @IBOutlet weak var btnBack: UIButton!
   28|       |    @IBOutlet weak var btnStart: UIButton!
   29|       |    @IBOutlet weak var btnStop: UIButton!
   30|       |    @IBOutlet weak var timerLabel: UILabel!
   31|       |    @IBOutlet weak var imgArtWork: UIImageView!
   32|       |    var timer = Timer()
   33|       |    var isTimerRunning = false
   34|       |    var counter = 0.0
   35|       |    var fHour = ""
   36|       |    var fMinute = ""
   37|       |    var fSecond = ""
   38|       |    var fTitle = ""
   39|       |    let myPTTimer = PTTimer()
   40|       |    let myPTPlayMusic = PTPlayMusic()
   41|      0|    override func viewDidLoad() {
   42|      0|        super.viewDidLoad()
   43|      0|        btnStart.customButton()
   44|      0|        btnStop.customButton()
   45|      0|        btnReset.customButton()
   46|      0|        btnBack.customButton()
   47|      0|        btnStop.isEnabled = false
   48|      0|        btnReset.isEnabled = false
   49|      0|        //Getting data from the viewModel
   50|      0|        let trackData = myPTTimer.ptInit()
   51|      0|        //Setting up first track
   52|      0|        //imgArtWork.image = trackData[2] as? UIImage
   53|      0|        imgArtWork.image = PTPlayMusic.getImage(count: count)
   54|      0|        lblSongTitle.text = trackData[0] as? String
   55|      0|        lblSongArtist.text = trackData[1] as? String
   56|      0|        txtHeaderTask.text = "Your Current Task: \(fTitle)"
   57|      0|        NotificationCenter.default.addObserver(self, selector: #selector(prepareNextTrack),
   58|      0|        name: .AVPlayerItemDidPlayToEndTime, object: nil)
   59|      0|    }
   60|      0|    @objc func prepareNextTrack() {
   61|      0|        let trackData = myPTTimer.ptInit()
   62|      0|        //imgArtWork.image = trackData[2] as? UIImage
   63|      0|        count += 1
   64|      0|        print("Prepare next track has been called")
   65|      0|        imgArtWork.image = PTPlayMusic.getImage(count: count)
   66|      0|        lblSongTitle.text = trackData[0] as? String
   67|      0|        lblSongArtist.text = trackData[1] as? String
   68|      0|        myPTTimer.setupTrack()
   69|      0|    }
   70|      0|    @IBAction func btnStart(_ sender: Any) {
   71|      0|        print("Start Button Selected")
   72|      0|        if !myPTTimer.isTimerRunning {
   73|      0|            timer = Timer.scheduledTimer(timeInterval: 0.1, target: self,
   74|      0|                                         selector: #selector(runTimer), userInfo: nil, repeats: true)
   75|      0|        }
   76|      0|        myPTTimer.ptStart()
   77|      0|        btnStop.isEnabled = true
   78|      0|        btnStart.isEnabled = false
   79|      0|        btnReset.isEnabled = true
   80|      0|    }
   81|       |    // MARK: Helper Methods
   82|       |    @objc
   83|      0|    func runTimer() {
   84|      0|        //timerLabel.text = "\(hourString):\(minuteString):\(secondString)"
   85|      0|        counter += 0.1
   86|      0|        var minuteString = ""
   87|      0|        var secondString = ""
   88|      0|        var hourString = ""
   89|      0|        let flooredCounter = Int(floor(counter))
   90|      0|        let hour = flooredCounter / 3600
   91|      0|        let minute = (flooredCounter % 36000) / 60
   92|      0|        hourString = "\(hour)"
   93|      0|        if hour < 10 {
   94|      0|            hourString = "0\(hour)"
   95|      0|        }
   96|      0|        minuteString = "\(minute)"
   97|      0|        if minute < 10 {
   98|      0|            minuteString = "0\(minute)"
   99|      0|        }
  100|      0|        let second = (flooredCounter % 3600) % 60
  101|      0|        secondString = "\(second)"
  102|      0|        if second < 10 {
  103|      0|            secondString = "0\(second)"
  104|      0|        }
  105|      0|        timerLabel.text = "\(hourString):\(minuteString):\(secondString)"
  106|      0|        //print("\(CMTimeGetSeconds(player!.currentTime()))")
  107|      0|        if hourString == fHour && minuteString == fMinute && secondString == fSecond {
  108|      0|            myPTTimer.ptStopPlayback()
  109|      0|            btnStop.isEnabled = false
  110|      0|            timerLabel.textColor = UIColor.systemGreen
  111|      0|            myPTTimer.isTimerRunning = false
  112|      0|            timer.invalidate()
  113|      0|        }
  114|      0|    }
  115|      0|    @IBAction func btnStop(_ sender: Any) {
  116|      0|        myPTTimer.ptStop()
  117|      0|        btnStart.isEnabled = true
  118|      0|        btnStop.isEnabled = false
  119|      0|        myPTTimer.isTimerRunning = false
  120|      0|        timer.invalidate()
  121|      0|    }
  122|      0|    @IBAction func btnBack(_ sender: Any) {
  123|      0|        myPTTimer.ptBackToList()
  124|      0|        timer.invalidate()
  125|      0|        timerLabel.text = "00:00:00"
  126|      0|        self.performSegue(withIdentifier: "backListView", sender: self)
  127|      0|    }
  128|      0|    @IBAction func btnReset(_ sender: Any) {
  129|      0|        myPTTimer.ptResetTimer()
  130|      0|        timer.invalidate()
  131|      0|        counter = 0.0
  132|      0|        timerLabel.textColor = UIColor.black
  133|      0|        timerLabel.text = "00:00:00"
  134|      0|        btnStart.isEnabled = true
  135|      0|        btnReset.isEnabled = false
  136|      0|        btnStop.isEnabled = false
  137|      0|    }
  138|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/HomeViewController.swift:
    1|       |//
    2|       |//  HomeViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/17.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |import PTFramework
   12|       |
   13|       |class HomeViewController: UIViewController {
   14|       |
   15|       |    @IBOutlet weak var btnSignOut: UIButton!
   16|       |    @IBOutlet weak var btnMove: UIButton!
   17|      0|    override func viewDidLoad() {
   18|      0|        super.viewDidLoad()
   19|      0|        // Do any additional setup after loading the view.
   20|      0|        btnSignOut.customButton()
   21|      0|        authenticateUserAndConfigure()
   22|      0|    }
   23|       |    // MARK: Button Action Functions
   24|      0|    @IBAction func btnSignOut(_ sender: Any) {
   25|      0|        let alertController = UIAlertController(title: nil, message: "Are you sure you want to sign out?",
   26|      0|                                                preferredStyle: .actionSheet)
   27|      0|        alertController.addAction(UIAlertAction(title: "Sign Out", style: .destructive, handler: {(_) in self.signOut()
   28|      0|        }))
   29|      0|        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
   30|      0|        present(alertController, animated: true, completion: nil)
   31|      0|    }
   32|       |    // MARK: Functions
   33|      0|    func authenticateUserAndConfigure() {
   34|      0|        if Auth.auth().currentUser == nil {
   35|      0|            DispatchQueue.main.async {
   36|      0|                self.performSegue(withIdentifier: "displayLoginView", sender: self)
   37|      0|            }
   38|      0|        }
   39|      0|    }
   40|      0|    @IBAction func btnMove(_ sender: Any) {
   41|      0|        self.performSegue(withIdentifier: "taskView", sender: self)
   42|      0|    }
   43|      0|    func signOut() {
   44|      0|        let myPTAccountManagement = PTAccountManagement()
   45|      0|        myPTAccountManagement.ptSignOut()
   46|      0|        self.performSegue(withIdentifier: "displayLoginView", sender: self)
   47|      0|    }
   48|      0|    public func unit(name: String, surname: String) -> Bool {
   49|      0|        if name == "Mike" && surname == "Smith" {
   50|      0|            print("Name: \(name)  Surname: \(surname)")
   51|      0|            return true
   52|      0|        }
   53|      0|        return false
   54|      0|    }
   55|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/LaunchViewController.swift:
    1|       |//
    2|       |//  LaunchViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/18.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class LaunchViewController: UIViewController {
   12|       |
   13|       |    @IBOutlet weak var imgLogo: UIImageView!
   14|      0|    override func viewDidLoad() {
   15|      0|        super.viewDidLoad()
   16|      0|
   17|      0|        // Do any additional setup after loading the view.
   18|      0|    }
   19|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/MusicTasteViewController.swift:
    1|       |//
    2|       |//  MusicTasteViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/16.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |import PTFramework
   12|       |
   13|       |class MusicTasteViewController: UIViewController {
   14|       |
   15|       |    var list: [String] = []
   16|       |    var checker = true
   17|       |    var count = 0
   18|       |    let myPTTasteSelection = PTTasteSelection()
   19|       |    // MARK: Components
   20|       |    @IBOutlet weak var btnRock: UIButton!
   21|       |    @IBOutlet weak var btnPop: UIButton!
   22|       |    @IBOutlet weak var btnIndie: UIButton!
   23|       |    @IBOutlet weak var btnStart: UIButton!
   24|       |    @IBOutlet weak var btnCountry: UIButton!
   25|       |    @IBOutlet weak var btnHipHop: UIButton!
   26|       |    @IBOutlet weak var btnJazz: UIButton!
   27|      0|    override func viewDidLoad() {
   28|      0|        super.viewDidLoad()
   29|      0|        // Do any additional setup after loading the view.
   30|      0|        btnStart.customButton()
   31|      0|        setButton()
   32|      0|    }
   33|       |    // MARK: Button Action Functions
   34|      0|    @IBAction func btnRock(_ sender: UIButton) {
   35|      0|        sender.colorChange(checker: checker)
   36|      0|        changeCheck()
   37|      0|        if myPTTasteSelection.ptCheckList(value: "Rock", taste: list) && btnRock.backgroundColor != UIColor.lightGray {
   38|      0|            return
   39|      0|        } else if myPTTasteSelection.ptCheckList(value: "Rock", taste: list) &&
   40|      0|                  btnRock.backgroundColor == UIColor.lightGray {
   41|      0|            list.remove(at: getIndex(value: "Rock"))
   42|      0|        } else {
   43|      0|            list.append("Rock")
   44|      0|        }
   45|      0|    }
   46|      0|    @IBAction func btnPop(_ sender: UIButton) {
   47|      0|        sender.colorChange(checker: checker)
   48|      0|        changeCheck()
   49|      0|        if myPTTasteSelection.ptCheckList(value: "Pop", taste: list) && btnPop.backgroundColor != UIColor.lightGray {
   50|      0|            return
   51|      0|        } else if myPTTasteSelection.ptCheckList(value: "Pop", taste: list) &&
   52|      0|                  btnPop.backgroundColor == UIColor.lightGray {
   53|      0|            list.remove(at: getIndex(value: "Pop"))
   54|      0|        } else {
   55|      0|            list.append("Pop")
   56|      0|        }
   57|      0|    }
   58|      0|    @IBAction func btnIndie(_ sender: UIButton) {
   59|      0|        sender.colorChange(checker: checker)
   60|      0|        changeCheck()
   61|      0|        if myPTTasteSelection.ptCheckList(value: "Indie", taste: list) && btnIndie.backgroundColor != UIColor.lightGray {
   62|      0|            return
   63|      0|        } else if myPTTasteSelection.ptCheckList(value: "Indie", taste: list) &&
   64|      0|                  btnIndie.backgroundColor == UIColor.lightGray {
   65|      0|            list.remove(at: getIndex(value: "Indie"))
   66|      0|        } else {
   67|      0|            list.append("Indie")
   68|      0|        }
   69|      0|    }
   70|      0|    @IBAction func btnHipHop(_ sender: UIButton) {
   71|      0|        sender.colorChange(checker: checker)
   72|      0|        changeCheck()
   73|      0|        if myPTTasteSelection.ptCheckList(value: "HipHop", taste: list) &&
   74|      0|           btnHipHop.backgroundColor != UIColor.lightGray {
   75|      0|            return
   76|      0|        } else if myPTTasteSelection.ptCheckList(value: "HipHop", taste: list) &&
   77|      0|                  btnHipHop.backgroundColor == UIColor.lightGray {
   78|      0|            list.remove(at: getIndex(value: "HipHop"))
   79|      0|        } else {
   80|      0|            list.append("HipHop")
   81|      0|        }
   82|      0|    }
   83|      0|    @IBAction func btnCountry(_ sender: UIButton) {
   84|      0|        sender.colorChange(checker: checker)
   85|      0|        changeCheck()
   86|      0|        if myPTTasteSelection.ptCheckList(value: "Country", taste: list) &&
   87|      0|           btnCountry.backgroundColor != UIColor.lightGray {
   88|      0|            return
   89|      0|        } else if myPTTasteSelection.ptCheckList(value: "Country", taste: list) &&
   90|      0|                  btnCountry.backgroundColor == UIColor.lightGray {
   91|      0|            list.remove(at: getIndex(value: "Country"))
   92|      0|        } else {
   93|      0|            list.append("Country")
   94|      0|        }
   95|      0|    }
   96|      0|    @IBAction func btnJazz(_ sender: UIButton) {
   97|      0|        sender.colorChange(checker: checker)
   98|      0|        changeCheck()
   99|      0|        if myPTTasteSelection.ptCheckList(value: "Jazz", taste: list) && btnJazz.backgroundColor != UIColor.lightGray {
  100|      0|            return
  101|      0|        } else if myPTTasteSelection.ptCheckList(value: "Jazz", taste: list) &&
  102|      0|                  btnJazz.backgroundColor == UIColor.lightGray {
  103|      0|            list.remove(at: getIndex(value: "Jazz"))
  104|      0|        } else {
  105|      0|            list.append("Jazz")
  106|      0|        }
  107|      0|    }
  108|      0|    func changeCheck() {
  109|      0|        if checker == true {
  110|      0|            checker = false
  111|      0|        } else {
  112|      0|            checker = true
  113|      0|        }
  114|      0|    }
  115|      0|    func setButton() {
  116|      0|        btnRock.backgroundColor = UIColor.lightGray
  117|      0|        btnPop.backgroundColor = UIColor.lightGray
  118|      0|        btnIndie.backgroundColor = UIColor.lightGray
  119|      0|        btnHipHop.backgroundColor = UIColor.lightGray
  120|      0|        btnCountry.backgroundColor = UIColor.lightGray
  121|      0|        btnJazz.backgroundColor = UIColor.lightGray
  122|      0|    }
  123|      0|    @IBAction func btnStart(_ sender: Any) {
  124|      0|        //Calling MusicSelection ViewModel
  125|      0|        myPTTasteSelection.ptSaveMusicTaste(taste: list)
  126|      0|        self.performSegue(withIdentifier: "ShowList", sender: self)
  127|      0|    }
  128|      0|    func checkList(value: String) -> Bool {
  129|      0|        for genre in list where genre == value {
  130|      0|            return true
  131|      0|        }
  132|      0|          return false
  133|      0|    }
  134|      0|    func getIndex(value: String) -> Int {
  135|      0|        let index = list.firstIndex(of: value)
  136|      0|        print(index!)
  137|      0|        return index!
  138|      0|    }
  139|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/SignInViewController.swift:
    1|       |//
    2|       |//  SignInViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/05.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SignInViewController: UIViewController {
   12|       |
   13|      0|    override func viewDidLoad() {
   14|      0|        super.viewDidLoad()
   15|      0|        // Do any additional setup after loading the view
   16|      0|    }
   17|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/SignViewController.swift:
    1|       |//
    2|       |//  SignViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/05.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |import FirebaseDatabase
   12|       |import PTFramework
   13|       |
   14|       |class SignViewController: UIViewController, UITextFieldDelegate {
   15|       |
   16|       |    //Components
   17|       |    @IBOutlet weak var txtEmail: UITextField!
   18|       |    @IBOutlet weak var txtPassword: UITextField!
   19|       |    @IBOutlet weak var txtComfirmPassword: UITextField!
   20|       |    @IBOutlet weak var btnCreateAccount: UIButton!
   21|       |    @IBOutlet weak var btnBack: UIButton!
   22|       |    //Function that Loads they view
   23|      0|    override func viewDidLoad() {
   24|      0|        super.viewDidLoad()
   25|      0|        // Do any additional setup after loading the view.
   26|      0|        //let ref = Data
   27|      0|        //Styling The Components
   28|      0|        btnCreateAccount.customButton()
   29|      0|        btnBack.customButton()
   30|      0|        txtPassword.customTextBox()
   31|      0|        txtEmail.customTextBox()
   32|      0|        txtComfirmPassword.customTextBox()
   33|      0|        txtPassword.delegate = self
   34|      0|        txtEmail.delegate = self
   35|      0|        txtComfirmPassword.delegate = self
   36|      0|    }
   37|      0|    deinit {
   38|      0|        //Stop Listening for keyboard hide/show events
   39|      0|        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillShowNotification, object: nil)
   40|      0|        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil)
   41|      0|        NotificationCenter.default.removeObserver(self,
   42|      0|                                                  name: UIResponder.keyboardWillChangeFrameNotification, object: nil)
   43|      0|    }
   44|       |    // MARK: - Button Clicked Functions
   45|      0|    @IBAction func btnBack(_ sender: UIButton) {
   46|      0|        self.performSegue(withIdentifier: "launchView", sender: self)
   47|      0|    }
   48|      0|    @IBAction func btnCreate(_ sender: Any) {
   49|      0|        //Collecting data from the view
   50|      0|        let email = txtEmail.text
   51|      0|        let password = txtPassword.text
   52|      0|        let conPassword = txtComfirmPassword.text
   53|      0|        //Sending data to the VM to be validated
   54|      0|        var myPTAccountManagement = PTAccountManagement()
   55|      0|        myPTAccountManagement.ptSignUp(email: email!, password: password!, conPassword: conPassword!) { (success) in
   56|      0|        if success {
   57|      0|            self.performSegue(withIdentifier: "styleView", sender: self)
   58|      0|        }
   59|      0|        }
   60|      0|//        if PTAccountManagement.ptCreateUser(email: email!, password: password!, conPassword: conPassword!) {
   61|      0|//            self.performSegue(withIdentifier: "styleView", sender: self)
   62|      0|//        } else {
   63|      0|//            clearFields()
   64|      0|//            let alertController = UIAlertController(title: "Sign Up Unsuccessful",
   65|      0|//                                                    message: "Error Signing Up.", preferredStyle: .alert)
   66|      0|//            alertController.addAction(UIAlertAction(title: "Dismiss", style: .default))
   67|      0|//            self.present(alertController, animated: true, completion: nil)
   68|      0|//        }
   69|      0|    }
   70|       |    // MARK: - Functions
   71|       |    //Clearing component
   72|      0|    func clearFields() {
   73|      0|        txtEmail.text = ""
   74|      0|        txtPassword.text = ""
   75|      0|        txtComfirmPassword.text = ""
   76|      0|    }
   77|       |    //Hiding the keyboard
   78|      0|    func hideKeyboard() {
   79|      0|        txtEmail.resignFirstResponder()
   80|      0|        txtPassword.resignFirstResponder()
   81|      0|        txtComfirmPassword.resignFirstResponder()
   82|      0|    }
   83|       |    //UITextFieldDelegate Methods
   84|      0|    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
   85|      0|        hideKeyboard()
   86|      0|        return true
   87|      0|    }
   88|      0|    func creatUser(email: String, password: String) {
   89|      0|        Auth.auth().createUser(withEmail: email, password: password) { (result, error) in
   90|      0|            if let error = error {
   91|      0|                print("Failed to create user ", error.localizedDescription)
   92|      0|                return
   93|      0|            }
   94|      0|            guard let uid = result?.user.uid else { return }
   95|      0|            Database.database().reference().child("users").child(uid).updateChildValues(
   96|      0|                ["email": email], withCompletionBlock: { error, _ in
   97|      0|                if let error = error {
   98|      0|                    print("Failed to update database values with error: ", error.localizedDescription)
   99|      0|                    return
  100|      0|            }
  101|      0|                print("Successful Sign Up")
  102|      0|                self.performSegue(withIdentifier: "styleView", sender: self)
  103|      0|            })
  104|      0|        }
  105|      0|    }
  106|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/TableViewCell.swift:
    1|       |//
    2|       |//  TableViewCell.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/18.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import PTFramework
   11|       |
   12|       |class TableViewCell: UITableViewCell {
   13|       |    @IBOutlet weak var lblTime: UILabel!
   14|       |    @IBOutlet weak var lblTitle: UILabel!
   15|      5|    func setTask(task: PTTask) {
   16|      5|        lblTitle.text = "\(task.title)\t\t\t\tDuration:\t \(task.hour):\(task.minute):\(task.second)"
   17|      5|    }
   18|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/TaskListViewController.swift:
    1|       |//
    2|       |//  TaskListViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/18.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |import PTFramework
   12|       |
   13|       |class TaskListViewController: UIViewController {
   14|       |
   15|       |    var finalHour = ""
   16|       |    var finalMinute = ""
   17|       |    var finalSecond = ""
   18|       |    var finalTitle = ""
   19|       |    let move = "SignOutView"
   20|       |    var flag = false
   21|       |    //@IBOutlet weak var btnAddTask: UIButton!
   22|       |    @IBOutlet weak var btnLogout: UIButton!
   23|       |    @IBOutlet weak var btnCancel: UIButton!
   24|       |    @IBOutlet weak var txtTaskTitle: UITextField!
   25|       |    @IBOutlet weak var txtTitle: UITextField!
   26|       |    @IBOutlet weak var txtDuration: UITextField!
   27|       |    @IBOutlet weak var tableView: UITableView!
   28|       |    @IBOutlet weak var btnAddSingleTask: UIButton!
   29|       |    //@IBOutlet weak var btnAddNow: UIButton!
   30|       |    var tasks: [PTTask] = []
   31|      1|    override func viewDidLoad() {
   32|      1|        super.viewDidLoad()
   33|      1|        print("Calling Api")
   34|      1|        //PTApiCall.ptPreparePlayList()
   35|      1|        let myPTPlayMusic = PTPlayMusic()
   36|      1|        myPTPlayMusic.readData()
   37|      1|        tasks = createTask()
   38|      1|        tableView.delegate = self
   39|      1|        tableView.dataSource = self
   40|      1|        authenticateUserAndConfigure()
   41|      1|        // Do any additional setup after loading the view.
   42|      1|    }
   43|      1|    func authenticateUserAndConfigure() {
   44|      1|        if Auth.auth().currentUser == nil {
   45|      1|            DispatchQueue.main.async {
   46|      1|                self.performSegue(withIdentifier: "SignOutView", sender: self)
   47|      1|            }
   48|      1|        }
   49|      1|    }
   50|      0|    @IBAction func btnLogout(_ sender: Any) {
   51|      0|        let alertController = UIAlertController(title: nil, message: "Are you sure you want to sign out?",
   52|      0|                                                preferredStyle: .actionSheet)
   53|      0|        alertController.addAction(UIAlertAction(title: "Sign Out", style: .destructive,
   54|      0|                                                handler: {(_) in self.signOut(moveTo: self.move)
   55|      0|        }))
   56|      0|        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
   57|      0|        present(alertController, animated: true, completion: nil)
   58|      0|    }
   59|      1|    func createTask() -> [PTTask] { //Read text file here
   60|      1|        //Test
   61|      1|            //Creating textfile test
   62|      1|            let fileName = "Tasks"
   63|      1|            // swiftlint:disable all
   64|      1|            let DocumentDirURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask,
   65|      1|                                                              appropriateFor: nil, create: true)
   66|      1|            // swiftlint:enable all
   67|      1|            let fileURL = DocumentDirURL.appendingPathComponent(fileName).appendingPathExtension("txt")
   68|      1|            print("File Path: \(fileURL.path)")
   69|      1|            let writeString = "This is the data that I am writing the the text file"
   70|      1|            do {
   71|      1|                //Write to file
   72|      1|                try writeString.write(to: fileURL, atomically: true, encoding: String.Encoding.utf8)
   73|      1|            } catch let error as NSError {
   74|      0|                print("Failed to write to URL ")
   75|      0|                print(error)
   76|      1|            }
   77|      1|            var readString = ""
   78|      1|            do {
   79|      1|                readString = try String(contentsOf: fileURL)
   80|      1|            } catch let error as NSError {
   81|      0|                print("Failed to read file")
   82|      0|                print(error)
   83|      1|            }
   84|      1|            print("Contents of the file: \(readString)")
   85|      1|        //Test
   86|      1|        var tempTask: [PTTask] = []
   87|      1|        let task1 = PTTask(title: "Cooking", hour: "01", minute: "00", second: "00")
   88|      1|        let task2 = PTTask(title: "Cleaning", hour: "00", minute: "30", second: "00")
   89|      1|        let task3 = PTTask(title: "Working", hour: "02", minute: "30", second: "00")
   90|      1|        let task4 = PTTask(title: "Gyming", hour: "00", minute: "00", second: "10")
   91|      1|        let task5 = PTTask(title: "Shopping", hour: "00", minute: "45", second: "45")
   92|      1|        tempTask.append(task1)
   93|      1|        tempTask.append(task2)
   94|      1|        tempTask.append(task3)
   95|      1|        tempTask.append(task4)
   96|      1|        tempTask.append(task5)
   97|      1|        print("Music taste successfully saved - PTFramework")
   98|      1|        return tempTask
   99|      1|    }
  100|      0|    func insetNewTask() {
  101|      0|        let duration = txtDuration.text?.components(separatedBy: ":")
  102|      0|        finalHour = (duration?[0])!
  103|      0|        finalMinute = (duration?[1])!
  104|      0|        finalSecond = (duration?[2])!
  105|      0|        finalTitle = txtTitle.text!
  106|      0|        let newTask = PTTask(title: finalTitle, hour: finalHour, minute: finalMinute, second: finalSecond)
  107|      0|        tasks.append(newTask)
  108|      0|        let indexPath = IndexPath(row: tasks.count - 1, section: 0)
  109|      0|        tableView.beginUpdates()
  110|      0|        tableView.insertRows(at: [indexPath], with: .fade)
  111|      0|        tableView.endUpdates()
  112|      0|        txtTitle.text = ""
  113|      0|        txtDuration.text = ""
  114|      0|        view.endEditing(true)
  115|      0|    }
  116|      0|    @IBAction func btnAddSingleTask(_ sender: Any) {
  117|      0|        insetNewTask()
  118|      0|    }
  119|      0|    func signOut(moveTo: String) {
  120|      0|        do {
  121|      0|            flag = false
  122|      0|            try Auth.auth().signOut()
  123|      0|            self.performSegue(withIdentifier: moveTo, sender: self)
  124|      0|        } catch let error {
  125|      0|            print("Failed to sign out with error: ", error.localizedDescription)
  126|      0|        }
  127|      0|    }
  128|       |}
  129|       |
  130|       |extension TaskListViewController: UITableViewDataSource, UITableViewDelegate {
  131|      2|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  132|      2|        return tasks.count
  133|      2|    }
  134|      5|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  135|      5|        let task = tasks[indexPath.row]
  136|      5|        // swiftlint:disable all
  137|      5|        let cell = tableView.dequeueReusableCell(withIdentifier: "TaskCell") as! TableViewCell
  138|      5|        // swiftlint:enable all
  139|      5|        cell.setTask(task: task)
  140|      5|        return cell
  141|      5|    }
  142|       |    //To enable delete
  143|      5|    func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
  144|      5|        return true
  145|      5|    }
  146|       |    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle,
  147|      0|                   forRowAt indexPath: IndexPath) {
  148|      0|        if editingStyle == .delete {
  149|      0|            tasks.remove(at: indexPath.row)
  150|      0|            tableView.beginUpdates()
  151|      0|            tableView.deleteRows(at: [indexPath], with: .fade)
  152|      0|            tableView.endUpdates()
  153|      0|        }
  154|      0|    }
  155|      0|    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  156|      0|        print("You selected cell number: \(indexPath.row)!")
  157|      0|        flag = true
  158|      0|        finalHour = tasks[indexPath.row].hour
  159|      0|        finalMinute = tasks[indexPath.row].minute
  160|      0|        finalSecond = tasks[indexPath.row].second
  161|      0|        finalTitle = tasks[indexPath.row].title
  162|      0|        self.performSegue(withIdentifier: "ActiveTaskView", sender: self)
  163|      0|    }
  164|      1|    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  165|      1|        if flag {
  166|      0|            // swiftlint:disable all
  167|      0|            let vc = segue.destination as! CurrentTaskViewController
  168|      0|            // swiftlint:enable all
  169|      0|            vc.fHour = finalHour
  170|      0|            vc.fMinute = finalMinute
  171|      0|            vc.fSecond = finalSecond
  172|      0|            vc.fTitle = finalTitle
  173|      1|        }
  174|      1|    }
  175|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/ToDoViewController.swift:
    1|       |//
    2|       |//  ToDoViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/12.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ToDoViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
   12|       |    var list = ["Some", "Random", "Data"]
   13|       |    @IBOutlet weak var tblView: UITableView!
   14|      0|    override func viewDidLoad() {
   15|      0|        super.viewDidLoad()
   16|      0|        // Do any additional setup after loading the view.
   17|      0|    }
   18|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   19|      0|        return list.count
   20|      0|    }
   21|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   22|      0|        let cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: "pcell")
   23|      0|        cell.textLabel?.text = list[indexPath.row]
   24|      0|        return cell
   25|      0|    }
   26|       |    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle,
   27|      0|                   forRowAt indexPath: IndexPath) {
   28|      0|        if editingStyle == UITableViewCell.EditingStyle.delete {
   29|      0|            list.remove(at: indexPath.row)
   30|      0|            tblView.reloadData()
   31|      0|        }
   32|      0|    }
   33|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Play Time/Views/ViewController.swift:
    1|       |//
    2|       |//  ViewController.swift
    3|       |//  Play Time
    4|       |//
    5|       |//  Created by Brandon Gouws on 2020/02/04.
    6|       |//  Copyright © 2020 Brandon Gouws. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |import AVFoundation
   12|       |import PTFramework
   13|       |
   14|       |class ViewController: UIViewController, UITextFieldDelegate {
   15|       |
   16|       |    //Components
   17|       |    @IBOutlet weak var txtPassword: UITextField!
   18|       |    @IBOutlet weak var txtEmail: UITextField!
   19|       |    @IBOutlet weak var signIn: UIButton!
   20|       |    @IBOutlet weak var signUp: UIButton!
   21|       |    @IBOutlet weak var btnAPI: UIButton!
   22|       |    @IBOutlet weak var imgTest: UIImageView!
   23|       |
   24|      1|    override func viewDidLoad() {
   25|      1|        //This is the new update
   26|      1|        super.viewDidLoad()
   27|      1|        // Do any additional setup after loading the view.
   28|      1|        //Styling Components
   29|      1|        txtEmail.customTextBox()
   30|      1|        txtPassword.customTextBox()
   31|      1|        signUp.customButton()
   32|      1|        signIn.customButton()
   33|      1|        txtPassword.delegate = self
   34|      1|        txtEmail.delegate = self
   35|      1|        //Hitting Api
   36|      1|        //PTPlayMusic.ptPrint()
   37|      1|        //Calling API
   38|      1|    }
   39|      0|    deinit {
   40|      0|        //Stop Listening for keyboard hide/show events
   41|      0|        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillShowNotification, object: nil)
   42|      0|        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil)
   43|      0|        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillChangeFrameNotification,
   44|      0|                                                  object: nil)
   45|      0|    }
   46|       |    // MARK: Button Clicked Functions
   47|      0|    @IBAction func btnAPI(_ sender: Any) {
   48|      0|    }
   49|      0|    @IBAction func btnSignIn(_ sender: UIButton) {
   50|      0|        sender.pulsate()
   51|      0|        hideKeyboard()
   52|      0|        //variables
   53|      0|        let email = txtEmail.text
   54|      0|        let password = txtPassword.text
   55|      0|        //Sending Data to SignInVM
   56|      0|        let myPTAccountManagement = PTAccountManagement()
   57|      0|        myPTAccountManagement.ptSignIn(email: email!, password: password!) { (success) in
   58|      0|            if success {
   59|      0|                self.performSegue(withIdentifier: "HomeView", sender: self)
   60|      0|            }
   61|      0|        }
   62|      0|    }
   63|       |    // MARK: Functions
   64|      0|    @IBAction func btnSignUp(_ sender: UIButton) {
   65|      0|        sender.pulsate()
   66|      0|        self.performSegue(withIdentifier: "SignView", sender: self)
   67|      0|    }
   68|       |    //Clearing component
   69|      0|    func clearFields() {
   70|      0|        txtEmail.text = ""
   71|      0|        txtPassword.text = ""
   72|      0|    }
   73|       |    //Hiding the keyboard
   74|      0|    func hideKeyboard() {
   75|      0|        txtEmail.resignFirstResponder()
   76|      0|        txtPassword.resignFirstResponder()
   77|      0|    }
   78|       |    //UITextFieldDelegate Methods
   79|      0|    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
   80|      0|        hideKeyboard()
   81|      0|        return true
   82|      0|    }
   83|       |    override func willTransition(to newCollection: UITraitCollection,
   84|      0|                                 with coordinator: UIViewControllerTransitionCoordinator) {
   85|      0|        print(UIDevice.current.orientation.isLandscape)
   86|      0|    }
   87|      0|    func displayError() {
   88|      0|        let alertController = UIAlertController(title: "Sign In Unsuccessful", message: "Error Signing In.",
   89|      0|                                                preferredStyle: .alert)
   90|      0|        alertController.addAction(UIAlertAction(title: "Dismiss", style: .default))
   91|      0|        self.present(alertController, animated: true, completion: nil)
   92|      0|    }
   93|       |}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRActionCodeSettings.m:
    1|       |/*
    2|       |  * Copyright 2017 Google
    3|       |  *
    4|       |  * Licensed under the Apache License, Version 2.0 (the "License");
    5|       |  * you may not use this file except in compliance with the License.
    6|       |  * You may obtain a copy of the License at
    7|       |  *
    8|       |  *      http://www.apache.org/licenses/LICENSE2.0
    9|       |  *
   10|       |  * Unless required by applicable law or agreed to in writing, software
   11|       |  * distributed under the License is distributed on an "AS IS" BASIS,
   12|       |  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |  * See the License for the specific language governing permissions and
   14|       |  * limitations under the License.
   15|       |  */
   16|       |
   17|       |#import "FIRActionCodeSettings.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRActionCodeSettings
   22|       |
   23|      0|- (instancetype)init {
   24|      0|  self = [super init];
   25|      0|  if (self) {
   26|      0|    _iOSBundleID = [NSBundle mainBundle].bundleIdentifier;
   27|      0|  }
   28|      0|  return self;
   29|      0|}
   30|       |
   31|      0|- (void)setIOSBundleID:(NSString *)iOSBundleID {
   32|      0|   _iOSBundleID = [iOSBundleID copy];
   33|      0| }
   34|       |
   35|       |- (void)setAndroidPackageName:(NSString *)androidPackageName
   36|       |         installIfNotAvailable:(BOOL)installIfNotAvailable
   37|      0|                minimumVersion:(nullable NSString *)minimumVersion {
   38|      0|   _androidPackageName = [androidPackageName copy];
   39|      0|   _androidInstallIfNotAvailable = installIfNotAvailable;
   40|      0|   _androidMinimumVersion = [minimumVersion copy];
   41|      0| }
   42|       |
   43|       | @end
   44|       |
   45|       | NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuth.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import "FIRAuth_Internal.h"
   20|       |
   21|       |#if __has_include(<UIKit/UIKit.h>)
   22|       |#import <UIKit/UIKit.h>
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRAppInternal.h>
   26|       |#import <FirebaseCore/FIRComponent.h>
   27|       |#import <FirebaseCore/FIRComponentContainer.h>
   28|       |#import <FirebaseCore/FIRLibrary.h>
   29|       |#import <FirebaseCore/FIRLogger.h>
   30|       |#import <FirebaseCore/FIROptions.h>
   31|       |#import <GoogleUtilities/GULAppDelegateSwizzler.h>
   32|       |#import <GoogleUtilities/GULSceneDelegateSwizzler.h>
   33|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   34|       |
   35|       |#import "FIREmailPasswordAuthCredential.h"
   36|       |#import "FIRAdditionalUserInfo_Internal.h"
   37|       |#import "FIRAuthCredential_Internal.h"
   38|       |#import "FIRAuthDataResult_Internal.h"
   39|       |#import "FIRAuthDispatcher.h"
   40|       |#import "FIRAuthErrorUtils.h"
   41|       |#import "FIRAuthExceptionUtils.h"
   42|       |#import "FIRAuthGlobalWorkQueue.h"
   43|       |#import "FIRAuthKeychainServices.h"
   44|       |#import "FIRAuthOperationType.h"
   45|       |#import "FIRAuthSettings.h"
   46|       |#import "FIRAuthStoredUserManager.h"
   47|       |#import "FIRAuthWebUtils.h"
   48|       |#import "FIRUser_Internal.h"
   49|       |#import "FirebaseAuth.h"
   50|       |#import "FIRAuthBackend.h"
   51|       |#import "FIRAuthRequestConfiguration.h"
   52|       |#import "FIRCreateAuthURIRequest.h"
   53|       |#import "FIRCreateAuthURIResponse.h"
   54|       |#import "FIREmailLinkSignInRequest.h"
   55|       |#import "FIREmailLinkSignInResponse.h"
   56|       |#import "FIRGameCenterAuthCredential.h"
   57|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   58|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   59|       |#import "FIROAuthCredential_Internal.h"
   60|       |#import "FIRResetPasswordRequest.h"
   61|       |#import "FIRResetPasswordResponse.h"
   62|       |#import "FIRSendVerificationCodeRequest.h"
   63|       |#import "FIRSendVerificationCodeResponse.h"
   64|       |#import "FIRSetAccountInfoRequest.h"
   65|       |#import "FIRSetAccountInfoResponse.h"
   66|       |#import "FIRSignInWithGameCenterRequest.h"
   67|       |#import "FIRSignInWithGameCenterResponse.h"
   68|       |#import "FIRSignUpNewUserRequest.h"
   69|       |#import "FIRSignUpNewUserResponse.h"
   70|       |#import "FIRVerifyAssertionRequest.h"
   71|       |#import "FIRVerifyAssertionResponse.h"
   72|       |#import "FIRVerifyCustomTokenRequest.h"
   73|       |#import "FIRVerifyCustomTokenResponse.h"
   74|       |#import "FIRVerifyPasswordRequest.h"
   75|       |#import "FIRVerifyPasswordResponse.h"
   76|       |#import "FIRVerifyPhoneNumberRequest.h"
   77|       |#import "FIRVerifyPhoneNumberResponse.h"
   78|       |
   79|       |#if TARGET_OS_IOS
   80|       |#import "FIRAuthAPNSToken.h"
   81|       |#import "FIRAuthAPNSTokenManager.h"
   82|       |#import "FIRAuthAppCredentialManager.h"
   83|       |#import "FIRPhoneAuthCredential_Internal.h"
   84|       |#import "FIRAuthNotificationManager.h"
   85|       |#import "FIRAuthURLPresenter.h"
   86|       |#endif
   87|       |
   88|       |NS_ASSUME_NONNULL_BEGIN
   89|       |
   90|       |#pragma mark - Constants
   91|       |
   92|       |#if defined(__IPHONE_10_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
   93|       |const NSNotificationName FIRAuthStateDidChangeNotification = @"FIRAuthStateDidChangeNotification";
   94|       |#else
   95|       |NSString *const FIRAuthStateDidChangeNotification = @"FIRAuthStateDidChangeNotification";
   96|       |#endif  // defined(__IPHONE_10_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
   97|       |
   98|       |/** @var kMaxWaitTimeForBackoff
   99|       |    @brief The maximum wait time before attempting to retry auto refreshing tokens after a failed
  100|       |        attempt.
  101|       |    @remarks This is the upper limit (in seconds) of the exponential backoff used for retrying
  102|       |        token refresh.
  103|       | */
  104|       |static NSTimeInterval kMaxWaitTimeForBackoff = 16 * 60;
  105|       |
  106|       |/** @var kTokenRefreshHeadStart
  107|       |    @brief The amount of time before the token expires that proactive refresh should be attempted.
  108|       | */
  109|       |NSTimeInterval kTokenRefreshHeadStart  = 5 * 60;
  110|       |
  111|       |/** @var kUserKey
  112|       |    @brief Key of user stored in the keychain. Prefixed with a Firebase app name.
  113|       | */
  114|       |static NSString *const kUserKey = @"%@_firebase_user";
  115|       |
  116|       |/** @var kMissingEmailInvalidParameterExceptionReason
  117|       |    @brief The reason for @c invalidParameterException when the email used to initiate password
  118|       |        reset is nil.
  119|       | */
  120|       |static NSString *const kMissingEmailInvalidParameterExceptionReason =
  121|       |    @"The email used to initiate password reset cannot be nil.";
  122|       |
  123|       |/** @var kHandleCodeInAppFalseExceptionReason
  124|       |    @brief The reason for @c invalidParameterException when the handleCodeInApp parameter is false
  125|       |        on the ActionCodeSettings object used to send the link for Email-link Authentication.
  126|       | */
  127|       |static NSString *const kHandleCodeInAppFalseExceptionReason =
  128|       |    @"You must set handleCodeInApp in your ActionCodeSettings to true for Email-link "
  129|       |    "Authentication.";
  130|       |
  131|       |static NSString *const kInvalidEmailSignInLinkExceptionMessage =
  132|       |    @"The link provided is not valid for email/link sign-in. Please check the link by calling "
  133|       |    "isSignInWithEmailLink:link: on Auth before attempting to use it for email/link sign-in.";
  134|       |
  135|       |/** @var kPasswordResetRequestType
  136|       |    @brief The action code type value for resetting password in the check action code response.
  137|       | */
  138|       |static NSString *const kPasswordResetRequestType = @"PASSWORD_RESET";
  139|       |
  140|       |/** @var kVerifyEmailRequestType
  141|       |    @brief The action code type value for verifying email in the check action code response.
  142|       | */
  143|       |static NSString *const kVerifyEmailRequestType = @"VERIFY_EMAIL";
  144|       |
  145|       |/** @var kRecoverEmailRequestType
  146|       |    @brief The action code type value for recovering email in the check action code response.
  147|       | */
  148|       |static NSString *const kRecoverEmailRequestType = @"RECOVER_EMAIL";
  149|       |
  150|       |/** @var kEmailLinkSignInRequestType
  151|       |    @brief The action code type value for an email sign-in link in the check action code response.
  152|       |*/
  153|       |static NSString *const kEmailLinkSignInRequestType = @"EMAIL_SIGNIN";
  154|       |
  155|       |/** @var kMissingPasswordReason
  156|       |    @brief The reason why the @c FIRAuthErrorCodeWeakPassword error is thrown.
  157|       |    @remarks This error message will be localized in the future.
  158|       | */
  159|       |static NSString *const kMissingPasswordReason = @"Missing Password";
  160|       |
  161|       |/** @var gKeychainServiceNameForAppName
  162|       |    @brief A map from Firebase app name to keychain service names.
  163|       |    @remarks This map is needed for looking up the keychain service name after the FIRApp instance
  164|       |        is deleted, to remove the associated keychain item. Accessing should occur within a
  165|       |        @syncronized([FIRAuth class]) context.
  166|       | */
  167|       |static NSMutableDictionary *gKeychainServiceNameForAppName;
  168|       |
  169|       |#pragma mark - FIRActionCodeInfo
  170|       |
  171|       |@implementation FIRActionCodeInfo {
  172|       |  /** @var _email
  173|       |      @brief The email address to which the code was sent. The new email address in the case of
  174|       |          FIRActionCodeOperationRecoverEmail.
  175|       |   */
  176|       |  NSString *_email;
  177|       |
  178|       |  /** @var _fromEmail
  179|       |      @brief The current email address in the case of FIRActionCodeOperationRecoverEmail.
  180|       |   */
  181|       |  NSString *_fromEmail;
  182|       |}
  183|       |
  184|      0|- (NSString *)dataForKey:(FIRActionDataKey)key{
  185|      0|  switch (key) {
  186|      0|    case FIRActionCodeEmailKey:
  187|      0|      return _email;
  188|      0|    case FIRActionCodeFromEmailKey:
  189|      0|      return _fromEmail;
  190|      0|  }
  191|      0|}
  192|       |
  193|       |- (instancetype)initWithOperation:(FIRActionCodeOperation)operation
  194|       |                            email:(NSString *)email
  195|      0|                         newEmail:(nullable NSString *)newEmail {
  196|      0|  self = [super init];
  197|      0|  if (self) {
  198|      0|    _operation = operation;
  199|      0|    if (newEmail) {
  200|      0|      _email = [newEmail copy];
  201|      0|      _fromEmail = [email copy];
  202|      0|    } else {
  203|      0|      _email = [email copy];
  204|      0|    }
  205|      0|  }
  206|      0|  return self;
  207|      0|}
  208|       |
  209|       |/** @fn actionCodeOperationForRequestType:
  210|       |    @brief Returns the corresponding operation type per provided request type string.
  211|       |    @param requestType Request type returned in in the server response.
  212|       |    @return The corresponding FIRActionCodeOperation for the supplied request type.
  213|       | */
  214|      0|+ (FIRActionCodeOperation)actionCodeOperationForRequestType:(NSString *)requestType {
  215|      0|  if ([requestType isEqualToString:kPasswordResetRequestType]) {
  216|      0|    return FIRActionCodeOperationPasswordReset;
  217|      0|  }
  218|      0|  if ([requestType isEqualToString:kVerifyEmailRequestType]) {
  219|      0|    return FIRActionCodeOperationVerifyEmail;
  220|      0|  }
  221|      0|  if ([requestType isEqualToString:kRecoverEmailRequestType]) {
  222|      0|    return FIRActionCodeOperationRecoverEmail;
  223|      0|  }
  224|      0|  if ([requestType isEqualToString:kEmailLinkSignInRequestType]) {
  225|      0|    return FIRActionCodeOperationEmailLink;
  226|      0|  }
  227|      0|  return FIRActionCodeOperationUnknown;
  228|      0|}
  229|       |
  230|       |@end
  231|       |
  232|       |#pragma mark - FIRAuth
  233|       |
  234|       |#if TARGET_OS_IOS
  235|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  236|       |@interface FIRAuth () <UIApplicationDelegate, UISceneDelegate, FIRLibrary, FIRComponentLifecycleMaintainer>
  237|       |#else
  238|       |@interface FIRAuth () <UIApplicationDelegate, FIRLibrary, FIRComponentLifecycleMaintainer>
  239|       |#endif
  240|       |#else
  241|       |@interface FIRAuth () <FIRLibrary, FIRComponentLifecycleMaintainer>
  242|       |#endif
  243|       |
  244|       |/** @property firebaseAppId
  245|       |    @brief The Firebase app ID.
  246|       | */
  247|       |@property(nonatomic, copy, readonly) NSString *firebaseAppId;
  248|       |
  249|       |/** @property additionalFrameworkMarker
  250|       |    @brief Additional framework marker that will be added as part of the header of every request.
  251|       | */
  252|       |@property(nonatomic, copy, nullable) NSString *additionalFrameworkMarker;
  253|       |
  254|       |/** @property storedUserManager
  255|       |    @brief The stored user manager.
  256|       | */
  257|       |@property(nonatomic, strong, nullable) FIRAuthStoredUserManager *storedUserManager;
  258|       |
  259|       |/** @fn initWithApp:
  260|       |    @brief Creates a @c FIRAuth instance associated with the provided @c FIRApp instance.
  261|       |    @param app The application to associate the auth instance with.
  262|       | */
  263|       |- (instancetype)initWithApp:(FIRApp *)app;
  264|       |
  265|       |@end
  266|       |
  267|       |@implementation FIRAuth {
  268|       |  /** @var _currentUser
  269|       |      @brief The current user.
  270|       |   */
  271|       |  FIRUser *_currentUser;
  272|       |
  273|       |  /** @var _firebaseAppName
  274|       |      @brief The Firebase app name.
  275|       |   */
  276|       |  NSString *_firebaseAppName;
  277|       |
  278|       |  /** @var _listenerHandles
  279|       |      @brief Handles returned from @c NSNotificationCenter for blocks which are "auth state did
  280|       |          change" notification listeners.
  281|       |      @remarks Mutations should occur within a @syncronized(self) context.
  282|       |   */
  283|       |  NSMutableArray<FIRAuthStateDidChangeListenerHandle> *_listenerHandles;
  284|       |
  285|       |  /** @var _keychainServices
  286|       |      @brief The keychain service.
  287|       |   */
  288|       |  FIRAuthKeychainServices *_keychainServices;
  289|       |
  290|       |  /** @var _lastNotifiedUserToken
  291|       |      @brief The user access (ID) token used last time for posting auth state changed notification.
  292|       |   */
  293|       |  NSString *_lastNotifiedUserToken;
  294|       |
  295|       |  /** @var _autoRefreshTokens
  296|       |      @brief This flag denotes whether or not tokens should be automatically refreshed.
  297|       |      @remarks Will only be set to @YES if the another Firebase service is included (additionally to
  298|       |        Firebase Auth).
  299|       |   */
  300|       |  BOOL _autoRefreshTokens;
  301|       |
  302|       |  /** @var _autoRefreshScheduled
  303|       |      @brief Whether or not token auto-refresh is currently scheduled.
  304|       |   */
  305|       |  BOOL _autoRefreshScheduled;
  306|       |
  307|       |  /** @var _isAppInBackground
  308|       |      @brief A flag that is set to YES if the app is put in the background and no when the app is
  309|       |          returned to the foreground.
  310|       |   */
  311|       |  BOOL _isAppInBackground;
  312|       |
  313|       |  /** @var _applicationDidBecomeActiveObserver
  314|       |      @brief An opaque object to act as the observer for UIApplicationDidBecomeActiveNotification.
  315|       |   */
  316|       |  id<NSObject> _applicationDidBecomeActiveObserver;
  317|       |
  318|       |  /** @var _applicationDidBecomeActiveObserver
  319|       |      @brief An opaque object to act as the observer for
  320|       |          UIApplicationDidEnterBackgroundNotification.
  321|       |   */
  322|       |  id<NSObject> _applicationDidEnterBackgroundObserver;
  323|       |}
  324|       |
  325|      1|+ (void)load {
  326|      1|  [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self
  327|      1|                 withName:@"fire-auth"
  328|      1|              withVersion:[NSString stringWithUTF8String:FirebaseAuthVersionStr]];
  329|      1|}
  330|       |
  331|      1|+ (void)initialize {
  332|      1|  gKeychainServiceNameForAppName = [[NSMutableDictionary alloc] init];
  333|      1|}
  334|       |
  335|      1|+ (FIRAuth *)auth {
  336|      1|  FIRApp *defaultApp = [FIRApp defaultApp];
  337|      1|  if (!defaultApp) {
  338|      0|    [NSException raise:NSInternalInconsistencyException
  339|      0|                format:@"The default FIRApp instance must be configured before the default FIRAuth"
  340|      0|                       @"instance can be initialized. One way to ensure that is to call "
  341|      0|                       @"`[FIRApp configure];` (`FirebaseApp.configure()` in Swift) in the App "
  342|      0|                       @"Delegate's `application:didFinishLaunchingWithOptions:` "
  343|      0|                       @"(`application(_:didFinishLaunchingWithOptions:)` in Swift)."];
  344|      0|  }
  345|      1|  return [self authWithApp:defaultApp];
  346|      1|}
  347|       |
  348|      1|+ (FIRAuth *)authWithApp:(FIRApp *)app {
  349|      1|  // Get the instance of Auth from the container, which will create or return the cached instance
  350|      1|  // associated with this app.
  351|      1|  id<FIRAuthInterop> auth = FIR_COMPONENT(FIRAuthInterop, app.container);
  352|      1|  return (FIRAuth *)auth;
  353|      1|}
  354|       |
  355|      1|- (instancetype)initWithApp:(FIRApp *)app {
  356|      1|  [FIRAuth setKeychainServiceNameForApp:app];
  357|      1|  self = [self initWithAPIKey:app.options.APIKey appName:app.name];
  358|      1|  if (self) {
  359|      1|    _app = app;
  360|      1|    #if TARGET_OS_IOS
  361|      1|    _authURLPresenter = [[FIRAuthURLPresenter alloc] init];
  362|      1|    #endif
  363|      1|  }
  364|      1|  return self;
  365|      1|}
  366|       |
  367|      1|- (nullable instancetype)initWithAPIKey:(NSString *)APIKey appName:(NSString *)appName {
  368|      1|  self = [super init];
  369|      1|  if (self) {
  370|      1|    _listenerHandles = [NSMutableArray array];
  371|      1|    _requestConfiguration = [[FIRAuthRequestConfiguration alloc] initWithAPIKey:APIKey];
  372|      1|    _settings = [[FIRAuthSettings alloc] init];
  373|      1|    _firebaseAppName = [appName copy];
  374|      1|    #if TARGET_OS_IOS
  375|      1|
  376|      1|    static Class applicationClass = nil;
  377|      1|    // iOS App extensions should not call [UIApplication sharedApplication], even if UIApplication
  378|      1|    // responds to it.
  379|      1|    if (![GULAppEnvironmentUtil isAppExtension]) {
  380|      1|      Class cls = NSClassFromString(@"UIApplication");
  381|      1|      if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
  382|      1|        applicationClass = cls;
  383|      1|      }
  384|      1|    }
  385|      1|    UIApplication *application = [applicationClass sharedApplication];
  386|      1|
  387|      1|    [GULAppDelegateSwizzler proxyOriginalDelegateIncludingAPNSMethods];
  388|      1|    [GULSceneDelegateSwizzler proxyOriginalSceneDelegate];
  389|      1|    #endif // TARGET_OS_IOS
  390|      1|
  391|      1|    // Continue with the rest of initialization in the work thread.
  392|      1|    __weak FIRAuth *weakSelf = self;
  393|      1|    dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  394|      1|      // Load current user from Keychain.
  395|      1|      FIRAuth *strongSelf = weakSelf;
  396|      1|      if (!strongSelf) {
  397|      0|        return;
  398|      0|      }
  399|      1|      NSString *keychainServiceName =
  400|      1|          [FIRAuth keychainServiceNameForAppName:strongSelf->_firebaseAppName];
  401|      1|      if (keychainServiceName) {
  402|      1|        strongSelf->_keychainServices = [[FIRAuthKeychainServices alloc] initWithService:keychainServiceName];
  403|      1|        strongSelf.storedUserManager =
  404|      1|            [[FIRAuthStoredUserManager alloc] initWithServiceName:keychainServiceName];
  405|      1|      }
  406|      1|
  407|      1|      NSError *error;
  408|      1|      NSString *storedUserAccessGroup = [strongSelf.storedUserManager getStoredUserAccessGroupWithError:&error];
  409|      1|      if (!error) {
  410|      1|        if (!storedUserAccessGroup) {
  411|      1|          FIRUser *user;
  412|      1|          if ([strongSelf getUser:&user error:&error]) {
  413|      1|            [strongSelf updateCurrentUser:user byForce:NO savingToDisk:NO error:&error];
  414|      1|            self->_lastNotifiedUserToken = user.rawAccessToken;
  415|      1|          } else {
  416|      0|            FIRLogError(kFIRLoggerAuth, @"I-AUT000001",
  417|      0|                        @"Error loading saved user when starting up: %@", error);
  418|      0|          }
  419|      1|        } else {
  420|      0|          [strongSelf useUserAccessGroup:storedUserAccessGroup error:&error];
  421|      0|          if (error) {
  422|      0|            FIRLogError(kFIRLoggerAuth, @"I-AUT000001",
  423|      0|                        @"Error loading saved user when starting up: %@", error);
  424|      0|          }
  425|      0|        }
  426|      1|      } else {
  427|      0|        FIRLogError(kFIRLoggerAuth, @"I-AUT000001",
  428|      0|                    @"Error loading saved user when starting up: %@", error);
  429|      0|      }
  430|      1|
  431|      1|      #if TARGET_OS_IOS
  432|      1|      // Initialize for phone number auth.
  433|      1|      strongSelf->_tokenManager =
  434|      1|          [[FIRAuthAPNSTokenManager alloc] initWithApplication:application];
  435|      1|
  436|      1|      strongSelf->_appCredentialManager =
  437|      1|          [[FIRAuthAppCredentialManager alloc] initWithKeychain:strongSelf->_keychainServices];
  438|      1|
  439|      1|      strongSelf->_notificationManager = [[FIRAuthNotificationManager alloc]
  440|      1|           initWithApplication:application
  441|      1|          appCredentialManager:strongSelf->_appCredentialManager];
  442|      1|
  443|      1|      [GULAppDelegateSwizzler registerAppDelegateInterceptor:strongSelf];
  444|      1|      #if ((TARGET_OS_IOS || TARGET_OS_TV) && (__IPHONE_OS_VERSION_MAX_ALLOWED >= 130000))
  445|      1|        if (@available(iOS 13, tvos 13, *)) {
  446|      1|        [GULSceneDelegateSwizzler registerSceneDelegateInterceptor:strongSelf];
  447|      1|      }
  448|      1|      #endif // ((TARGET_OS_IOS || TARGET_OS_TV) && (__IPHONE_OS_VERSION_MAX_ALLOWED >= 130000))
  449|      1|      #endif // TARGET_OS_IOS
  450|      1|    });
  451|      1|  }
  452|      1|  return self;
  453|      1|}
  454|       |
  455|      0|- (void)dealloc {
  456|      0|  @synchronized (self) {
  457|      0|    NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter];
  458|      0|    while (_listenerHandles.count != 0) {
  459|      0|      FIRAuthStateDidChangeListenerHandle handleToRemove = _listenerHandles.lastObject;
  460|      0|      [defaultCenter removeObserver:handleToRemove];
  461|      0|      [_listenerHandles removeLastObject];
  462|      0|    }
  463|      0|
  464|      0|    #if TARGET_OS_IOS
  465|      0|    [defaultCenter removeObserver:_applicationDidBecomeActiveObserver
  466|      0|                             name:UIApplicationDidBecomeActiveNotification
  467|      0|                           object:nil];
  468|      0|    [defaultCenter removeObserver:_applicationDidEnterBackgroundObserver
  469|      0|                             name:UIApplicationDidEnterBackgroundNotification
  470|      0|                           object:nil];
  471|      0|    #endif
  472|      0|  }
  473|      0|}
  474|       |
  475|       |#pragma mark - Public API
  476|       |
  477|      1|- (nullable FIRUser *)currentUser {
  478|      1|  __block FIRUser *result;
  479|      1|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
  480|      1|    result = self->_currentUser;
  481|      1|  });
  482|      1|  return result;
  483|      1|}
  484|       |
  485|       |- (void)fetchProvidersForEmail:(NSString *)email
  486|      0|                    completion:(nullable FIRProviderQueryCallback)completion {
  487|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  488|      0|    FIRCreateAuthURIRequest *request =
  489|      0|        [[FIRCreateAuthURIRequest alloc] initWithIdentifier:email
  490|      0|                                                continueURI:@"http://www.google.com/"
  491|      0|                                       requestConfiguration:self->_requestConfiguration];
  492|      0|    [FIRAuthBackend createAuthURI:request callback:^(FIRCreateAuthURIResponse *_Nullable response,
  493|      0|                                                     NSError *_Nullable error) {
  494|      0|      if (completion) {
  495|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  496|      0|          completion(response.allProviders, error);
  497|      0|        });
  498|      0|      }
  499|      0|    }];
  500|      0|  });
  501|      0|}
  502|       |
  503|       |
  504|       |- (void)signInWithProvider:(id<FIRFederatedAuthProvider>)provider
  505|       |                UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  506|      0|                completion:(nullable FIRAuthDataResultCallback)completion {
  507|      0|#if TARGET_OS_IOS
  508|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  509|      0|    FIRAuthDataResultCallback decoratedCallback =
  510|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  511|      0|    [provider getCredentialWithUIDelegate:UIDelegate
  512|      0|                               completion:^(FIRAuthCredential *_Nullable credential,
  513|      0|                                            NSError *_Nullable error) {
  514|      0|      if (error) {
  515|      0|        decoratedCallback(nil, error);
  516|      0|        return;
  517|      0|      }
  518|      0|      [self internalSignInAndRetrieveDataWithCredential:credential
  519|      0|                                     isReauthentication:NO
  520|      0|                                               callback:decoratedCallback];
  521|      0|    }];
  522|      0|  });
  523|      0|#endif  // TARGET_OS_IOS
  524|      0|}
  525|       |
  526|       |- (void)fetchSignInMethodsForEmail:(nonnull NSString *)email
  527|      0|                        completion:(nullable FIRSignInMethodQueryCallback)completion {
  528|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  529|      0|    FIRCreateAuthURIRequest *request =
  530|      0|        [[FIRCreateAuthURIRequest alloc] initWithIdentifier:email
  531|      0|                                                continueURI:@"http://www.google.com/"
  532|      0|                                       requestConfiguration:self->_requestConfiguration];
  533|      0|    [FIRAuthBackend createAuthURI:request callback:^(FIRCreateAuthURIResponse *_Nullable response,
  534|      0|                                                     NSError *_Nullable error) {
  535|      0|      if (completion) {
  536|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  537|      0|          completion(response.signinMethods, error);
  538|      0|        });
  539|      0|      }
  540|      0|    }];
  541|      0|  });
  542|      0|}
  543|       |
  544|       |- (void)signInWithEmail:(NSString *)email
  545|       |               password:(NSString *)password
  546|      0|             completion:(nullable FIRAuthDataResultCallback)completion {
  547|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  548|      0|    FIRAuthDataResultCallback decoratedCallback =
  549|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  550|      0|    [self internalSignInAndRetrieveDataWithEmail:email
  551|      0|                                        password:password
  552|      0|                                      completion:^(FIRAuthDataResult *_Nullable authResult,
  553|      0|                                                   NSError *_Nullable error) {
  554|      0|      decoratedCallback(authResult, error);
  555|      0|    }];
  556|      0|  });
  557|      0|}
  558|       |
  559|       |- (void)signInWithEmail:(NSString *)email
  560|       |                   link:(NSString *)link
  561|      0|             completion:(nullable FIRAuthDataResultCallback)completion {
  562|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  563|      0|    FIRAuthDataResultCallback decoratedCallback =
  564|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  565|      0|    FIREmailPasswordAuthCredential *credential =
  566|      0|        [[FIREmailPasswordAuthCredential alloc] initWithEmail:email link:link];
  567|      0|    [self internalSignInAndRetrieveDataWithCredential:credential
  568|      0|                                   isReauthentication:NO
  569|      0|                                             callback:^(FIRAuthDataResult *_Nullable authResult,
  570|      0|                                                        NSError *_Nullable error) {
  571|      0|      decoratedCallback(authResult, error);
  572|      0|    }];
  573|      0|  });
  574|      0|}
  575|       |
  576|       |/** @fn signInWithEmail:password:callback:
  577|       |    @brief Signs in using an email address and password.
  578|       |    @param email The user's email address.
  579|       |    @param password The user's password.
  580|       |    @param callback A block which is invoked when the sign in finishes (or is cancelled.) Invoked
  581|       |        asynchronously on the global auth work queue in the future.
  582|       |    @remarks This is the internal counterpart of this method, which uses a callback that does not
  583|       |        update the current user.
  584|       | */
  585|       |- (void)signInWithEmail:(NSString *)email
  586|       |               password:(NSString *)password
  587|      0|               callback:(FIRAuthResultCallback)callback {
  588|      0|
  589|      0|  FIRVerifyPasswordRequest *request =
  590|      0|      [[FIRVerifyPasswordRequest alloc] initWithEmail:email
  591|      0|                                             password:password
  592|      0|                                 requestConfiguration:_requestConfiguration];
  593|      0|
  594|      0|  if (![request.password length]) {
  595|      0|    callback(nil, [FIRAuthErrorUtils wrongPasswordErrorWithMessage:nil]);
  596|      0|    return;
  597|      0|  }
  598|      0|  [FIRAuthBackend verifyPassword:request
  599|      0|                        callback:^(FIRVerifyPasswordResponse *_Nullable response,
  600|      0|                                   NSError *_Nullable error) {
  601|      0|    if (error) {
  602|      0|      callback(nil, error);
  603|      0|      return;
  604|      0|    }
  605|      0|    [self completeSignInWithAccessToken:response.IDToken
  606|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  607|      0|                           refreshToken:response.refreshToken
  608|      0|                              anonymous:NO
  609|      0|                               callback:callback];
  610|      0|  }];
  611|      0|}
  612|       |
  613|       |/** @fn internalSignInAndRetrieveDataWithEmail:password:callback:
  614|       |    @brief Signs in using an email address and password.
  615|       |    @param email The user's email address.
  616|       |    @param password The user's password.
  617|       |    @param completion A block which is invoked when the sign in finishes (or is cancelled.) Invoked
  618|       |        asynchronously on the global auth work queue in the future.
  619|       |    @remarks This is the internal counterpart of this method, which uses a callback that does not
  620|       |        update the current user.
  621|       | */
  622|       |- (void)internalSignInAndRetrieveDataWithEmail:(NSString *)email
  623|       |                                      password:(NSString *)password
  624|      0|                                    completion:(FIRAuthDataResultCallback)completion {
  625|      0|  FIREmailPasswordAuthCredential *credentail =
  626|      0|      [[FIREmailPasswordAuthCredential alloc] initWithEmail:email password:password];
  627|      0|  [self internalSignInAndRetrieveDataWithCredential:credentail
  628|      0|                                 isReauthentication:NO
  629|      0|                                           callback:completion];
  630|      0|}
  631|       |
  632|       |/** @fn signInAndRetrieveDataWithGameCenterCredential:callback:
  633|       |    @brief Signs in using a game center credential.
  634|       |    @param credential The Game Center Auth Credential used to sign in.
  635|       |    @param callback A block which is invoked when the sign in finished (or is cancelled). Invoked
  636|       |        asynchronously on the global auth work queue in the future.
  637|       | */
  638|       |- (void)signInAndRetrieveDataWithGameCenterCredential:(FIRGameCenterAuthCredential *)credential
  639|      0|                                             callback:(FIRAuthDataResultCallback)callback {
  640|      0|  FIRSignInWithGameCenterRequest *request =
  641|      0|    [[FIRSignInWithGameCenterRequest alloc] initWithPlayerID:credential.playerID
  642|      0|                                                publicKeyURL:credential.publicKeyURL
  643|      0|                                                   signature:credential.signature
  644|      0|                                                        salt:credential.salt
  645|      0|                                                   timestamp:credential.timestamp
  646|      0|                                                 displayName:credential.displayName
  647|      0|                                        requestConfiguration:_requestConfiguration];
  648|      0|  [FIRAuthBackend signInWithGameCenter:request
  649|      0|                              callback:^(FIRSignInWithGameCenterResponse *_Nullable response,
  650|      0|                                         NSError *_Nullable error) {
  651|      0|    if (error) {
  652|      0|      if (callback) {
  653|      0|        callback(nil, error);
  654|      0|      }
  655|      0|      return;
  656|      0|    }
  657|      0|
  658|      0|    [self completeSignInWithAccessToken:response.IDToken
  659|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  660|      0|                           refreshToken:response.refreshToken
  661|      0|                              anonymous:NO
  662|      0|                               callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  663|      0|      if (error && callback) {
  664|      0|        callback(nil, error);
  665|      0|        return;
  666|      0|      }
  667|      0|      FIRAdditionalUserInfo *additionalUserInfo =
  668|      0|      [[FIRAdditionalUserInfo alloc] initWithProviderID:FIRGameCenterAuthProviderID
  669|      0|                                                profile:nil
  670|      0|                                               username:nil
  671|      0|                                              isNewUser:response.isNewUser];
  672|      0|      FIRAuthDataResult *result = user ?
  673|      0|      [[FIRAuthDataResult alloc] initWithUser:user
  674|      0|                           additionalUserInfo:additionalUserInfo] : nil;
  675|      0|      if (callback) {
  676|      0|        callback(result, error);
  677|      0|      }
  678|      0|    }];
  679|      0|  }];
  680|      0|}
  681|       |
  682|       |/** @fn internalSignInAndRetrieveDataWithEmail:link:completion:
  683|       |    @brief Signs in using an email and email sign-in link.
  684|       |    @param email The user's email address.
  685|       |    @param link The email sign-in link.
  686|       |    @param callback A block which is invoked when the sign in finishes (or is cancelled.) Invoked
  687|       |        asynchronously on the global auth work queue in the future.
  688|       | */
  689|       |- (void)internalSignInAndRetrieveDataWithEmail:(nonnull NSString *)email
  690|       |                                          link:(nonnull NSString *)link
  691|      0|                                      callback:(nullable FIRAuthDataResultCallback)callback {
  692|      0|  if (![self isSignInWithEmailLink:link]) {
  693|      0|    [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
  694|      0|        kInvalidEmailSignInLinkExceptionMessage];
  695|      0|    return;
  696|      0|  }
  697|      0|  NSDictionary<NSString *, NSString *> *queryItems = [FIRAuthWebUtils parseURL:link];
  698|      0|  if (![queryItems count]) {
  699|      0|    NSURLComponents *urlComponents = [NSURLComponents componentsWithString:link];
  700|      0|    queryItems = [FIRAuthWebUtils parseURL:urlComponents.query];
  701|      0|  }
  702|      0|  NSString *actionCode = queryItems[@"oobCode"];
  703|      0|
  704|      0|  FIREmailLinkSignInRequest *request =
  705|      0|      [[FIREmailLinkSignInRequest alloc] initWithEmail:email
  706|      0|                                               oobCode:actionCode
  707|      0|                                  requestConfiguration:_requestConfiguration];
  708|      0|
  709|      0|  [FIRAuthBackend emailLinkSignin:request
  710|      0|                         callback:^(FIREmailLinkSignInResponse *_Nullable response,
  711|      0|                                    NSError *_Nullable error) {
  712|      0|    if (error) {
  713|      0|      if (callback) {
  714|      0|        callback(nil, error);
  715|      0|      }
  716|      0|      return;
  717|      0|    }
  718|      0|    [self completeSignInWithAccessToken:response.IDToken
  719|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  720|      0|                           refreshToken:response.refreshToken
  721|      0|                              anonymous:NO
  722|      0|                               callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  723|      0|      if (error && callback) {
  724|      0|        callback(nil, error);
  725|      0|        return;
  726|      0|      }
  727|      0|      FIRAdditionalUserInfo *additionalUserInfo =
  728|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  729|      0|                                                    profile:nil
  730|      0|                                                   username:nil
  731|      0|                                                  isNewUser:response.isNewUser];
  732|      0|      FIRAuthDataResult *result = user ?
  733|      0|          [[FIRAuthDataResult alloc] initWithUser:user
  734|      0|                               additionalUserInfo:additionalUserInfo] : nil;
  735|      0|      if (callback) {
  736|      0|        callback(result, error);
  737|      0|      }
  738|      0|    }];
  739|      0|  }];
  740|      0|}
  741|       |
  742|       |#pragma clang diagnostic push
  743|       |#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  744|       |- (void)signInWithCredential:(FIRAuthCredential *)credential
  745|      0|                  completion:(nullable FIRAuthDataResultCallback)completion {
  746|      0|  [self signInAndRetrieveDataWithCredential:credential completion:completion];
  747|      0|}
  748|       |#pragma clang diagnostic pop
  749|       |
  750|       |- (void)signInAndRetrieveDataWithCredential:(FIRAuthCredential *)credential
  751|      0|                                 completion:(nullable FIRAuthDataResultCallback)completion {
  752|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  753|      0|    FIRAuthDataResultCallback callback =
  754|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  755|      0|    [self internalSignInAndRetrieveDataWithCredential:credential
  756|      0|                                   isReauthentication:NO
  757|      0|                                             callback:callback];
  758|      0|  });
  759|      0|}
  760|       |
  761|       |- (void)internalSignInWithCredential:(FIRAuthCredential *)credential
  762|      0|                            callback:(FIRAuthResultCallback)callback {
  763|      0|  [self internalSignInAndRetrieveDataWithCredential:credential
  764|      0|                                 isReauthentication:NO
  765|      0|                                           callback:^(FIRAuthDataResult *_Nullable authResult,
  766|      0|                                                      NSError *_Nullable error) {
  767|      0|    callback(authResult.user, error);
  768|      0|  }];
  769|      0|}
  770|       |
  771|       |- (void)internalSignInAndRetrieveDataWithCredential:(FIRAuthCredential *)credential
  772|       |                                 isReauthentication:(BOOL)isReauthentication
  773|      0|                                           callback:(nullable FIRAuthDataResultCallback)callback {
  774|      0|  if ([credential isKindOfClass:[FIREmailPasswordAuthCredential class]]) {
  775|      0|    // Special case for email/password credentials
  776|      0|    FIREmailPasswordAuthCredential *emailPasswordCredential =
  777|      0|        (FIREmailPasswordAuthCredential *)credential;
  778|      0|
  779|      0|    if (emailPasswordCredential.link) {
  780|      0|      // Email link sign in
  781|      0|      [self internalSignInAndRetrieveDataWithEmail:emailPasswordCredential.email
  782|      0|                                              link:emailPasswordCredential.link
  783|      0|                                          callback:callback];
  784|      0|    } else {
  785|      0|      // Email password sign in
  786|      0|      FIRAuthResultCallback completeEmailSignIn = ^(FIRUser *_Nullable user,
  787|      0|                                                    NSError *_Nullable error) {
  788|      0|        if (callback) {
  789|      0|          if (error) {
  790|      0|            callback(nil, error);
  791|      0|            return;
  792|      0|          }
  793|      0|          FIRAdditionalUserInfo *additionalUserInfo =
  794|      0|              [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  795|      0|                                                        profile:nil
  796|      0|                                                       username:nil
  797|      0|                                                      isNewUser:NO];
  798|      0|          FIRAuthDataResult *result = user ?
  799|      0|              [[FIRAuthDataResult alloc] initWithUser:user
  800|      0|                                   additionalUserInfo:additionalUserInfo] : nil;
  801|      0|          callback(result, error);
  802|      0|        }
  803|      0|      };
  804|      0|
  805|      0|      [self signInWithEmail:emailPasswordCredential.email
  806|      0|                   password:emailPasswordCredential.password
  807|      0|                   callback:completeEmailSignIn];
  808|      0|    }
  809|      0|    return;
  810|      0|  }
  811|      0|
  812|      0|  if ([credential isKindOfClass:[FIRGameCenterAuthCredential class]]) {
  813|      0|    // Special case for Game Center credentials.
  814|      0|    [self signInAndRetrieveDataWithGameCenterCredential:(FIRGameCenterAuthCredential *)credential
  815|      0|                                               callback:callback];
  816|      0|    return;
  817|      0|  }
  818|      0|
  819|      0|  #if TARGET_OS_IOS
  820|      0|  if ([credential isKindOfClass:[FIRPhoneAuthCredential class]]) {
  821|      0|    // Special case for phone auth credentials
  822|      0|    FIRPhoneAuthCredential *phoneCredential = (FIRPhoneAuthCredential *)credential;
  823|      0|    FIRAuthOperationType operation =
  824|      0|        isReauthentication ? FIRAuthOperationTypeReauth : FIRAuthOperationTypeSignUpOrSignIn;
  825|      0|    [self signInWithPhoneCredential:phoneCredential
  826|      0|                          operation:operation
  827|      0|                           callback:^(FIRVerifyPhoneNumberResponse *_Nullable response,
  828|      0|                                      NSError *_Nullable error) {
  829|      0|      if (callback) {
  830|      0|        if (error) {
  831|      0|          callback(nil, error);
  832|      0|          return;
  833|      0|        }
  834|      0|
  835|      0|        [self completeSignInWithAccessToken:response.IDToken
  836|      0|                  accessTokenExpirationDate:response.approximateExpirationDate
  837|      0|                               refreshToken:response.refreshToken
  838|      0|                                  anonymous:NO
  839|      0|                                   callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  840|      0|          if (error && callback) {
  841|      0|            callback(nil, error);
  842|      0|            return;
  843|      0|          }
  844|      0|          FIRAdditionalUserInfo *additionalUserInfo =
  845|      0|              [[FIRAdditionalUserInfo alloc] initWithProviderID:FIRPhoneAuthProviderID
  846|      0|                                                        profile:nil
  847|      0|                                                       username:nil
  848|      0|                                                      isNewUser:response.isNewUser];
  849|      0|          FIRAuthDataResult *result = user ?
  850|      0|              [[FIRAuthDataResult alloc] initWithUser:user
  851|      0|                                   additionalUserInfo:additionalUserInfo] : nil;
  852|      0|          if (callback) {
  853|      0|            callback(result, error);
  854|      0|          }
  855|      0|        }];
  856|      0|      }
  857|      0|    }];
  858|      0|    return;
  859|      0|  }
  860|      0|  #endif
  861|      0|  FIRVerifyAssertionRequest *request =
  862|      0|      [[FIRVerifyAssertionRequest alloc] initWithProviderID:credential.provider
  863|      0|                                       requestConfiguration:_requestConfiguration];
  864|      0|  request.autoCreate = !isReauthentication;
  865|      0|  [credential prepareVerifyAssertionRequest:request];
  866|      0|  [FIRAuthBackend verifyAssertion:request
  867|      0|                         callback:^(FIRVerifyAssertionResponse *response, NSError *error) {
  868|      0|    if (error) {
  869|      0|      if (callback) {
  870|      0|        callback(nil, error);
  871|      0|      }
  872|      0|      return;
  873|      0|    }
  874|      0|
  875|      0|    if (response.needConfirmation) {
  876|      0|      if (callback) {
  877|      0|        NSString *email = response.email;
  878|      0|        FIROAuthCredential *credential =
  879|      0|            [[FIROAuthCredential alloc] initWithVerifyAssertionResponse:response];
  880|      0|        callback(nil, [FIRAuthErrorUtils accountExistsWithDifferentCredentialErrorWithEmail:email
  881|      0|            updatedCredential:credential]);
  882|      0|      }
  883|      0|      return;
  884|      0|    }
  885|      0|
  886|      0|    if (!response.providerID.length) {
  887|      0|      if (callback) {
  888|      0|        callback(nil, [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:response]);
  889|      0|      }
  890|      0|      return;
  891|      0|    }
  892|      0|    [self completeSignInWithAccessToken:response.IDToken
  893|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  894|      0|                           refreshToken:response.refreshToken
  895|      0|                              anonymous:NO
  896|      0|                               callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  897|      0|      if (callback) {
  898|      0|        if (error) {
  899|      0|          callback(nil, error);
  900|      0|          return;
  901|      0|        }
  902|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  903|      0|            [FIRAdditionalUserInfo userInfoWithVerifyAssertionResponse:response];
  904|      0|        FIROAuthCredential *updatedOAuthCredential =
  905|      0|            [[FIROAuthCredential alloc] initWithVerifyAssertionResponse:response];
  906|      0|        FIRAuthDataResult *result = user ?
  907|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  908|      0|                                 additionalUserInfo:additionalUserInfo
  909|      0|                                         credential:updatedOAuthCredential] : nil;
  910|      0|        callback(result, error);
  911|      0|      }
  912|      0|    }];
  913|      0|  }];
  914|      0|}
  915|       |
  916|      0|- (void)signInAnonymouslyWithCompletion:(nullable FIRAuthDataResultCallback)completion {
  917|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  918|      0|    FIRAuthDataResultCallback decoratedCallback =
  919|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  920|      0|    if (self->_currentUser.anonymous) {
  921|      0|      FIRAuthDataResult *result =
  922|      0|          [[FIRAuthDataResult alloc] initWithUser:self->_currentUser additionalUserInfo:nil];
  923|      0|      decoratedCallback(result, nil);
  924|      0|      return;
  925|      0|    }
  926|      0|    [self internalSignInAnonymouslyWithCompletion:^(FIRSignUpNewUserResponse *_Nullable response,
  927|      0|                                                    NSError *_Nullable error) {
  928|      0|      if (error) {
  929|      0|        decoratedCallback(nil, error);
  930|      0|        return;
  931|      0|      }
  932|      0|      [self completeSignInWithAccessToken:response.IDToken
  933|      0|                accessTokenExpirationDate:response.approximateExpirationDate
  934|      0|                             refreshToken:response.refreshToken
  935|      0|                                anonymous:YES
  936|      0|                                 callback:^(FIRUser * _Nullable user, NSError * _Nullable error) {
  937|      0|        if (error) {
  938|      0|          decoratedCallback(nil, error);
  939|      0|          return;
  940|      0|        }
  941|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  942|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:nil
  943|      0|                                                    profile:nil
  944|      0|                                                   username:nil
  945|      0|                                                  isNewUser:YES];
  946|      0|        FIRAuthDataResult *authDataResult = user ?
  947|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  948|      0|                                 additionalUserInfo:additionalUserInfo] : nil;
  949|      0|        decoratedCallback(authDataResult, error);
  950|      0|      }];
  951|      0|    }];
  952|      0|  });
  953|      0|}
  954|       |
  955|       |- (void)signInWithCustomToken:(NSString *)token
  956|      0|                   completion:(nullable FIRAuthDataResultCallback)completion {
  957|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  958|      0|    FIRAuthDataResultCallback decoratedCallback =
  959|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  960|      0|    [self internalSignInAndRetrieveDataWithCustomToken:token
  961|      0|                                            completion:^(FIRAuthDataResult *_Nullable authResult,
  962|      0|                                                         NSError *_Nullable error) {
  963|      0|      decoratedCallback(authResult, error);
  964|      0|    }];
  965|      0|  });
  966|      0|}
  967|       |
  968|       |- (void)createUserWithEmail:(NSString *)email
  969|       |                   password:(NSString *)password
  970|      0|                 completion:(nullable FIRAuthDataResultCallback)completion {
  971|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  972|      0|    FIRAuthDataResultCallback decoratedCallback =
  973|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  974|      0|    [self internalCreateUserWithEmail:email
  975|      0|                             password:password
  976|      0|                           completion:^(FIRSignUpNewUserResponse *_Nullable response,
  977|      0|                                        NSError *_Nullable error) {
  978|      0|      if (error) {
  979|      0|        decoratedCallback(nil, error);
  980|      0|        return;
  981|      0|      }
  982|      0|      [self completeSignInWithAccessToken:response.IDToken
  983|      0|                accessTokenExpirationDate:response.approximateExpirationDate
  984|      0|                             refreshToken:response.refreshToken
  985|      0|                                anonymous:NO
  986|      0|                                 callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  987|      0|        if (error) {
  988|      0|          decoratedCallback(nil, error);
  989|      0|          return;
  990|      0|        }
  991|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  992|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  993|      0|                                                    profile:nil
  994|      0|                                                   username:nil
  995|      0|                                                  isNewUser:YES];
  996|      0|        FIRAuthDataResult *authDataResult = user ?
  997|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  998|      0|                                 additionalUserInfo:additionalUserInfo] : nil;
  999|      0|        decoratedCallback(authDataResult, error);
 1000|      0|      }];
 1001|      0|    }];
 1002|      0|  });
 1003|      0|}
 1004|       |
 1005|       |- (void)confirmPasswordResetWithCode:(NSString *)code
 1006|       |                         newPassword:(NSString *)newPassword
 1007|      0|                          completion:(FIRConfirmPasswordResetCallback)completion {
 1008|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1009|      0|    FIRResetPasswordRequest *request =
 1010|      0|        [[FIRResetPasswordRequest alloc] initWithOobCode:code
 1011|      0|                                             newPassword:newPassword
 1012|      0|                                    requestConfiguration:self->_requestConfiguration];
 1013|      0|    [FIRAuthBackend resetPassword:request callback:^(FIRResetPasswordResponse *_Nullable response,
 1014|      0|                                                     NSError *_Nullable error) {
 1015|      0|      if (completion) {
 1016|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1017|      0|          if (error) {
 1018|      0|            completion(error);
 1019|      0|            return;
 1020|      0|          }
 1021|      0|          completion(nil);
 1022|      0|        });
 1023|      0|      }
 1024|      0|    }];
 1025|      0|  });
 1026|      0|}
 1027|       |
 1028|      0|- (void)checkActionCode:(NSString *)code completion:(FIRCheckActionCodeCallBack)completion {
 1029|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^ {
 1030|      0|    FIRResetPasswordRequest *request =
 1031|      0|    [[FIRResetPasswordRequest alloc] initWithOobCode:code
 1032|      0|                                         newPassword:nil
 1033|      0|                                requestConfiguration:self->_requestConfiguration];
 1034|      0|    [FIRAuthBackend resetPassword:request callback:^(FIRResetPasswordResponse *_Nullable response,
 1035|      0|                                                     NSError *_Nullable error) {
 1036|      0|      if (completion) {
 1037|      0|        if (error) {
 1038|      0|          dispatch_async(dispatch_get_main_queue(), ^{
 1039|      0|            completion(nil, error);
 1040|      0|          });
 1041|      0|          return;
 1042|      0|        }
 1043|      0|        FIRActionCodeOperation operation =
 1044|      0|            [FIRActionCodeInfo actionCodeOperationForRequestType:response.requestType];
 1045|      0|        FIRActionCodeInfo *actionCodeInfo =
 1046|      0|            [[FIRActionCodeInfo alloc] initWithOperation:operation
 1047|      0|                                                   email:response.email
 1048|      0|                                                newEmail:response.verifiedEmail];
 1049|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1050|      0|          completion(actionCodeInfo, nil);
 1051|      0|        });
 1052|      0|      }
 1053|      0|    }];
 1054|      0|  });
 1055|      0|}
 1056|       |
 1057|       |- (void)verifyPasswordResetCode:(NSString *)code
 1058|      0|                     completion:(FIRVerifyPasswordResetCodeCallback)completion {
 1059|      0|  [self checkActionCode:code completion:^(FIRActionCodeInfo *_Nullable info,
 1060|      0|                                          NSError *_Nullable error) {
 1061|      0|    if (completion) {
 1062|      0|      if (error) {
 1063|      0|        completion(nil, error);
 1064|      0|        return;
 1065|      0|      }
 1066|      0|      completion([info dataForKey:FIRActionCodeEmailKey], nil);
 1067|      0|    }
 1068|      0|  }];
 1069|      0|}
 1070|       |
 1071|      0|- (void)applyActionCode:(NSString *)code completion:(FIRApplyActionCodeCallback)completion {
 1072|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^ {
 1073|      0|    FIRSetAccountInfoRequest *request =
 1074|      0|        [[FIRSetAccountInfoRequest alloc] initWithRequestConfiguration:self->_requestConfiguration];
 1075|      0|    request.OOBCode = code;
 1076|      0|    [FIRAuthBackend setAccountInfo:request callback:^(FIRSetAccountInfoResponse *_Nullable response,
 1077|      0|                                                      NSError *_Nullable error) {
 1078|      0|      if (completion) {
 1079|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1080|      0|          completion(error);
 1081|      0|        });
 1082|      0|      }
 1083|      0|    }];
 1084|      0|  });
 1085|      0|}
 1086|       |
 1087|       |- (void)sendPasswordResetWithEmail:(NSString *)email
 1088|      0|                        completion:(nullable FIRSendPasswordResetCallback)completion {
 1089|      0|  [self sendPasswordResetWithNullableActionCodeSettings:nil email:email completion:completion];
 1090|      0|}
 1091|       |
 1092|       |- (void)sendPasswordResetWithEmail:(NSString *)email
 1093|       |                actionCodeSettings:(FIRActionCodeSettings *)actionCodeSettings
 1094|      0|                        completion:(nullable FIRSendPasswordResetCallback)completion {
 1095|      0|  [self sendPasswordResetWithNullableActionCodeSettings:actionCodeSettings
 1096|      0|                                                  email:email
 1097|      0|                                             completion:completion];
 1098|      0|}
 1099|       |
 1100|       |/** @fn sendPasswordResetWithNullableActionCodeSettings:actionCodeSetting:email:completion:
 1101|       |    @brief Initiates a password reset for the given email address and @FIRActionCodeSettings object.
 1102|       |
 1103|       |    @param actionCodeSettings Optionally, An @c FIRActionCodeSettings object containing settings
 1104|       |        related to the handling action codes.
 1105|       |    @param email The email address of the user.
 1106|       |    @param completion Optionally; a block which is invoked when the request finishes. Invoked
 1107|       |        asynchronously on the main thread in the future.
 1108|       | */
 1109|       |- (void)sendPasswordResetWithNullableActionCodeSettings:(nullable FIRActionCodeSettings *)
 1110|       |                                                        actionCodeSettings
 1111|       |                                                  email:(NSString *)email
 1112|       |                                             completion:(nullable FIRSendPasswordResetCallback)
 1113|      0|                                                        completion {
 1114|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1115|      0|    if (!email) {
 1116|      0|      [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
 1117|      0|          kMissingEmailInvalidParameterExceptionReason];
 1118|      0|      return;
 1119|      0|    }
 1120|      0|    FIRGetOOBConfirmationCodeRequest *request =
 1121|      0|        [FIRGetOOBConfirmationCodeRequest passwordResetRequestWithEmail:email
 1122|      0|                                                     actionCodeSettings:actionCodeSettings
 1123|      0|                                                   requestConfiguration:self->_requestConfiguration
 1124|      0|        ];
 1125|      0|    [FIRAuthBackend getOOBConfirmationCode:request
 1126|      0|                                  callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable response,
 1127|      0|                                             NSError *_Nullable error) {
 1128|      0|      if (completion) {
 1129|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1130|      0|          completion(error);
 1131|      0|        });
 1132|      0|      }
 1133|      0|    }];
 1134|      0|  });
 1135|      0|}
 1136|       |
 1137|       |- (void)sendSignInLinkToEmail:(nonnull NSString *)email
 1138|       |           actionCodeSettings:(nonnull FIRActionCodeSettings *)actionCodeSettings
 1139|      0|                   completion:(nullable FIRSendSignInLinkToEmailCallback)completion {
 1140|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1141|      0|    if (!email) {
 1142|      0|      [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
 1143|      0|          kMissingEmailInvalidParameterExceptionReason];
 1144|      0|    }
 1145|      0|
 1146|      0|    if (!actionCodeSettings.handleCodeInApp) {
 1147|      0|      [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
 1148|      0|          kHandleCodeInAppFalseExceptionReason];
 1149|      0|    }
 1150|      0|    FIRGetOOBConfirmationCodeRequest *request =
 1151|      0|        [FIRGetOOBConfirmationCodeRequest signInWithEmailLinkRequest:email
 1152|      0|                                                  actionCodeSettings:actionCodeSettings
 1153|      0|                                                requestConfiguration:self->_requestConfiguration];
 1154|      0|    [FIRAuthBackend getOOBConfirmationCode:request
 1155|      0|                                  callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable response,
 1156|      0|                                             NSError *_Nullable error) {
 1157|      0|      if (completion) {
 1158|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1159|      0|          completion(error);
 1160|      0|        });
 1161|      0|      }
 1162|      0|    }];
 1163|      0|  });
 1164|      0|}
 1165|       |
 1166|      0|- (void)updateCurrentUser:(FIRUser *)user completion:(nullable FIRUserUpdateCallback)completion {
 1167|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1168|      0|    if (!user) {
 1169|      0|      if (completion) {
 1170|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1171|      0|          completion([FIRAuthErrorUtils nullUserErrorWithMessage:nil]);
 1172|      0|        });
 1173|      0|      }
 1174|      0|      return;
 1175|      0|    }
 1176|      0|    void (^updateUserBlock)(FIRUser *user) = ^(FIRUser *user) {
 1177|      0|      NSError *error;
 1178|      0|      [self updateCurrentUser:user byForce:YES savingToDisk:YES error:(&error)];
 1179|      0|      if (error) {
 1180|      0|        if (completion) {
 1181|      0|          dispatch_async(dispatch_get_main_queue(), ^{
 1182|      0|            completion(error);
 1183|      0|          });
 1184|      0|        }
 1185|      0|        return;
 1186|      0|      } if (completion) {
 1187|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1188|      0|          completion(nil);
 1189|      0|        });
 1190|      0|      }
 1191|      0|    };
 1192|      0|    if (![user.requestConfiguration.APIKey isEqualToString:self->_requestConfiguration.APIKey]) {
 1193|      0|      // If the API keys are different, then we need to confirm that the user belongs to the same
 1194|      0|      // project before proceeding.
 1195|      0|      user.requestConfiguration = self->_requestConfiguration;
 1196|      0|      [user reloadWithCompletion:^(NSError *_Nullable error) {
 1197|      0|        if (error) {
 1198|      0|          if (completion) {
 1199|      0|            dispatch_async(dispatch_get_main_queue(), ^{
 1200|      0|              completion(error);
 1201|      0|            });
 1202|      0|          }
 1203|      0|          return;
 1204|      0|        }
 1205|      0|        updateUserBlock(user);
 1206|      0|      }];
 1207|      0|    } else {
 1208|      0|      updateUserBlock(user);
 1209|      0|    }
 1210|      0|  });
 1211|      0|}
 1212|       |
 1213|      0|- (BOOL)signOut:(NSError *_Nullable __autoreleasing *_Nullable)error {
 1214|      0|  __block BOOL result = YES;
 1215|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1216|      0|    if (!self->_currentUser) {
 1217|      0|      return;
 1218|      0|    }
 1219|      0|    result = [self updateCurrentUser:nil byForce:NO savingToDisk:YES error:error];
 1220|      0|  });
 1221|      0|  return result;
 1222|      0|}
 1223|       |
 1224|      0|- (BOOL)signOutByForceWithUserID:(NSString *)userID error:(NSError *_Nullable *_Nullable)error {
 1225|      0|  if (_currentUser.uid != userID) {
 1226|      0|    return YES;
 1227|      0|  }
 1228|      0|  return [self updateCurrentUser:nil byForce:YES savingToDisk:YES error:error];
 1229|      0|}
 1230|       |
 1231|      0|- (BOOL)isSignInWithEmailLink:(NSString *)link {
 1232|      0|  if (link.length == 0) {
 1233|      0|    return NO;
 1234|      0|  }
 1235|      0|  NSDictionary<NSString *, NSString *> *queryItems = [FIRAuthWebUtils parseURL:link];
 1236|      0|  if (![queryItems count]) {
 1237|      0|    NSURLComponents *urlComponents = [NSURLComponents componentsWithString:link];
 1238|      0|    if (!urlComponents.query) {
 1239|      0|      return NO;
 1240|      0|    }
 1241|      0|    queryItems = [FIRAuthWebUtils parseURL:urlComponents.query];
 1242|      0|  }
 1243|      0|
 1244|      0|  if (![queryItems count]) {
 1245|      0|    return NO;
 1246|      0|  }
 1247|      0|
 1248|      0|  NSString *actionCode = queryItems[@"oobCode"];
 1249|      0|  NSString *mode = queryItems[@"mode"];
 1250|      0|
 1251|      0|  if (actionCode && [mode isEqualToString:@"signIn"]) {
 1252|      0|    return YES;
 1253|      0|  }
 1254|      0|  return NO;
 1255|      0|}
 1256|       |
 1257|       |- (FIRAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:
 1258|      0|    (FIRAuthStateDidChangeListenerBlock)listener {
 1259|      0|  __block BOOL firstInvocation = YES;
 1260|      0|  __block NSString *previousUserID;
 1261|      0|  return [self addIDTokenDidChangeListener:^(FIRAuth *_Nonnull auth, FIRUser *_Nullable user) {
 1262|      0|    BOOL shouldCallListener = firstInvocation ||
 1263|      0|         !(previousUserID == user.uid || [previousUserID isEqualToString:user.uid]);
 1264|      0|    firstInvocation = NO;
 1265|      0|    previousUserID = [user.uid copy];
 1266|      0|    if (shouldCallListener) {
 1267|      0|      listener(auth, user);
 1268|      0|    }
 1269|      0|  }];
 1270|      0|}
 1271|       |
 1272|      0|- (void)removeAuthStateDidChangeListener:(FIRAuthStateDidChangeListenerHandle)listenerHandle {
 1273|      0|  [self removeIDTokenDidChangeListener:listenerHandle];
 1274|      0|}
 1275|       |
 1276|       |- (FIRIDTokenDidChangeListenerHandle)addIDTokenDidChangeListener:
 1277|      0|    (FIRIDTokenDidChangeListenerBlock)listener {
 1278|      0|  if (!listener) {
 1279|      0|    [NSException raise:NSInvalidArgumentException format:@"listener must not be nil."];
 1280|      0|    return nil;
 1281|      0|  }
 1282|      0|  FIRAuthStateDidChangeListenerHandle handle;
 1283|      0|  NSNotificationCenter *notifications = [NSNotificationCenter defaultCenter];
 1284|      0|  handle = [notifications addObserverForName:FIRAuthStateDidChangeNotification
 1285|      0|                                      object:self
 1286|      0|                                       queue:[NSOperationQueue mainQueue]
 1287|      0|                                  usingBlock:^(NSNotification *_Nonnull notification) {
 1288|      0|    FIRAuth *auth = notification.object;
 1289|      0|    listener(auth, auth.currentUser);
 1290|      0|  }];
 1291|      0|  @synchronized (self) {
 1292|      0|    [_listenerHandles addObject:handle];
 1293|      0|  }
 1294|      0|  dispatch_async(dispatch_get_main_queue(), ^{
 1295|      0|    listener(self, self->_currentUser);
 1296|      0|  });
 1297|      0|  return handle;
 1298|      0|}
 1299|       |
 1300|      0|- (void)removeIDTokenDidChangeListener:(FIRIDTokenDidChangeListenerHandle)listenerHandle {
 1301|      0|  [[NSNotificationCenter defaultCenter] removeObserver:listenerHandle];
 1302|      0|  @synchronized (self) {
 1303|      0|    [_listenerHandles removeObject:listenerHandle];
 1304|      0|  }
 1305|      0|}
 1306|       |
 1307|      0|- (void)useAppLanguage {
 1308|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1309|      0|    self->_requestConfiguration.languageCode = [[NSLocale preferredLanguages] firstObject];
 1310|      0|  });
 1311|      0|}
 1312|       |
 1313|      0|- (nullable NSString *)languageCode {
 1314|      0|  return _requestConfiguration.languageCode;
 1315|      0|}
 1316|       |
 1317|      0|- (void)setLanguageCode:(nullable NSString *)languageCode {
 1318|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1319|      0|    self->_requestConfiguration.languageCode = [languageCode copy];
 1320|      0|  });
 1321|      0|}
 1322|       |
 1323|      0|- (nullable NSString *)additionalFrameworkMarker {
 1324|      0|  return self->_requestConfiguration.additionalFrameworkMarker;
 1325|      0|}
 1326|       |
 1327|      0|- (void)setAdditionalFrameworkMarker:(nullable NSString *)additionalFrameworkMarker {
 1328|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1329|      0|    self->_requestConfiguration.additionalFrameworkMarker = [additionalFrameworkMarker copy];
 1330|      0|  });
 1331|      0|}
 1332|       |
 1333|       |#if TARGET_OS_IOS
 1334|       |#pragma clang diagnostic push
 1335|       |#pragma clang diagnostic ignored "-Wunused-property-ivar"
 1336|       |// The warning is ignored because we use the token manager to get the token, instead of using the ivar.
 1337|      0|- (nullable NSData *)APNSToken {
 1338|      0|  __block NSData *result = nil;
 1339|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1340|      0|    result = self->_tokenManager.token.data;
 1341|      0|  });
 1342|      0|  return result;
 1343|      0|}
 1344|       |#pragma clang diagnostic pop
 1345|       |
 1346|       |#pragma mark - UIApplicationDelegate
 1347|       |
 1348|       |- (void)application:(UIApplication *)application
 1349|      0|didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
 1350|      0|  [self setAPNSToken:deviceToken type:FIRAuthAPNSTokenTypeUnknown];
 1351|      0|}
 1352|       |
 1353|       |- (void)application:(UIApplication *)application
 1354|      0|didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
 1355|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1356|      0|    [self->_tokenManager cancelWithError:error];
 1357|      0|  });
 1358|      0|}
 1359|       |
 1360|       |- (void)application:(UIApplication *)application
 1361|       |didReceiveRemoteNotification:(NSDictionary *)userInfo
 1362|      0|fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
 1363|      0|  [self canHandleNotification:userInfo];
 1364|      0|}
 1365|       |
 1366|       |- (void)application:(UIApplication *)application
 1367|      0|didReceiveRemoteNotification:(NSDictionary *)userInfo {
 1368|      0|  [self canHandleNotification:userInfo];
 1369|      0|}
 1370|       |
 1371|       |- (BOOL)application:(UIApplication *)app
 1372|       |            openURL:(NSURL *)url
 1373|      0|            options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {
 1374|      0|  return [self canHandleURL:url];
 1375|      0|}
 1376|       |
 1377|       |- (BOOL)application:(UIApplication *)application
 1378|       |            openURL:(NSURL *)url
 1379|       |  sourceApplication:(nullable NSString *)sourceApplication
 1380|      0|         annotation:(id)annotation {
 1381|      0|  return [self canHandleURL:url];
 1382|      0|}
 1383|       |
 1384|      0|- (void)setAPNSToken:(NSData *)token type:(FIRAuthAPNSTokenType)type {
 1385|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1386|      0|    self->_tokenManager.token = [[FIRAuthAPNSToken alloc] initWithData:token type:type];
 1387|      0|  });
 1388|      0|}
 1389|       |
 1390|      0|- (BOOL)canHandleNotification:(NSDictionary *)userInfo {
 1391|      0|  __block BOOL result = NO;
 1392|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1393|      0|    result = [self->_notificationManager canHandleNotification:userInfo];
 1394|      0|  });
 1395|      0|  return result;
 1396|      0|}
 1397|       |
 1398|      0|- (BOOL)canHandleURL:(NSURL *)URL {
 1399|      0|  __block BOOL result = NO;
 1400|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1401|      0|    result = [self->_authURLPresenter canHandleURL:URL];
 1402|      0|  });
 1403|      0|  return result;
 1404|      0|}
 1405|       |
 1406|       |#pragma mark - UISceneDelegate
 1407|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
 1408|      0|- (void)scene:(UIScene *)scene openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts API_AVAILABLE(ios(13.0)) {
 1409|      0|  for (UIOpenURLContext *urlContext in URLContexts) {
 1410|      0|    NSURL *url = [urlContext URL];
 1411|      0|    [self canHandleURL:url];
 1412|      0|  }
 1413|      0|}
 1414|       |#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
 1415|       |#endif  // TARGET_OS_IOS
 1416|       |
 1417|       |#pragma mark - Internal Methods
 1418|       |
 1419|       |#if TARGET_OS_IOS
 1420|       |/** @fn signInWithPhoneCredential:callback:
 1421|       |    @brief Signs in using a phone credential.
 1422|       |    @param credential The Phone Auth credential used to sign in.
 1423|       |    @param operation The type of operation for which this sign-in attempt is initiated.
 1424|       |    @param callback A block which is invoked when the sign in finishes (or is cancelled.) Invoked
 1425|       |        asynchronously on the global auth work queue in the future.
 1426|       | */
 1427|       |- (void)signInWithPhoneCredential:(FIRPhoneAuthCredential *)credential
 1428|       |                        operation:(FIRAuthOperationType)operation
 1429|      0|                         callback:(FIRVerifyPhoneNumberResponseCallback)callback {
 1430|      0|  if (credential.temporaryProof.length && credential.phoneNumber.length) {
 1431|      0|    FIRVerifyPhoneNumberRequest *request =
 1432|      0|      [[FIRVerifyPhoneNumberRequest alloc] initWithTemporaryProof:credential.temporaryProof
 1433|      0|                                                      phoneNumber:credential.phoneNumber
 1434|      0|                                                        operation:operation
 1435|      0|                                             requestConfiguration:_requestConfiguration];
 1436|      0|    [FIRAuthBackend verifyPhoneNumber:request callback:callback];
 1437|      0|    return;
 1438|      0|  }
 1439|      0|
 1440|      0|  if (!credential.verificationID.length) {
 1441|      0|    callback(nil, [FIRAuthErrorUtils missingVerificationIDErrorWithMessage:nil]);
 1442|      0|    return;
 1443|      0|  }
 1444|      0|  if (!credential.verificationCode.length) {
 1445|      0|    callback(nil, [FIRAuthErrorUtils missingVerificationCodeErrorWithMessage:nil]);
 1446|      0|    return;
 1447|      0|  }
 1448|      0|  FIRVerifyPhoneNumberRequest *request =
 1449|      0|      [[FIRVerifyPhoneNumberRequest alloc]initWithVerificationID:credential.verificationID
 1450|      0|                                                verificationCode:credential.verificationCode
 1451|      0|                                                       operation:operation
 1452|      0|                                            requestConfiguration:_requestConfiguration];
 1453|      0|  [FIRAuthBackend verifyPhoneNumber:request callback:callback];
 1454|      0|}
 1455|       |
 1456|       |#endif
 1457|       |
 1458|       |/** @fn internalSignInAndRetrieveDataWithCustomToken:completion:
 1459|       |    @brief Signs in a Firebase user given a custom token.
 1460|       |    @param token A self-signed custom auth token.
 1461|       |    @param completion A block which is invoked when the custom token sign in request completes.
 1462|       | */
 1463|       |- (void)internalSignInAndRetrieveDataWithCustomToken:(NSString *)token
 1464|       |                                          completion:(nullable FIRAuthDataResultCallback)
 1465|      0|                                              completion {
 1466|      0|  FIRVerifyCustomTokenRequest *request =
 1467|      0|    [[FIRVerifyCustomTokenRequest alloc] initWithToken:token
 1468|      0|                                  requestConfiguration:_requestConfiguration];
 1469|      0|  [FIRAuthBackend verifyCustomToken:request
 1470|      0|                           callback:^(FIRVerifyCustomTokenResponse *_Nullable response,
 1471|      0|                                      NSError *_Nullable error) {
 1472|      0|    if (error) {
 1473|      0|      if (completion) {
 1474|      0|        completion(nil, error);
 1475|      0|        return;
 1476|      0|      }
 1477|      0|    }
 1478|      0|    [self completeSignInWithAccessToken:response.IDToken
 1479|      0|              accessTokenExpirationDate:response.approximateExpirationDate
 1480|      0|                           refreshToken:response.refreshToken
 1481|      0|                              anonymous:NO
 1482|      0|                               callback:^(FIRUser *_Nullable user,
 1483|      0|                                          NSError *_Nullable error) {
 1484|      0|      if (error && completion) {
 1485|      0|        completion(nil, error);
 1486|      0|        return;
 1487|      0|      }
 1488|      0|      FIRAdditionalUserInfo *additonalUserInfo =
 1489|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:nil
 1490|      0|                                                   profile:nil
 1491|      0|                                                  username:nil
 1492|      0|                                                 isNewUser:response.isNewUser];
 1493|      0|      FIRAuthDataResult *result = user ?
 1494|      0|          [[FIRAuthDataResult alloc] initWithUser:user additionalUserInfo:additonalUserInfo] : nil;
 1495|      0|      if (completion) {
 1496|      0|        completion(result, error);
 1497|      0|      }
 1498|      0|    }];
 1499|      0|  }];
 1500|      0|}
 1501|       |
 1502|       |/** @fn internalCreateUserWithEmail:password:completion:
 1503|       |    @brief Makes a backend request attempting to create a new Firebase user given an email address
 1504|       |        and password.
 1505|       |    @param email The email address used to create the new Firebase user.
 1506|       |    @param password The password used to create the new Firebase user.
 1507|       |    @param completion Optionally; a block which is invoked when the request finishes.
 1508|       | */
 1509|       |- (void)internalCreateUserWithEmail:(NSString *)email
 1510|       |                           password:(NSString *)password
 1511|      0|                         completion:(nullable FIRSignupNewUserCallback)completion {
 1512|      0|  FIRSignUpNewUserRequest *request =
 1513|      0|      [[FIRSignUpNewUserRequest alloc] initWithEmail:email
 1514|      0|                                            password:password
 1515|      0|                                         displayName:nil
 1516|      0|                                requestConfiguration:_requestConfiguration];
 1517|      0|  if (![request.password length]) {
 1518|      0|    completion(nil, [FIRAuthErrorUtils
 1519|      0|        weakPasswordErrorWithServerResponseReason:kMissingPasswordReason]);
 1520|      0|    return;
 1521|      0|  }
 1522|      0|  if (![request.email length]) {
 1523|      0|    completion(nil, [FIRAuthErrorUtils missingEmailErrorWithMessage:nil]);
 1524|      0|    return;
 1525|      0|  }
 1526|      0|  [FIRAuthBackend signUpNewUser:request callback:completion];
 1527|      0|}
 1528|       |
 1529|       |/** @fn internalSignInAnonymouslyWithCompletion:
 1530|       |    @param completion A block which is invoked when the anonymous sign in request completes.
 1531|       | */
 1532|      0|- (void)internalSignInAnonymouslyWithCompletion:(FIRSignupNewUserCallback)completion {
 1533|      0|  FIRSignUpNewUserRequest *request =
 1534|      0|      [[FIRSignUpNewUserRequest alloc]initWithRequestConfiguration:_requestConfiguration];
 1535|      0|  [FIRAuthBackend signUpNewUser:request
 1536|      0|                       callback:completion];
 1537|      0|}
 1538|       |
 1539|       |/** @fn possiblyPostAuthStateChangeNotification
 1540|       |    @brief Posts the auth state change notificaton if current user's token has been changed.
 1541|       | */
 1542|      1|- (void)possiblyPostAuthStateChangeNotification {
 1543|      1|  NSString *token = _currentUser.rawAccessToken;
 1544|      1|  if (_lastNotifiedUserToken == token ||
 1545|      1|      (token != nil && [_lastNotifiedUserToken isEqualToString:token])) {
 1546|      1|    return;
 1547|      1|  }
 1548|      0|  _lastNotifiedUserToken = token;
 1549|      0|  if (_autoRefreshTokens) {
 1550|      0|    // Shedule new refresh task after successful attempt.
 1551|      0|    [self scheduleAutoTokenRefresh];
 1552|      0|  }
 1553|      0|  NSMutableDictionary *internalNotificationParameters = [NSMutableDictionary dictionary];
 1554|      0|  if (self.app) {
 1555|      0|    internalNotificationParameters[FIRAuthStateDidChangeInternalNotificationAppKey] = self.app;
 1556|      0|  }
 1557|      0|  if (token.length) {
 1558|      0|    internalNotificationParameters[FIRAuthStateDidChangeInternalNotificationTokenKey] = token;
 1559|      0|  }
 1560|      0|  internalNotificationParameters[FIRAuthStateDidChangeInternalNotificationUIDKey] = _currentUser.uid;
 1561|      0|  NSNotificationCenter *notifications = [NSNotificationCenter defaultCenter];
 1562|      0|  dispatch_async(dispatch_get_main_queue(), ^{
 1563|      0|    [notifications postNotificationName:FIRAuthStateDidChangeInternalNotification
 1564|      0|                                 object:self
 1565|      0|                               userInfo:internalNotificationParameters];
 1566|      0|    [notifications postNotificationName:FIRAuthStateDidChangeNotification
 1567|      0|                                 object:self];
 1568|      0|  });
 1569|      0|}
 1570|       |
 1571|      0|- (BOOL)updateKeychainWithUser:(FIRUser *)user error:(NSError *_Nullable *_Nullable)error {
 1572|      0|  if (user != _currentUser) {
 1573|      0|    // No-op if the user is no longer signed in. This is not considered an error as we don't check
 1574|      0|    // whether the user is still current on other callbacks of user operations either.
 1575|      0|    return YES;
 1576|      0|  }
 1577|      0|  if ([self saveUser:user error:error]) {
 1578|      0|    [self possiblyPostAuthStateChangeNotification];
 1579|      0|    return YES;
 1580|      0|  }
 1581|      0|  return NO;
 1582|      0|}
 1583|       |
 1584|       |/** @fn setKeychainServiceNameForApp
 1585|       |    @brief Sets the keychain service name global data for the particular app.
 1586|       |    @param app The Firebase app to set keychain service name for.
 1587|       | */
 1588|      1|+ (void)setKeychainServiceNameForApp:(FIRApp *)app {
 1589|      1|  @synchronized (self) {
 1590|      1|    gKeychainServiceNameForAppName[app.name] =
 1591|      1|        [@"firebase_auth_" stringByAppendingString:app.options.googleAppID];
 1592|      1|  }
 1593|      1|}
 1594|       |
 1595|       |/** @fn keychainServiceNameForAppName:
 1596|       |    @brief Gets the keychain service name global data for the particular app by name.
 1597|       |    @param appName The name of the Firebase app to get keychain service name for.
 1598|       | */
 1599|      1|+ (NSString *)keychainServiceNameForAppName:(NSString *)appName {
 1600|      1|  @synchronized (self) {
 1601|      1|    return gKeychainServiceNameForAppName[appName];
 1602|      1|  }
 1603|      1|}
 1604|       |
 1605|       |/** @fn deleteKeychainServiceNameForAppName:
 1606|       |    @brief Deletes the keychain service name global data for the particular app by name.
 1607|       |    @param appName The name of the Firebase app to delete keychain service name for.
 1608|       | */
 1609|      0|+ (void)deleteKeychainServiceNameForAppName:(NSString *)appName {
 1610|      0|  @synchronized (self) {
 1611|      0|    [gKeychainServiceNameForAppName removeObjectForKey:appName];
 1612|      0|  }
 1613|      0|}
 1614|       |
 1615|       |/** @fn scheduleAutoTokenRefreshWithDelay:
 1616|       |    @brief Schedules a task to automatically refresh tokens on the current user. The token refresh
 1617|       |        is scheduled 5 minutes before the  scheduled expiration time.
 1618|       |    @remarks If the token expires in less than 5 minutes, schedule the token refresh immediately.
 1619|       | */
 1620|      0|- (void)scheduleAutoTokenRefresh {
 1621|      0|  NSTimeInterval tokenExpirationInterval =
 1622|      0|      [_currentUser.accessTokenExpirationDate timeIntervalSinceNow] - kTokenRefreshHeadStart;
 1623|      0|  [self scheduleAutoTokenRefreshWithDelay:MAX(tokenExpirationInterval, 0) retry:NO];
 1624|      0|}
 1625|       |
 1626|       |/** @fn scheduleAutoTokenRefreshWithDelay:
 1627|       |    @brief Schedules a task to automatically refresh tokens on the current user.
 1628|       |    @param delay The delay in seconds after which the token refresh task should be scheduled to be
 1629|       |        executed.
 1630|       |    @param retry Flag to determine whether the invocation is a retry attempt or not.
 1631|       | */
 1632|      0|- (void)scheduleAutoTokenRefreshWithDelay:(NSTimeInterval)delay retry:(BOOL)retry {
 1633|      0|  NSString *accessToken = _currentUser.rawAccessToken;
 1634|      0|  if (!accessToken) {
 1635|      0|    return;
 1636|      0|  }
 1637|      0|  if (retry) {
 1638|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000003",
 1639|      0|               @"Token auto-refresh re-scheduled in %02d:%02d "
 1640|      0|               @"because of error on previous refresh attempt.",
 1641|      0|               (int)ceil(delay) / 60, (int)ceil(delay) % 60);
 1642|      0|  } else {
 1643|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000004",
 1644|      0|               @"Token auto-refresh scheduled in %02d:%02d for the new token.",
 1645|      0|               (int)ceil(delay) / 60, (int)ceil(delay) % 60);
 1646|      0|  }
 1647|      0|  _autoRefreshScheduled = YES;
 1648|      0|  __weak FIRAuth *weakSelf = self;
 1649|      0|  [[FIRAuthDispatcher sharedInstance] dispatchAfterDelay:delay
 1650|      0|                                                   queue:FIRAuthGlobalWorkQueue()
 1651|      0|                                                    task:^(void) {
 1652|      0|    FIRAuth *strongSelf = weakSelf;
 1653|      0|    if (!strongSelf) {
 1654|      0|      return;
 1655|      0|    }
 1656|      0|    if (![strongSelf->_currentUser.rawAccessToken isEqualToString:accessToken]) {
 1657|      0|      // Another auto refresh must have been scheduled, so keep _autoRefreshScheduled unchanged.
 1658|      0|      return;
 1659|      0|    }
 1660|      0|    strongSelf->_autoRefreshScheduled = NO;
 1661|      0|    if (strongSelf->_isAppInBackground) {
 1662|      0|      return;
 1663|      0|    }
 1664|      0|    NSString *uid = strongSelf->_currentUser.uid;
 1665|      0|    [strongSelf->_currentUser internalGetTokenForcingRefresh:YES
 1666|      0|                                                    callback:^(NSString *_Nullable token,
 1667|      0|                                                               NSError *_Nullable error) {
 1668|      0|      if (![strongSelf->_currentUser.uid isEqualToString:uid]) {
 1669|      0|        return;
 1670|      0|      }
 1671|      0|      if (error) {
 1672|      0|        // Kicks off exponential back off logic to retry failed attempt. Starts with one minute
 1673|      0|        // delay (60 seconds) if this is the first failed attempt.
 1674|      0|        NSTimeInterval rescheduleDelay;
 1675|      0|        if (retry) {
 1676|      0|          rescheduleDelay = MIN(delay * 2, kMaxWaitTimeForBackoff);
 1677|      0|        } else {
 1678|      0|          rescheduleDelay = 60;
 1679|      0|        }
 1680|      0|        [strongSelf scheduleAutoTokenRefreshWithDelay:rescheduleDelay retry:YES];
 1681|      0|      }
 1682|      0|    }];
 1683|      0|  }];
 1684|      0|}
 1685|       |
 1686|       |#pragma mark -
 1687|       |
 1688|       |/** @fn completeSignInWithTokenService:callback:
 1689|       |    @brief Completes a sign-in flow once we have access and refresh tokens for the user.
 1690|       |    @param accessToken The STS access token.
 1691|       |    @param accessTokenExpirationDate The approximate expiration date of the access token.
 1692|       |    @param refreshToken The STS refresh token.
 1693|       |    @param anonymous Whether or not the user is anonymous.
 1694|       |    @param callback Called when the user has been signed in or when an error occurred. Invoked
 1695|       |        asynchronously on the global auth work queue in the future.
 1696|       | */
 1697|       |- (void)completeSignInWithAccessToken:(nullable NSString *)accessToken
 1698|       |            accessTokenExpirationDate:(nullable NSDate *)accessTokenExpirationDate
 1699|       |                         refreshToken:(nullable NSString *)refreshToken
 1700|       |                            anonymous:(BOOL)anonymous
 1701|      0|                             callback:(FIRAuthResultCallback)callback {
 1702|      0|  [FIRUser retrieveUserWithAuth:self
 1703|      0|                    accessToken:accessToken
 1704|      0|      accessTokenExpirationDate:accessTokenExpirationDate
 1705|      0|                   refreshToken:refreshToken
 1706|      0|                      anonymous:anonymous
 1707|      0|                       callback:callback];
 1708|      0|}
 1709|       |
 1710|       |/** @fn signInFlowAuthResultCallbackByDecoratingCallback:
 1711|       |    @brief Creates a FIRAuthResultCallback block which wraps another FIRAuthResultCallback; trying
 1712|       |        to update the current user before forwarding it's invocations along to a subject block
 1713|       |    @param callback Called when the user has been updated or when an error has occurred. Invoked
 1714|       |        asynchronously on the main thread in the future.
 1715|       |    @return Returns a block that updates the current user.
 1716|       |    @remarks Typically invoked as part of the complete sign-in flow. For any other uses please
 1717|       |        consider alternative ways of updating the current user.
 1718|       |*/
 1719|       |- (FIRAuthResultCallback)signInFlowAuthResultCallbackByDecoratingCallback:
 1720|      0|    (nullable FIRAuthResultCallback)callback {
 1721|      0|  return ^(FIRUser *_Nullable user, NSError *_Nullable error) {
 1722|      0|    if (error) {
 1723|      0|      if (callback) {
 1724|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1725|      0|          callback(nil, error);
 1726|      0|        });
 1727|      0|      }
 1728|      0|      return;
 1729|      0|    }
 1730|      0|    if (![self updateCurrentUser:user byForce:NO savingToDisk:YES error:&error]) {
 1731|      0|      if (callback) {
 1732|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1733|      0|          callback(nil, error);
 1734|      0|        });
 1735|      0|      }
 1736|      0|      return;
 1737|      0|    }
 1738|      0|    if (callback) {
 1739|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1740|      0|        callback(user, nil);
 1741|      0|      });
 1742|      0|    }
 1743|      0|  };
 1744|      0|}
 1745|       |
 1746|       |/** @fn signInFlowAuthDataResultCallbackByDecoratingCallback:
 1747|       |    @brief Creates a FIRAuthDataResultCallback block which wraps another FIRAuthDataResultCallback;
 1748|       |        trying to update the current user before forwarding it's invocations along to a subject
 1749|       |        block.
 1750|       |    @param callback Called when the user has been updated or when an error has occurred. Invoked
 1751|       |        asynchronously on the main thread in the future.
 1752|       |    @return Returns a block that updates the current user.
 1753|       |    @remarks Typically invoked as part of the complete sign-in flow. For any other uses please
 1754|       |        consider alternative ways of updating the current user.
 1755|       |*/
 1756|       |- (FIRAuthDataResultCallback)signInFlowAuthDataResultCallbackByDecoratingCallback:
 1757|      0|    (nullable FIRAuthDataResultCallback)callback {
 1758|      0|  return ^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
 1759|      0|    if (error) {
 1760|      0|      if (callback) {
 1761|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1762|      0|          callback(nil, error);
 1763|      0|        });
 1764|      0|      }
 1765|      0|      return;
 1766|      0|    }
 1767|      0|    if (![self updateCurrentUser:authResult.user byForce:NO savingToDisk:YES error:&error]) {
 1768|      0|      if (callback) {
 1769|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1770|      0|          callback(nil, error);
 1771|      0|        });
 1772|      0|      }
 1773|      0|      return;
 1774|      0|    }
 1775|      0|    if (callback) {
 1776|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1777|      0|        callback(authResult, nil);
 1778|      0|      });
 1779|      0|    }
 1780|      0|  };
 1781|      0|}
 1782|       |
 1783|       |#pragma mark - User-Related Methods
 1784|       |
 1785|       |/** @fn updateCurrentUser:byForce:savingToDisk:error:
 1786|       |    @brief Update the current user; initializing the user's internal properties correctly, and
 1787|       |        optionally saving the user to disk.
 1788|       |    @remarks This method is called during: sign in and sign out events, as well as during class
 1789|       |        initialization time. The only time the saveToDisk parameter should be set to NO is during
 1790|       |        class initialization time because the user was just read from disk.
 1791|       |    @param user The user to use as the current user (including nil, which is passed at sign out
 1792|       |        time.)
 1793|       |    @param saveToDisk Indicates the method should persist the user data to disk.
 1794|       | */
 1795|       |- (BOOL)updateCurrentUser:(nullable FIRUser *)user
 1796|       |                  byForce:(BOOL)force
 1797|       |             savingToDisk:(BOOL)saveToDisk
 1798|      1|                    error:(NSError *_Nullable *_Nullable)error {
 1799|      1|  if (user == _currentUser) {
 1800|      1|    [self possiblyPostAuthStateChangeNotification];
 1801|      1|    return YES;
 1802|      1|  }
 1803|      0|  BOOL success = YES;
 1804|      0|  if (saveToDisk) {
 1805|      0|    success = [self saveUser:user error:error];
 1806|      0|  }
 1807|      0|  if (success || force) {
 1808|      0|    _currentUser = user;
 1809|      0|    [self possiblyPostAuthStateChangeNotification];
 1810|      0|  }
 1811|      0|  return success;
 1812|      0|}
 1813|       |
 1814|       |/** @fn saveUser:error:
 1815|       |    @brief Persists user.
 1816|       |    @param user The user to save.
 1817|       |    @param outError Return value for any error which occurs.
 1818|       |    @return @YES on success, @NO otherwise.
 1819|       | */
 1820|       |- (BOOL)saveUser:(nullable FIRUser *)user
 1821|      0|           error:(NSError *_Nullable *_Nullable)outError {
 1822|      0|  BOOL success;
 1823|      0|
 1824|      0|  if (!self.userAccessGroup) {
 1825|      0|    NSString *userKey = [NSString stringWithFormat:kUserKey, _firebaseAppName];
 1826|      0|    if (!user) {
 1827|      0|      success = [_keychainServices removeDataForKey:userKey error:outError];
 1828|      0|    } else {
 1829|      0|      // Encode the user object.
 1830|      0|      NSMutableData *archiveData = [NSMutableData data];
 1831|      0|      NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:archiveData];
 1832|      0|      [archiver encodeObject:user forKey:userKey];
 1833|      0|      [archiver finishEncoding];
 1834|      0|
 1835|      0|      // Save the user object's encoded value.
 1836|      0|      success = [_keychainServices setData:archiveData forKey:userKey error:outError];
 1837|      0|    }
 1838|      0|  } else {
 1839|      0|    if (!user) {
 1840|      0|      success = [self.storedUserManager removeStoredUserForAccessGroup:self.userAccessGroup
 1841|      0|                                                     projectIdentifier:self.app.options.APIKey
 1842|      0|                                                                 error:outError];
 1843|      0|    } else {
 1844|      0|      success = [self.storedUserManager setStoredUser:user
 1845|      0|                                       forAccessGroup:self.userAccessGroup
 1846|      0|                                    projectIdentifier:self.app.options.APIKey
 1847|      0|                                                error:outError];
 1848|      0|    }
 1849|      0|  }
 1850|      0|
 1851|      0|  return success;
 1852|      0|}
 1853|       |
 1854|       |/** @fn getUser:error:
 1855|       |    @brief Retrieves the saved user associated, if one exists, from the keychain.
 1856|       |    @param outUser An out parameter which is populated with the saved user, if one exists.
 1857|       |    @param error Return value for any error which occurs.
 1858|       |    @return YES if the operation was a success (irrespective of whether or not a saved user existed
 1859|       |        for the given @c firebaseAppId,) NO if an error occurred.
 1860|       | */
 1861|       |- (BOOL)getUser:(FIRUser *_Nullable *)outUser
 1862|      1|          error:(NSError *_Nullable *_Nullable)error {
 1863|      1|  if (!self.userAccessGroup) {
 1864|      1|    NSString *userKey = [NSString stringWithFormat:kUserKey, _firebaseAppName];
 1865|      1|
 1866|      1|    NSError *keychainError;
 1867|      1|    NSData *encodedUserData = [_keychainServices dataForKey:userKey error:&keychainError];
 1868|      1|    if (keychainError) {
 1869|      0|      if (error) {
 1870|      0|        *error = keychainError;
 1871|      0|      }
 1872|      0|      return NO;
 1873|      0|    }
 1874|      1|    if (!encodedUserData) {
 1875|      1|      *outUser = nil;
 1876|      1|      return YES;
 1877|      1|    }
 1878|      0|    NSKeyedUnarchiver *unarchiver =
 1879|      0|        [[NSKeyedUnarchiver alloc] initForReadingWithData:encodedUserData];
 1880|      0|    FIRUser *user = [unarchiver decodeObjectOfClass:[FIRUser class] forKey:userKey];
 1881|      0|    user.auth = self;
 1882|      0|    *outUser = user;
 1883|      0|
 1884|      0|    return YES;
 1885|      0|  } else {
 1886|      0|    FIRUser *user = [self.storedUserManager getStoredUserForAccessGroup:self.userAccessGroup
 1887|      0|                                                      projectIdentifier:self.app.options.APIKey
 1888|      0|                                                                  error:error];
 1889|      0|    user.auth = self;
 1890|      0|    *outUser = user;
 1891|      0|    if (user) {
 1892|      0|      return YES;
 1893|      0|    } else {
 1894|      0|      if (error && *error) {
 1895|      0|        return NO;
 1896|      0|      } else {
 1897|      0|        return YES;
 1898|      0|      }
 1899|      0|    }
 1900|      0|  }
 1901|      1|}
 1902|       |
 1903|       |#pragma mark - Interoperability
 1904|       |
 1905|      1|+ (nonnull NSArray<FIRComponent *> *)componentsToRegister {
 1906|      1|  FIRComponentCreationBlock authCreationBlock =
 1907|      1|  ^id _Nullable(FIRComponentContainer *_Nonnull container, BOOL *_Nonnull isCacheable) {
 1908|      1|    *isCacheable = YES;
 1909|      1|    return [[FIRAuth alloc] initWithApp:container.app];
 1910|      1|  };
 1911|      1|  FIRComponent *authInterop = [FIRComponent componentWithProtocol:@protocol(FIRAuthInterop)
 1912|      1|                                              instantiationTiming:FIRInstantiationTimingAlwaysEager
 1913|      1|                                                     dependencies:@[]
 1914|      1|                                                    creationBlock:authCreationBlock];
 1915|      1|  return @[authInterop];
 1916|      1|}
 1917|       |
 1918|       |#pragma mark - FIRComponentLifecycleMaintainer
 1919|       |
 1920|      0|- (void)appWillBeDeleted:(nonnull FIRApp *)app {
 1921|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1922|      0|    // This doesn't stop any request already issued, see b/27704535 .
 1923|      0|    NSString *keychainServiceName = [FIRAuth keychainServiceNameForAppName:app.name];
 1924|      0|    if (keychainServiceName) {
 1925|      0|      [[self class] deleteKeychainServiceNameForAppName:app.name];
 1926|      0|      FIRAuthKeychainServices *keychain = [[FIRAuthKeychainServices alloc] initWithService:keychainServiceName];
 1927|      0|      NSString *userKey = [NSString stringWithFormat:kUserKey, app.name];
 1928|      0|      [keychain removeDataForKey:userKey error:NULL];
 1929|      0|    }
 1930|      0|    dispatch_async(dispatch_get_main_queue(), ^{
 1931|      0|      // TODO: Move over to fire an event instead, once ready.
 1932|      0|      [[NSNotificationCenter defaultCenter] postNotificationName:FIRAuthStateDidChangeNotification
 1933|      0|                                                          object:nil];
 1934|      0|    });
 1935|      0|  });
 1936|      0|}
 1937|       |
 1938|       |#pragma mark - FIRAuthInterop
 1939|       |
 1940|      0|- (void)getTokenForcingRefresh:(BOOL)forceRefresh withCallback:(FIRTokenCallback)callback {
 1941|      0|  __weak FIRAuth *weakSelf = self;
 1942|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1943|      0|    FIRAuth *strongSelf = weakSelf;
 1944|      0|    // Enable token auto-refresh if not aleady enabled.
 1945|      0|    if (strongSelf && !strongSelf->_autoRefreshTokens) {
 1946|      0|      FIRLogInfo(kFIRLoggerAuth, @"I-AUT000002", @"Token auto-refresh enabled.");
 1947|      0|      strongSelf->_autoRefreshTokens = YES;
 1948|      0|      [strongSelf scheduleAutoTokenRefresh];
 1949|      0|
 1950|      0|#if TARGET_OS_IOS || TARGET_OS_TV // TODO: Is a similar mechanism needed on macOS?
 1951|      0|      strongSelf->_applicationDidBecomeActiveObserver = [[NSNotificationCenter defaultCenter]
 1952|      0|                                                         addObserverForName:UIApplicationDidBecomeActiveNotification
 1953|      0|                                                         object:nil
 1954|      0|                                                         queue:nil
 1955|      0|                                                         usingBlock:^(NSNotification *notification) {
 1956|      0|                                                           FIRAuth *strongSelf = weakSelf;
 1957|      0|                                                           if (strongSelf) {
 1958|      0|                                                             strongSelf->_isAppInBackground = NO;
 1959|      0|                                                             if (!strongSelf->_autoRefreshScheduled) {
 1960|      0|                                                               [weakSelf scheduleAutoTokenRefresh];
 1961|      0|                                                             }
 1962|      0|                                                           }
 1963|      0|                                                         }];
 1964|      0|      strongSelf->_applicationDidEnterBackgroundObserver = [[NSNotificationCenter defaultCenter]
 1965|      0|                                                            addObserverForName:UIApplicationDidEnterBackgroundNotification
 1966|      0|                                                            object:nil
 1967|      0|                                                            queue:nil
 1968|      0|                                                            usingBlock:^(NSNotification *notification) {
 1969|      0|                                                              FIRAuth *strongSelf = weakSelf;
 1970|      0|                                                              if (strongSelf) {
 1971|      0|                                                                strongSelf->_isAppInBackground = YES;
 1972|      0|                                                              }
 1973|      0|                                                            }];
 1974|      0|#endif
 1975|      0|    }
 1976|      0|    // Call back with 'nil' if there is no current user.
 1977|      0|    if (!strongSelf || !strongSelf->_currentUser) {
 1978|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1979|      0|        callback(nil, nil);
 1980|      0|      });
 1981|      0|      return;
 1982|      0|    }
 1983|      0|    // Call back with current user token.
 1984|      0|    [strongSelf->_currentUser internalGetTokenForcingRefresh:forceRefresh
 1985|      0|                                                    callback:^(NSString *_Nullable token,
 1986|      0|                                                               NSError *_Nullable error) {
 1987|      0|                                                      dispatch_async(dispatch_get_main_queue(), ^{
 1988|      0|                                                        callback(token, error);
 1989|      0|                                                      });
 1990|      0|                                                    }];
 1991|      0|  });
 1992|      0|}
 1993|       |
 1994|      0|- (nullable NSString *)getUserID {
 1995|      0|  return _currentUser.uid;
 1996|      0|}
 1997|       |
 1998|       |#pragma mark - Keychain sharing
 1999|       |
 2000|       |- (BOOL)useUserAccessGroup:(NSString *_Nullable)accessGroup
 2001|      0|                     error:(NSError *_Nullable *_Nullable)outError {
 2002|      0|  BOOL success;
 2003|      0|  success = [self.storedUserManager setStoredUserAccessGroup:accessGroup error:outError];
 2004|      0|  if (!success) {
 2005|      0|    return NO;
 2006|      0|  }
 2007|      0|
 2008|      0|  FIRUser *user = [self getStoredUserForAccessGroup:accessGroup error:outError];
 2009|      0|  if (!user && outError && *outError) {
 2010|      0|    return NO;
 2011|      0|  }
 2012|      0|  success = [self updateCurrentUser:user byForce:NO savingToDisk:NO error:outError];
 2013|      0|  if (!success) {
 2014|      0|    return NO;
 2015|      0|  }
 2016|      0|
 2017|      0|  if(_userAccessGroup == nil && accessGroup != nil) {
 2018|      0|    NSString *userKey = [NSString stringWithFormat:kUserKey, _firebaseAppName];
 2019|      0|    [_keychainServices removeDataForKey:userKey error:outError];
 2020|      0|  }
 2021|      0|  _userAccessGroup = accessGroup;
 2022|      0|  self->_lastNotifiedUserToken = user.rawAccessToken;
 2023|      0|
 2024|      0|  return YES;
 2025|      0|}
 2026|       |
 2027|       |- (nullable FIRUser *)getStoredUserForAccessGroup:(NSString *_Nullable)accessGroup
 2028|      0|                                            error:(NSError *_Nullable *_Nullable)outError {
 2029|      0|  FIRUser *user;
 2030|      0|  if (!accessGroup) {
 2031|      0|    NSString *userKey = [NSString stringWithFormat:kUserKey, _firebaseAppName];
 2032|      0|    NSData *encodedUserData = [_keychainServices dataForKey:userKey error:outError];
 2033|      0|    if (!encodedUserData) {
 2034|      0|      return nil;
 2035|      0|    }
 2036|      0|
 2037|      0|    NSKeyedUnarchiver *unarchiver =
 2038|      0|        [[NSKeyedUnarchiver alloc] initForReadingWithData:encodedUserData];
 2039|      0|    user = [unarchiver decodeObjectOfClass:[FIRUser class] forKey:userKey];
 2040|      0|  } else {
 2041|      0|    user = [self.storedUserManager getStoredUserForAccessGroup:self.userAccessGroup
 2042|      0|                                             projectIdentifier:self.app.options.APIKey
 2043|      0|                                                         error:outError];
 2044|      0|  }
 2045|      0|
 2046|      0|  user.auth = self;
 2047|      0|  return user;
 2048|      0|}
 2049|       |
 2050|       |@end
 2051|       |
 2052|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuthDataResult.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthDataResult_Internal.h"
   18|       |
   19|       |#import "FIRAdditionalUserInfo.h"
   20|       |#import "FIRUser.h"
   21|       |#import "FIROAuthCredential.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |@implementation FIRAuthDataResult
   26|       |
   27|       |/** @var kAdditionalUserInfoCodingKey
   28|       |    @brief The key used to encode the additionalUserInfo property for NSSecureCoding.
   29|       | */
   30|       |static NSString *const kAdditionalUserInfoCodingKey = @"additionalUserInfo";
   31|       |
   32|       |/** @var kUserCodingKey
   33|       |    @brief The key used to encode the user property for NSSecureCoding.
   34|       | */
   35|       |static NSString *const kUserCodingKey = @"user";
   36|       |
   37|       |/** @var kCredentialCodingKey
   38|       |    @brief The key used to encode the credential for NSSecureCoding.
   39|       | */
   40|       |static NSString *const kCredentialCodingKey = @"credential";
   41|       |
   42|       |- (nullable instancetype)initWithUser:(FIRUser *)user
   43|      0|                   additionalUserInfo:(nullable FIRAdditionalUserInfo *)additionalUserInfo {
   44|      0|  return [self initWithUser:user additionalUserInfo:additionalUserInfo credential:nil];
   45|      0|}
   46|       |
   47|       |- (nullable instancetype)initWithUser:(FIRUser *)user
   48|       |                   additionalUserInfo:(nullable FIRAdditionalUserInfo *)additionalUserInfo
   49|      0|                           credential:(nullable FIROAuthCredential *)credential {
   50|      0|  self = [super init];
   51|      0|  if (self) {
   52|      0|    _additionalUserInfo = additionalUserInfo;
   53|      0|    _user = user;
   54|      0|    _credential = credential;
   55|      0|  }
   56|      0|  return self;
   57|      0|}
   58|       |
   59|       |#pragma mark - NSSecureCoding
   60|       |
   61|      0|+ (BOOL)supportsSecureCoding {
   62|      0|  return YES;
   63|      0|}
   64|       |
   65|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   66|      0|  FIRUser *user =
   67|      0|      [aDecoder decodeObjectOfClass:[FIRUser class] forKey:kUserCodingKey];
   68|      0|  FIRAdditionalUserInfo *additionalUserInfo =
   69|      0|      [aDecoder decodeObjectOfClass:[FIRAdditionalUserInfo class]
   70|      0|                             forKey:kAdditionalUserInfoCodingKey];
   71|      0|  FIROAuthCredential *credential =
   72|      0|      [aDecoder decodeObjectOfClass:[FIROAuthCredential class]
   73|      0|                             forKey:kCredentialCodingKey];
   74|      0|  return [self initWithUser:user additionalUserInfo:additionalUserInfo credential:credential];
   75|      0|}
   76|       |
   77|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   78|      0|  [aCoder encodeObject:_user forKey:kUserCodingKey];
   79|      0|  [aCoder encodeObject:_additionalUserInfo forKey:kAdditionalUserInfoCodingKey];
   80|      0|  [aCoder encodeObject:_credential forKey:kCredentialCodingKey];
   81|      0|}
   82|       |
   83|       |@end
   84|       |
   85|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuthDispatcher.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthDispatcher.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRAuthDispatcher
   22|       |
   23|       |@synthesize dispatchAfterImplementation = _dispatchAfterImplementation;
   24|       |
   25|      0|+ (instancetype)sharedInstance {
   26|      0|  static dispatch_once_t onceToken;
   27|      0|  static FIRAuthDispatcher *sharedInstance;
   28|      0|   dispatch_once(&onceToken, ^{
   29|      0|     sharedInstance = [[self alloc] init];
   30|      0|   });
   31|      0|  return sharedInstance;
   32|      0|}
   33|       |
   34|       |- (void)dispatchAfterDelay:(NSTimeInterval)delay
   35|       |                     queue:(dispatch_queue_t)queue
   36|      0|                      task:(void (^)(void))task {
   37|      0|  if (_dispatchAfterImplementation) {
   38|      0|    _dispatchAfterImplementation(delay, queue, task);
   39|      0|    return;
   40|      0|  }
   41|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delay * NSEC_PER_SEC), queue, task);
   42|      0|}
   43|       |
   44|       |@end
   45|       |
   46|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuthGlobalWorkQueue.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthGlobalWorkQueue.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|      2|dispatch_queue_t FIRAuthGlobalWorkQueue() {
   22|      2|  static dispatch_once_t once;
   23|      2|  static dispatch_queue_t queue;
   24|      2|  dispatch_once(&once, ^{
   25|      1|    queue = dispatch_queue_create("com.google.firebase.auth.globalWorkQueue", NULL);
   26|      1|  });
   27|      2|  return queue;
   28|      2|}
   29|       |
   30|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuthSerialTaskQueue.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthSerialTaskQueue.h"
   18|       |
   19|       |#import "FIRAuthGlobalWorkQueue.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@implementation FIRAuthSerialTaskQueue {
   24|       |  /** @var _dispatchQueue
   25|       |      @brief The asyncronous dispatch queue into which tasks are enqueued and processed
   26|       |          serially.
   27|       |   */
   28|       |  dispatch_queue_t _dispatchQueue;
   29|       |}
   30|       |
   31|      0|- (instancetype)init {
   32|      0|  self = [super init];
   33|      0|  if (self) {
   34|      0|    _dispatchQueue = dispatch_queue_create("com.google.firebase.auth.serialTaskQueue", NULL);
   35|      0|    dispatch_set_target_queue(_dispatchQueue, FIRAuthGlobalWorkQueue());
   36|      0|  }
   37|      0|  return self;
   38|      0|}
   39|       |
   40|      0|- (void)enqueueTask:(FIRAuthSerialTask)task {
   41|      0|  // This dispatch queue will run tasks serially in FIFO order, as long as it's not suspended.
   42|      0|  dispatch_async(self->_dispatchQueue, ^{
   43|      0|    // But as soon as a task is started, stop other tasks from running until the task calls it's
   44|      0|    // completion handler, which allows the queue to resume processing of tasks. This allows the
   45|      0|    // task to perform other asyncronous actions on other dispatch queues and "get back to us" when
   46|      0|    // all of their sub-tasks are complete.
   47|      0|    dispatch_suspend(self->_dispatchQueue);
   48|      0|    task(^{
   49|      0|      dispatch_resume(self->_dispatchQueue);
   50|      0|    });
   51|      0|  });
   52|      0|}
   53|       |
   54|       |@end
   55|       |
   56|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuthSettings.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthSettings.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRAuthSettings
   22|       |
   23|      1|- (instancetype)init {
   24|      1|  self = [super init];
   25|      1|  if (self) {
   26|      1|    _appVerificationDisabledForTesting = NO;
   27|      1|  }
   28|      1|  return self;
   29|      1|}
   30|       |
   31|       |@end
   32|       |
   33|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Auth/FIRAuthTokenResult.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthTokenResult_Internal.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kExpirationDateKey
   22|       |    @brief The key used to encode the expirationDate property for NSSecureCoding.
   23|       | */
   24|       |static NSString *const kExpirationDateKey = @"expiratinDate";
   25|       |
   26|       |/** @var kTokenKey
   27|       |    @brief The key used to encode the token property for NSSecureCoding.
   28|       | */
   29|       |static NSString *const kTokenKey = @"token";
   30|       |
   31|       |/** @var kAuthDateKey
   32|       |    @brief The key used to encode the authDate property for NSSecureCoding.
   33|       | */
   34|       |static NSString *const kAuthDateKey = @"authDate";
   35|       |
   36|       |/** @var kIssuedDateKey
   37|       |    @brief The key used to encode the issuedDate property for NSSecureCoding.
   38|       | */
   39|       |static NSString *const kIssuedDateKey = @"issuedDate";
   40|       |
   41|       |/** @var kSignInProviderKey
   42|       |    @brief The key used to encode the signInProvider property for NSSecureCoding.
   43|       | */
   44|       |static NSString *const kSignInProviderKey = @"signInProvider";
   45|       |
   46|       |/** @var kClaimsKey
   47|       |    @brief The key used to encode the claims property for NSSecureCoding.
   48|       | */
   49|       |static NSString *const kClaimsKey = @"claims";
   50|       |
   51|       |@implementation FIRAuthTokenResult
   52|       |
   53|       |- (instancetype)initWithToken:(NSString *)token
   54|       |               expirationDate:(NSDate *)expirationDate
   55|       |                     authDate:(NSDate *)authDate
   56|       |                 issuedAtDate:(NSDate *)issuedAtDate
   57|       |               signInProvider:(NSString *)signInProvider
   58|      0|                       claims:(NSDictionary *)claims {
   59|      0|  self = [super init];
   60|      0|  if (self) {
   61|      0|    _token = token;
   62|      0|    _expirationDate = expirationDate;
   63|      0|    _authDate = authDate;
   64|      0|    _issuedAtDate = issuedAtDate;
   65|      0|    _signInProvider = signInProvider;
   66|      0|    _claims = claims;
   67|      0|  }
   68|      0|  return self;
   69|      0|}
   70|       |
   71|       |#pragma mark - NSSecureCoding
   72|       |
   73|      0|+ (BOOL)supportsSecureCoding {
   74|      0|  return YES;
   75|      0|}
   76|       |
   77|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   78|      0|  NSString *token =
   79|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kTokenKey];
   80|      0|  NSDate *expirationDate =
   81|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kExpirationDateKey];
   82|      0|  NSDate *authDate =
   83|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kAuthDateKey];
   84|      0|  NSDate *issuedAtDate =
   85|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kAuthDateKey];
   86|      0|  NSString *signInProvider =
   87|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kSignInProviderKey];
   88|      0|  NSDictionary<NSString *, NSString *> *claims =
   89|      0|      [aDecoder decodeObjectOfClass:[NSDictionary<NSString *, NSString *> class] forKey:kClaimsKey];
   90|      0|
   91|      0|  return [self initWithToken:token
   92|      0|              expirationDate:expirationDate
   93|      0|                    authDate:authDate
   94|      0|                issuedAtDate:issuedAtDate
   95|      0|              signInProvider:signInProvider
   96|      0|                      claims:claims];
   97|      0|}
   98|       |
   99|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  100|      0|  [aCoder encodeObject:_token forKey:kTokenKey];
  101|      0|  [aCoder encodeObject:_expirationDate forKey:kExpirationDateKey];
  102|      0|  [aCoder encodeObject:_authDate forKey:kAuthDateKey];
  103|      0|  [aCoder encodeObject:_issuedAtDate forKey:kIssuedDateKey];
  104|      0|  [aCoder encodeObject:_signInProvider forKey:kSignInProviderKey];
  105|      0|  [aCoder encodeObject:_claims forKey:kClaimsKey];
  106|      0|}
  107|       |
  108|       |@end
  109|       |
  110|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Email/FIREmailAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailAuthProvider.h"
   18|       |
   19|       |#import "FIREmailPasswordAuthCredential.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@implementation FIREmailAuthProvider
   24|       |
   25|      0|- (instancetype)init {
   26|      0|  @throw [NSException exceptionWithName:@"Attempt to call unavailable initializer."
   27|      0|                                 reason:@"This class is not meant to be initialized."
   28|      0|                               userInfo:nil];
   29|      0|}
   30|       |
   31|      0|+ (FIRAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password {
   32|      0|  return [[FIREmailPasswordAuthCredential alloc] initWithEmail:email password:password];
   33|      0|}
   34|       |
   35|      0|+ (FIRAuthCredential *)credentialWithEmail:(NSString *)email link:(NSString *)link {
   36|      0|  return [[FIREmailPasswordAuthCredential alloc] initWithEmail:email link:link];
   37|      0|}
   38|       |
   39|       |@end
   40|       |
   41|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Email/FIREmailPasswordAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailPasswordAuthCredential.h"
   18|       |
   19|       |#import "FIREmailAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |@interface FIREmailPasswordAuthCredential ()
   26|       |
   27|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIREmailPasswordAuthCredential
   32|       |
   33|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   34|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   35|      0|      @"Please call the designated initializer."];
   36|      0|  return nil;
   37|      0|}
   38|       |
   39|      0|- (nullable instancetype)initWithEmail:(NSString *)email password:(NSString *)password {
   40|      0|  self = [super initWithProvider:FIREmailAuthProviderID];
   41|      0|  if (self) {
   42|      0|    _email = [email copy];
   43|      0|    _password = [password copy];
   44|      0|  }
   45|      0|  return self;
   46|      0|}
   47|       |
   48|      0|- (nullable instancetype)initWithEmail:(NSString *)email link:(NSString *)link {
   49|      0|  self = [super initWithProvider:FIREmailAuthProviderID];
   50|      0|  if (self) {
   51|      0|    _email = [email copy];
   52|      0|    _link = [link copy];
   53|      0|  }
   54|      0|  return self;
   55|      0|}
   56|       |
   57|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   58|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   59|      0|      @"Attempt to call prepareVerifyAssertionRequest: on a FIREmailPasswordAuthCredential."];
   60|      0|}
   61|       |
   62|       |#pragma mark - NSSecureCoding
   63|       |
   64|      0|+ (BOOL)supportsSecureCoding {
   65|      0|  return YES;
   66|      0|}
   67|       |
   68|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   69|      0|  NSString *email = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"email"];
   70|      0|  NSString *password = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"password"];
   71|      0|  NSString *link = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"link"];
   72|      0|  if (email.length && password.length) {
   73|      0|    self = [self initWithEmail:email password:password];
   74|      0|  } else if (email.length && link.length) {
   75|      0|    self = [self initWithEmail:email link:link];
   76|      0|  } else {
   77|      0|    self = nil;
   78|      0|  }
   79|      0|  return self;
   80|      0|}
   81|       |
   82|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   83|      0|  [aCoder encodeObject:self.email forKey:@"email"];
   84|      0|  [aCoder encodeObject:self.password forKey:@"password"];
   85|      0|  [aCoder encodeObject:self.link forKey:@"link"];
   86|      0|}
   87|       |
   88|       |@end
   89|       |
   90|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/FIRAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthCredential_Internal.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRAuthCredential
   22|       |
   23|      0|- (instancetype)init {
   24|      0|  @throw [NSException exceptionWithName:@"Attempt to call unavailable initializer."
   25|      0|                                 reason:@"This class is an abstract base class. It's init method "
   26|      0|          "should not be called directly."
   27|      0|                               userInfo:nil];
   28|      0|}
   29|       |
   30|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   31|      0|  self = [super init];
   32|      0|  if (self) {
   33|      0|    _provider = [provider copy];
   34|      0|  }
   35|      0|  return self;
   36|      0|}
   37|       |
   38|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   39|      0|  @throw [NSException exceptionWithName:@"Attempt to call virtual method."
   40|      0|                                 reason:@"This method must be overridden by a subclass."
   41|      0|                               userInfo:nil];
   42|      0|}
   43|       |
   44|       |@end
   45|       |
   46|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Facebook/FIRFacebookAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRFacebookAuthCredential.h"
   18|       |
   19|       |#import "FIRFacebookAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |@interface FIRFacebookAuthCredential ()
   26|       |
   27|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRFacebookAuthCredential {
   32|       |  NSString *_accessToken;
   33|       |}
   34|       |
   35|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   36|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   37|      0|      @"Please call the designated initializer."];
   38|      0|  return nil;
   39|      0|}
   40|       |
   41|      0|- (nullable instancetype)initWithAccessToken:(NSString *)accessToken {
   42|      0|  self = [super initWithProvider:FIRFacebookAuthProviderID];
   43|      0|  if (self) {
   44|      0|    _accessToken = [accessToken copy];
   45|      0|  }
   46|      0|  return self;
   47|      0|}
   48|       |
   49|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   50|      0|  request.providerAccessToken = _accessToken;
   51|      0|}
   52|       |
   53|       |#pragma mark - NSSecureCoding
   54|       |
   55|      0|+ (BOOL)supportsSecureCoding {
   56|      0|  return YES;
   57|      0|}
   58|       |
   59|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   60|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"accessToken"];
   61|      0|  self = [self initWithAccessToken:accessToken];
   62|      0|  return self;
   63|      0|}
   64|       |
   65|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   66|      0|  [aCoder encodeObject:_accessToken forKey:@"accessToken"];
   67|      0|}
   68|       |
   69|       |@end
   70|       |
   71|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Facebook/FIRFacebookAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRFacebookAuthProvider.h"
   18|       |
   19|       |#import "FIRFacebookAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRFacebookAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@implementation FIRFacebookAuthProvider
   27|       |
   28|      0|- (instancetype)init {
   29|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   30|      0|      @"This class is not meant to be initialized."];
   31|      0|  return nil;
   32|      0|}
   33|       |
   34|      0|+ (FIRAuthCredential *)credentialWithAccessToken:(NSString *)accessToken {
   35|      0|  return [[FIRFacebookAuthCredential alloc] initWithAccessToken:accessToken];
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/GameCenter/FIRGameCenterAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGameCenterAuthCredential.h"
   18|       |
   19|       |#import "FIRAuthExceptionUtils.h"
   20|       |#import "FIRAuthCredential_Internal.h"
   21|       |#import "FIRGameCenterAuthProvider.h"
   22|       |#import "FIRVerifyAssertionRequest.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@implementation FIRGameCenterAuthCredential
   27|       |
   28|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   29|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   30|      0|     @"Please call the designated initializer."];
   31|      0|  return nil;
   32|      0|}
   33|       |
   34|       |- (nullable instancetype)initWithPlayerID:(NSString *)playerID
   35|       |                             publicKeyURL:(NSURL *)publicKeyURL
   36|       |                                signature:(NSData *)signature
   37|       |                                     salt:(NSData *)salt
   38|       |                                timestamp:(uint64_t)timestamp
   39|      0|                              displayName:(NSString *)displayName {
   40|      0|  self = [super initWithProvider:FIRGameCenterAuthProviderID];
   41|      0|  if (self) {
   42|      0|    _playerID = [playerID copy];
   43|      0|    _publicKeyURL = [publicKeyURL copy];
   44|      0|    _signature = [signature copy];
   45|      0|    _salt = [salt copy];
   46|      0|    _timestamp = timestamp;
   47|      0|    _displayName = [displayName copy];
   48|      0|  }
   49|      0|  return self;
   50|      0|}
   51|       |
   52|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   53|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   54|      0|      @"Attempt to call prepareVerifyAssertionRequest: on a FIRGameCenterAuthCredential."];
   55|      0|}
   56|       |
   57|       |#pragma mark - NSSecureCoding
   58|       |
   59|      0|+ (BOOL)supportsSecureCoding {
   60|      0|  return YES;
   61|      0|}
   62|       |
   63|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   64|      0|  NSString *playerID = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"playerID"];
   65|      0|  NSURL *publicKeyURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:@"publicKeyURL"];
   66|      0|  NSData *signature = [aDecoder decodeObjectOfClass:[NSData class] forKey:@"signature"];
   67|      0|  NSData *salt = [aDecoder decodeObjectOfClass:[NSData class] forKey:@"salt"];
   68|      0|  NSNumber *timestamp = [aDecoder decodeObjectOfClass:[NSNumber class] forKey:@"timestamp"];
   69|      0|  NSString *displayName = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"displayName"];
   70|      0|  self = [self initWithPlayerID:playerID
   71|      0|                   publicKeyURL:publicKeyURL
   72|      0|                      signature:signature
   73|      0|                           salt:salt
   74|      0|                      timestamp:timestamp.unsignedLongLongValue
   75|      0|                    displayName:displayName];
   76|      0|  return self;
   77|      0|}
   78|       |
   79|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   80|      0|  [aCoder encodeObject:self.playerID forKey:@"playerID"];
   81|      0|  [aCoder encodeObject:self.publicKeyURL forKey:@"publicKeyURL"];
   82|      0|  [aCoder encodeObject:self.signature forKey:@"signature"];
   83|      0|  [aCoder encodeObject:self.salt forKey:@"salt"];
   84|      0|  [aCoder encodeObject:[NSNumber numberWithUnsignedLongLong:self.timestamp] forKey:@"timestamp"];
   85|      0|  [aCoder encodeObject:self.displayName forKey:@"displayName"];
   86|      0|}
   87|       |
   88|       |@end
   89|       |
   90|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/GameCenter/FIRGameCenterAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGameCenterAuthProvider.h"
   18|       |
   19|       |#import <GameKit/GameKit.h>
   20|       |
   21|       |#import "FIRAuthErrorUtils.h"
   22|       |#import "FIRAuthExceptionUtils.h"
   23|       |#import "FIRGameCenterAuthCredential.h"
   24|       |
   25|       |NS_ASSUME_NONNULL_BEGIN
   26|       |
   27|       |@implementation FIRGameCenterAuthProvider
   28|       |
   29|      0|- (instancetype)init {
   30|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   31|      0|      @"This class is not meant to be initialized."];
   32|      0|  return nil;
   33|      0|}
   34|       |
   35|      0|+ (void)getCredentialWithCompletion:(FIRGameCenterCredentialCallback)completion {
   36|      0|  /**
   37|      0|   Linking GameKit.framework without using it on macOS results in App Store rejection.
   38|      0|   Thus we don't link GameKit.framework to our SDK directly. `optionalLocalPlayer` is used for
   39|      0|   checking whether the APP that consuming our SDK has linked GameKit.framework. If not, a
   40|      0|   `GameKitNotLinkedError` will be raised.
   41|      0|   **/
   42|      0|  GKLocalPlayer * _Nullable optionalLocalPlayer = [[NSClassFromString(@"GKLocalPlayer") alloc] init];
   43|      0|
   44|      0|  if (!optionalLocalPlayer) {
   45|      0|    if (completion) {
   46|      0|      completion(nil, [FIRAuthErrorUtils gameKitNotLinkedError]);
   47|      0|    }
   48|      0|    return;
   49|      0|  }
   50|      0|
   51|      0|  __weak GKLocalPlayer *localPlayer = [[optionalLocalPlayer class] localPlayer];
   52|      0|  if (!localPlayer.isAuthenticated) {
   53|      0|    if (completion) {
   54|      0|      completion(nil, [FIRAuthErrorUtils localPlayerNotAuthenticatedError]);
   55|      0|    }
   56|      0|    return;
   57|      0|  }
   58|      0|
   59|      0|  [localPlayer generateIdentityVerificationSignatureWithCompletionHandler:
   60|      0|   ^(NSURL *publicKeyURL, NSData *signature, NSData *salt, uint64_t timestamp, NSError *error) {
   61|      0|     if (error) {
   62|      0|       if (completion) {
   63|      0|         completion(nil, error);
   64|      0|       }
   65|      0|     } else {
   66|      0|       if (completion) {
   67|      0|         /**
   68|      0|          @c `localPlayer.alias` is actually the displayname needed, instead of
   69|      0|          `localPlayer.displayname`. For more information, check
   70|      0|          https://developer.apple.com/documentation/gamekit/gkplayer
   71|      0|          **/
   72|      0|         NSString *displayName = localPlayer.alias;
   73|      0|         FIRGameCenterAuthCredential *credential =
   74|      0|             [[FIRGameCenterAuthCredential alloc] initWithPlayerID:localPlayer.playerID
   75|      0|                                                      publicKeyURL:publicKeyURL
   76|      0|                                                         signature:signature
   77|      0|                                                              salt:salt
   78|      0|                                                         timestamp:timestamp
   79|      0|                                                       displayName:displayName];
   80|      0|         completion(credential, nil);
   81|      0|       }
   82|      0|     }
   83|      0|   }];
   84|      0|}
   85|       |
   86|       |@end
   87|       |
   88|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/GitHub/FIRGitHubAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGitHubAuthCredential.h"
   18|       |
   19|       |#import "FIRGitHubAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |@interface FIRGitHubAuthCredential ()
   26|       |
   27|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRGitHubAuthCredential
   32|       |
   33|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   34|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   35|      0|      @"Please call the designated initializer."];
   36|      0|  return nil;
   37|      0|}
   38|       |
   39|      0|- (nullable instancetype)initWithToken:(NSString *)token {
   40|      0|  self = [super initWithProvider:FIRGitHubAuthProviderID];
   41|      0|  if (self) {
   42|      0|    _token = [token copy];
   43|      0|  }
   44|      0|  return self;
   45|      0|}
   46|       |
   47|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   48|      0|  request.providerAccessToken = _token;
   49|      0|}
   50|       |
   51|       |#pragma mark - NSSecureCoding
   52|       |
   53|      0|+ (BOOL)supportsSecureCoding {
   54|      0|  return YES;
   55|      0|}
   56|       |
   57|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   58|      0|  NSString *token = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"token"];
   59|      0|  self = [self initWithToken:token];
   60|      0|  return self;
   61|      0|}
   62|       |
   63|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   64|      0|  [aCoder encodeObject:self.token forKey:@"token"];
   65|      0|}
   66|       |
   67|       |@end
   68|       |
   69|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/GitHub/FIRGitHubAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGitHubAuthProvider.h"
   18|       |
   19|       |#import "FIRGitHubAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRGitHubAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@implementation FIRGitHubAuthProvider
   27|       |
   28|      0|- (instancetype)init {
   29|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   30|      0|      @"This class is not meant to be initialized."];
   31|      0|  return nil;
   32|      0|}
   33|       |
   34|      0|+ (FIRAuthCredential *)credentialWithToken:(NSString *)token {
   35|      0|  return [[FIRGitHubAuthCredential alloc] initWithToken:token];
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Google/FIRGoogleAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGoogleAuthCredential.h"
   18|       |
   19|       |#import "FIRGoogleAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |@interface FIRGoogleAuthCredential ()
   26|       |
   27|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRGoogleAuthCredential {
   32|       |  NSString *_IDToken;
   33|       |  NSString *_accessToken;
   34|       |}
   35|       |
   36|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   37|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   38|      0|      @"Please call the designated initializer."];
   39|      0|  return nil;
   40|      0|}
   41|       |
   42|      0|- (nullable instancetype)initWithIDToken:(NSString *)IDToken accessToken:(NSString *)accessToken {
   43|      0|  self = [super initWithProvider:FIRGoogleAuthProviderID];
   44|      0|  if (self) {
   45|      0|    _IDToken = [IDToken copy];
   46|      0|    _accessToken = [accessToken copy];
   47|      0|  }
   48|      0|  return self;
   49|      0|}
   50|       |
   51|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   52|      0|  request.providerIDToken = _IDToken;
   53|      0|  request.providerAccessToken = _accessToken;
   54|      0|}
   55|       |
   56|       |#pragma mark - NSSecureCoding
   57|       |
   58|      0|+ (BOOL)supportsSecureCoding {
   59|      0|  return YES;
   60|      0|}
   61|       |
   62|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   63|      0|  NSString *IDToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"IDToken"];
   64|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"accessToken"];
   65|      0|  self = [self initWithIDToken:IDToken accessToken:accessToken];
   66|      0|  return self;
   67|      0|}
   68|       |
   69|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   70|      0|  [aCoder encodeObject:_IDToken forKey:@"IDToken"];
   71|      0|  [aCoder encodeObject:_accessToken forKey:@"accessToken"];
   72|      0|}
   73|       |
   74|       |@end
   75|       |
   76|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Google/FIRGoogleAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGoogleAuthProvider.h"
   18|       |
   19|       |#import "FIRGoogleAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRGoogleAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@implementation FIRGoogleAuthProvider
   27|       |
   28|      0|- (instancetype)init {
   29|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   30|      0|      @"This class is not meant to be initialized."];
   31|      0|  return nil;
   32|      0|}
   33|       |
   34|       |+ (FIRAuthCredential *)credentialWithIDToken:(NSString *)IDToken
   35|      0|                                 accessToken:(NSString *)accessToken {
   36|      0|  return [[FIRGoogleAuthCredential alloc] initWithIDToken:IDToken accessToken:accessToken];
   37|      0|}
   38|       |
   39|       |@end
   40|       |
   41|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/OAuth/FIROAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIROAuthCredential.h"
   18|       |
   19|       |#import "FIRAuthCredential_Internal.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIROAuthCredential_Internal.h"
   22|       |#import "FIRVerifyAssertionRequest.h"
   23|       |#import "FIRVerifyAssertionResponse.h"
   24|       |
   25|       |NS_ASSUME_NONNULL_BEGIN
   26|       |
   27|       |@interface FIROAuthCredential ()
   28|       |
   29|       |@property(nonatomic, nullable) NSString *rawNonce;
   30|       |
   31|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   32|       |
   33|       |@end
   34|       |
   35|       |@implementation FIROAuthCredential
   36|       |
   37|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   38|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   39|      0|      @"Please call the designated initializer."];
   40|      0|  return nil;
   41|      0|}
   42|       |
   43|       |- (instancetype)initWithProviderID:(NSString *)providerID
   44|       |                           IDToken:(nullable NSString *)IDToken
   45|       |                          rawNonce:(nullable NSString *)rawNonce
   46|       |                       accessToken:(nullable NSString *)accessToken
   47|       |                            secret:(nullable NSString *)secret
   48|      0|                      pendingToken:(nullable NSString *)pendingToken {
   49|      0|  self = [super initWithProvider:providerID];
   50|      0|  if (self) {
   51|      0|    _IDToken = IDToken;
   52|      0|    _rawNonce = rawNonce;
   53|      0|    _accessToken = accessToken;
   54|      0|    _pendingToken = pendingToken;
   55|      0|    _secret = secret;
   56|      0|  }
   57|      0|  return self;
   58|      0|}
   59|       |
   60|       |- (instancetype)initWithProviderID:(NSString *)providerID
   61|       |                         sessionID:(NSString *)sessionID
   62|      0|            OAuthResponseURLString:(NSString *)OAuthResponseURLString {
   63|      0|  self = [self initWithProviderID:providerID
   64|      0|                          IDToken:nil
   65|      0|                         rawNonce:nil
   66|      0|                      accessToken:nil
   67|      0|                           secret:nil
   68|      0|                     pendingToken:nil];
   69|      0|  if (self) {
   70|      0|    _OAuthResponseURLString = OAuthResponseURLString;
   71|      0|    _sessionID = sessionID;
   72|      0|  }
   73|      0|  return self;
   74|      0|}
   75|       |
   76|       |
   77|      0|- (nullable instancetype)initWithVerifyAssertionResponse:(FIRVerifyAssertionResponse *)response {
   78|      0|  if (response.oauthIDToken.length || response.oauthAccessToken.length ||
   79|      0|      response.oauthSecretToken.length) {
   80|      0|    return [self initWithProviderID:response.providerID
   81|      0|                            IDToken:response.oauthIDToken
   82|      0|                           rawNonce:nil
   83|      0|                        accessToken:response.oauthAccessToken
   84|      0|                             secret:response.oauthSecretToken
   85|      0|                       pendingToken:response.pendingToken];
   86|      0|  }
   87|      0|  return nil;
   88|      0|}
   89|       |
   90|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   91|      0|  request.providerIDToken = _IDToken;
   92|      0|  request.providerRawNonce = _rawNonce;
   93|      0|  request.providerAccessToken = _accessToken;
   94|      0|  request.requestURI = _OAuthResponseURLString;
   95|      0|  request.sessionID = _sessionID;
   96|      0|  request.providerOAuthTokenSecret = _secret;
   97|      0|  request.pendingToken = _pendingToken;
   98|      0|}
   99|       |
  100|       |#pragma mark - NSSecureCoding
  101|       |
  102|      0|+ (BOOL)supportsSecureCoding {
  103|      0|  return YES;
  104|      0|}
  105|       |
  106|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  107|      0|  NSString *IDToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"IDToken"];
  108|      0|  NSString *rawNonce = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"rawNonce"];
  109|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"accessToken"];
  110|      0|  NSString *pendingToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"pendingToken"];
  111|      0|  NSString *secret = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"secret"];
  112|      0|  self = [self initWithProviderID:self.provider
  113|      0|                          IDToken:IDToken
  114|      0|                         rawNonce:rawNonce
  115|      0|                      accessToken:accessToken
  116|      0|                           secret:secret
  117|      0|                     pendingToken:pendingToken];
  118|      0|  return self;
  119|      0|}
  120|       |
  121|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  122|      0|  [aCoder encodeObject:self.IDToken forKey:@"IDToken"];
  123|      0|  [aCoder encodeObject:self.rawNonce forKey:@"rawNonce"];
  124|      0|  [aCoder encodeObject:self.accessToken forKey:@"accessToken"];
  125|      0|  [aCoder encodeObject:self.pendingToken forKey:@"pendingToken"];
  126|      0|  [aCoder encodeObject:self.secret forKey:@"secret"];
  127|      0|}
  128|       |
  129|       |@end
  130|       |
  131|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/OAuth/FIROAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <CommonCrypto/CommonCrypto.h>
   18|       |#import "FIROAuthProvider.h"
   19|       |
   20|       |#import <FirebaseCore/FIRApp.h>
   21|       |#import <FirebaseCore/FIROptions.h>
   22|       |
   23|       |#import "FIRAuthBackend.h"
   24|       |#import "FIRAuth_Internal.h"
   25|       |#import "FIRAuthErrorUtils.h"
   26|       |#import "FIRAuthGlobalWorkQueue.h"
   27|       |#import "FIRAuthRequestConfiguration.h"
   28|       |#import "FIRAuthWebUtils.h"
   29|       |#import "FIRFacebookAuthProvider.h"
   30|       |#import "FIROAuthCredential_Internal.h"
   31|       |#import "FIROAuthCredential.h"
   32|       |
   33|       |#if TARGET_OS_IOS
   34|       |#import "FIRAuthURLPresenter.h"
   35|       |#endif
   36|       |
   37|       |NS_ASSUME_NONNULL_BEGIN
   38|       |
   39|       |/** @typedef FIRHeadfulLiteURLCallBack
   40|       |    @brief The callback invoked at the end of the flow to fetch a headful-lite URL.
   41|       |    @param headfulLiteURL The headful lite URL.
   42|       |    @param error The error that occurred while fetching the headful-lite, if any.
   43|       | */
   44|       |typedef void (^FIRHeadfulLiteURLCallBack)(NSURL *_Nullable headfulLiteURL,
   45|       |               NSError *_Nullable error);
   46|       |
   47|       |/** @var kHeadfulLiteURLStringFormat
   48|       |    @brief The format of the URL used to open the headful lite page during sign-in.
   49|       | */
   50|       |NSString *const kHeadfulLiteURLStringFormat = @"https://%@/__/auth/handler?%@";
   51|       |
   52|       |/** @var kauthTypeSignInWithRedirect
   53|       |    @brief The auth type to be specified in the sign-in request with redirect request and response.
   54|       | */
   55|       |static NSString *const kAuthTypeSignInWithRedirect = @"signInWithRedirect";
   56|       |
   57|       |@implementation FIROAuthProvider {
   58|       |  /** @var _auth
   59|       |      @brief The auth instance used for launching the URL presenter.
   60|       |   */
   61|       |  FIRAuth *_auth;
   62|       |
   63|       |  /** @var _callbackScheme
   64|       |      @brief The callback URL scheme used for headful-lite sign-in.
   65|       |   */
   66|       |  NSString *_callbackScheme;
   67|       |}
   68|       |
   69|       |+ (FIROAuthCredential *)credentialWithProviderID:(NSString *)providerID
   70|       |                                        IDToken:(NSString *)IDToken
   71|      0|                                    accessToken:(nullable NSString *)accessToken {
   72|      0|  return [[FIROAuthCredential alloc] initWithProviderID:providerID
   73|      0|                                                IDToken:IDToken
   74|      0|                                               rawNonce:nil
   75|      0|                                            accessToken:accessToken
   76|      0|                                                 secret:nil
   77|      0|                                           pendingToken:nil];
   78|      0|}
   79|       |
   80|       |+ (FIROAuthCredential *)credentialWithProviderID:(NSString *)providerID
   81|      0|                                     accessToken:(NSString *)accessToken {
   82|      0|  return [[FIROAuthCredential alloc] initWithProviderID:providerID
   83|      0|                                                IDToken:nil
   84|      0|                                               rawNonce:nil
   85|      0|                                            accessToken:accessToken
   86|      0|                                                 secret:nil
   87|      0|                                           pendingToken:nil];
   88|      0|}
   89|       |
   90|       |+ (FIROAuthCredential *)credentialWithProviderID:(NSString *)providerID
   91|       |                                         IDToken:(NSString *)IDToken
   92|       |                                        rawNonce:(nullable NSString *)rawNonce
   93|      0|                                     accessToken:(nullable NSString *)accessToken {
   94|      0|  return [[FIROAuthCredential alloc] initWithProviderID:providerID
   95|      0|                                                IDToken:IDToken
   96|      0|                                               rawNonce:rawNonce
   97|      0|                                            accessToken:accessToken
   98|      0|                                                 secret:nil
   99|      0|                                           pendingToken:nil];
  100|      0|}
  101|       |
  102|       |+ (FIROAuthCredential *)credentialWithProviderID:(NSString *)providerID
  103|       |                                         IDToken:(NSString *)IDToken
  104|      0|                                        rawNonce:(nullable NSString *)rawNonce {
  105|      0|  return [[FIROAuthCredential alloc] initWithProviderID:providerID
  106|      0|                                                IDToken:IDToken
  107|      0|                                               rawNonce:rawNonce
  108|      0|                                            accessToken:nil
  109|      0|                                                 secret:nil
  110|      0|                                           pendingToken:nil];
  111|      0|}
  112|       |
  113|      0|+ (instancetype)providerWithProviderID:(NSString *)providerID {
  114|      0|  return [[self alloc]initWithProviderID:providerID auth:[FIRAuth auth]];
  115|      0|}
  116|       |
  117|      0|+ (instancetype)providerWithProviderID:(NSString *)providerID auth:(FIRAuth *)auth {
  118|      0|  return [[self alloc] initWithProviderID:providerID auth:auth];
  119|      0|}
  120|       |
  121|       |#if TARGET_OS_IOS
  122|       |- (void)getCredentialWithUIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  123|      0|                         completion:(nullable FIRAuthCredentialCallback)completion {
  124|      0|  if (![FIRAuthWebUtils isCallbackSchemeRegisteredForCustomURLScheme:self->_callbackScheme]) {
  125|      0|    [NSException raise:NSInternalInconsistencyException
  126|      0|                format:@"Please register custom URL scheme '%@' in the app's Info.plist file.",
  127|      0|                       self->_callbackScheme];
  128|      0|  }
  129|      0|  __weak __typeof__(self) weakSelf = self;
  130|      0|  __weak FIRAuth *weakAuth = _auth;
  131|      0|  __weak NSString *weakProviderID = _providerID;
  132|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  133|      0|    FIRAuthCredentialCallback callbackOnMainThread = ^(FIRAuthCredential *_Nullable credential,
  134|      0|                                                       NSError *_Nullable error) {
  135|      0|      if (completion) {
  136|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  137|      0|          completion(credential, error);
  138|      0|        });
  139|      0|      }
  140|      0|    };
  141|      0|    NSString *eventID = [FIRAuthWebUtils randomStringWithLength:10];
  142|      0|    NSString *sessionID = [FIRAuthWebUtils randomStringWithLength:10];
  143|      0|    __strong __typeof__(self) strongSelf = weakSelf;
  144|      0|    [strongSelf getHeadFulLiteURLWithEventID:eventID
  145|      0|                             sessionID:sessionID
  146|      0|                            completion:^(NSURL *_Nullable headfulLiteURL,
  147|      0|                                         NSError *_Nullable error) {
  148|      0|      if (error) {
  149|      0|        callbackOnMainThread(nil, error);
  150|      0|        return;
  151|      0|      }
  152|      0|      FIRAuthURLCallbackMatcher callbackMatcher = ^BOOL(NSURL *_Nullable callbackURL) {
  153|      0|        return [FIRAuthWebUtils isExpectedCallbackURL:callbackURL
  154|      0|                                              eventID:eventID
  155|      0|                                             authType:kAuthTypeSignInWithRedirect
  156|      0|                                       callbackScheme:strongSelf->_callbackScheme];
  157|      0|      };
  158|      0|      __strong FIRAuth *strongAuth = weakAuth;
  159|      0|      [strongAuth.authURLPresenter presentURL:headfulLiteURL
  160|      0|                                   UIDelegate:UIDelegate
  161|      0|                              callbackMatcher:callbackMatcher
  162|      0|                                   completion:^(NSURL *_Nullable callbackURL,
  163|      0|                                                NSError *_Nullable error) {
  164|      0|        if (error) {
  165|      0|          callbackOnMainThread(nil, error);
  166|      0|          return;
  167|      0|        }
  168|      0|        NSString *OAuthResponseURLString =
  169|      0|            [strongSelf OAuthResponseForURL:callbackURL error:&error];
  170|      0|        if (error) {
  171|      0|          callbackOnMainThread(nil, error);
  172|      0|          return;
  173|      0|        }
  174|      0|        __strong NSString *strongProviderID = weakProviderID;
  175|      0|        FIROAuthCredential *credential =
  176|      0|            [[FIROAuthCredential alloc] initWithProviderID:strongProviderID
  177|      0|                                                 sessionID:sessionID
  178|      0|                                    OAuthResponseURLString:OAuthResponseURLString];
  179|      0|        callbackOnMainThread(credential, nil);
  180|      0|      }];
  181|      0|    }];
  182|      0|  });
  183|      0|}
  184|       |#endif  // TARGET_OS_IOS
  185|       |
  186|       |#pragma mark - Internal Methods
  187|       |
  188|       |/** @fn initWithProviderID:auth:
  189|       |    @brief returns an instance of @c FIROAuthProvider associated with the provided auth instance.
  190|       |    @param auth The Auth instance to be associated with the OAuthProvider instance.
  191|       |    @return An Instance of @c FIROAuthProvider.
  192|       |  */
  193|      0|- (nullable instancetype)initWithProviderID:(NSString *)providerID auth:(FIRAuth *)auth {
  194|      0|  NSAssert(![providerID isEqual:FIRFacebookAuthProviderID],
  195|      0|           @"Sign in with Facebook is not supported via generic IDP; the Facebook TOS "
  196|      0|           "dictate that you must use the Facebook iOS SDK for Facebook login.");
  197|      0|  NSAssert(![providerID isEqual:@"apple.com"],
  198|      0|           @"Sign in with Apple is not supported via generic IDP; You must use the Apple iOS SDK"
  199|      0|           " for Sign in with Apple.");
  200|      0|  self = [super init];
  201|      0|  if (self) {
  202|      0|    _auth = auth;
  203|      0|    _providerID = providerID;
  204|      0|    _callbackScheme = [[[_auth.app.options.clientID componentsSeparatedByString:@"."]
  205|      0|        reverseObjectEnumerator].allObjects componentsJoinedByString:@"."];
  206|      0|  }
  207|      0|  return self;
  208|      0|}
  209|       |
  210|       |/** @fn OAuthResponseForURL:error:
  211|       |    @brief Parses the redirected URL and returns a string representation of the OAuth response URL.
  212|       |    @param URL The url to be parsed for an OAuth response URL.
  213|       |    @param error The error that occurred if any.
  214|       |    @return The OAuth response if successful.
  215|       | */
  216|      0|- (nullable NSString *)OAuthResponseForURL:(NSURL *)URL error:(NSError *_Nullable *_Nullable)error {
  217|      0|  NSDictionary<NSString *, NSString *> *URLQueryItems =
  218|      0|      [FIRAuthWebUtils dictionaryWithHttpArgumentsString:URL.query];
  219|      0|  NSURL *deepLinkURL = [NSURL URLWithString:URLQueryItems[@"deep_link_id"]];
  220|      0|  URLQueryItems =
  221|      0|      [FIRAuthWebUtils dictionaryWithHttpArgumentsString:deepLinkURL.query];
  222|      0|  NSString *queryItemLink = URLQueryItems[@"link"];
  223|      0|  if (queryItemLink) {
  224|      0|    return queryItemLink;
  225|      0|  }
  226|      0|  if (!error) {
  227|      0|    return nil;
  228|      0|  }
  229|      0|  NSData *errorData = [URLQueryItems[@"firebaseError"] dataUsingEncoding:NSUTF8StringEncoding];
  230|      0|  NSError *jsonError;
  231|      0|  NSDictionary *errorDict = [NSJSONSerialization JSONObjectWithData:errorData
  232|      0|                                                            options:0
  233|      0|                                                              error:&jsonError];
  234|      0|  if (jsonError) {
  235|      0|    *error = [FIRAuthErrorUtils JSONSerializationErrorWithUnderlyingError:jsonError];
  236|      0|    return nil;
  237|      0|  }
  238|      0|  *error = [FIRAuthErrorUtils URLResponseErrorWithCode:errorDict[@"code"]
  239|      0|                                               message:errorDict[@"message"]];
  240|      0|  if (!*error) {
  241|      0|    NSString *reason;
  242|      0|    if(errorDict[@"code"] && errorDict[@"message"]) {
  243|      0|      reason = [NSString stringWithFormat:@"[%@] - %@",errorDict[@"code"], errorDict[@"message"]];
  244|      0|    }
  245|      0|    *error = [FIRAuthErrorUtils webSignInUserInteractionFailureWithReason:reason];
  246|      0|  }
  247|      0|  return nil;
  248|      0|}
  249|       |
  250|       |/** @fn getHeadFulLiteURLWithEventID:completion:
  251|       |    @brief Constructs a URL used for opening a headful-lite flow using a given event
  252|       |        ID and session ID.
  253|       |    @param eventID The event ID used for this purpose.
  254|       |    @param sessionID The session ID used when completing the headful lite flow.
  255|       |    @param completion The callback invoked after the URL has been constructed or an error
  256|       |        has been encountered.
  257|       | */
  258|       |- (void)getHeadFulLiteURLWithEventID:(NSString *)eventID
  259|       |                           sessionID:(NSString *)sessionID
  260|      0|                          completion:(FIRHeadfulLiteURLCallBack)completion {
  261|      0|   __weak __typeof__(self) weakSelf = self;
  262|      0|  [FIRAuthWebUtils fetchAuthDomainWithRequestConfiguration:_auth.requestConfiguration
  263|      0|                                                completion:^(NSString *_Nullable authDomain,
  264|      0|                                                             NSError *_Nullable error) {
  265|      0|    if (error) {
  266|      0|      if (completion) {
  267|      0|        completion(nil, error);
  268|      0|      }
  269|      0|      return;
  270|      0|    }
  271|      0|     __strong __typeof__(self) strongSelf = weakSelf;
  272|      0|    NSString *bundleID = [NSBundle mainBundle].bundleIdentifier;
  273|      0|    NSString *clienID = strongSelf->_auth.app.options.clientID;
  274|      0|    NSString *apiKey = strongSelf->_auth.requestConfiguration.APIKey;
  275|      0|    NSMutableDictionary *urlArguments = [@{
  276|      0|      @"apiKey" : apiKey,
  277|      0|      @"authType" : @"signInWithRedirect",
  278|      0|      @"ibi" : bundleID ?: @"",
  279|      0|      @"clientId" : clienID,
  280|      0|      @"sessionId" : [strongSelf hashforString:sessionID],
  281|      0|      @"v" : [FIRAuthBackend authUserAgent],
  282|      0|      @"eventId" : eventID,
  283|      0|      @"providerId" : strongSelf->_providerID,
  284|      0|    } mutableCopy];
  285|      0|    if (strongSelf.scopes.count) {
  286|      0|      urlArguments[@"scopes"] = [strongSelf.scopes componentsJoinedByString:@","];
  287|      0|    }
  288|      0|    if (strongSelf.customParameters.count) {
  289|      0|      NSString *customParameters = [strongSelf customParametersStringWithError:&error];
  290|      0|      if (error) {
  291|      0|        completion(nil, error);
  292|      0|        return;
  293|      0|      }
  294|      0|      if (customParameters) {
  295|      0|        urlArguments[@"customParameters"] = customParameters;
  296|      0|      }
  297|      0|    }
  298|      0|    if (strongSelf->_auth.requestConfiguration.languageCode) {
  299|      0|      urlArguments[@"hl"] = strongSelf->_auth.requestConfiguration.languageCode;
  300|      0|    }
  301|      0|    NSString *argumentsString = [strongSelf httpArgumentsStringForArgsDictionary:urlArguments];
  302|      0|    NSString *URLString =
  303|      0|        [NSString stringWithFormat:kHeadfulLiteURLStringFormat, authDomain, argumentsString];
  304|      0|    if (completion) {
  305|      0|      NSCharacterSet *set = [NSCharacterSet URLFragmentAllowedCharacterSet];
  306|      0|      completion([NSURL URLWithString:
  307|      0|          [URLString stringByAddingPercentEncodingWithAllowedCharacters:set]], nil);
  308|      0|    }
  309|      0|  }];
  310|      0|}
  311|       |
  312|       |/** @fn customParametersString
  313|       |    @brief Returns a JSON string representation of the custom parameters dictionary corresponding
  314|       |        to the OAuthProvider.
  315|       |    @return The JSON string representation of the custom parameters dictionary corresponding
  316|       |        to the OAuthProvider.
  317|       | */
  318|      0|- (nullable NSString *)customParametersStringWithError:(NSError *_Nullable *_Nullable)error {
  319|      0|  if (!_customParameters.count) {
  320|      0|    return nil;
  321|      0|  }
  322|      0|
  323|      0|  if (!error) {
  324|      0|    return nil;
  325|      0|  }
  326|      0|  NSError *jsonError;
  327|      0|  NSData *customParametersJSONData =
  328|      0|      [NSJSONSerialization dataWithJSONObject:_customParameters
  329|      0|                                      options:0
  330|      0|                                        error:&jsonError];
  331|      0|  if (jsonError) {
  332|      0|    *error = [FIRAuthErrorUtils JSONSerializationErrorWithUnderlyingError:jsonError];
  333|      0|    return nil;
  334|      0|  }
  335|      0|
  336|      0|  NSString *customParamsRawJSON =
  337|      0|      [[NSString alloc] initWithData:customParametersJSONData encoding:NSUTF8StringEncoding];
  338|      0|  return customParamsRawJSON;
  339|      0|}
  340|       |
  341|       |/** @fn hashforString:
  342|       |    @brief Returns the SHA256 hash representation of a given string object.
  343|       |    @param string The string for which a SHA256 hash is desired.
  344|       |    @return An hexadecimal string representation of the SHA256 hash.
  345|       | */
  346|      0|- (NSString *)hashforString:(NSString *)string {
  347|      0|  NSData *sessionIDData = [string dataUsingEncoding:NSUTF8StringEncoding];
  348|      0|  NSMutableData *hashOutputData = [NSMutableData dataWithLength:CC_SHA256_DIGEST_LENGTH];
  349|      0|  if (CC_SHA256(sessionIDData.bytes,
  350|      0|      (CC_LONG)[sessionIDData length],
  351|      0|      hashOutputData.mutableBytes)) {
  352|      0|  }
  353|      0|  return [self hexStringFromData:hashOutputData];;
  354|      0|}
  355|       |
  356|       |/** @fn hexStringFromData:
  357|       |    @brief Returns the hexadecimal string representation of an NSData object.
  358|       |    @param data The NSData object for which a hexadecical string is desired.
  359|       |    @return The hexadecimal string representation of the supplied NSData object.
  360|       | */
  361|      0|- (NSString *)hexStringFromData:(NSData *)data {
  362|      0|  const unsigned char *dataBuffer = (const unsigned char *)[data bytes];
  363|      0|  NSMutableString *string = [[NSMutableString alloc] init];
  364|      0|  for (unsigned int i = 0; i < data.length; i++){
  365|      0|    [string appendFormat:@"%02lx", (unsigned long)dataBuffer[i]];
  366|      0|  }
  367|      0|  return [string copy];
  368|      0|}
  369|       |
  370|      0|- (NSString *)httpArgumentsStringForArgsDictionary:(NSDictionary *)argsDictionary {
  371|      0|  NSMutableArray* arguments = [NSMutableArray arrayWithCapacity:argsDictionary.count];
  372|      0|  NSString* key;
  373|      0|  for (key in argsDictionary) {
  374|      0|    NSString *description = [argsDictionary[key] description];
  375|      0|    [arguments addObject:[NSString stringWithFormat:@"%@=%@",
  376|      0|                          [FIRAuthWebUtils stringByUnescapingFromURLArgument:key],
  377|      0|                          [FIRAuthWebUtils stringByUnescapingFromURLArgument:description]]] ;
  378|      0|  }
  379|      0|  return [arguments componentsJoinedByString:@"&"];
  380|      0|}
  381|       |
  382|       |@end
  383|       |
  384|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Phone/FIRPhoneAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX && !TARGET_OS_TV
   19|       |
   20|       |#import "FIRPhoneAuthCredential.h"
   21|       |
   22|       |#import "FIRPhoneAuthCredential_Internal.h"
   23|       |#import "FIRAuthCredential_Internal.h"
   24|       |#import "FIRAuthExceptionUtils.h"
   25|       |#import "FIRVerifyAssertionRequest.h"
   26|       |
   27|       |NS_ASSUME_NONNULL_BEGIN
   28|       |
   29|       |@interface FIRPhoneAuthCredential ()
   30|       |
   31|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   32|       |
   33|       |@end
   34|       |
   35|       |@implementation FIRPhoneAuthCredential
   36|       |
   37|       |- (instancetype)initWithTemporaryProof:(NSString *)temporaryProof
   38|       |                           phoneNumber:(NSString *)phoneNumber
   39|      0|                            providerID:(NSString *)providerID {
   40|      0|  self = [super initWithProvider:providerID];
   41|      0|  if (self) {
   42|      0|    _temporaryProof = [temporaryProof copy];
   43|      0|    _phoneNumber = [phoneNumber copy];
   44|      0|  }
   45|      0|  return self;
   46|      0|}
   47|       |
   48|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   49|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   50|      0|      @"Please call the designated initializer."];
   51|      0|  return nil;
   52|      0|}
   53|       |
   54|       |- (instancetype)initWithProviderID:(NSString *)providerID
   55|       |                    verificationID:(NSString *)verificationID
   56|      0|                  verificationCode:(NSString *)verificationCode {
   57|      0|  self = [super initWithProvider:providerID];
   58|      0|  if (self) {
   59|      0|    _verificationID = [verificationID copy];
   60|      0|    _verificationCode = [verificationCode copy];
   61|      0|  }
   62|      0|  return self;
   63|      0|}
   64|       |
   65|       |#pragma mark - NSSecureCoding
   66|       |
   67|      0|+ (BOOL)supportsSecureCoding {
   68|      0|  return YES;
   69|      0|}
   70|       |
   71|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   72|      0|  NSString *verificationID = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"verificationID"];
   73|      0|  NSString *verificationCode = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"verificationCode"];
   74|      0|  NSString *temporaryProof = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"temporaryProof"];
   75|      0|  NSString *phoneNumber = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"phoneNumber"];
   76|      0|  if (temporaryProof.length && phoneNumber.length) {
   77|      0|    self = [self initWithTemporaryProof:temporaryProof phoneNumber:phoneNumber providerID:self.provider];
   78|      0|  } else if (verificationID.length && verificationCode.length) {
   79|      0|    self = [self initWithProviderID:self.provider verificationID:verificationID verificationCode:verificationCode];
   80|      0|  } else {
   81|      0|    self = nil;
   82|      0|  }
   83|      0|  return self;
   84|      0|}
   85|       |
   86|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   87|      0|  [aCoder encodeObject:self.verificationID forKey:@"verificationID"];
   88|      0|  [aCoder encodeObject:self.verificationCode forKey:@"verificationCode"];
   89|      0|  [aCoder encodeObject:self.temporaryProof forKey:@"temporaryProof"];
   90|      0|  [aCoder encodeObject:self.phoneNumber forKey:@"phoneNumber"];
   91|      0|}
   92|       |
   93|       |@end
   94|       |
   95|       |NS_ASSUME_NONNULL_END
   96|       |
   97|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Phone/FIRPhoneAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX && !TARGET_OS_TV
   19|       |
   20|       |#import "FIRPhoneAuthProvider.h"
   21|       |
   22|       |#import <FirebaseCore/FIRLogger.h>
   23|       |#import "FIRPhoneAuthCredential_Internal.h"
   24|       |#import <FirebaseCore/FIRApp.h>
   25|       |#import "FIRAuthAPNSToken.h"
   26|       |#import "FIRAuthAPNSTokenManager.h"
   27|       |#import "FIRAuthAppCredential.h"
   28|       |#import "FIRAuthAppCredentialManager.h"
   29|       |#import "FIRAuthGlobalWorkQueue.h"
   30|       |#import "FIRAuth_Internal.h"
   31|       |#import "FIRAuthURLPresenter.h"
   32|       |#import "FIRAuthNotificationManager.h"
   33|       |#import "FIRAuthErrorUtils.h"
   34|       |#import "FIRAuthBackend.h"
   35|       |#import "FIRAuthSettings.h"
   36|       |#import "FIRAuthWebUtils.h"
   37|       |#import "FirebaseAuthVersion.h"
   38|       |#import <FirebaseCore/FIROptions.h>
   39|       |#import "FIRGetProjectConfigRequest.h"
   40|       |#import "FIRGetProjectConfigResponse.h"
   41|       |#import "FIRSendVerificationCodeRequest.h"
   42|       |#import "FIRSendVerificationCodeResponse.h"
   43|       |#import "FIRVerifyClientRequest.h"
   44|       |#import "FIRVerifyClientResponse.h"
   45|       |
   46|       |NS_ASSUME_NONNULL_BEGIN
   47|       |
   48|       |/** @typedef FIRReCAPTCHAURLCallBack
   49|       |    @brief The callback invoked at the end of the flow to fetch a reCAPTCHA URL.
   50|       |    @param reCAPTCHAURL The reCAPTCHA URL.
   51|       |    @param error The error that occurred while fetching the reCAPTCHAURL, if any.
   52|       | */
   53|       |typedef void (^FIRReCAPTCHAURLCallBack)(NSURL *_Nullable reCAPTCHAURL, NSError *_Nullable error);
   54|       |
   55|       |/** @typedef FIRVerifyClientCallback
   56|       |    @brief The callback invoked at the end of a client verification flow.
   57|       |    @param appCredential credential that proves the identity of the app during a phone
   58|       |        authentication flow.
   59|       |    @param error The error that occurred while verifying the app, if any.
   60|       | */
   61|       |typedef void (^FIRVerifyClientCallback)(FIRAuthAppCredential *_Nullable appCredential,
   62|       |                                        NSString *_Nullable reCAPTCHAToken,
   63|       |                                        NSError *_Nullable error);
   64|       |
   65|       |/** @typedef FIRFetchAuthDomainCallback
   66|       |    @brief The callback invoked at the end of the flow to fetch the Auth domain.
   67|       |    @param authDomain The Auth domain.
   68|       |    @param error The error that occurred while fetching the auth domain, if any.
   69|       | */
   70|       |typedef void (^FIRFetchAuthDomainCallback)(NSString *_Nullable authDomain,
   71|       |                                           NSError *_Nullable error);
   72|       |
   73|       |/** @var kauthTypeVerifyApp
   74|       |    @brief The auth type to be specified in the app verification request.
   75|       | */
   76|       |static NSString *const kAuthTypeVerifyApp = @"verifyApp";
   77|       |
   78|       |/** @var kReCAPTCHAURLStringFormat
   79|       |    @brief The format of the URL used to open the reCAPTCHA page during app verification.
   80|       | */
   81|       |NSString *const kReCAPTCHAURLStringFormat = @"https://%@/__/auth/handler?";
   82|       |
   83|       |@implementation FIRPhoneAuthProvider {
   84|       |
   85|       |  /** @var _auth
   86|       |      @brief The auth instance used for verifying the phone number.
   87|       |   */
   88|       |  FIRAuth *_auth;
   89|       |
   90|       |  /** @var _callbackScheme
   91|       |      @brief The callback URL scheme used for reCAPTCHA fallback.
   92|       |   */
   93|       |  NSString *_callbackScheme;
   94|       |}
   95|       |
   96|       |/** @fn initWithAuth:
   97|       |    @brief returns an instance of @c FIRPhoneAuthProvider associated with the provided auth
   98|       |          instance.
   99|       |    @return An Instance of @c FIRPhoneAuthProvider.
  100|       |   */
  101|      0|- (nullable instancetype)initWithAuth:(FIRAuth *)auth {
  102|      0|  self = [super init];
  103|      0|  if (self) {
  104|      0|    _auth = auth;
  105|      0|    _callbackScheme = [[[_auth.app.options.clientID componentsSeparatedByString:@"."]
  106|      0|        reverseObjectEnumerator].allObjects componentsJoinedByString:@"."];
  107|      0|  }
  108|      0|  return self;
  109|      0|}
  110|       |
  111|       |- (void)verifyPhoneNumber:(NSString *)phoneNumber
  112|       |               UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  113|      0|               completion:(nullable FIRVerificationResultCallback)completion {
  114|      0|  if (![FIRAuthWebUtils isCallbackSchemeRegisteredForCustomURLScheme:_callbackScheme]) {
  115|      0|    [NSException raise:NSInternalInconsistencyException
  116|      0|                format:@"Please register custom URL scheme '%@' in the app's Info.plist file.",
  117|      0|                       _callbackScheme];
  118|      0|  }
  119|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  120|      0|    FIRVerificationResultCallback callBackOnMainThread = ^(NSString *_Nullable verificationID,
  121|      0|                                                           NSError *_Nullable error) {
  122|      0|      if (completion) {
  123|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  124|      0|          completion(verificationID, error);
  125|      0|        });
  126|      0|      }
  127|      0|    };
  128|      0|    [self internalVerifyPhoneNumber:phoneNumber
  129|      0|                         UIDelegate:UIDelegate
  130|      0|                         completion:^(NSString *_Nullable verificationID,
  131|      0|                                      NSError *_Nullable error) {
  132|      0|      if (!error) {
  133|      0|        callBackOnMainThread(verificationID, nil);
  134|      0|        return;
  135|      0|      } else {
  136|      0|        callBackOnMainThread(nil, error);
  137|      0|        return;
  138|      0|      }
  139|      0|    }];
  140|      0|  });
  141|      0|}
  142|       |
  143|       |- (FIRPhoneAuthCredential *)credentialWithVerificationID:(NSString *)verificationID
  144|      0|                                        verificationCode:(NSString *)verificationCode {
  145|      0|  return [[FIRPhoneAuthCredential alloc] initWithProviderID:FIRPhoneAuthProviderID
  146|      0|                                             verificationID:verificationID
  147|      0|                                           verificationCode:verificationCode];
  148|      0|}
  149|       |
  150|      0|+ (instancetype)provider {
  151|      0|  return [[self alloc]initWithAuth:[FIRAuth auth]];
  152|      0|}
  153|       |
  154|      0|+ (instancetype)providerWithAuth:(FIRAuth *)auth {
  155|      0|  return [[self alloc]initWithAuth:auth];
  156|      0|}
  157|       |
  158|       |#pragma mark - Internal Methods
  159|       |
  160|       |/** @fn reCAPTCHATokenForURL:error:
  161|       |    @brief Parses the reCAPTCHA URL and returns the reCAPTCHA token.
  162|       |    @param URL The url to be parsed for a reCAPTCHA token.
  163|       |    @param error The error that occurred if any.
  164|       |    @return The reCAPTCHA token if successful.
  165|       | */
  166|      0|- (NSString *)reCAPTCHATokenForURL:(NSURL *)URL error:(NSError **)error {
  167|      0|  NSURLComponents *actualURLComponents = [NSURLComponents componentsWithURL:URL resolvingAgainstBaseURL:NO];
  168|      0|  NSArray<NSURLQueryItem *> *queryItems = [actualURLComponents queryItems];
  169|      0|  NSString *deepLinkURL = [FIRAuthWebUtils queryItemValue:@"deep_link_id" from:queryItems];
  170|      0|  NSData *errorData;
  171|      0|  if (deepLinkURL) {
  172|      0|    actualURLComponents = [NSURLComponents componentsWithString:deepLinkURL];
  173|      0|    queryItems = [actualURLComponents queryItems];
  174|      0|    NSString *recaptchaToken = [FIRAuthWebUtils queryItemValue:@"recaptchaToken" from:queryItems];
  175|      0|    if (recaptchaToken) {
  176|      0|      return recaptchaToken;
  177|      0|    }
  178|      0|    NSString *firebaseError = [FIRAuthWebUtils queryItemValue:@"firebaseError" from:queryItems];
  179|      0|    errorData = [firebaseError dataUsingEncoding:NSUTF8StringEncoding];
  180|      0|  } else {
  181|      0|    errorData = nil;
  182|      0|  }
  183|      0|  NSError *jsonError;
  184|      0|  NSDictionary *errorDict = [NSJSONSerialization JSONObjectWithData:errorData
  185|      0|                                                            options:0
  186|      0|                                                              error:&jsonError];
  187|      0|  if (jsonError) {
  188|      0|    *error = [FIRAuthErrorUtils JSONSerializationErrorWithUnderlyingError:jsonError];
  189|      0|    return nil;
  190|      0|  }
  191|      0|  *error = [FIRAuthErrorUtils URLResponseErrorWithCode:errorDict[@"code"]
  192|      0|                                               message:errorDict[@"message"]];
  193|      0|  if (!*error) {
  194|      0|    NSString *reason;
  195|      0|    if(errorDict[@"code"] && errorDict[@"message"]) {
  196|      0|      reason = [NSString stringWithFormat:@"[%@] - %@",errorDict[@"code"], errorDict[@"message"]];
  197|      0|    } else {
  198|      0|      reason = [NSString stringWithFormat:@"An unknown error occurred with the following "
  199|      0|          "response: %@", deepLinkURL];
  200|      0|    }
  201|      0|    *error = [FIRAuthErrorUtils appVerificationUserInteractionFailureWithReason:reason];
  202|      0|  }
  203|      0|  return nil;
  204|      0|}
  205|       |
  206|       |/** @fn internalVerifyPhoneNumber:completion:
  207|       |    @brief Starts the phone number authentication flow by sending a verifcation code to the
  208|       |        specified phone number.
  209|       |    @param phoneNumber The phone number to be verified.
  210|       |    @param completion The callback to be invoked when the verification flow is finished.
  211|       | */
  212|       |
  213|       |- (void)internalVerifyPhoneNumber:(NSString *)phoneNumber
  214|       |                       UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  215|      0|                       completion:(nullable FIRVerificationResultCallback)completion {
  216|      0|  if (!phoneNumber.length) {
  217|      0|    completion(nil, [FIRAuthErrorUtils missingPhoneNumberErrorWithMessage:nil]);
  218|      0|    return;
  219|      0|  }
  220|      0|  [_auth.notificationManager checkNotificationForwardingWithCallback:
  221|      0|      ^(BOOL isNotificationBeingForwarded) {
  222|      0|    if (!isNotificationBeingForwarded) {
  223|      0|      completion(nil, [FIRAuthErrorUtils notificationNotForwardedError]);
  224|      0|      return;
  225|      0|    }
  226|      0|    FIRVerificationResultCallback callback = ^(NSString *_Nullable verificationID,
  227|      0|                                               NSError *_Nullable error) {
  228|      0|      if (completion) {
  229|      0|        completion(verificationID, error);
  230|      0|      }
  231|      0|    };
  232|      0|    [self verifyClientAndSendVerificationCodeToPhoneNumber:phoneNumber
  233|      0|                               retryOnInvalidAppCredential:YES
  234|      0|                                                UIDelegate:UIDelegate
  235|      0|                                                  callback:callback];
  236|      0|  }];
  237|      0|}
  238|       |
  239|       |/** @fn verifyClientAndSendVerificationCodeToPhoneNumber:retryOnInvalidAppCredential:callback:
  240|       |    @brief Starts the flow to verify the client via silent push notification.
  241|       |    @param retryOnInvalidAppCredential Whether of not the flow should be retried if an
  242|       |        FIRAuthErrorCodeInvalidAppCredential error is returned from the backend.
  243|       |    @param phoneNumber The phone number to be verified.
  244|       |    @param callback The callback to be invoked on the global work queue when the flow is
  245|       |        finished.
  246|       | */
  247|       |- (void)verifyClientAndSendVerificationCodeToPhoneNumber:(NSString *)phoneNumber
  248|       |                             retryOnInvalidAppCredential:(BOOL)retryOnInvalidAppCredential
  249|       |                                              UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  250|      0|                                                callback:(FIRVerificationResultCallback)callback {
  251|      0|  if (_auth.settings.isAppVerificationDisabledForTesting) {
  252|      0|    FIRSendVerificationCodeRequest *request =
  253|      0|        [[FIRSendVerificationCodeRequest alloc] initWithPhoneNumber:phoneNumber
  254|      0|                                                     appCredential:nil
  255|      0|                                                    reCAPTCHAToken:nil
  256|      0|                                              requestConfiguration:
  257|      0|                                                  _auth.requestConfiguration];
  258|      0|    [FIRAuthBackend sendVerificationCode:request
  259|      0|                                callback:^(FIRSendVerificationCodeResponse *_Nullable response,
  260|      0|                                           NSError *_Nullable error) {
  261|      0|      callback(response.verificationID, error);
  262|      0|    }];
  263|      0|    return;
  264|      0|  }
  265|      0|  [self verifyClientWithUIDelegate:UIDelegate
  266|      0|                        completion:^(FIRAuthAppCredential *_Nullable appCredential,
  267|      0|                                     NSString *_Nullable reCAPTCHAToken,
  268|      0|                                     NSError *_Nullable error) {
  269|      0|    if (error) {
  270|      0|      callback(nil, error);
  271|      0|      return;
  272|      0|    }
  273|      0|    FIRSendVerificationCodeRequest * _Nullable request;
  274|      0|    if (appCredential) {
  275|      0|      request =
  276|      0|          [[FIRSendVerificationCodeRequest alloc]
  277|      0|              initWithPhoneNumber:phoneNumber
  278|      0|                    appCredential:appCredential
  279|      0|                   reCAPTCHAToken:nil
  280|      0|             requestConfiguration:self->_auth.requestConfiguration];
  281|      0|    } else if (reCAPTCHAToken) {
  282|      0|      request =
  283|      0|          [[FIRSendVerificationCodeRequest alloc]
  284|      0|              initWithPhoneNumber:phoneNumber
  285|      0|                    appCredential:nil
  286|      0|                   reCAPTCHAToken:reCAPTCHAToken
  287|      0|             requestConfiguration:self->_auth.requestConfiguration];
  288|      0|    }
  289|      0|    if (request) {
  290|      0|      [FIRAuthBackend sendVerificationCode:request
  291|      0|                                  callback:^(FIRSendVerificationCodeResponse *_Nullable response,
  292|      0|                                             NSError *_Nullable error) {
  293|      0|        if (error) {
  294|      0|          if (error.code == FIRAuthErrorCodeInvalidAppCredential) {
  295|      0|            if (retryOnInvalidAppCredential) {
  296|      0|              [self->_auth.appCredentialManager clearCredential];
  297|      0|              [self verifyClientAndSendVerificationCodeToPhoneNumber:phoneNumber
  298|      0|                                         retryOnInvalidAppCredential:NO
  299|      0|                                                          UIDelegate:UIDelegate
  300|      0|                                                            callback:callback];
  301|      0|              return;
  302|      0|            }
  303|      0|            callback(nil, [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:nil
  304|      0|                                                                        underlyingError:error]);
  305|      0|            return;
  306|      0|          }
  307|      0|          callback(nil, error);
  308|      0|          return;
  309|      0|        }
  310|      0|        callback(response.verificationID, nil);
  311|      0|      }];
  312|      0|    }
  313|      0|  }];
  314|      0|}
  315|       |
  316|       |/** @fn verifyClientWithCompletion:completion:
  317|       |    @brief Continues the flow to verify the client via silent push notification.
  318|       |    @param completion The callback to be invoked when the client verification flow is finished.
  319|       | */
  320|       |- (void)verifyClientWithUIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  321|      0|                        completion:(FIRVerifyClientCallback)completion {
  322|      0|  if (_auth.appCredentialManager.credential) {
  323|      0|    completion(_auth.appCredentialManager.credential, nil, nil);
  324|      0|    return;
  325|      0|  }
  326|      0|  [_auth.tokenManager getTokenWithCallback:^(FIRAuthAPNSToken *_Nullable token,
  327|      0|                                             NSError *_Nullable error) {
  328|      0|    if (!token) {
  329|      0|      [self reCAPTCHAFlowWithUIDelegate:UIDelegate completion:completion];
  330|      0|      return;
  331|      0|    }
  332|      0|    FIRVerifyClientRequest *request =
  333|      0|        [[FIRVerifyClientRequest alloc] initWithAppToken:token.string
  334|      0|                                               isSandbox:token.type == FIRAuthAPNSTokenTypeSandbox
  335|      0|                                    requestConfiguration:self->_auth.requestConfiguration];
  336|      0|    [FIRAuthBackend verifyClient:request callback:^(FIRVerifyClientResponse *_Nullable response,
  337|      0|                                                    NSError *_Nullable error) {
  338|      0|      if (error) {
  339|      0|        NSError *underlyingError = error.userInfo[NSUnderlyingErrorKey];
  340|      0|        BOOL isInvalidAppCredential = error.code == FIRAuthErrorCodeInternalError &&
  341|      0|            underlyingError.code == FIRAuthErrorCodeInvalidAppCredential;
  342|      0|        if (error.code != FIRAuthErrorCodeMissingAppToken && !isInvalidAppCredential) {
  343|      0|          completion(nil, nil, error);
  344|      0|          return;
  345|      0|        } else {
  346|      0|          [self reCAPTCHAFlowWithUIDelegate:UIDelegate completion:completion];
  347|      0|          return;
  348|      0|        }
  349|      0|      }
  350|      0|      NSTimeInterval timeout = [response.suggestedTimeOutDate timeIntervalSinceNow];
  351|      0|      [self->_auth.appCredentialManager
  352|      0|          didStartVerificationWithReceipt:response.receipt
  353|      0|                                  timeout:timeout
  354|      0|                                 callback:^(FIRAuthAppCredential *credential) {
  355|      0|        if (!credential.secret) {
  356|      0|          FIRLogWarning(kFIRLoggerAuth, @"I-AUT000014",
  357|      0|                        @"Failed to receive remote notification to verify app identity within "
  358|      0|                        @"%.0f second(s)", timeout);
  359|      0|        }
  360|      0|        completion(credential, nil, nil);
  361|      0|      }];
  362|      0|    }];
  363|      0|  }];
  364|      0|}
  365|       |
  366|       |- (void)reCAPTCHAFlowWithUIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  367|      0|                         completion:(FIRVerifyClientCallback)completion {
  368|      0|  NSString *eventID = [FIRAuthWebUtils randomStringWithLength:10];
  369|      0|  [self reCAPTCHAURLWithEventID:eventID completion:^(NSURL *_Nullable reCAPTCHAURL,
  370|      0|                                                     NSError *_Nullable error) {
  371|      0|    if (error) {
  372|      0|      completion(nil, nil, error);
  373|      0|      return;
  374|      0|    }
  375|      0|    FIRAuthURLCallbackMatcher callbackMatcher = ^BOOL(NSURL *_Nullable callbackURL) {
  376|      0|      return [FIRAuthWebUtils isExpectedCallbackURL:callbackURL
  377|      0|                                            eventID:eventID
  378|      0|                                           authType:kAuthTypeVerifyApp
  379|      0|                                     callbackScheme:self->_callbackScheme];
  380|      0|    };
  381|      0|    [self->_auth.authURLPresenter presentURL:reCAPTCHAURL
  382|      0|                                  UIDelegate:UIDelegate
  383|      0|                             callbackMatcher:callbackMatcher
  384|      0|                                  completion:^(NSURL *_Nullable callbackURL,
  385|      0|                                               NSError *_Nullable error) {
  386|      0|      if (error) {
  387|      0|        completion(nil, nil, error);
  388|      0|        return;
  389|      0|      }
  390|      0|      NSError *reCAPTCHAError;
  391|      0|      NSString *reCAPTCHAToken = [self reCAPTCHATokenForURL:callbackURL error:&reCAPTCHAError];
  392|      0|      if (!reCAPTCHAToken) {
  393|      0|        completion(nil, nil, reCAPTCHAError);
  394|      0|        return;
  395|      0|      } else {
  396|      0|        completion(nil, reCAPTCHAToken, nil);
  397|      0|        return;
  398|      0|      }
  399|      0|    }];
  400|      0|  }];
  401|      0|}
  402|       |
  403|       |/** @fn reCAPTCHAURLWithEventID:completion:
  404|       |    @brief Constructs a URL used for opening a reCAPTCHA app verification flow using a given event
  405|       |        ID.
  406|       |    @param eventID The event ID used for this purpose.
  407|       |    @param completion The callback invoked after the URL has been constructed or an error
  408|       |        has been encountered.
  409|       | */
  410|      0|- (void)reCAPTCHAURLWithEventID:(NSString *)eventID completion:(FIRReCAPTCHAURLCallBack)completion {
  411|      0|  [FIRAuthWebUtils fetchAuthDomainWithRequestConfiguration:_auth.requestConfiguration
  412|      0|                                                completion:^(NSString *_Nullable authDomain,
  413|      0|                                                             NSError *_Nullable error) {
  414|      0|    if (error) {
  415|      0|      if (completion) {
  416|      0|        completion(nil, error);
  417|      0|        return;
  418|      0|      }
  419|      0|    }
  420|      0|    NSString *bundleID = [NSBundle mainBundle].bundleIdentifier;
  421|      0|    NSString *clientID = self->_auth.app.options.clientID;
  422|      0|    NSString *apiKey = self->_auth.requestConfiguration.APIKey;
  423|      0|    NSMutableArray<NSURLQueryItem *> *queryItems = [@[
  424|      0|      [NSURLQueryItem queryItemWithName:@"apiKey" value:apiKey],
  425|      0|      [NSURLQueryItem queryItemWithName:@"authType" value:kAuthTypeVerifyApp],
  426|      0|      [NSURLQueryItem queryItemWithName:@"ibi" value:bundleID ?: @""],
  427|      0|      [NSURLQueryItem queryItemWithName:@"clientId" value:clientID],
  428|      0|      [NSURLQueryItem queryItemWithName:@"v" value:[FIRAuthBackend authUserAgent]],
  429|      0|      [NSURLQueryItem queryItemWithName:@"eventId" value:eventID]
  430|      0|      ] mutableCopy
  431|      0|    ];
  432|      0|
  433|      0|    if (self->_auth.requestConfiguration.languageCode) {
  434|      0|      [queryItems addObject:[NSURLQueryItem queryItemWithName:@"hl"value:
  435|      0|                             self->_auth.requestConfiguration.languageCode]];
  436|      0|    }
  437|      0|    NSURLComponents *components = [[NSURLComponents alloc] initWithString:
  438|      0|      [NSString stringWithFormat:kReCAPTCHAURLStringFormat, authDomain]];
  439|      0|    [components setQueryItems:queryItems];
  440|      0|    if (completion) {
  441|      0|      completion([components URL], nil);
  442|      0|    }
  443|      0|  }];
  444|      0|}
  445|       |
  446|       |@end
  447|       |
  448|       |NS_ASSUME_NONNULL_END
  449|       |
  450|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Twitter/FIRTwitterAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRTwitterAuthCredential.h"
   18|       |
   19|       |#import "FIRTwitterAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |@interface FIRTwitterAuthCredential ()
   26|       |
   27|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRTwitterAuthCredential
   32|       |
   33|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   34|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   35|      0|      @"Please call the designated initializer."];
   36|      0|  return nil;
   37|      0|}
   38|       |
   39|      0|- (nullable instancetype)initWithToken:(NSString *)token secret:(NSString *)secret {
   40|      0|  self = [super initWithProvider:FIRTwitterAuthProviderID];
   41|      0|  if (self) {
   42|      0|    _token = [token copy];
   43|      0|    _secret = [secret copy];
   44|      0|  }
   45|      0|  return self;
   46|      0|}
   47|       |
   48|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   49|      0|  request.providerAccessToken = _token;
   50|      0|  request.providerOAuthTokenSecret = _secret;
   51|      0|}
   52|       |
   53|       |#pragma mark - NSSecureCoding
   54|       |
   55|      0|+ (BOOL)supportsSecureCoding {
   56|      0|  return YES;
   57|      0|}
   58|       |
   59|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   60|      0|  NSString *token = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"token"];
   61|      0|  NSString *secret = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"secret"];
   62|      0|  self = [self initWithToken:token secret:secret];
   63|      0|  return self;
   64|      0|}
   65|       |
   66|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   67|      0|  [aCoder encodeObject:self.token forKey:@"token"];
   68|      0|  [aCoder encodeObject:self.secret forKey:@"secret"];
   69|      0|}
   70|       |
   71|       |@end
   72|       |
   73|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProvider/Twitter/FIRTwitterAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRTwitterAuthProvider.h"
   18|       |
   19|       |#import "FIRTwitterAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRTwitterAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@implementation FIRTwitterAuthProvider
   27|       |
   28|      0|- (instancetype)init {
   29|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   30|      0|      @"This class is not meant to be initialized."];
   31|      0|  return nil;
   32|      0|}
   33|       |
   34|      0|+ (FIRAuthCredential *)credentialWithToken:(NSString *)token secret:(NSString *)secret {
   35|      0|  return [[FIRTwitterAuthCredential alloc] initWithToken:token secret:secret];
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/FIRAuthBackend.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthBackend.h"
   18|       |
   19|       |#import <GTMSessionFetcher/GTMSessionFetcher.h>
   20|       |#import <GTMSessionFetcher/GTMSessionFetcherService.h>
   21|       |
   22|       |#import "FIRAuthErrorUtils.h"
   23|       |#import "FIRAuthGlobalWorkQueue.h"
   24|       |#import "FirebaseAuth.h"
   25|       |#import "FIRAuthRPCRequest.h"
   26|       |#import "FIRAuthRPCResponse.h"
   27|       |#import "FIRCreateAuthURIRequest.h"
   28|       |#import "FIRCreateAuthURIResponse.h"
   29|       |#import "FIRDeleteAccountRequest.h"
   30|       |#import "FIRDeleteAccountResponse.h"
   31|       |#import "FIRGetAccountInfoRequest.h"
   32|       |#import "FIRGetAccountInfoResponse.h"
   33|       |#import "FIRSignInWithGameCenterRequest.h"
   34|       |#import "FIRSignInWithGameCenterResponse.h"
   35|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   36|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   37|       |#import "FIRGetProjectConfigRequest.h"
   38|       |#import "FIRGetProjectConfigResponse.h"
   39|       |#import "FIRResetPasswordRequest.h"
   40|       |#import "FIRResetPasswordResponse.h"
   41|       |#import "FIRSendVerificationCodeRequest.h"
   42|       |#import "FIRSendVerificationCodeResponse.h"
   43|       |#import "FIRSecureTokenRequest.h"
   44|       |#import "FIRSecureTokenResponse.h"
   45|       |#import "FIRSetAccountInfoRequest.h"
   46|       |#import "FIRSetAccountInfoResponse.h"
   47|       |#import "FIRSignUpNewUserRequest.h"
   48|       |#import "FIRSignUpNewUserResponse.h"
   49|       |#import "FIRVerifyAssertionRequest.h"
   50|       |#import "FIRVerifyAssertionResponse.h"
   51|       |#import "FIRVerifyClientRequest.h"
   52|       |#import "FIRVerifyClientResponse.h"
   53|       |#import "FIRVerifyCustomTokenRequest.h"
   54|       |#import "FIRVerifyCustomTokenResponse.h"
   55|       |#import "FIRVerifyPasswordRequest.h"
   56|       |#import "FIRVerifyPasswordResponse.h"
   57|       |#import "FIREmailLinkSignInRequest.h"
   58|       |#import "FIREmailLinkSignInResponse.h"
   59|       |#import "FIRVerifyPhoneNumberRequest.h"
   60|       |#import "FIRVerifyPhoneNumberResponse.h"
   61|       |
   62|       |#import "FIROAuthCredential_Internal.h"
   63|       |#if TARGET_OS_IOS
   64|       |#import "FIRPhoneAuthCredential_Internal.h"
   65|       |#import "FIRPhoneAuthProvider.h"
   66|       |#endif
   67|       |
   68|       |NS_ASSUME_NONNULL_BEGIN
   69|       |
   70|       |/** @var kClientVersionHeader
   71|       |    @brief HTTP header name for the client version.
   72|       | */
   73|       |static NSString *const kClientVersionHeader = @"X-Client-Version";
   74|       |
   75|       |/** @var kIosBundleIdentifierHeader
   76|       |    @brief HTTP header name for iOS bundle ID.
   77|       | */
   78|       |static NSString *const kIosBundleIdentifierHeader = @"X-Ios-Bundle-Identifier";
   79|       |
   80|       |/** @var kFirebaseLocalHeader
   81|       |    @brief HTTP header name for the firebase locale.
   82|       | */
   83|       |static NSString *const kFirebaseLocalHeader = @"X-Firebase-Locale";
   84|       |
   85|       |/** @var kFirebaseAuthCoreFrameworkMarker
   86|       |    @brief The marker in the HTTP header that indicates the request comes from Firebase Auth Core.
   87|       | */
   88|       |static NSString *const kFirebaseAuthCoreFrameworkMarker = @"FirebaseCore-iOS";
   89|       |
   90|       |/** @var kJSONContentType
   91|       |    @brief The value of the HTTP content-type header for JSON payloads.
   92|       | */
   93|       |static NSString *const kJSONContentType = @"application/json";
   94|       |
   95|       |/** @var kErrorDataKey
   96|       |    @brief Key for error data in NSError returned by @c GTMSessionFetcher.
   97|       | */
   98|       |static NSString * const kErrorDataKey = @"data";
   99|       |
  100|       |/** @var kErrorKey
  101|       |    @brief The key for the "error" value in JSON responses from the server.
  102|       | */
  103|       |static NSString *const kErrorKey = @"error";
  104|       |
  105|       |/** @var kErrorsKey
  106|       |    @brief The key for the "errors" value in JSON responses from the server.
  107|       | */
  108|       |static NSString *const kErrorsKey = @"errors";
  109|       |
  110|       |/** @var kReasonKey
  111|       |    @brief The key for the "reason" value in JSON responses from the server.
  112|       | */
  113|       |static NSString *const kReasonKey = @"reason";
  114|       |
  115|       |/** @var kInvalidKeyReasonValue
  116|       |    @brief The value for the "reason" key indicating an invalid API Key was received by the server.
  117|       | */
  118|       |static NSString *const kInvalidKeyReasonValue = @"keyInvalid";
  119|       |
  120|       |/** @var kAppNotAuthorizedReasonValue
  121|       |    @brief The value for the "reason" key indicating the App is not authorized to use Firebase
  122|       |        Authentication.
  123|       | */
  124|       |static NSString *const kAppNotAuthorizedReasonValue = @"ipRefererBlocked";
  125|       |
  126|       |/** @var kErrorMessageKey
  127|       |    @brief The key for an error's "message" value in JSON responses from the server.
  128|       | */
  129|       |static NSString *const kErrorMessageKey = @"message";
  130|       |
  131|       |/** @var kReturnIDPCredentialErrorMessageKey
  132|       |    @brief The key for "errorMessage" value in JSON responses from the server, In case
  133|       |        returnIDPCredential of a verifyAssertion request is set to @YES.
  134|       | */
  135|       |static NSString *const kReturnIDPCredentialErrorMessageKey = @"errorMessage";
  136|       |
  137|       |/** @var kUserNotFoundErrorMessage
  138|       |    @brief This is the error message returned when the user is not found, which means the user
  139|       |        account has been deleted given the token was once valid.
  140|       | */
  141|       |static NSString *const kUserNotFoundErrorMessage = @"USER_NOT_FOUND";
  142|       |
  143|       |/** @var kUserDeletedErrorMessage
  144|       |    @brief This is the error message the server will respond with if the user entered an invalid
  145|       |        email address.
  146|       | */
  147|       |static NSString *const kUserDeletedErrorMessage = @"EMAIL_NOT_FOUND";
  148|       |
  149|       |/** @var kInvalidLocalIDErrorMessage
  150|       |    @brief This is the error message the server responds with if the user local id in the id token
  151|       |        does not exit.
  152|       | */
  153|       |static NSString *const kInvalidLocalIDErrorMessage = @"INVALID_LOCAL_ID";
  154|       |
  155|       |/** @var kUserTokenExpiredErrorMessage
  156|       |    @brief The error returned by the server if the token issue time is older than the account's
  157|       |        valid_since time.
  158|       | */
  159|       |static NSString *const kUserTokenExpiredErrorMessage = @"TOKEN_EXPIRED";
  160|       |
  161|       |/** @var kTooManyRequestsErrorMessage
  162|       |    @brief This is the error message the server will respond with if too many requests were made to
  163|       |        a server method.
  164|       | */
  165|       |static NSString *const kTooManyRequestsErrorMessage = @"TOO_MANY_ATTEMPTS_TRY_LATER";
  166|       |
  167|       |/** @var kInvalidTokenCustomErrorMessage
  168|       |    @brief This is the error message the server will respond with if there is a validation error
  169|       |        with the custom token.
  170|       | */
  171|       |static NSString *const kInvalidCustomTokenErrorMessage = @"INVALID_CUSTOM_TOKEN";
  172|       |
  173|       |/** @var kCustomTokenMismatch
  174|       |    @brief This is the error message the server will respond with if the service account and API key
  175|       |        belong to different projects.
  176|       | */
  177|       |static NSString *const kCustomTokenMismatch = @"CREDENTIAL_MISMATCH";
  178|       |
  179|       |/** @var kInvalidCredentialErrorMessage
  180|       |    @brief This is the error message the server responds with if the IDP token or requestUri is
  181|       |        invalid.
  182|       | */
  183|       |static NSString *const kInvalidCredentialErrorMessage = @"INVALID_IDP_RESPONSE";
  184|       |
  185|       |/** @var kUserDisabledErrorMessage
  186|       |    @brief The error returned by the server if the user account is diabled.
  187|       | */
  188|       |static NSString *const kUserDisabledErrorMessage = @"USER_DISABLED";
  189|       |
  190|       |/** @var kOperationNotAllowedErrorMessage
  191|       |    @brief This is the error message the server will respond with if Admin disables IDP specified by
  192|       |        provider.
  193|       | */
  194|       |static NSString *const kOperationNotAllowedErrorMessage = @"OPERATION_NOT_ALLOWED";
  195|       |
  196|       |/** @var kPasswordLoginDisabledErrorMessage
  197|       |    @brief This is the error message the server responds with if password login is disabled.
  198|       | */
  199|       |static NSString *const kPasswordLoginDisabledErrorMessage = @"PASSWORD_LOGIN_DISABLED";
  200|       |
  201|       |/** @var kEmailAlreadyInUseErrorMessage
  202|       |    @brief This is the error message the server responds with if the email address already exists.
  203|       | */
  204|       |static NSString *const kEmailAlreadyInUseErrorMessage = @"EMAIL_EXISTS";
  205|       |
  206|       |/** @var kInvalidEmailErrorMessage
  207|       |    @brief The error returned by the server if the email is invalid.
  208|       | */
  209|       |static NSString *const kInvalidEmailErrorMessage = @"INVALID_EMAIL";
  210|       |
  211|       |/** @var kInvalidIdentifierErrorMessage
  212|       |    @brief The error returned by the server if the identifier is invalid.
  213|       | */
  214|       |static NSString *const kInvalidIdentifierErrorMessage = @"INVALID_IDENTIFIER";
  215|       |
  216|       |/** @var kWrongPasswordErrorMessage
  217|       |    @brief This is the error message the server will respond with if the user entered a wrong
  218|       |        password.
  219|       | */
  220|       |static NSString *const kWrongPasswordErrorMessage = @"INVALID_PASSWORD";
  221|       |
  222|       |/** @var kCredentialTooOldErrorMessage
  223|       |    @brief This is the error message the server responds with if account change is attempted 5
  224|       |        minutes after signing in.
  225|       | */
  226|       |static NSString *const kCredentialTooOldErrorMessage = @"CREDENTIAL_TOO_OLD_LOGIN_AGAIN";
  227|       |
  228|       |/** @var kFederatedUserIDAlreadyLinkedMessage
  229|       |    @brief This is the error message the server will respond with if the federated user ID has been
  230|       |        already linked with another account.
  231|       | */
  232|       |static NSString *const kFederatedUserIDAlreadyLinkedMessage = @"FEDERATED_USER_ID_ALREADY_LINKED";
  233|       |
  234|       |/** @var kInvalidUserTokenErrorMessage
  235|       |    @brief This is the error message the server responds with if user's saved auth credential is
  236|       |        invalid, and the user needs to sign in again.
  237|       | */
  238|       |static NSString *const kInvalidUserTokenErrorMessage = @"INVALID_ID_TOKEN";
  239|       |
  240|       |/** @var kWeakPasswordErrorMessagePrefix
  241|       |    @brief This is the prefix for the error message the server responds with if user's new password
  242|       |        to be set is too weak.
  243|       | */
  244|       |static NSString *const kWeakPasswordErrorMessagePrefix = @"WEAK_PASSWORD";
  245|       |
  246|       |/** @var kExpiredActionCodeErrorMessage
  247|       |    @brief This is the error message the server will respond with if the action code is expired.
  248|       | */
  249|       |static NSString *const kExpiredActionCodeErrorMessage = @"EXPIRED_OOB_CODE";
  250|       |
  251|       |/** @var kInvalidActionCodeErrorMessage
  252|       |    @brief This is the error message the server will respond with if the action code is invalid.
  253|       | */
  254|       |static NSString *const kInvalidActionCodeErrorMessage = @"INVALID_OOB_CODE";
  255|       |
  256|       |/** @var kMissingEmailErrorMessage
  257|       |    @brief This is the error message the server will respond with if the email address is missing
  258|       |        during a "send password reset email" attempt.
  259|       | */
  260|       |static NSString *const kMissingEmailErrorMessage = @"MISSING_EMAIL";
  261|       |
  262|       |/** @var kInvalidSenderEmailErrorMessage
  263|       |    @brief This is the error message the server will respond with if the sender email is invalid
  264|       |        during a "send password reset email" attempt.
  265|       | */
  266|       |static NSString *const kInvalidSenderEmailErrorMessage = @"INVALID_SENDER";
  267|       |
  268|       |/** @var kInvalidMessagePayloadErrorMessage
  269|       |    @brief This is the error message the server will respond with if there are invalid parameters in
  270|       |        the payload during a "send password reset email" attempt.
  271|       | */
  272|       |static NSString *const kInvalidMessagePayloadErrorMessage = @"INVALID_MESSAGE_PAYLOAD";
  273|       |
  274|       |/** @var kInvalidRecipientEmailErrorMessage
  275|       |    @brief This is the error message the server will respond with if the recipient email is invalid.
  276|       | */
  277|       |static NSString *const kInvalidRecipientEmailErrorMessage = @"INVALID_RECIPIENT_EMAIL";
  278|       |
  279|       |/** @var kMissingIosBundleIDErrorMessage
  280|       |    @brief This is the error message the server will respond with if iOS bundle ID is missing but
  281|       |        the iOS App store ID is provided.
  282|       | */
  283|       |static NSString *const kMissingIosBundleIDErrorMessage = @"MISSING_IOS_BUNDLE_ID";
  284|       |
  285|       |/** @var kMissingAndroidPackageNameErrorMessage
  286|       |    @brief This is the error message the server will respond with if Android Package Name is missing
  287|       |        but the flag indicating the app should be installed is set to true.
  288|       | */
  289|       |static NSString *const kMissingAndroidPackageNameErrorMessage = @"MISSING_ANDROID_PACKAGE_NAME";
  290|       |
  291|       |/** @var kUnauthorizedDomainErrorMessage
  292|       |    @brief This is the error message the server will respond with if the domain of the continue URL
  293|       |        specified is not whitelisted in the firebase console.
  294|       | */
  295|       |static NSString *const kUnauthorizedDomainErrorMessage = @"UNAUTHORIZED_DOMAIN";
  296|       |
  297|       |/** @var kInvalidProviderIDErrorMessage
  298|       |    @brief This is the error message the server will respond with if the provider id given for the
  299|       |        web operation is invalid.
  300|       | */
  301|       |static NSString *const kInvalidProviderIDErrorMessage = @"INVALID_PROVIDER_ID";
  302|       |
  303|       |/** @var kInvalidDynamicLinkDomainErrorMessage
  304|       |    @brief This is the error message the server will respond with if the dynamic link domain
  305|       |        provided in the request is invalid.
  306|       | */
  307|       |static NSString *const kInvalidDynamicLinkDomainErrorMessage = @"INVALID_DYNAMIC_LINK_DOMAIN";
  308|       |
  309|       |/** @var kInvalidContinueURIErrorMessage
  310|       |    @brief This is the error message the server will respond with if the continue URL provided in
  311|       |        the request is invalid.
  312|       | */
  313|       |static NSString *const kInvalidContinueURIErrorMessage = @"INVALID_CONTINUE_URI";
  314|       |
  315|       |/** @var kMissingContinueURIErrorMessage
  316|       |    @brief This is the error message the server will respond with if there was no continue URI
  317|       |        present in a request that required one.
  318|       | */
  319|       |static NSString *const kMissingContinueURIErrorMessage = @"MISSING_CONTINUE_URI";
  320|       |
  321|       |/** @var kInvalidPhoneNumberErrorMessage
  322|       |    @brief This is the error message the server will respond with if an incorrectly formatted phone
  323|       |        number is provided.
  324|       | */
  325|       |static NSString *const kInvalidPhoneNumberErrorMessage = @"INVALID_PHONE_NUMBER";
  326|       |
  327|       |/** @var kInvalidVerificationCodeErrorMessage
  328|       |    @brief This is the error message the server will respond with if an invalid verification code is
  329|       |        provided.
  330|       | */
  331|       |static NSString *const kInvalidVerificationCodeErrorMessage = @"INVALID_CODE";
  332|       |
  333|       |/** @var kInvalidSessionInfoErrorMessage
  334|       |    @brief This is the error message the server will respond with if an invalid session info
  335|       |        (verification ID) is provided.
  336|       | */
  337|       |static NSString *const kInvalidSessionInfoErrorMessage = @"INVALID_SESSION_INFO";
  338|       |
  339|       |/** @var kSessionExpiredErrorMessage
  340|       |    @brief This is the error message the server will respond with if the SMS code has expired before
  341|       |        it is used.
  342|       | */
  343|       |static NSString *const kSessionExpiredErrorMessage = @"SESSION_EXPIRED";
  344|       |
  345|       |/** @var kMissingOrInvalidNonceErrorMessage
  346|       |    @brief This is the error message the server will respond with if the nonce is missing or invalid.
  347|       | */
  348|       |static NSString *const kMissingOrInvalidNonceErrorMessage = @"MISSING_OR_INVALID_NONCE";
  349|       |
  350|       |/** @var kMissingAppTokenErrorMessage
  351|       |    @brief This is the error message the server will respond with if the APNS token is missing in a
  352|       |        verifyClient request.
  353|       | */
  354|       |static NSString *const kMissingAppTokenErrorMessage = @"MISSING_IOS_APP_TOKEN";
  355|       |
  356|       |/** @var kMissingAppCredentialErrorMessage
  357|       |    @brief This is the error message the server will respond with if the app token is missing in a
  358|       |        sendVerificationCode request.
  359|       | */
  360|       |static NSString *const kMissingAppCredentialErrorMessage = @"MISSING_APP_CREDENTIAL";
  361|       |
  362|       |/** @var kInvalidAppCredentialErrorMessage
  363|       |    @brief This is the error message the server will respond with if the app credential in a
  364|       |        sendVerificationCode request is invalid.
  365|       | */
  366|       |static NSString *const kInvalidAppCredentialErrorMessage = @"INVALID_APP_CREDENTIAL";
  367|       |
  368|       |/** @var kQuoutaExceededErrorMessage
  369|       |    @brief This is the error message the server will respond with if the quota for SMS text messages
  370|       |        has been exceeded for the project.
  371|       | */
  372|       |static NSString *const kQuoutaExceededErrorMessage = @"QUOTA_EXCEEDED";
  373|       |
  374|       |/** @var kAppNotVerifiedErrorMessage
  375|       |    @brief This is the error message the server will respond with if Firebase could not verify the
  376|       |        app during a phone authentication flow.
  377|       | */
  378|       |static NSString *const kAppNotVerifiedErrorMessage = @"APP_NOT_VERIFIED";
  379|       |
  380|       |/** @var kMissingClientIdentifier
  381|       |    @brief This is the error message the server will respond with if Firebase could not verify the
  382|       |        app during a phone authentication flow when a real phone number is used and app verification
  383|       |        is disabled for testing.
  384|       | */
  385|       |static NSString *const kMissingClientIdentifier = @"MISSING_CLIENT_IDENTIFIER";
  386|       |
  387|       |/** @var kCaptchaCheckFailedErrorMessage
  388|       |    @brief This is the error message the server will respond with if the reCAPTCHA token provided is
  389|       |        invalid.
  390|       | */
  391|       |static NSString *const kCaptchaCheckFailedErrorMessage = @"CAPTCHA_CHECK_FAILED";
  392|       |
  393|       |/** @var kInvalidPendingToken
  394|       |    @brief Generic IDP error codes.
  395|       | */
  396|       |static NSString *const kInvalidPendingToken = @"INVALID_PENDING_TOKEN";
  397|       |
  398|       |/** @var gBackendImplementation
  399|       |    @brief The singleton FIRAuthBackendImplementation instance to use.
  400|       | */
  401|       |static id<FIRAuthBackendImplementation> gBackendImplementation;
  402|       |
  403|       |/** @class FIRAuthBackendRPCImplementation
  404|       |    @brief The default RPC-based backend implementation.
  405|       | */
  406|       |@interface FIRAuthBackendRPCImplementation : NSObject <FIRAuthBackendImplementation>
  407|       |
  408|       |/** @property RPCIssuer
  409|       |    @brief An instance of FIRAuthBackendRPCIssuer for making RPC requests. Allows the RPC
  410|       |        requests/responses to be easily faked.
  411|       | */
  412|       |@property(nonatomic, strong) id<FIRAuthBackendRPCIssuer> RPCIssuer;
  413|       |
  414|       |@end
  415|       |
  416|       |@implementation FIRAuthBackend
  417|       |
  418|      0|+ (id<FIRAuthBackendImplementation>)implementation {
  419|      0|  if (!gBackendImplementation) {
  420|      0|    gBackendImplementation = [[FIRAuthBackendRPCImplementation alloc] init];
  421|      0|  }
  422|      0|  return gBackendImplementation;
  423|      0|}
  424|       |
  425|      0|+ (void)setBackendImplementation:(id<FIRAuthBackendImplementation>)backendImplementation {
  426|      0|  gBackendImplementation = backendImplementation;
  427|      0|}
  428|       |
  429|       |+ (void)setDefaultBackendImplementationWithRPCIssuer:
  430|      0|    (nullable id<FIRAuthBackendRPCIssuer>)RPCIssuer {
  431|      0|  FIRAuthBackendRPCImplementation *defaultImplementation =
  432|      0|      [[FIRAuthBackendRPCImplementation alloc] init];
  433|      0|  if (RPCIssuer) {
  434|      0|    defaultImplementation.RPCIssuer = RPCIssuer;
  435|      0|  }
  436|      0|  gBackendImplementation = defaultImplementation;
  437|      0|}
  438|       |
  439|       |+ (void)createAuthURI:(FIRCreateAuthURIRequest *)request
  440|      0|             callback:(FIRCreateAuthURIResponseCallback)callback {
  441|      0|  [[self implementation] createAuthURI:request callback:callback];
  442|      0|}
  443|       |
  444|       |+ (void)getAccountInfo:(FIRGetAccountInfoRequest *)request
  445|      0|              callback:(FIRGetAccountInfoResponseCallback)callback {
  446|      0|  [[self implementation] getAccountInfo:request callback:callback];
  447|      0|}
  448|       |
  449|       |+ (void)getProjectConfig:(FIRGetProjectConfigRequest *)request
  450|      0|                callback:(FIRGetProjectConfigResponseCallback)callback {
  451|      0|  [[self implementation] getProjectConfig:request callback:callback];
  452|      0|}
  453|       |
  454|       |+ (void)setAccountInfo:(FIRSetAccountInfoRequest *)request
  455|      0|              callback:(FIRSetAccountInfoResponseCallback)callback {
  456|      0|  [[self implementation] setAccountInfo:request callback:callback];
  457|      0|}
  458|       |
  459|       |+ (void)verifyAssertion:(FIRVerifyAssertionRequest *)request
  460|      0|               callback:(FIRVerifyAssertionResponseCallback)callback {
  461|      0|  [[self implementation] verifyAssertion:request callback:callback];
  462|      0|}
  463|       |
  464|       |+ (void)verifyCustomToken:(FIRVerifyCustomTokenRequest *)request
  465|      0|                 callback:(FIRVerifyCustomTokenResponseCallback)callback {
  466|      0|  [[self implementation] verifyCustomToken:request callback:callback];
  467|      0|}
  468|       |
  469|       |+ (void)verifyPassword:(FIRVerifyPasswordRequest *)request
  470|      0|              callback:(FIRVerifyPasswordResponseCallback)callback {
  471|      0|  [[self implementation] verifyPassword:request callback:callback];
  472|      0|}
  473|       |
  474|       |+ (void)emailLinkSignin:(FIREmailLinkSignInRequest *)request
  475|      0|               callback:(FIREmailLinkSigninResponseCallback)callback {
  476|      0|  [[self implementation] emailLinkSignin:request callback:callback];
  477|      0|}
  478|       |
  479|       |+ (void)secureToken:(FIRSecureTokenRequest *)request
  480|      0|           callback:(FIRSecureTokenResponseCallback)callback {
  481|      0|  [[self implementation] secureToken:request callback:callback];
  482|      0|}
  483|       |
  484|       |+ (void)getOOBConfirmationCode:(FIRGetOOBConfirmationCodeRequest *)request
  485|      0|                      callback:(FIRGetOOBConfirmationCodeResponseCallback)callback {
  486|      0|  [[self implementation] getOOBConfirmationCode:request callback:callback];
  487|      0|}
  488|       |
  489|       |+ (void)signUpNewUser:(FIRSignUpNewUserRequest *)request
  490|      0|             callback:(FIRSignupNewUserCallback)callback {
  491|      0|  [[self implementation] signUpNewUser:request callback:callback];
  492|      0|}
  493|       |
  494|      0|+ (void)deleteAccount:(FIRDeleteAccountRequest *)request callback:(FIRDeleteCallBack)callback {
  495|      0|  [[self implementation] deleteAccount:request callback:callback];
  496|      0|}
  497|       |
  498|       |+ (void)signInWithGameCenter:(FIRSignInWithGameCenterRequest *)request
  499|      0|                    callback:(FIRSignInWithGameCenterResponseCallback)callback {
  500|      0|  [[self implementation] signInWithGameCenter:request callback:callback];
  501|      0|}
  502|       |
  503|       |#if TARGET_OS_IOS
  504|       |+ (void)sendVerificationCode:(FIRSendVerificationCodeRequest *)request
  505|      0|                    callback:(FIRSendVerificationCodeResponseCallback)callback {
  506|      0|  [[self implementation] sendVerificationCode:request callback:callback];
  507|      0|}
  508|       |
  509|       |+ (void)verifyPhoneNumber:(FIRVerifyPhoneNumberRequest *)request
  510|      0|                 callback:(FIRVerifyPhoneNumberResponseCallback)callback {
  511|      0|  [[self implementation] verifyPhoneNumber:request callback:callback];
  512|      0|}
  513|       |
  514|      0|+ (void)verifyClient:(id)request callback:(FIRVerifyClientResponseCallback)callback {
  515|      0|  [[self implementation] verifyClient:request callback:callback];
  516|      0|}
  517|       |#endif
  518|       |
  519|       |+ (void)resetPassword:(FIRResetPasswordRequest *)request
  520|      0|             callback:(FIRResetPasswordCallback)callback {
  521|      0|  [[self implementation] resetPassword:request callback:callback];
  522|      0|}
  523|       |
  524|      0|+ (NSString *)authUserAgent {
  525|      0|  return [NSString stringWithFormat:@"FirebaseAuth.iOS/%s %@",
  526|      0|      FirebaseAuthVersionStr, GTMFetcherStandardUserAgentString(nil)];
  527|      0|}
  528|       |
  529|       |@end
  530|       |
  531|       |@interface FIRAuthBackendRPCIssuerImplementation : NSObject <FIRAuthBackendRPCIssuer>
  532|       |@end
  533|       |
  534|       |@implementation FIRAuthBackendRPCIssuerImplementation {
  535|       |  /** @var The session fetcher service.
  536|       |   */
  537|       |  GTMSessionFetcherService *_fetcherService;
  538|       |}
  539|       |
  540|      0|- (instancetype)init {
  541|      0|  self = [super init];
  542|      0|  if (self) {
  543|      0|    _fetcherService = [[GTMSessionFetcherService alloc] init];
  544|      0|    _fetcherService.userAgent = [FIRAuthBackend authUserAgent];
  545|      0|    _fetcherService.callbackQueue = FIRAuthGlobalWorkQueue();
  546|      0|
  547|      0|    // Avoid reusing the session to prevent
  548|      0|    // https://github.com/firebase/firebase-ios-sdk/issues/1261
  549|      0|    _fetcherService.reuseSession = NO;
  550|      0|  }
  551|      0|  return self;
  552|      0|}
  553|       |
  554|       |- (void)asyncPostToURLWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
  555|       |                                           URL:(NSURL *)URL
  556|       |                                          body:(nullable NSData *)body
  557|       |                                   contentType:(NSString *)contentType
  558|       |                             completionHandler:(void (^)(NSData *_Nullable,
  559|      0|                                                         NSError *_Nullable))handler {
  560|      0|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
  561|      0|  [request setValue:contentType forHTTPHeaderField:@"Content-Type"];
  562|      0|  NSString *additionalFrameworkMarker = requestConfiguration.additionalFrameworkMarker ?:
  563|      0|      kFirebaseAuthCoreFrameworkMarker;
  564|      0|  NSString *clientVersion = [NSString stringWithFormat:@"iOS/FirebaseSDK/%s/%@",
  565|      0|                                                       FirebaseAuthVersionStr,
  566|      0|                                                       additionalFrameworkMarker];
  567|      0|  [request setValue:clientVersion forHTTPHeaderField:kClientVersionHeader];
  568|      0|  NSString *bundleID = [[NSBundle mainBundle] bundleIdentifier];
  569|      0|  [request setValue:bundleID forHTTPHeaderField:kIosBundleIdentifierHeader];
  570|      0|
  571|      0|  NSArray<NSString *> *preferredLocalizations = [NSBundle mainBundle].preferredLocalizations;
  572|      0|  if (preferredLocalizations.count) {
  573|      0|    NSString *acceptLanguage = preferredLocalizations.firstObject;
  574|      0|    [request setValue:acceptLanguage forHTTPHeaderField:@"Accept-Language"];
  575|      0|  }
  576|      0|  NSString *languageCode = requestConfiguration.languageCode;
  577|      0|  if (languageCode.length) {
  578|      0|    [request setValue:languageCode forHTTPHeaderField:kFirebaseLocalHeader];
  579|      0|  }
  580|      0|  GTMSessionFetcher *fetcher = [_fetcherService fetcherWithRequest:request];
  581|      0|  fetcher.bodyData = body;
  582|      0|  [fetcher beginFetchWithCompletionHandler:handler];
  583|      0|}
  584|       |
  585|       |@end
  586|       |
  587|       |@implementation FIRAuthBackendRPCImplementation
  588|       |
  589|      0|- (instancetype)init {
  590|      0|  self = [super init];
  591|      0|  if (self) {
  592|      0|    _RPCIssuer = [[FIRAuthBackendRPCIssuerImplementation alloc] init];
  593|      0|  }
  594|      0|  return self;
  595|      0|}
  596|       |
  597|       |- (void)createAuthURI:(FIRCreateAuthURIRequest *)request
  598|      0|             callback:(FIRCreateAuthURIResponseCallback)callback {
  599|      0|  FIRCreateAuthURIResponse *response = [[FIRCreateAuthURIResponse alloc] init];
  600|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  601|      0|    if (error) {
  602|      0|      callback(nil, error);
  603|      0|    } else {
  604|      0|      callback(response, nil);
  605|      0|    }
  606|      0|  }];
  607|      0|}
  608|       |
  609|       |- (void)getAccountInfo:(FIRGetAccountInfoRequest *)request
  610|      0|              callback:(FIRGetAccountInfoResponseCallback)callback {
  611|      0|  FIRGetAccountInfoResponse *response = [[FIRGetAccountInfoResponse alloc] init];
  612|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  613|      0|    if (error) {
  614|      0|      callback(nil, error);
  615|      0|    } else {
  616|      0|      callback(response, nil);
  617|      0|    }
  618|      0|  }];
  619|      0|}
  620|       |
  621|       |- (void)getProjectConfig:(FIRGetProjectConfigRequest *)request
  622|      0|                callback:(FIRGetProjectConfigResponseCallback)callback {
  623|      0|  FIRGetProjectConfigResponse *response = [[FIRGetProjectConfigResponse alloc] init];
  624|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  625|      0|    if (error) {
  626|      0|      callback(nil, error);
  627|      0|    } else {
  628|      0|      callback(response, nil);
  629|      0|    }
  630|      0|  }];
  631|      0|}
  632|       |
  633|       |- (void)setAccountInfo:(FIRSetAccountInfoRequest *)request
  634|      0|              callback:(FIRSetAccountInfoResponseCallback)callback {
  635|      0|  FIRSetAccountInfoResponse *response = [[FIRSetAccountInfoResponse alloc] init];
  636|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  637|      0|    if (error) {
  638|      0|      callback(nil, error);
  639|      0|    } else {
  640|      0|      callback(response, nil);
  641|      0|    }
  642|      0|  }];
  643|      0|}
  644|       |
  645|       |- (void)verifyAssertion:(FIRVerifyAssertionRequest *)request
  646|      0|               callback:(FIRVerifyAssertionResponseCallback)callback {
  647|      0|  FIRVerifyAssertionResponse *response = [[FIRVerifyAssertionResponse alloc] init];
  648|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  649|      0|    if (error) {
  650|      0|      callback(nil, error);
  651|      0|      return;
  652|      0|    }
  653|      0|    callback(response, nil);
  654|      0|  }];
  655|      0|}
  656|       |
  657|       |- (void)verifyCustomToken:(FIRVerifyCustomTokenRequest *)request
  658|      0|                 callback:(FIRVerifyCustomTokenResponseCallback)callback {
  659|      0|  FIRVerifyCustomTokenResponse *response = [[FIRVerifyCustomTokenResponse alloc] init];
  660|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  661|      0|    if (error) {
  662|      0|      callback(nil, error);
  663|      0|    } else {
  664|      0|      callback(response, nil);
  665|      0|    }
  666|      0|  }];
  667|      0|}
  668|       |
  669|       |- (void)verifyPassword:(FIRVerifyPasswordRequest *)request
  670|      0|              callback:(FIRVerifyPasswordResponseCallback)callback {
  671|      0|  FIRVerifyPasswordResponse *response = [[FIRVerifyPasswordResponse alloc] init];
  672|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  673|      0|    if (error) {
  674|      0|      callback(nil, error);
  675|      0|    } else {
  676|      0|      callback(response, nil);
  677|      0|    }
  678|      0|  }];
  679|      0|}
  680|       |
  681|       |- (void)emailLinkSignin:(FIREmailLinkSignInRequest *)request
  682|      0|               callback:(FIREmailLinkSigninResponseCallback)callback {
  683|      0|  FIREmailLinkSignInResponse *response = [[FIREmailLinkSignInResponse alloc] init];
  684|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  685|      0|    if (error) {
  686|      0|      callback(nil, error);
  687|      0|    } else {
  688|      0|      callback(response, nil);
  689|      0|    }
  690|      0|  }];
  691|      0|}
  692|       |
  693|       |- (void)secureToken:(FIRSecureTokenRequest *)request
  694|      0|           callback:(FIRSecureTokenResponseCallback)callback {
  695|      0|  FIRSecureTokenResponse *response = [[FIRSecureTokenResponse alloc] init];
  696|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  697|      0|    if (error) {
  698|      0|      callback(nil, error);
  699|      0|    } else {
  700|      0|      callback(response, nil);
  701|      0|    }
  702|      0|  }];
  703|      0|}
  704|       |
  705|       |- (void)getOOBConfirmationCode:(FIRGetOOBConfirmationCodeRequest *)request
  706|      0|                      callback:(FIRGetOOBConfirmationCodeResponseCallback)callback {
  707|      0|  FIRGetOOBConfirmationCodeResponse *response = [[FIRGetOOBConfirmationCodeResponse alloc] init];
  708|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  709|      0|    if (error) {
  710|      0|      callback(nil, error);
  711|      0|    } else {
  712|      0|      callback(response, nil);
  713|      0|    }
  714|      0|  }];
  715|      0|}
  716|       |
  717|       |- (void)signUpNewUser:(FIRSignUpNewUserRequest *)request
  718|      0|             callback:(FIRSignupNewUserCallback)callback{
  719|      0|  FIRSignUpNewUserResponse *response  = [[FIRSignUpNewUserResponse alloc] init];
  720|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  721|      0|    if (error) {
  722|      0|      callback(nil, error);
  723|      0|    } else {
  724|      0|      callback(response, nil);
  725|      0|    }
  726|      0|  }];
  727|      0|}
  728|       |
  729|      0|- (void)deleteAccount:(FIRDeleteAccountRequest *)request callback:(FIRDeleteCallBack)callback {
  730|      0|  FIRDeleteAccountResponse *response = [[FIRDeleteAccountResponse alloc] init];
  731|      0|  [self postWithRequest:request response:response callback:callback];
  732|      0|}
  733|       |
  734|       |#if TARGET_OS_IOS
  735|       |- (void)sendVerificationCode:(FIRSendVerificationCodeRequest *)request
  736|      0|                    callback:(FIRSendVerificationCodeResponseCallback)callback {
  737|      0|  FIRSendVerificationCodeResponse *response = [[FIRSendVerificationCodeResponse alloc] init];
  738|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  739|      0|    if (error) {
  740|      0|      callback(nil, error);
  741|      0|    } else {
  742|      0|      callback(response, error);
  743|      0|    }
  744|      0|  }];
  745|      0|}
  746|       |
  747|       |- (void)verifyPhoneNumber:(FIRVerifyPhoneNumberRequest *)request
  748|      0|                 callback:(FIRVerifyPhoneNumberResponseCallback)callback {
  749|      0|  FIRVerifyPhoneNumberResponse *response = [[FIRVerifyPhoneNumberResponse alloc] init];
  750|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  751|      0|    if (error) {
  752|      0|      callback(nil, error);
  753|      0|      return;
  754|      0|    }
  755|      0|    // Check whether or not the successful response is actually the special case phone auth flow
  756|      0|    // that returns a temporary proof and phone number.
  757|      0|    if (response.phoneNumber.length && response.temporaryProof.length) {
  758|      0|      FIRPhoneAuthCredential *credential =
  759|      0|          [[FIRPhoneAuthCredential alloc] initWithTemporaryProof:response.temporaryProof
  760|      0|                                                     phoneNumber:response.phoneNumber
  761|      0|                                                      providerID:FIRPhoneAuthProviderID];
  762|      0|      callback(nil,
  763|      0|               [FIRAuthErrorUtils credentialAlreadyInUseErrorWithMessage:nil
  764|      0|                                                              credential:credential
  765|      0|                                                                   email:nil]);
  766|      0|      return;
  767|      0|    }
  768|      0|    callback(response, nil);
  769|      0|  }];
  770|      0|}
  771|       |
  772|      0|- (void)verifyClient:(id)request callback:(FIRVerifyClientResponseCallback)callback {
  773|      0|  FIRVerifyClientResponse *response = [[FIRVerifyClientResponse alloc] init];
  774|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  775|      0|    if (error) {
  776|      0|      callback(nil, error);
  777|      0|      return;
  778|      0|    }
  779|      0|    callback(response, nil);
  780|      0|  }];
  781|      0|}
  782|       |#endif
  783|       |
  784|       |- (void)resetPassword:(FIRResetPasswordRequest *)request
  785|      0|             callback:(FIRResetPasswordCallback)callback {
  786|      0|  FIRResetPasswordResponse *response = [[FIRResetPasswordResponse alloc] init];
  787|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  788|      0|    if (error) {
  789|      0|      callback(nil, error);
  790|      0|      return;
  791|      0|    }
  792|      0|    callback(response, nil);
  793|      0|  }];
  794|      0|}
  795|       |
  796|       |- (void)signInWithGameCenter:(FIRSignInWithGameCenterRequest *)request
  797|      0|                    callback:(FIRSignInWithGameCenterResponseCallback)callback {
  798|      0|  FIRSignInWithGameCenterResponse *response = [[FIRSignInWithGameCenterResponse alloc] init];
  799|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  800|      0|    if (error) {
  801|      0|      if (callback) {
  802|      0|        callback(nil, error);
  803|      0|      }
  804|      0|    } else {
  805|      0|      if (callback) {
  806|      0|        callback(response, nil);
  807|      0|      }
  808|      0|    }
  809|      0|  }];
  810|      0|}
  811|       |
  812|       |#pragma mark - Generic RPC handling methods
  813|       |
  814|       |/** @fn postWithRequest:response:callback:
  815|       |    @brief Calls the RPC using HTTP POST.
  816|       |    @remarks Possible error responses:
  817|       |        @see FIRAuthInternalErrorCodeRPCRequestEncodingError
  818|       |        @see FIRAuthInternalErrorCodeJSONSerializationError
  819|       |        @see FIRAuthInternalErrorCodeNetworkError
  820|       |        @see FIRAuthInternalErrorCodeUnexpectedErrorResponse
  821|       |        @see FIRAuthInternalErrorCodeUnexpectedResponse
  822|       |        @see FIRAuthInternalErrorCodeRPCResponseDecodingError
  823|       |    @param request The request.
  824|       |    @param response The empty response to be filled.
  825|       |    @param callback The callback for both success and failure.
  826|       | */
  827|       |- (void)postWithRequest:(id<FIRAuthRPCRequest>)request
  828|       |               response:(id<FIRAuthRPCResponse>)response
  829|      0|               callback:(void (^)(NSError * _Nullable error))callback {
  830|      0|  NSError *error;
  831|      0|  NSData *bodyData;
  832|      0|  if ([request containsPostBody]) {
  833|      0|    id postBody = [request unencodedHTTPRequestBodyWithError:&error];
  834|      0|    if (!postBody) {
  835|      0|      callback([FIRAuthErrorUtils RPCRequestEncodingErrorWithUnderlyingError:error]);
  836|      0|      return;
  837|      0|    }
  838|      0|
  839|      0|    NSJSONWritingOptions JSONWritingOptions = 0;
  840|      0|    #if DEBUG
  841|      0|      JSONWritingOptions |= NSJSONWritingPrettyPrinted;
  842|      0|    #endif
  843|      0|
  844|      0|    if ([NSJSONSerialization isValidJSONObject:postBody]) {
  845|      0|      bodyData = [NSJSONSerialization dataWithJSONObject:postBody
  846|      0|                                                 options:JSONWritingOptions
  847|      0|                                                   error:&error];
  848|      0|      if (!bodyData) {
  849|      0|        // This is an untested case. This happens exclusively when there is an error in the framework
  850|      0|        // implementation of dataWithJSONObject:options:error:. This shouldn't normally occur as
  851|      0|        // isValidJSONObject: should return NO in any case we should encounter an error.
  852|      0|        error = [FIRAuthErrorUtils JSONSerializationErrorWithUnderlyingError:error];
  853|      0|      }
  854|      0|    } else {
  855|      0|      error = [FIRAuthErrorUtils JSONSerializationErrorForUnencodableType];
  856|      0|    }
  857|      0|    if (!bodyData) {
  858|      0|      callback(error);
  859|      0|      return;
  860|      0|    }
  861|      0|  }
  862|      0|
  863|      0|  [_RPCIssuer asyncPostToURLWithRequestConfiguration:[request requestConfiguration]
  864|      0|                                                 URL:[request requestURL]
  865|      0|                                                body:bodyData
  866|      0|                                         contentType:kJSONContentType
  867|      0|                                   completionHandler:^(NSData *data, NSError *error) {
  868|      0|    // If there is an error with no body data at all, then this must be a network error.
  869|      0|    if (error && !data) {
  870|      0|      callback([FIRAuthErrorUtils networkErrorWithUnderlyingError:error]);
  871|      0|      return;
  872|      0|    }
  873|      0|
  874|      0|    // Try to decode the HTTP response data which may contain either a successful response or error
  875|      0|    // message.
  876|      0|    NSError *jsonError;
  877|      0|    NSDictionary * dictionary =
  878|      0|        [NSJSONSerialization JSONObjectWithData:data
  879|      0|                                        options:NSJSONReadingMutableLeaves
  880|      0|                                          error:&jsonError];
  881|      0|    if (!dictionary) {
  882|      0|      if (error) {
  883|      0|        // We have an error, but we couldn't decode the body, so we have no additional information
  884|      0|        // other than the raw response and the original NSError (the jsonError is infered by the
  885|      0|        // error code (FIRAuthErrorCodeUnexpectedHTTPResponse, and is irrelevant.)
  886|      0|        callback([FIRAuthErrorUtils unexpectedErrorResponseWithData:data underlyingError:error]);
  887|      0|      } else {
  888|      0|        // This is supposed to be a "successful" response, but we couldn't deserialize the body.
  889|      0|        callback([FIRAuthErrorUtils unexpectedResponseWithData:data underlyingError:jsonError]);
  890|      0|      }
  891|      0|      return;
  892|      0|    }
  893|      0|    if (![dictionary isKindOfClass:[NSDictionary class]]) {
  894|      0|      if (error) {
  895|      0|        callback([FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:dictionary]);
  896|      0|      } else {
  897|      0|        callback([FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary]);
  898|      0|      }
  899|      0|      return;
  900|      0|    }
  901|      0|
  902|      0|    // At this point we either have an error with successfully decoded details in the body, or we
  903|      0|    // have a response which must pass further validation before we know it's truly successful.
  904|      0|    // We deal with the case where we have an error with successfully decoded error details first:
  905|      0|    if (error) {
  906|      0|      NSDictionary *errorDictionary = dictionary[kErrorKey];
  907|      0|      if ([errorDictionary isKindOfClass:[NSDictionary class]]) {
  908|      0|        id<NSObject> errorMessage = errorDictionary[kErrorMessageKey];
  909|      0|        if ([errorMessage isKindOfClass:[NSString class]]) {
  910|      0|          NSString *errorMessageString = (NSString *)errorMessage;
  911|      0|
  912|      0|          // Contruct client error.
  913|      0|          NSError *clientError = [[self class] clientErrorWithServerErrorMessage:errorMessageString
  914|      0|                                                                 errorDictionary:errorDictionary
  915|      0|                                                                        response:response];
  916|      0|          if (clientError) {
  917|      0|            callback(clientError);
  918|      0|            return;
  919|      0|          }
  920|      0|        }
  921|      0|        // Not a message we know, return the message directly.
  922|      0|        if (errorMessage) {
  923|      0|          NSError *unexpecterErrorResponse =
  924|      0|              [FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:errorDictionary];
  925|      0|          callback(unexpecterErrorResponse);
  926|      0|          return;
  927|      0|        }
  928|      0|      }
  929|      0|      // No error message at all, return the decoded response.
  930|      0|      callback([FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:dictionary]);
  931|      0|      return;
  932|      0|    }
  933|      0|
  934|      0|    // Finally, we try to populate the response object with the JSON values.
  935|      0|    if (![response setWithDictionary:dictionary error:&error]) {
  936|      0|      callback([FIRAuthErrorUtils RPCResponseDecodingErrorWithDeserializedResponse:dictionary
  937|      0|                                                                   underlyingError:error]);
  938|      0|      return;
  939|      0|    }
  940|      0|    // In case returnIDPCredential of a verifyAssertion request is set to @YES, the server may
  941|      0|    // return a 200 with a response that may contain a server error.
  942|      0|    if ([request isKindOfClass:[FIRVerifyAssertionRequest class]]) {
  943|      0|      FIRVerifyAssertionRequest *verifyAssertionRequest = (FIRVerifyAssertionRequest *)request;
  944|      0|      if (verifyAssertionRequest.returnIDPCredential) {
  945|      0|        NSString *errorMessage = dictionary[kReturnIDPCredentialErrorMessageKey];
  946|      0|        if ([errorMessage isKindOfClass:[NSString class]]) {
  947|      0|          NSString *errorString = (NSString *)errorMessage;
  948|      0|          NSError *clientError = [[self class] clientErrorWithServerErrorMessage:errorString
  949|      0|                                                                 errorDictionary:@{}
  950|      0|                                                                        response:response];
  951|      0|          if (clientError) {
  952|      0|            callback(clientError);
  953|      0|            return;
  954|      0|          }
  955|      0|        }
  956|      0|      }
  957|      0|    }
  958|      0|    // Success! The response object originally passed in can be used by the caller.
  959|      0|    callback(nil);
  960|      0|  }];
  961|      0|}
  962|       |
  963|       |/** @fn clientErrorWithServerErrorMessage:errorDictionary:
  964|       |    @brief Translates known server errors to client errors.
  965|       |    @param serverErrorMessage The error message from the server.
  966|       |    @param errorDictionary The error part of the response from the server.
  967|       |    @param response The response from the server RPC.
  968|       |    @return A client error, if any.
  969|       | */
  970|       |+ (nullable NSError *)clientErrorWithServerErrorMessage:(NSString *)serverErrorMessage
  971|       |                                        errorDictionary:(NSDictionary *)errorDictionary
  972|      0|                                               response:(id<FIRAuthRPCResponse>)response {
  973|      0|  NSString *shortErrorMessage = serverErrorMessage;
  974|      0|  NSString *serverDetailErrorMessage;
  975|      0|  NSRange colonRange = [serverErrorMessage rangeOfString:@":"];
  976|      0|  if (colonRange.location != NSNotFound) {
  977|      0|    shortErrorMessage = [serverErrorMessage substringToIndex:colonRange.location];
  978|      0|    shortErrorMessage =
  979|      0|        [shortErrorMessage stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
  980|      0|    serverDetailErrorMessage = [serverErrorMessage substringFromIndex:colonRange.location + 1];
  981|      0|    serverDetailErrorMessage = [serverDetailErrorMessage stringByTrimmingCharactersInSet:
  982|      0|        [NSCharacterSet whitespaceCharacterSet]];
  983|      0|  }
  984|      0|
  985|      0|  // Delegate the responsibility for constructing the client error to the response object,
  986|      0|  // if possible.
  987|      0|  SEL clientErrorWithServerErrorMessageSelector =
  988|      0|      @selector(clientErrorWithShortErrorMessage:detailErrorMessage:);
  989|      0|  if ([response respondsToSelector:clientErrorWithServerErrorMessageSelector]) {
  990|      0|    NSError *error = [response clientErrorWithShortErrorMessage:shortErrorMessage
  991|      0|                                             detailErrorMessage:serverDetailErrorMessage];
  992|      0|    if (error) {
  993|      0|      return error;
  994|      0|    }
  995|      0|  }
  996|      0|
  997|      0|  if ([shortErrorMessage isEqualToString:kUserNotFoundErrorMessage]) {
  998|      0|    return [FIRAuthErrorUtils userNotFoundErrorWithMessage:serverDetailErrorMessage];
  999|      0|  }
 1000|      0|
 1001|      0|  if ([shortErrorMessage isEqualToString:kUserDeletedErrorMessage]) {
 1002|      0|    return [FIRAuthErrorUtils userNotFoundErrorWithMessage:serverDetailErrorMessage];
 1003|      0|  }
 1004|      0|
 1005|      0|  if ([shortErrorMessage isEqualToString:kInvalidLocalIDErrorMessage]) {
 1006|      0|    // This case shouldn't be necessary but it is for now: b/27908364 .
 1007|      0|    return [FIRAuthErrorUtils userNotFoundErrorWithMessage:serverDetailErrorMessage];
 1008|      0|  }
 1009|      0|
 1010|      0|  if ([shortErrorMessage isEqualToString:kUserTokenExpiredErrorMessage]) {
 1011|      0|    return [FIRAuthErrorUtils userTokenExpiredErrorWithMessage:serverDetailErrorMessage];
 1012|      0|  }
 1013|      0|
 1014|      0|  if ([shortErrorMessage isEqualToString:kTooManyRequestsErrorMessage]) {
 1015|      0|    return [FIRAuthErrorUtils tooManyRequestsErrorWithMessage:serverDetailErrorMessage];
 1016|      0|  }
 1017|      0|
 1018|      0|  if ([shortErrorMessage isEqualToString:kInvalidCustomTokenErrorMessage]) {
 1019|      0|    return [FIRAuthErrorUtils invalidCustomTokenErrorWithMessage:serverDetailErrorMessage];
 1020|      0|  }
 1021|      0|
 1022|      0|  if ([shortErrorMessage isEqualToString:kCustomTokenMismatch]) {
 1023|      0|    return [FIRAuthErrorUtils customTokenMistmatchErrorWithMessage:serverDetailErrorMessage];
 1024|      0|  }
 1025|      0|
 1026|      0|  if ([shortErrorMessage isEqualToString:kInvalidCredentialErrorMessage] ||
 1027|      0|      [shortErrorMessage isEqualToString:kInvalidPendingToken]) {
 1028|      0|    return [FIRAuthErrorUtils invalidCredentialErrorWithMessage:serverDetailErrorMessage];
 1029|      0|  }
 1030|      0|
 1031|      0|  if ([shortErrorMessage isEqualToString:kUserDisabledErrorMessage]) {
 1032|      0|    return [FIRAuthErrorUtils userDisabledErrorWithMessage:serverDetailErrorMessage];
 1033|      0|  }
 1034|      0|
 1035|      0|  if ([shortErrorMessage isEqualToString:kOperationNotAllowedErrorMessage]) {
 1036|      0|    return [FIRAuthErrorUtils operationNotAllowedErrorWithMessage:serverDetailErrorMessage];
 1037|      0|  }
 1038|      0|
 1039|      0|  if ([shortErrorMessage isEqualToString:kPasswordLoginDisabledErrorMessage]) {
 1040|      0|    return [FIRAuthErrorUtils operationNotAllowedErrorWithMessage:serverDetailErrorMessage];
 1041|      0|  }
 1042|      0|
 1043|      0|  if ([shortErrorMessage isEqualToString:kEmailAlreadyInUseErrorMessage]) {
 1044|      0|    return [FIRAuthErrorUtils emailAlreadyInUseErrorWithEmail:nil];
 1045|      0|  }
 1046|      0|
 1047|      0|  if ([shortErrorMessage isEqualToString:kInvalidEmailErrorMessage]) {
 1048|      0|    return [FIRAuthErrorUtils invalidEmailErrorWithMessage:serverDetailErrorMessage];
 1049|      0|  }
 1050|      0|
 1051|      0|  // "INVALID_IDENTIFIER" can be returned by createAuthURI RPC. Considering email addresses are
 1052|      0|  //  currently the only identifiers, we surface the FIRAuthErrorCodeInvalidEmail error code in this
 1053|      0|  //  case.
 1054|      0|  if ([shortErrorMessage isEqualToString:kInvalidIdentifierErrorMessage]) {
 1055|      0|    return [FIRAuthErrorUtils invalidEmailErrorWithMessage:serverDetailErrorMessage];
 1056|      0|  }
 1057|      0|
 1058|      0|  if ([shortErrorMessage isEqualToString:kWrongPasswordErrorMessage]) {
 1059|      0|    return [FIRAuthErrorUtils wrongPasswordErrorWithMessage:serverDetailErrorMessage];
 1060|      0|  }
 1061|      0|
 1062|      0|  if ([shortErrorMessage isEqualToString:kCredentialTooOldErrorMessage]) {
 1063|      0|    return [FIRAuthErrorUtils requiresRecentLoginErrorWithMessage:serverDetailErrorMessage];
 1064|      0|  }
 1065|      0|
 1066|      0|  if ([shortErrorMessage isEqualToString:kInvalidUserTokenErrorMessage]) {
 1067|      0|    return [FIRAuthErrorUtils invalidUserTokenErrorWithMessage:serverDetailErrorMessage];
 1068|      0|  }
 1069|      0|
 1070|      0|  if ([shortErrorMessage isEqualToString:kFederatedUserIDAlreadyLinkedMessage]) {
 1071|      0|    FIROAuthCredential *credential;
 1072|      0|    NSString *email;
 1073|      0|    if ([response isKindOfClass:[FIRVerifyAssertionResponse class]]) {
 1074|      0|      FIRVerifyAssertionResponse *verifyAssertion = (FIRVerifyAssertionResponse *)response;
 1075|      0|      credential =
 1076|      0|          [[FIROAuthCredential alloc] initWithVerifyAssertionResponse:verifyAssertion];
 1077|      0|      email = verifyAssertion.email;
 1078|      0|    }
 1079|      0|    return [FIRAuthErrorUtils credentialAlreadyInUseErrorWithMessage:serverDetailErrorMessage
 1080|      0|                                                          credential:credential
 1081|      0|                                                               email:email];
 1082|      0|  }
 1083|      0|
 1084|      0|  if ([shortErrorMessage isEqualToString:kWeakPasswordErrorMessagePrefix]) {
 1085|      0|    return [FIRAuthErrorUtils weakPasswordErrorWithServerResponseReason:serverDetailErrorMessage];
 1086|      0|  }
 1087|      0|
 1088|      0|  if ([shortErrorMessage isEqualToString:kExpiredActionCodeErrorMessage]) {
 1089|      0|    return [FIRAuthErrorUtils expiredActionCodeErrorWithMessage:serverDetailErrorMessage];
 1090|      0|  }
 1091|      0|
 1092|      0|  if ([shortErrorMessage isEqualToString:kInvalidActionCodeErrorMessage]) {
 1093|      0|    return [FIRAuthErrorUtils invalidActionCodeErrorWithMessage:serverDetailErrorMessage];
 1094|      0|  }
 1095|      0|
 1096|      0|  if ([shortErrorMessage isEqualToString:kMissingEmailErrorMessage]) {
 1097|      0|    return [FIRAuthErrorUtils missingEmailErrorWithMessage:serverDetailErrorMessage];
 1098|      0|  }
 1099|      0|
 1100|      0|  if ([shortErrorMessage isEqualToString:kInvalidSenderEmailErrorMessage]) {
 1101|      0|    return [FIRAuthErrorUtils invalidSenderErrorWithMessage:serverDetailErrorMessage];
 1102|      0|  }
 1103|      0|
 1104|      0|  if ([shortErrorMessage isEqualToString:kInvalidMessagePayloadErrorMessage]) {
 1105|      0|    return [FIRAuthErrorUtils invalidMessagePayloadErrorWithMessage:serverDetailErrorMessage];
 1106|      0|  }
 1107|      0|
 1108|      0|  if ([shortErrorMessage isEqualToString:kInvalidRecipientEmailErrorMessage]) {
 1109|      0|    return [FIRAuthErrorUtils invalidRecipientEmailErrorWithMessage:serverDetailErrorMessage];
 1110|      0|  }
 1111|      0|
 1112|      0|  if ([shortErrorMessage isEqualToString:kMissingIosBundleIDErrorMessage]) {
 1113|      0|    return [FIRAuthErrorUtils missingIosBundleIDErrorWithMessage:serverDetailErrorMessage];
 1114|      0|  }
 1115|      0|
 1116|      0|  if ([shortErrorMessage isEqualToString:kMissingAndroidPackageNameErrorMessage]) {
 1117|      0|    return [FIRAuthErrorUtils missingAndroidPackageNameErrorWithMessage:serverDetailErrorMessage];
 1118|      0|  }
 1119|      0|
 1120|      0|  if ([shortErrorMessage isEqualToString:kUnauthorizedDomainErrorMessage]) {
 1121|      0|    return [FIRAuthErrorUtils unauthorizedDomainErrorWithMessage:serverDetailErrorMessage];
 1122|      0|  }
 1123|      0|
 1124|      0|  if ([shortErrorMessage isEqualToString:kInvalidContinueURIErrorMessage]) {
 1125|      0|    return [FIRAuthErrorUtils invalidContinueURIErrorWithMessage:serverDetailErrorMessage];
 1126|      0|  }
 1127|      0|
 1128|      0|  if ([shortErrorMessage isEqualToString:kInvalidProviderIDErrorMessage]) {
 1129|      0|    return [FIRAuthErrorUtils invalidProviderIDErrorWithMessage:serverDetailErrorMessage];
 1130|      0|  }
 1131|      0|
 1132|      0|  if ([shortErrorMessage isEqualToString:kInvalidDynamicLinkDomainErrorMessage]) {
 1133|      0|    return [FIRAuthErrorUtils invalidDynamicLinkDomainErrorWithMessage:serverDetailErrorMessage];
 1134|      0|  }
 1135|      0|
 1136|      0|  if ([shortErrorMessage isEqualToString:kMissingContinueURIErrorMessage]) {
 1137|      0|    return [FIRAuthErrorUtils missingContinueURIErrorWithMessage:serverDetailErrorMessage];
 1138|      0|  }
 1139|      0|
 1140|      0|  if ([shortErrorMessage isEqualToString:kInvalidPhoneNumberErrorMessage]) {
 1141|      0|    return [FIRAuthErrorUtils invalidPhoneNumberErrorWithMessage:serverDetailErrorMessage];
 1142|      0|  }
 1143|      0|
 1144|      0|  if ([shortErrorMessage isEqualToString:kInvalidSessionInfoErrorMessage]) {
 1145|      0|    return [FIRAuthErrorUtils invalidVerificationIDErrorWithMessage:serverDetailErrorMessage];
 1146|      0|  }
 1147|      0|
 1148|      0|  if ([shortErrorMessage isEqualToString:kInvalidVerificationCodeErrorMessage]) {
 1149|      0|    return [FIRAuthErrorUtils invalidVerificationCodeErrorWithMessage:serverDetailErrorMessage];
 1150|      0|  }
 1151|      0|
 1152|      0|  if ([shortErrorMessage isEqualToString:kSessionExpiredErrorMessage]) {
 1153|      0|    return [FIRAuthErrorUtils sessionExpiredErrorWithMessage:serverDetailErrorMessage];
 1154|      0|  }
 1155|      0|
 1156|      0|  if ([shortErrorMessage isEqualToString:kMissingAppTokenErrorMessage]) {
 1157|      0|    return [FIRAuthErrorUtils missingAppTokenErrorWithUnderlyingError:nil];
 1158|      0|  }
 1159|      0|
 1160|      0|  if ([shortErrorMessage isEqualToString:kMissingAppCredentialErrorMessage]) {
 1161|      0|    return [FIRAuthErrorUtils missingAppCredentialWithMessage:serverDetailErrorMessage];
 1162|      0|  }
 1163|      0|
 1164|      0|  if ([shortErrorMessage isEqualToString:kInvalidAppCredentialErrorMessage]) {
 1165|      0|    return [FIRAuthErrorUtils invalidAppCredentialWithMessage:serverDetailErrorMessage];
 1166|      0|  }
 1167|      0|
 1168|      0|  if ([shortErrorMessage isEqualToString:kQuoutaExceededErrorMessage]) {
 1169|      0|    return [FIRAuthErrorUtils quotaExceededErrorWithMessage:serverErrorMessage];
 1170|      0|  }
 1171|      0|
 1172|      0|  if ([shortErrorMessage isEqualToString:kAppNotVerifiedErrorMessage]) {
 1173|      0|    return [FIRAuthErrorUtils appNotVerifiedErrorWithMessage:serverErrorMessage];
 1174|      0|  }
 1175|      0|
 1176|      0|  if ([shortErrorMessage isEqualToString:kMissingClientIdentifier]) {
 1177|      0|    return [FIRAuthErrorUtils missingClientIdentifierErrorWithMessage:serverErrorMessage];
 1178|      0|  }
 1179|      0|
 1180|      0|  if ([shortErrorMessage isEqualToString:kCaptchaCheckFailedErrorMessage]) {
 1181|      0|    return [FIRAuthErrorUtils captchaCheckFailedErrorWithMessage:serverErrorMessage];
 1182|      0|  }
 1183|      0|
 1184|      0|  if ([shortErrorMessage isEqualToString:kMissingOrInvalidNonceErrorMessage]) {
 1185|      0|    return [FIRAuthErrorUtils missingOrInvalidNonceErrorWithMessage:serverDetailErrorMessage];
 1186|      0|  }
 1187|      0|
 1188|      0|  // In this case we handle an error that might be specified in the underlying errors dictionary,
 1189|      0|  // the error message in determined based on the @c reason key in the dictionary.
 1190|      0|  if (errorDictionary[kErrorsKey]) {
 1191|      0|    // Check for underlying error with reason = keyInvalid;
 1192|      0|    id underlyingErrors = errorDictionary[kErrorsKey];
 1193|      0|    if ([underlyingErrors isKindOfClass:[NSArray class]]) {
 1194|      0|      NSArray *underlyingErrorsArray = (NSArray *)underlyingErrors;
 1195|      0|      for (id underlyingError in underlyingErrorsArray) {
 1196|      0|        if ([underlyingError isKindOfClass:[NSDictionary class]]) {
 1197|      0|          NSDictionary *underlyingErrorDictionary = (NSDictionary *)underlyingError;
 1198|      0|          NSString *reason = underlyingErrorDictionary[kReasonKey];
 1199|      0|          if ([reason hasPrefix:kInvalidKeyReasonValue]) {
 1200|      0|            return [FIRAuthErrorUtils invalidAPIKeyError];
 1201|      0|          }
 1202|      0|          if ([reason isEqualToString:kAppNotAuthorizedReasonValue]) {
 1203|      0|            return [FIRAuthErrorUtils appNotAuthorizedError];
 1204|      0|          }
 1205|      0|        }
 1206|      0|      }
 1207|      0|    }
 1208|      0|  }
 1209|      0|  return nil;
 1210|      0|}
 1211|       |
 1212|       |@end
 1213|       |
 1214|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/FIRAuthRequestConfiguration.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthRequestConfiguration.h"
   18|       |#import "FIRAuthExceptionUtils.h"
   19|       |
   20|       |NS_ASSUME_NONNULL_BEGIN
   21|       |
   22|       |@implementation FIRAuthRequestConfiguration
   23|       |
   24|      1|- (nullable instancetype)initWithAPIKey:(NSString *)APIKey {
   25|      1|  self = [super init];
   26|      1|  if (self) {
   27|      1|    _APIKey = [APIKey copy];
   28|      1|  }
   29|      1|  return self;
   30|      1|}
   31|       |
   32|       |@end
   33|       |
   34|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/FIRIdentityToolkitRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRIdentityToolkitRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kAPIURLFormat
   22|       |    @brief URL format for server API calls.
   23|       | */
   24|       |static NSString *const kAPIURLFormat = @"https://%@/identitytoolkit/v3/relyingparty/%@?key=%@";
   25|       |
   26|       |/** @var gAPIHost
   27|       |    @brief Host for server API calls.
   28|       | */
   29|       |static NSString *gAPIHost = @"www.googleapis.com";
   30|       |
   31|       |@implementation FIRIdentityToolkitRequest {
   32|       |  FIRAuthRequestConfiguration *_requestConfiguration;
   33|       |}
   34|       |
   35|       |- (nullable instancetype)initWithEndpoint:(NSString *)endpoint
   36|      0|                     requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   37|      0|  self = [super init];
   38|      0|  if (self) {
   39|      0|    _endpoint = [endpoint copy];
   40|      0|    _APIKey = [requestConfiguration.APIKey copy];
   41|      0|    _requestConfiguration = requestConfiguration;
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|      0|- (BOOL)containsPostBody {
   47|      0|  return YES;
   48|      0|}
   49|       |
   50|      0|- (NSURL *)requestURL {
   51|      0|  NSString *URLString = [NSString stringWithFormat:kAPIURLFormat, gAPIHost, _endpoint, _APIKey];
   52|      0|  NSURL *URL = [NSURL URLWithString:URLString];
   53|      0|  return URL;
   54|      0|}
   55|       |
   56|      0|- (FIRAuthRequestConfiguration *)requestConfiguration {
   57|      0|  return _requestConfiguration;
   58|      0|}
   59|       |
   60|       |#pragma mark - Internal API for development
   61|       |
   62|      0|+ (NSString *)host {
   63|      0|  return gAPIHost;
   64|      0|}
   65|       |
   66|      0|+ (void)setHost:(NSString *)host {
   67|      0|  gAPIHost = host;
   68|      0|}
   69|       |
   70|       |NS_ASSUME_NONNULL_END
   71|       |
   72|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRCreateAuthURIRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRCreateAuthURIRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kCreateAuthURIEndpoint
   22|       |    @brief The "createAuthUri" endpoint.
   23|       | */
   24|       |static NSString *const kCreateAuthURIEndpoint = @"createAuthUri";
   25|       |
   26|       |/** @var kProviderIDKey
   27|       |    @brief The key for the "providerId" value in the request.
   28|       | */
   29|       |static NSString *const kProviderIDKey = @"providerId";
   30|       |
   31|       |/** @var kIdentifierKey
   32|       |    @brief The key for the "identifier" value in the request.
   33|       | */
   34|       |static NSString *const kIdentifierKey = @"identifier";
   35|       |
   36|       |/** @var kContinueURIKey
   37|       |    @brief The key for the "continueUri" value in the request.
   38|       | */
   39|       |static NSString *const kContinueURIKey = @"continueUri";
   40|       |
   41|       |/** @var kOpenIDRealmKey
   42|       |    @brief The key for the "openidRealm" value in the request.
   43|       | */
   44|       |static NSString *const kOpenIDRealmKey = @"openidRealm";
   45|       |
   46|       |/** @var kClientIDKey
   47|       |    @brief The key for the "clientId" value in the request.
   48|       | */
   49|       |static NSString *const kClientIDKey = @"clientId";
   50|       |
   51|       |/** @var kContextKey
   52|       |    @brief The key for the "context" value in the request.
   53|       | */
   54|       |static NSString *const kContextKey = @"context";
   55|       |
   56|       |/** @var kAppIDKey
   57|       |    @brief The key for the "appId" value in the request.
   58|       | */
   59|       |static NSString *const kAppIDKey = @"appId";
   60|       |
   61|       |@implementation FIRCreateAuthURIRequest
   62|       |
   63|       |- (nullable instancetype)initWithIdentifier:(NSString *)identifier
   64|       |                                continueURI:(NSString *)continueURI
   65|      0|                       requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   66|      0|  self = [super initWithEndpoint:kCreateAuthURIEndpoint requestConfiguration:requestConfiguration];
   67|      0|  if (self) {
   68|      0|    _identifier = [identifier copy];
   69|      0|    _continueURI = [continueURI copy];
   70|      0|  }
   71|      0|  return self;
   72|      0|}
   73|       |
   74|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   75|      0|  NSMutableDictionary *postBody = [@{
   76|      0|    kIdentifierKey : _identifier,
   77|      0|    kContinueURIKey : _continueURI
   78|      0|  } mutableCopy];
   79|      0|  if (_providerID) {
   80|      0|    postBody[kProviderIDKey] = _providerID;
   81|      0|  }
   82|      0|  if (_openIDRealm) {
   83|      0|    postBody[kOpenIDRealmKey] = _openIDRealm;
   84|      0|  }
   85|      0|  if (_clientID) {
   86|      0|    postBody[kClientIDKey] = _clientID;
   87|      0|  }
   88|      0|  if (_context) {
   89|      0|    postBody[kContextKey] = _context;
   90|      0|  }
   91|      0|  if (_appID) {
   92|      0|    postBody[kAppIDKey] = _appID;
   93|      0|  }
   94|      0|  return postBody;
   95|      0|}
   96|       |
   97|       |@end
   98|       |
   99|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRCreateAuthURIResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRCreateAuthURIResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRCreateAuthURIResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _providerID = [dictionary[@"providerId"] copy];
   26|      0|  _authURI = [dictionary[@"authUri"] copy];
   27|      0|  _registered = [dictionary[@"registered"] boolValue];
   28|      0|  _forExistingProvider = [dictionary[@"forExistingProvider"] boolValue];
   29|      0|  _allProviders = [dictionary[@"allProviders"] copy];
   30|      0|  _signinMethods = [dictionary[@"signinMethods"] copy];
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRDeleteAccountRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDeleteAccountRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kCreateAuthURIEndpoint
   22|       |    @brief The "deleteAccount" endpoint.
   23|       | */
   24|       |static NSString *const kDeleteAccountEndpoint = @"deleteAccount";
   25|       |
   26|       |/** @var kIDTokenKey
   27|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   28|       |        despite it's confusing (backwards compatiable) parameter name.
   29|       | */
   30|       |static NSString *const kIDTokenKey = @"idToken";
   31|       |
   32|       |/** @var kLocalIDKey
   33|       |    @brief The key for the "localID" value in the request.
   34|       | */
   35|       |static NSString *const kLocalIDKey = @"localId";
   36|       |
   37|       |@implementation FIRDeleteAccountRequest {
   38|       |  /** @var _accessToken
   39|       |      @brief The STS Access Token of the authenticated user.
   40|       |   */
   41|       |  NSString *_accessToken;
   42|       |
   43|       |  /** @var _localID
   44|       |      @brief The localID of the user.
   45|       |   */
   46|       |  NSString *_localID;
   47|       |}
   48|       |
   49|       |- (nullable instancetype)initWitLocalID:(NSString *)localID
   50|       |                            accessToken:(NSString *)accessToken
   51|      0|                   requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   52|      0|  self = [super initWithEndpoint:kDeleteAccountEndpoint requestConfiguration:requestConfiguration];
   53|      0|  if (self) {
   54|      0|    _localID = [localID copy];
   55|      0|    _accessToken = [accessToken copy];
   56|      0|  }
   57|      0|  return self;
   58|      0|}
   59|       |
   60|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   61|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   62|      0|  postBody[kIDTokenKey] = _accessToken;
   63|      0|  postBody[kLocalIDKey] = _localID;
   64|      0|  return postBody;
   65|      0|}
   66|       |
   67|       |@end
   68|       |
   69|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRDeleteAccountResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDeleteAccountResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRDeleteAccountResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                   error:(NSError *_Nullable *_Nullable)error {
   25|      0|  return YES;
   26|      0|}
   27|       |
   28|       |@end
   29|       |
   30|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIREmailLinkSignInRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailLinkSignInRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kEmailLinkSigninEndpoint
   22|       |    @brief The "EmailLinkSignin" endpoint.
   23|       | */
   24|       |static NSString *const kEmailLinkSigninEndpoint = @"emailLinkSignin";
   25|       |
   26|       |/** @var kEmailKey
   27|       |    @brief The key for the "identifier" value in the request.
   28|       | */
   29|       |static NSString *const kEmailKey = @"email";
   30|       |
   31|       |/** @var kEmailLinkKey
   32|       |    @brief The key for the "emailLink" value in the request.
   33|       | */
   34|       |static NSString *const kOOBCodeKey = @"oobCode";
   35|       |
   36|       |/** @var kIDTokenKey
   37|       |    @brief The key for the "IDToken" value in the request.
   38|       | */
   39|       |static NSString *const kIDTokenKey = @"idToken";
   40|       |
   41|       |/** @var kPostBodyKey
   42|       |    @brief The key for the "postBody" value in the request.
   43|       | */
   44|       |static NSString *const kPostBodyKey = @"postBody";
   45|       |
   46|       |@implementation FIREmailLinkSignInRequest
   47|       |
   48|       |- (instancetype)initWithEmail:(NSString *)email
   49|       |                      oobCode:(NSString *)oobCode
   50|      0|         requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   51|      0|  self = [super initWithEndpoint:kEmailLinkSigninEndpoint
   52|      0|            requestConfiguration:requestConfiguration];
   53|      0|  if (self) {
   54|      0|    _email = email;
   55|      0|    _oobCode = oobCode;
   56|      0|  }
   57|      0|  return self;
   58|      0|}
   59|       |
   60|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   61|      0|  NSMutableDictionary *postBody = [@{
   62|      0|    kEmailKey : _email,
   63|      0|    kOOBCodeKey : _oobCode,
   64|      0|  } mutableCopy];
   65|      0|
   66|      0|  if (_IDToken) {
   67|      0|    postBody[kIDTokenKey] = _IDToken;
   68|      0|  }
   69|      0|  return postBody;
   70|      0|}
   71|       |
   72|       |@end
   73|       |
   74|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIREmailLinkSignInResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailLinkSignInResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIREmailLinkSignInResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable  *_Nullable)error {
   25|      0|  _email = [dictionary[@"email"] copy];
   26|      0|  _IDToken = [dictionary[@"idToken"] copy];
   27|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   28|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   29|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   30|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRGetAccountInfoRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetAccountInfoRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kGetAccountInfoEndpoint
   22|       |    @brief The "getAccountInfo" endpoint.
   23|       | */
   24|       |static NSString *const kGetAccountInfoEndpoint = @"getAccountInfo";
   25|       |
   26|       |/** @var kIDTokenKey
   27|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   28|       |        despite it's confusing (backwards compatiable) parameter name.
   29|       | */
   30|       |static NSString *const kIDTokenKey = @"idToken";
   31|       |
   32|       |@implementation FIRGetAccountInfoRequest
   33|       |
   34|       |- (nullable instancetype)initWithAccessToken:(NSString *)accessToken
   35|      0|                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   36|      0|  self = [super initWithEndpoint:kGetAccountInfoEndpoint
   37|      0|            requestConfiguration:requestConfiguration];
   38|      0|  if (self) {
   39|      0|    _accessToken = [accessToken copy];
   40|      0|  }
   41|      0|  return self;
   42|      0|}
   43|       |
   44|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   45|      0|  return @{
   46|      0|    kIDTokenKey : _accessToken
   47|      0|  };
   48|      0|}
   49|       |
   50|       |@end
   51|       |
   52|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRGetAccountInfoResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetAccountInfoResponse.h"
   18|       |
   19|       |#import "FIRAuthErrorUtils.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kErrorKey
   24|       |    @brief The key for the "error" value in JSON responses from the server.
   25|       | */
   26|       |static NSString *const kErrorKey = @"error";
   27|       |
   28|       |@implementation FIRGetAccountInfoResponseProviderUserInfo
   29|       |
   30|      0|- (instancetype)initWithDictionary:(NSDictionary *)dictionary {
   31|      0|  self = [super init];
   32|      0|  if (self) {
   33|      0|    _providerID = [dictionary[@"providerId"] copy];
   34|      0|    _displayName = [dictionary[@"displayName"] copy];
   35|      0|    NSString *photoURL = dictionary[@"photoUrl"];
   36|      0|    if (photoURL) {
   37|      0|      _photoURL = [NSURL URLWithString:photoURL];
   38|      0|    }
   39|      0|    _federatedID = [dictionary[@"federatedId"] copy];
   40|      0|    _email = [dictionary[@"email"] copy];
   41|      0|    _phoneNumber = [dictionary[@"phoneNumber"] copy];
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|       |@end
   47|       |
   48|       |@implementation FIRGetAccountInfoResponseUser
   49|       |
   50|      0|- (instancetype)initWithDictionary:(NSDictionary *)dictionary {
   51|      0|  self = [super init];
   52|      0|  if (self) {
   53|      0|    NSArray<NSDictionary *> *providerUserInfoData = dictionary[@"providerUserInfo"];
   54|      0|    if (providerUserInfoData) {
   55|      0|      NSMutableArray<FIRGetAccountInfoResponseProviderUserInfo *> *providerUserInfoArray =
   56|      0|          [NSMutableArray arrayWithCapacity:providerUserInfoData.count];
   57|      0|      for (NSDictionary *dictionary in providerUserInfoData) {
   58|      0|        [providerUserInfoArray addObject:
   59|      0|            [[FIRGetAccountInfoResponseProviderUserInfo alloc] initWithDictionary:dictionary]];
   60|      0|      }
   61|      0|      _providerUserInfo = [providerUserInfoArray copy];
   62|      0|    }
   63|      0|    _localID = [dictionary[@"localId"] copy];
   64|      0|    _displayName = [dictionary[@"displayName"] copy];
   65|      0|    _email = [dictionary[@"email"] copy];
   66|      0|    NSString *photoURL = dictionary[@"photoUrl"];
   67|      0|    if (photoURL) {
   68|      0|      _photoURL = [NSURL URLWithString:photoURL];
   69|      0|    }
   70|      0|    if ([dictionary[@"createdAt"] isKindOfClass:[NSString class]]) {
   71|      0|      // Divide by 1000 in order to convert miliseconds to seconds.
   72|      0|      NSTimeInterval creationDateTimeInterval = [dictionary[@"createdAt"] doubleValue] / 1000;
   73|      0|      _creationDate = [NSDate dateWithTimeIntervalSince1970:creationDateTimeInterval];
   74|      0|    }
   75|      0|    if ([dictionary[@"lastLoginAt"] isKindOfClass:[NSString class]]) {
   76|      0|      // Divide by 1000 in order to convert miliseconds to seconds
   77|      0|      NSTimeInterval creationDateTimeInterval = [dictionary[@"lastLoginAt"] doubleValue] / 1000;
   78|      0|      _lastLoginDate = [NSDate dateWithTimeIntervalSince1970:creationDateTimeInterval];
   79|      0|    }
   80|      0|    _emailVerified = [dictionary[@"emailVerified"] boolValue];
   81|      0|    _passwordHash = [dictionary[@"passwordHash"] copy];
   82|      0|    _phoneNumber = [dictionary[@"phoneNumber"] copy];
   83|      0|  }
   84|      0|  return self;
   85|      0|}
   86|       |
   87|       |@end
   88|       |
   89|       |@implementation FIRGetAccountInfoResponse
   90|       |
   91|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   92|      0|                    error:(NSError *_Nullable *_Nullable)error {
   93|      0|  NSArray<NSDictionary *> *usersData = dictionary[@"users"];
   94|      0|  // The client side never sends a getAccountInfo request with multiple localID, so only one user
   95|      0|  // data is expected in the response.
   96|      0|  if (![usersData isKindOfClass:[NSArray class]] || usersData.count != 1) {
   97|      0|    if (error) {
   98|      0|      *error = [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary];
   99|      0|    }
  100|      0|    return NO;
  101|      0|  }
  102|      0|  _users = @[ [[FIRGetAccountInfoResponseUser alloc] initWithDictionary:usersData.firstObject] ];
  103|      0|  return YES;
  104|      0|}
  105|       |
  106|       |@end
  107|       |
  108|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRGetOOBConfirmationCodeRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   18|       |
   19|       |#import "FIRActionCodeSettings.h"
   20|       |
   21|       |#import "FIRAuthErrorUtils.h"
   22|       |#import "FIRAuth_Internal.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |/** @var kEndpoint
   27|       |    @brief The getOobConfirmationCode endpoint name.
   28|       | */
   29|       |static NSString *const kGetOobConfirmationCodeEndpoint = @"getOobConfirmationCode";
   30|       |
   31|       |/** @var kRequestTypeKey
   32|       |    @brief The name of the required "requestType" property in the request.
   33|       | */
   34|       |static NSString *const kRequestTypeKey = @"requestType";
   35|       |
   36|       |/** @var kEmailKey
   37|       |    @brief The name of the "email" property in the request.
   38|       | */
   39|       |static NSString *const kEmailKey = @"email";
   40|       |
   41|       |/** @var kNewEmailKey
   42|       |    @brief The name of the "newEmail" property in the request.
   43|       | */
   44|       |static NSString *const kNewEmailKey = @"newEmail";
   45|       |
   46|       |/** @var kIDTokenKey
   47|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   48|       |        despite it's confusing (backwards compatiable) parameter name.
   49|       | */
   50|       |static NSString *const kIDTokenKey = @"idToken";
   51|       |
   52|       |/** @var kContinueURLKey
   53|       |    @brief The key for the "continue URL" value in the request.
   54|       | */
   55|       |static NSString *const kContinueURLKey = @"continueUrl";
   56|       |
   57|       |/** @var kIosBundeIDKey
   58|       |    @brief The key for the "iOS Bundle Identifier" value in the request.
   59|       | */
   60|       |static NSString *const kIosBundleIDKey = @"iOSBundleId";
   61|       |
   62|       |/** @var kAndroidPackageNameKey
   63|       |    @brief The key for the "Android Package Name" value in the request.
   64|       | */
   65|       |static NSString *const kAndroidPackageNameKey = @"androidPackageName";
   66|       |
   67|       |/** @var kAndroidInstallAppKey
   68|       |    @brief The key for the request parameter indicating whether the android app should be installed
   69|       |        or not.
   70|       | */
   71|       |static NSString *const kAndroidInstallAppKey = @"androidInstallApp";
   72|       |
   73|       |/** @var kAndroidMinimumVersionKey
   74|       |    @brief The key for the "minimum Android version supported" value in the request.
   75|       | */
   76|       |static NSString *const kAndroidMinimumVersionKey = @"androidMinimumVersion";
   77|       |
   78|       |/** @var kCanHandleCodeInAppKey
   79|       |    @brief The key for the request parameter indicating whether the action code can be handled in
   80|       |        the app or not.
   81|       | */
   82|       |static NSString *const kCanHandleCodeInAppKey = @"canHandleCodeInApp";
   83|       |
   84|       |/** @var kDynamicLinkDomainKey
   85|       |    @brief The key for the "dynamic link domain" value in the request.
   86|       | */
   87|       |static NSString *const kDynamicLinkDomainKey = @"dynamicLinkDomain";
   88|       |
   89|       |/** @var kPasswordResetRequestTypeValue
   90|       |    @brief The value for the "PASSWORD_RESET" request type.
   91|       | */
   92|       |static NSString *const kPasswordResetRequestTypeValue = @"PASSWORD_RESET";
   93|       |
   94|       |/** @var kEmailLinkSignInTypeValue
   95|       |    @brief The value for the "EMAIL_SIGNIN" request type.
   96|       | */
   97|       |static NSString *const kEmailLinkSignInTypeValue= @"EMAIL_SIGNIN";
   98|       |
   99|       |/** @var kVerifyEmailRequestTypeValue
  100|       |    @brief The value for the "VERIFY_EMAIL" request type.
  101|       | */
  102|       |static NSString *const kVerifyEmailRequestTypeValue = @"VERIFY_EMAIL";
  103|       |
  104|       |/** @var kVerifyBeforeUpdateEmailRequestTypeValue
  105|       |    @brief The value for the "VERIFY_AND_CHANGE_EMAIL" request type.
  106|       | */
  107|       |static NSString *const kVerifyBeforeUpdateEmailRequestTypeValue = @"VERIFY_AND_CHANGE_EMAIL";
  108|       |
  109|       |@interface FIRGetOOBConfirmationCodeRequest ()
  110|       |
  111|       |/** @fn initWithRequestType:email:APIKey:
  112|       |    @brief Designated initializer.
  113|       |    @param requestType The types of OOB Confirmation Code to request.
  114|       |    @param email The email of the user.
  115|       |    @param newEmail The email of the user to be updated.
  116|       |    @param accessToken The STS Access Token of the currently signed in user.
  117|       |    @param actionCodeSettings An object of FIRActionCodeSettings which specifies action code
  118|       |        settings to be applied to the OOB code request.
  119|       |    @param requestConfiguration An object containing configurations to be added to the request.
  120|       | */
  121|       |- (nullable instancetype)initWithRequestType:(FIRGetOOBConfirmationCodeRequestType)requestType
  122|       |                                       email:(nullable NSString *)email
  123|       |                                    newEmail:(nullable NSString *)newEmail
  124|       |                                 accessToken:(nullable NSString *)accessToken
  125|       |                          actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  126|       |                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
  127|       |                              NS_DESIGNATED_INITIALIZER;
  128|       |
  129|       |@end
  130|       |
  131|       |@implementation FIRGetOOBConfirmationCodeRequest
  132|       |
  133|       |/** @var requestTypeStringValueForRequestType:
  134|       |    @brief Returns the string equivilent for an @c FIRGetOOBConfirmationCodeRequestType value.
  135|       | */
  136|       |+ (NSString *)requestTypeStringValueForRequestType:
  137|      0|    (FIRGetOOBConfirmationCodeRequestType)requestType {
  138|      0|  switch (requestType) {
  139|      0|    case FIRGetOOBConfirmationCodeRequestTypePasswordReset:
  140|      0|      return kPasswordResetRequestTypeValue;
  141|      0|    case FIRGetOOBConfirmationCodeRequestTypeVerifyEmail:
  142|      0|      return kVerifyEmailRequestTypeValue;
  143|      0|    case FIRGetOOBConfirmationCodeRequestTypeEmailLink:
  144|      0|      return kEmailLinkSignInTypeValue;
  145|      0|    case FIRGetOOBConfirmationCodeRequestTypeVerifyBeforeUpdateEmail:
  146|      0|      return kVerifyBeforeUpdateEmailRequestTypeValue;
  147|      0|    // No default case so that we get a compiler warning if a new value was added to the enum.
  148|      0|  }
  149|      0|}
  150|       |
  151|       |+ (nullable FIRGetOOBConfirmationCodeRequest *)
  152|       |    passwordResetRequestWithEmail:(NSString *)email
  153|       |               actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  154|      0|             requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  155|      0|  return [[self alloc] initWithRequestType:FIRGetOOBConfirmationCodeRequestTypePasswordReset
  156|      0|                                     email:email
  157|      0|                                  newEmail:nil
  158|      0|                               accessToken:nil
  159|      0|                        actionCodeSettings:actionCodeSettings
  160|      0|                      requestConfiguration:requestConfiguration];
  161|      0|}
  162|       |
  163|       |+ (nullable FIRGetOOBConfirmationCodeRequest *)
  164|       |    verifyEmailRequestWithAccessToken:(NSString *)accessToken
  165|       |                   actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  166|      0|                 requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  167|      0|  return [[self alloc] initWithRequestType:FIRGetOOBConfirmationCodeRequestTypeVerifyEmail
  168|      0|                                     email:nil
  169|      0|                                  newEmail:nil
  170|      0|                               accessToken:accessToken
  171|      0|                        actionCodeSettings:actionCodeSettings
  172|      0|                      requestConfiguration:requestConfiguration];
  173|      0|}
  174|       |
  175|       |+ (nullable FIRGetOOBConfirmationCodeRequest *)
  176|       |    signInWithEmailLinkRequest:(NSString *)email
  177|       |            actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  178|      0|          requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  179|      0|  return [[self alloc] initWithRequestType:FIRGetOOBConfirmationCodeRequestTypeEmailLink
  180|      0|                                     email:email
  181|      0|                                  newEmail:nil
  182|      0|                               accessToken:nil
  183|      0|                        actionCodeSettings:actionCodeSettings
  184|      0|                      requestConfiguration:requestConfiguration];
  185|      0|}
  186|       |
  187|       |+ (nullable FIRGetOOBConfirmationCodeRequest *)
  188|       |    verifyBeforeUpdateEmailWithAccessToken:(NSString *)accessToken
  189|       |                                  newEmail:(NSString *)newEmail
  190|       |                        actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  191|      0|                      requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  192|      0|  return [[self alloc]
  193|      0|      initWithRequestType:FIRGetOOBConfirmationCodeRequestTypeVerifyBeforeUpdateEmail
  194|      0|                    email:nil
  195|      0|                 newEmail:newEmail
  196|      0|              accessToken:accessToken
  197|      0|       actionCodeSettings:actionCodeSettings
  198|      0|     requestConfiguration:requestConfiguration];
  199|      0|}
  200|       |
  201|       |- (nullable instancetype)initWithRequestType:(FIRGetOOBConfirmationCodeRequestType)requestType
  202|       |                                       email:(nullable NSString *)email
  203|       |                                    newEmail:(nullable NSString *)newEmail
  204|       |                                 accessToken:(nullable NSString *)accessToken
  205|       |                          actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  206|      0|                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  207|      0|  self = [super initWithEndpoint:kGetOobConfirmationCodeEndpoint
  208|      0|            requestConfiguration:requestConfiguration];
  209|      0|  if (self) {
  210|      0|    _requestType = requestType;
  211|      0|    _email = email;
  212|      0|    _updatedEmail = newEmail;
  213|      0|    _accessToken = accessToken;
  214|      0|    _continueURL = actionCodeSettings.URL.absoluteString;
  215|      0|    _iOSBundleID = actionCodeSettings.iOSBundleID;
  216|      0|    _androidPackageName = actionCodeSettings.androidPackageName;
  217|      0|    _androidMinimumVersion = actionCodeSettings.androidMinimumVersion;
  218|      0|    _androidInstallApp = actionCodeSettings.androidInstallIfNotAvailable;
  219|      0|    _handleCodeInApp = actionCodeSettings.handleCodeInApp;
  220|      0|    _dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
  221|      0|  }
  222|      0|  return self;
  223|      0|}
  224|       |
  225|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  226|      0|  NSMutableDictionary *body = [@{
  227|      0|    kRequestTypeKey : [[self class] requestTypeStringValueForRequestType:_requestType]
  228|      0|  } mutableCopy];
  229|      0|
  230|      0|  // For password reset requests, we only need an email address in addition to the already required
  231|      0|  // fields.
  232|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypePasswordReset) {
  233|      0|    body[kEmailKey] = _email;
  234|      0|  }
  235|      0|
  236|      0|  // For verify email requests, we only need an STS Access Token in addition to the already required
  237|      0|  // fields.
  238|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypeVerifyEmail) {
  239|      0|    body[kIDTokenKey] = _accessToken;
  240|      0|  }
  241|      0|
  242|      0|  // For email sign-in link requests, we only need an email address in addition to the already
  243|      0|  // required fields.
  244|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypeEmailLink) {
  245|      0|    body[kEmailKey] = _email;
  246|      0|  }
  247|      0|
  248|      0|  // For email sign-in link requests, we only need an STS Access Token, a new email address in
  249|      0|  // addition to the already required fields.
  250|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypeVerifyBeforeUpdateEmail) {
  251|      0|    body[kNewEmailKey] = _updatedEmail;
  252|      0|    body[kIDTokenKey] = _accessToken;
  253|      0|  }
  254|      0|
  255|      0|  if (_continueURL) {
  256|      0|    body[kContinueURLKey] = _continueURL;
  257|      0|  }
  258|      0|
  259|      0|  if (_iOSBundleID) {
  260|      0|    body[kIosBundleIDKey] = _iOSBundleID;
  261|      0|  }
  262|      0|
  263|      0|  if (_androidPackageName) {
  264|      0|    body[kAndroidPackageNameKey] = _androidPackageName;
  265|      0|  }
  266|      0|
  267|      0|  if (_androidMinimumVersion) {
  268|      0|    body[kAndroidMinimumVersionKey] = _androidMinimumVersion;
  269|      0|  }
  270|      0|
  271|      0|  if (_androidInstallApp) {
  272|      0|    body[kAndroidInstallAppKey] = @YES;
  273|      0|  }
  274|      0|
  275|      0|  if (_handleCodeInApp) {
  276|      0|    body[kCanHandleCodeInAppKey] = @YES;
  277|      0|  }
  278|      0|
  279|      0|  if (_dynamicLinkDomain) {
  280|      0|    body[kDynamicLinkDomainKey] = _dynamicLinkDomain;
  281|      0|  }
  282|      0|
  283|      0|  return body;
  284|      0|}
  285|       |
  286|       |@end
  287|       |
  288|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRGetOOBConfirmationCodeResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kOOBCodeKey
   22|       |    @brief The name of the field in the response JSON for the OOB code.
   23|       | */
   24|       |static NSString *const kOOBCodeKey = @"oobCode";
   25|       |
   26|       |@implementation FIRGetOOBConfirmationCodeResponse
   27|       |
   28|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   29|      0|                    error:(NSError *_Nullable *_Nullable)error {
   30|      0|  _OOBCode = [dictionary[kOOBCodeKey] copy];
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRGetProjectConfigRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetProjectConfigRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kGetProjectConfigEndPoint
   22|       |    @brief The "getProjectConfig" endpoint.
   23|       | */
   24|       |static NSString *const kGetProjectConfigEndPoint = @"getProjectConfig";
   25|       |
   26|       |@implementation FIRGetProjectConfigRequest
   27|       |
   28|       |- (nullable instancetype)initWithRequestConfiguration:
   29|      0|    (FIRAuthRequestConfiguration *)requestConfiguration {
   30|      0|  return [super initWithEndpoint:kGetProjectConfigEndPoint
   31|      0|            requestConfiguration:requestConfiguration];
   32|      0|}
   33|       |
   34|      0|- (BOOL)containsPostBody {
   35|      0|  return NO;
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRGetProjectConfigResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetProjectConfigResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRGetProjectConfigResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _projectID = [dictionary[@"projectId"] copy];
   26|      0|  id authorizedDomains = dictionary[@"authorizedDomains"];
   27|      0|  if ([authorizedDomains isKindOfClass:[NSString class]]) {
   28|      0|    NSData *data = [authorizedDomains dataUsingEncoding:NSUTF8StringEncoding];
   29|      0|    authorizedDomains = [NSJSONSerialization JSONObjectWithData:data
   30|      0|                                                       options:NSJSONReadingMutableLeaves
   31|      0|                                                         error:nil];
   32|      0|  }
   33|      0|  if ([authorizedDomains isKindOfClass:[NSArray class]]) {
   34|      0|    _authorizedDomains = [[NSArray alloc] initWithArray:authorizedDomains
   35|      0|                                              copyItems:YES];
   36|      0|  }
   37|      0|  return YES;
   38|      0|}
   39|       |
   40|       |@end
   41|       |
   42|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRResetPasswordRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRResetPasswordRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kResetPasswordEndpoint
   22|       |    @brief The "resetPassword" endpoint.
   23|       | */
   24|       |static NSString *const kResetPasswordEndpoint = @"resetPassword";
   25|       |
   26|       |/** @var kOOBCodeKey
   27|       |    @brief The "resetPassword" key.
   28|       | */
   29|       |static NSString *const kOOBCodeKey = @"oobCode";
   30|       |
   31|       |/** @var kCurrentPasswordKey
   32|       |    @brief The "newPassword" key.
   33|       | */
   34|       |static NSString *const kCurrentPasswordKey = @"newPassword";
   35|       |
   36|       |@implementation FIRResetPasswordRequest
   37|       |
   38|       |- (nullable instancetype)initWithOobCode:(NSString *)oobCode
   39|       |                             newPassword:(nullable NSString *)newPassword
   40|      0|                    requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   41|      0|  self = [super initWithEndpoint:kResetPasswordEndpoint requestConfiguration:requestConfiguration];
   42|      0|  if (self) {
   43|      0|    _oobCode = oobCode;
   44|      0|    _updatedPassword = newPassword;
   45|      0|  }
   46|      0|  return self;
   47|      0|}
   48|       |
   49|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   50|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   51|      0|  postBody[kOOBCodeKey] = _oobCode;
   52|      0|  if (_updatedPassword) {
   53|      0|    postBody[kCurrentPasswordKey] = _updatedPassword;
   54|      0|  }
   55|      0|  return postBody;
   56|      0|}
   57|       |
   58|       |@end
   59|       |
   60|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRResetPasswordResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRResetPasswordResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRResetPasswordResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _email = [dictionary[@"email"] copy];
   26|      0|  _requestType = [dictionary[@"requestType"] copy];
   27|      0|  _verifiedEmail = [dictionary[@"newEmail"] copy];
   28|      0|  return YES;
   29|      0|}
   30|       |
   31|       |@end
   32|       |
   33|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSecureTokenRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureTokenRequest.h"
   18|       |#import "FIRAuthRequestConfiguration.h"
   19|       |
   20|       |NS_ASSUME_NONNULL_BEGIN
   21|       |
   22|       |/** @var kFIRSecureTokenServiceGetTokenURLFormat
   23|       |    @brief The format of the secure token service URLs. Requires string format substitution with
   24|       |        the client's API Key.
   25|       | */
   26|       |static NSString *const kFIRSecureTokenServiceGetTokenURLFormat = @"https://%@/v1/token?key=%@";
   27|       |
   28|       |/** @var kFIRSecureTokenServiceGrantTypeRefreshToken
   29|       |    @brief The string value of the @c FIRSecureTokenRequestGrantTypeRefreshToken request type.
   30|       | */
   31|       |static NSString *const kFIRSecureTokenServiceGrantTypeRefreshToken = @"refresh_token";
   32|       |
   33|       |/** @var kFIRSecureTokenServiceGrantTypeAuthorizationCode
   34|       |    @brief The string value of the @c FIRSecureTokenRequestGrantTypeAuthorizationCode request type.
   35|       | */
   36|       |static NSString *const kFIRSecureTokenServiceGrantTypeAuthorizationCode = @"authorization_code";
   37|       |
   38|       |/** @var kGrantTypeKey
   39|       |    @brief The key for the "grantType" parameter in the request.
   40|       | */
   41|       |static NSString *const kGrantTypeKey = @"grantType";
   42|       |
   43|       |/** @var kScopeKey
   44|       |    @brief The key for the "scope" parameter in the request.
   45|       | */
   46|       |static NSString *const kScopeKey = @"scope";
   47|       |
   48|       |/** @var kRefreshTokenKey
   49|       |    @brief The key for the "refreshToken" parameter in the request.
   50|       | */
   51|       |static NSString *const kRefreshTokenKey = @"refreshToken";
   52|       |
   53|       |/** @var kCodeKey
   54|       |    @brief The key for the "code" parameter in the request.
   55|       | */
   56|       |static NSString *const kCodeKey = @"code";
   57|       |
   58|       |/** @var gAPIHost
   59|       | @brief Host for server API calls.
   60|       | */
   61|       |static NSString *gAPIHost = @"securetoken.googleapis.com";
   62|       |
   63|       |@implementation FIRSecureTokenRequest {
   64|       |  /** @var _requestConfiguration
   65|       |      @brief Contains configuration relevant to the request.
   66|       |   */
   67|       |  FIRAuthRequestConfiguration *_requestConfiguration;
   68|       |}
   69|       |
   70|       |+ (FIRSecureTokenRequest *)authCodeRequestWithCode:(NSString *)code
   71|       |                                     requestConfiguration:(FIRAuthRequestConfiguration *)
   72|      0|                                         requestConfiguration {
   73|      0|  return [[self alloc] initWithGrantType:FIRSecureTokenRequestGrantTypeAuthorizationCode
   74|      0|                                   scope:nil
   75|      0|                            refreshToken:nil
   76|      0|                                    code:code
   77|      0|                    requestConfiguration:requestConfiguration];
   78|      0|}
   79|       |
   80|       |+ (FIRSecureTokenRequest *)refreshRequestWithRefreshToken:(NSString *)refreshToken
   81|       |                                     requestConfiguration:(FIRAuthRequestConfiguration *)
   82|      0|                                         requestConfiguration {
   83|      0|  return [[self alloc] initWithGrantType:FIRSecureTokenRequestGrantTypeRefreshToken
   84|      0|                                   scope:nil
   85|      0|                            refreshToken:refreshToken
   86|      0|                                    code:nil
   87|      0|                    requestConfiguration:requestConfiguration];
   88|      0|}
   89|       |
   90|       |/** @fn grantTypeStringWithGrantType:
   91|       |    @brief Converts a @c FIRSecureTokenRequestGrantType to it's @c NSString equivilent.
   92|       | */
   93|      0|+ (NSString *)grantTypeStringWithGrantType:(FIRSecureTokenRequestGrantType)grantType {
   94|      0|  switch (grantType) {
   95|      0|    case FIRSecureTokenRequestGrantTypeAuthorizationCode:
   96|      0|      return kFIRSecureTokenServiceGrantTypeAuthorizationCode;
   97|      0|    case FIRSecureTokenRequestGrantTypeRefreshToken:
   98|      0|      return kFIRSecureTokenServiceGrantTypeRefreshToken;
   99|      0|    // No Default case so we will notice if new grant types are added to the enum.
  100|      0|  }
  101|      0|}
  102|       |
  103|       |- (nullable instancetype)initWithGrantType:(FIRSecureTokenRequestGrantType)grantType
  104|       |                                     scope:(nullable NSString *)scope
  105|       |                              refreshToken:(nullable NSString *)refreshToken
  106|       |                                      code:(nullable NSString *)code
  107|      0|                      requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  108|      0|  self = [super init];
  109|      0|  if (self) {
  110|      0|    _grantType = grantType;
  111|      0|    _scope = [scope copy];
  112|      0|    _refreshToken = [refreshToken copy];
  113|      0|    _code = [code copy];
  114|      0|    _APIKey = [requestConfiguration.APIKey copy];
  115|      0|    _requestConfiguration = requestConfiguration;
  116|      0|  }
  117|      0|  return self;
  118|      0|}
  119|       |
  120|      0|- (FIRAuthRequestConfiguration *)requestConfiguration {
  121|      0|  return _requestConfiguration;
  122|      0|}
  123|       |
  124|      0|- (NSURL *)requestURL {
  125|      0|  NSString *URLString =
  126|      0|      [NSString stringWithFormat:kFIRSecureTokenServiceGetTokenURLFormat, gAPIHost, _APIKey];
  127|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  128|      0|  return URL;
  129|      0|}
  130|       |
  131|      0|- (BOOL)containsPostBody {
  132|      0|  return YES;
  133|      0|}
  134|       |
  135|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  136|      0|  NSMutableDictionary *postBody = [@{
  137|      0|    kGrantTypeKey : [[self class] grantTypeStringWithGrantType:_grantType]
  138|      0|  } mutableCopy];
  139|      0|  if (_scope) {
  140|      0|    postBody[kScopeKey] = _scope;
  141|      0|  }
  142|      0|  if (_refreshToken) {
  143|      0|    postBody[kRefreshTokenKey] = _refreshToken;
  144|      0|  }
  145|      0|  if (_code) {
  146|      0|    postBody[kCodeKey] = _code;
  147|      0|  }
  148|      0|  return postBody;
  149|      0|}
  150|       |
  151|       |#pragma mark - Internal API for development
  152|       |
  153|      0|+ (NSString *)host {
  154|      0|  return gAPIHost;
  155|      0|}
  156|       |
  157|      0|+ (void)setHost:(NSString *)host {
  158|      0|  gAPIHost = host;
  159|      0|}
  160|       |
  161|       |@end
  162|       |
  163|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSecureTokenResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureTokenResponse.h"
   18|       |
   19|       |#import "FIRAuthErrorUtils.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kExpiresInKey
   24|       |    @brief The key for the number of seconds till the access token expires.
   25|       | */
   26|       |static NSString *const kExpiresInKey = @"expires_in";
   27|       |
   28|       |/** @var kRefreshTokenKey
   29|       |    @brief The key for the refresh token.
   30|       | */
   31|       |static NSString *const kRefreshTokenKey = @"refresh_token";
   32|       |
   33|       |/** @var kAccessTokenKey
   34|       |    @brief The key for the access token.
   35|       | */
   36|       |static NSString *const kAccessTokenKey = @"access_token";
   37|       |
   38|       |/** @var kIDTokenKey
   39|       |    @brief The key for the "id_token" value in the response.
   40|       | */
   41|       |static NSString *const kIDTokenKey = @"id_token";
   42|       |
   43|       |@implementation FIRSecureTokenResponse
   44|       |
   45|      0|- (nullable NSString *)expectedKind {
   46|      0|  return nil;
   47|      0|}
   48|       |
   49|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   50|      0|                    error:(NSError *_Nullable *_Nullable)error {
   51|      0|  _refreshToken = dictionary[kRefreshTokenKey];
   52|      0|  _accessToken = dictionary[kAccessTokenKey];
   53|      0|  _IDToken = dictionary[kIDTokenKey];
   54|      0|  if (!_accessToken.length) {
   55|      0|    if (error) {
   56|      0|      *error = [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary];
   57|      0|    }
   58|      0|    return NO;
   59|      0|  }
   60|      0|  id expiresIn = dictionary[kExpiresInKey];
   61|      0|  if (![expiresIn isKindOfClass:[NSString class]]) {
   62|      0|    if (error) {
   63|      0|      *error = [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary];
   64|      0|    }
   65|      0|    return NO;
   66|      0|  }
   67|      0|
   68|      0|  _approximateExpirationDate = [NSDate dateWithTimeIntervalSinceNow:[expiresIn doubleValue]];
   69|      0|  return YES;
   70|      0|}
   71|       |
   72|       |@end
   73|       |
   74|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSendVerificationCodeRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSendVerificationCodeRequest.h"
   18|       |
   19|       |#import "FIRAuthAppCredential.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kSendVerificationCodeEndPoint
   24|       |    @brief The "sendVerificationCodeEnd" endpoint.
   25|       | */
   26|       |static NSString *const kSendVerificationCodeEndPoint = @"sendVerificationCode";
   27|       |
   28|       |/** @var kPhoneNumberKey
   29|       |    @brief The key for the Phone Number parameter in the request.
   30|       | */
   31|       |static NSString *const kPhoneNumberKey = @"phoneNumber";
   32|       |
   33|       |/** @var kReceiptKey
   34|       |    @brief The key for the receipt parameter in the request.
   35|       | */
   36|       |static NSString *const kReceiptKey = @"iosReceipt";
   37|       |
   38|       |/** @var kSecretKey
   39|       |    @brief The key for the Secret parameter in the request.
   40|       | */
   41|       |static NSString *const kSecretKey = @"iosSecret";
   42|       |
   43|       |/** @var kreCAPTCHATokenKey
   44|       |    @brief The key for the reCAPTCHAToken parameter in the request.
   45|       | */
   46|       |static NSString *const kreCAPTCHATokenKey = @"recaptchaToken";
   47|       |
   48|       |@implementation FIRSendVerificationCodeRequest {
   49|       |}
   50|       |
   51|       |- (nullable instancetype)initWithPhoneNumber:(NSString *)phoneNumber
   52|       |                               appCredential:(nullable FIRAuthAppCredential *)appCredential
   53|       |                              reCAPTCHAToken:(nullable NSString *)reCAPTCHAToken
   54|      0|                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   55|      0|  self = [super initWithEndpoint:kSendVerificationCodeEndPoint
   56|      0|            requestConfiguration:requestConfiguration];
   57|      0|  if (self) {
   58|      0|    _phoneNumber = [phoneNumber copy];
   59|      0|    _appCredential = appCredential;
   60|      0|    _reCAPTCHAToken = [reCAPTCHAToken copy];
   61|      0|  }
   62|      0|  return self;
   63|      0|}
   64|       |
   65|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   66|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   67|      0|  if (_phoneNumber) {
   68|      0|    postBody[kPhoneNumberKey] = _phoneNumber;
   69|      0|  }
   70|      0|  if (_appCredential.receipt) {
   71|      0|    postBody[kReceiptKey] = _appCredential.receipt;
   72|      0|  }
   73|      0|  if (_appCredential.secret) {
   74|      0|    postBody[kSecretKey] = _appCredential.secret;
   75|      0|  }
   76|      0|  if (_reCAPTCHAToken) {
   77|      0|    postBody[kreCAPTCHATokenKey] = _reCAPTCHAToken;
   78|      0|  }
   79|      0|  return postBody;
   80|      0|}
   81|       |
   82|       |@end
   83|       |
   84|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSendVerificationCodeResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSendVerificationCodeResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRSendVerificationCodeResponse
   22|       |
   23|       |// TODO: remove when resolving b/37169084 .
   24|      0|- (nullable NSString *)expectedKind {
   25|      0|  return nil;
   26|      0|}
   27|       |
   28|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   29|      0|                    error:(NSError *_Nullable  *_Nullable)error {
   30|      0|  _verificationID = [dictionary[@"sessionInfo"] copy];
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSetAccountInfoRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSetAccountInfoRequest.h"
   18|       |
   19|       |#import "FIRAuthErrorUtils.h"
   20|       |#import "FIRAuth_Internal.h"
   21|       |#import "FIRGetAccountInfoResponse.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |NSString *const FIRSetAccountInfoUserAttributeEmail = @"EMAIL";
   26|       |
   27|       |NSString *const FIRSetAccountInfoUserAttributeDisplayName = @"DISPLAY_NAME";
   28|       |
   29|       |NSString *const FIRSetAccountInfoUserAttributeProvider = @"PROVIDER";
   30|       |
   31|       |NSString *const FIRSetAccountInfoUserAttributePhotoURL = @"PHOTO_URL";
   32|       |
   33|       |NSString *const FIRSetAccountInfoUserAttributePassword = @"PASSWORD";
   34|       |
   35|       |/** @var kCreateAuthURIEndpoint
   36|       |    @brief The "setAccountInfo" endpoint.
   37|       | */
   38|       |static NSString *const kSetAccountInfoEndpoint = @"setAccountInfo";
   39|       |
   40|       |/** @var kIDTokenKey
   41|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   42|       |        despite it's confusing (backwards compatiable) parameter name.
   43|       | */
   44|       |static NSString *const kIDTokenKey = @"idToken";
   45|       |
   46|       |/** @var kDisplayNameKey
   47|       |    @brief The key for the "displayName" value in the request.
   48|       | */
   49|       |static NSString *const kDisplayNameKey = @"displayName";
   50|       |
   51|       |/** @var kLocalIDKey
   52|       |    @brief The key for the "localID" value in the request.
   53|       | */
   54|       |static NSString *const kLocalIDKey = @"localId";
   55|       |
   56|       |/** @var kEmailKey
   57|       |    @brief The key for the "email" value in the request.
   58|       | */
   59|       |static NSString *const kEmailKey = @"email";
   60|       |
   61|       |/** @var kPasswordKey
   62|       |    @brief The key for the "password" value in the request.
   63|       | */
   64|       |static NSString *const kPasswordKey = @"password";
   65|       |
   66|       |/** @var kPhotoURLKey
   67|       |    @brief The key for the "photoURL" value in the request.
   68|       | */
   69|       |static NSString *const kPhotoURLKey = @"photoUrl";
   70|       |
   71|       |/** @var kProvidersKey
   72|       |    @brief The key for the "providers" value in the request.
   73|       | */
   74|       |static NSString *const kProvidersKey = @"provider";
   75|       |
   76|       |/** @var kOOBCodeKey
   77|       |    @brief The key for the "OOBCode" value in the request.
   78|       | */
   79|       |static NSString *const kOOBCodeKey = @"oobCode";
   80|       |
   81|       |/** @var kEmailVerifiedKey
   82|       |    @brief The key for the "emailVerified" value in the request.
   83|       | */
   84|       |static NSString *const kEmailVerifiedKey = @"emailVerified";
   85|       |
   86|       |/** @var kUpgradeToFederatedLoginKey
   87|       |    @brief The key for the "upgradeToFederatedLogin" value in the request.
   88|       | */
   89|       |static NSString *const kUpgradeToFederatedLoginKey = @"upgradeToFederatedLogin";
   90|       |
   91|       |/** @var kCaptchaChallengeKey
   92|       |    @brief The key for the "captchaChallenge" value in the request.
   93|       | */
   94|       |static NSString *const kCaptchaChallengeKey = @"captchaChallenge";
   95|       |
   96|       |/** @var kCaptchaResponseKey
   97|       |    @brief The key for the "captchaResponse" value in the request.
   98|       | */
   99|       |static NSString *const kCaptchaResponseKey = @"captchaResponse";
  100|       |
  101|       |/** @var kDeleteAttributesKey
  102|       |    @brief The key for the "deleteAttribute" value in the request.
  103|       | */
  104|       |static NSString *const kDeleteAttributesKey = @"deleteAttribute";
  105|       |
  106|       |/** @var kDeleteProvidersKey
  107|       |    @brief The key for the "deleteProvider" value in the request.
  108|       | */
  109|       |static NSString *const kDeleteProvidersKey = @"deleteProvider";
  110|       |
  111|       |/** @var kReturnSecureTokenKey
  112|       |    @brief The key for the "returnSecureToken" value in the request.
  113|       | */
  114|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
  115|       |
  116|       |@implementation FIRSetAccountInfoRequest
  117|       |
  118|       |- (nullable instancetype)initWithRequestConfiguration:
  119|      0|    (FIRAuthRequestConfiguration *)requestConfiguration {
  120|      0|  self = [super initWithEndpoint:kSetAccountInfoEndpoint requestConfiguration:requestConfiguration];
  121|      0|  if (self) {
  122|      0|    _returnSecureToken = YES;
  123|      0|  }
  124|      0|  return self;
  125|      0|}
  126|       |
  127|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  128|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
  129|      0|  if (_accessToken) {
  130|      0|    postBody[kIDTokenKey] = _accessToken;
  131|      0|  }
  132|      0|  if (_displayName) {
  133|      0|    postBody[kDisplayNameKey] = _displayName;
  134|      0|  }
  135|      0|  if (_localID) {
  136|      0|    postBody[kLocalIDKey] = _localID;
  137|      0|  }
  138|      0|  if (_email) {
  139|      0|    postBody[kEmailKey] = _email;
  140|      0|  }
  141|      0|  if (_password) {
  142|      0|    postBody[kPasswordKey] = _password;
  143|      0|  }
  144|      0|  if (_photoURL) {
  145|      0|    postBody[kPhotoURLKey] = _photoURL.absoluteString;
  146|      0|  }
  147|      0|  if (_providers) {
  148|      0|    postBody[kProvidersKey] = _providers;
  149|      0|  }
  150|      0|  if (_OOBCode) {
  151|      0|    postBody[kOOBCodeKey] = _OOBCode;
  152|      0|  }
  153|      0|  if (_emailVerified) {
  154|      0|    postBody[kEmailVerifiedKey] = @YES;
  155|      0|  }
  156|      0|  if (_upgradeToFederatedLogin) {
  157|      0|    postBody[kUpgradeToFederatedLoginKey] = @YES;
  158|      0|  }
  159|      0|  if (_captchaChallenge) {
  160|      0|    postBody[kCaptchaChallengeKey] = _captchaChallenge;
  161|      0|  }
  162|      0|  if (_captchaResponse) {
  163|      0|    postBody[kCaptchaResponseKey] = _captchaResponse;
  164|      0|  }
  165|      0|  if (_deleteAttributes) {
  166|      0|    postBody[kDeleteAttributesKey] = _deleteAttributes;
  167|      0|  }
  168|      0|  if (_deleteProviders) {
  169|      0|    postBody[kDeleteProvidersKey] = _deleteProviders;
  170|      0|  }
  171|      0|  if (_returnSecureToken) {
  172|      0|    postBody[kReturnSecureTokenKey] = @YES;
  173|      0|  }
  174|      0|  return postBody;
  175|      0|}
  176|       |
  177|       |@end
  178|       |
  179|       |NS_ASSUME_NONNULL_END
  180|       |

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSetAccountInfoResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSetAccountInfoResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRSetAccountInfoResponseProviderUserInfo
   22|       |
   23|      0|- (instancetype)initWithDictionary:(NSDictionary *)dictionary {
   24|      0|  self = [super init];
   25|      0|  if (self) {
   26|      0|    _providerID = [dictionary[@"providerId"] copy];
   27|      0|    _displayName = [dictionary[@"displayName"] copy];
   28|      0|    NSString *photoURL = dictionary[@"photoUrl"];
   29|      0|    if (photoURL) {
   30|      0|      _photoURL = [NSURL URLWithString:photoURL];
   31|      0|    }
   32|      0|  }
   33|      0|  return self;
   34|      0|}
   35|       |
   36|       |@end
   37|       |
   38|       |@implementation FIRSetAccountInfoResponse
   39|       |
   40|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   41|      0|                    error:(NSError *_Nullable *_Nullable)error {
   42|      0|  _email = [dictionary[@"email"] copy];
   43|      0|  _displayName = [dictionary[@"displayName"] copy];
   44|      0|  _IDToken = [dictionary[@"idToken"] copy];
   45|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   46|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   47|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   48|      0|  NSArray<NSDictionary *> *providerUserInfoData = dictionary[@"providerUserInfo"];
   49|      0|  if (providerUserInfoData) {
   50|      0|    NSMutableArray<FIRSetAccountInfoResponseProviderUserInfo *> *providerUserInfoArray =
   51|      0|        [NSMutableArray arrayWithCapacity:providerUserInfoData.count];
   52|      0|    for (NSDictionary *dictionary in providerUserInfoData) {
   53|      0|      [providerUserInfoArray addObject:
   54|      0|          [[FIRSetAccountInfoResponseProviderUserInfo alloc] initWithDictionary:dictionary]];
   55|      0|    }
   56|      0|    _providerUserInfo = [providerUserInfoArray copy];
   57|      0|  }
   58|      0|  return YES;
   59|      0|}
   60|       |
   61|       |@end
   62|       |
   63|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSignInWithGameCenterRequest.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignInWithGameCenterRequest.h"
   18|       |
   19|       |#import "NSData+FIRBase64.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kSignInWithGameCenterEndPoint
   24|       |    @brief The "SignInWithGameCenter" endpoint.
   25|       | */
   26|       |static NSString *const kSignInWithGameCenterEndPoint = @"signInWithGameCenter";
   27|       |
   28|       |@implementation FIRSignInWithGameCenterRequest
   29|       |
   30|       |- (nullable instancetype)initWithPlayerID:(NSString *)playerID
   31|       |                             publicKeyURL:(NSURL *)publicKeyURL
   32|       |                                signature:(NSData *)signature
   33|       |                                     salt:(NSData *)salt
   34|       |                                timestamp:(uint64_t)timestamp
   35|       |                              displayName:(NSString *)displayName
   36|      0|                     requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   37|      0|  self = [super initWithEndpoint:kSignInWithGameCenterEndPoint
   38|      0|            requestConfiguration:requestConfiguration];
   39|      0|  if (self) {
   40|      0|    _playerID = playerID;
   41|      0|    _publicKeyURL = [publicKeyURL copy];
   42|      0|    _signature = [signature copy];
   43|      0|    _salt = [salt copy];
   44|      0|    _timestamp = timestamp;
   45|      0|    _displayName = displayName;
   46|      0|  }
   47|      0|  return self;
   48|      0|}
   49|       |
   50|       |#pragma mark - FIRAuthRPCRequest
   51|       |
   52|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *__autoreleasing  _Nullable *)error {
   53|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   54|      0|  if (_playerID) {
   55|      0|    postBody[@"playerId"] = _playerID;
   56|      0|  }
   57|      0|  if (_publicKeyURL) {
   58|      0|    postBody[@"publicKeyUrl"] = _publicKeyURL.absoluteString;
   59|      0|  }
   60|      0|  if (_signature) {
   61|      0|    postBody[@"signature"] = [_signature fir_base64URLEncodedStringWithOptions:0];
   62|      0|  }
   63|      0|  if (_salt) {
   64|      0|    postBody[@"salt"] = [_salt fir_base64URLEncodedStringWithOptions:0];
   65|      0|  }
   66|      0|  if (_timestamp != 0) {
   67|      0|    postBody[@"timestamp"] = [NSNumber numberWithUnsignedLongLong:_timestamp];
   68|      0|  }
   69|      0|  if (_accessToken) {
   70|      0|    postBody[@"idToken"] = _accessToken;
   71|      0|  }
   72|      0|  if (_displayName) {
   73|      0|    postBody[@"displayName"] = _displayName;
   74|      0|  }
   75|      0|  return postBody;
   76|      0|}
   77|       |
   78|       |@end
   79|       |
   80|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSignInWithGameCenterResponse.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignInWithGameCenterResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRSignInWithGameCenterResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _IDToken = [dictionary[@"idToken"] copy];
   26|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   27|      0|  _localID = [dictionary[@"localId"] copy];
   28|      0|  _approximateExpirationDate = nil;
   29|      0|  if ([dictionary[@"expiresIn"] isKindOfClass:[NSString class]]) {
   30|      0|    _approximateExpirationDate = [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] integerValue]];
   31|      0|  }
   32|      0|  _playerID = [dictionary[@"playerId"] copy];
   33|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   34|      0|  _displayName = [dictionary[@"displayName"] copy];
   35|      0|  return YES;
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSignUpNewUserRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignUpNewUserRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kSignupNewUserEndpoint
   22|       |    @brief The "SingupNewUserEndpoint" endpoint.
   23|       | */
   24|       |static NSString *const kSignupNewUserEndpoint = @"signupNewUser";
   25|       |
   26|       |/** @var kEmailKey
   27|       |    @brief The key for the "email" value in the request.
   28|       | */
   29|       |static NSString *const kEmailKey = @"email";
   30|       |
   31|       |/** @var kPasswordKey
   32|       |    @brief The key for the "password" value in the request.
   33|       | */
   34|       |static NSString *const kPasswordKey = @"password";
   35|       |
   36|       |/** @var kDisplayNameKey
   37|       |    @brief The key for the "kDisplayName" value in the request.
   38|       | */
   39|       |static NSString *const kDisplayNameKey = @"displayName";
   40|       |
   41|       |/** @var kReturnSecureTokenKey
   42|       |    @brief The key for the "returnSecureToken" value in the request.
   43|       | */
   44|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   45|       |
   46|       |@implementation FIRSignUpNewUserRequest
   47|       |
   48|       |- (nullable instancetype)initWithEmail:(nullable NSString *)email
   49|       |                              password:(nullable NSString *)password
   50|       |                           displayName:(nullable NSString *)displayName
   51|      0|                  requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   52|      0|  self = [super initWithEndpoint:kSignupNewUserEndpoint requestConfiguration:requestConfiguration];
   53|      0|  if (self) {
   54|      0|    _email = [email copy];
   55|      0|    _password = [password copy];
   56|      0|    _displayName = [displayName copy];
   57|      0|    _returnSecureToken = YES;
   58|      0|  }
   59|      0|  return self;
   60|      0|}
   61|       |
   62|       |- (nullable instancetype)initWithRequestConfiguration:
   63|      0|    (FIRAuthRequestConfiguration *)requestConfiguration {
   64|      0|    self = [self initWithEmail:nil
   65|      0|                      password:nil
   66|      0|                   displayName:nil
   67|      0|          requestConfiguration:requestConfiguration];
   68|      0|    return self;
   69|      0|}
   70|       |
   71|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   72|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   73|      0|  if (_email) {
   74|      0|    postBody[kEmailKey] = _email;
   75|      0|  }
   76|      0|  if (_password) {
   77|      0|    postBody[kPasswordKey] = _password;
   78|      0|  }
   79|      0|  if (_displayName) {
   80|      0|    postBody[kDisplayNameKey] = _displayName;
   81|      0|  }
   82|      0|  if (_returnSecureToken) {
   83|      0|    postBody[kReturnSecureTokenKey] = @YES;
   84|      0|  }
   85|      0|  return postBody;
   86|      0|}
   87|       |
   88|       |@end
   89|       |
   90|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRSignUpNewUserResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignUpNewUserResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRSignUpNewUserResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _IDToken = [dictionary[@"idToken"] copy];
   26|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   27|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   28|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   29|      0|  return YES;
   30|      0|}
   31|       |
   32|       |@end
   33|       |
   34|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyAssertionRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyAssertionRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kVerifyAssertionEndpoint
   22|       |    @brief The "verifyAssertion" endpoint.
   23|       | */
   24|       |static NSString *const kVerifyAssertionEndpoint = @"verifyAssertion";
   25|       |
   26|       |/** @var kProviderIDKey
   27|       |    @brief The key for the "providerId" value in the request.
   28|       | */
   29|       |static NSString *const kProviderIDKey = @"providerId";
   30|       |
   31|       |/** @var kProviderIDTokenKey
   32|       |    @brief The key for the "id_token" value in the request.
   33|       | */
   34|       |static NSString *const kProviderIDTokenKey = @"id_token";
   35|       |
   36|       |/** @var kProviderNonceKey
   37|       |    @brief The key for the "nonce" value in the request.
   38|       | */
   39|       |static NSString *const kProviderNonceKey = @"nonce";
   40|       |
   41|       |/** @var kProviderAccessTokenKey
   42|       |    @brief The key for the "access_token" value in the request.
   43|       | */
   44|       |static NSString *const kProviderAccessTokenKey = @"access_token";
   45|       |
   46|       |/** @var kProviderOAuthTokenSecretKey
   47|       |    @brief The key for the "oauth_token_secret" value in the request.
   48|       | */
   49|       |static NSString *const kProviderOAuthTokenSecretKey = @"oauth_token_secret";
   50|       |
   51|       |/** @var kIdentifierKey
   52|       |    @brief The key for the "identifier" value in the request.
   53|       | */
   54|       |static NSString *const kIdentifierKey = @"identifier";
   55|       |
   56|       |/** @var kRequestURIKey
   57|       |    @brief The key for the "requestUri" value in the request.
   58|       | */
   59|       |static NSString *const kRequestURIKey = @"requestUri";
   60|       |
   61|       |/** @var kPostBodyKey
   62|       |    @brief The key for the "postBody" value in the request.
   63|       | */
   64|       |static NSString *const kPostBodyKey = @"postBody";
   65|       |
   66|       |/** @var kPendingTokenKey
   67|       |    @brief The key for the "pendingToken" value in the request.
   68|       | */
   69|       |static NSString *const kPendingTokenKey = @"pendingToken";
   70|       |
   71|       |/** @var kAutoCreateKey
   72|       |    @brief The key for the "autoCreate" value in the request.
   73|       | */
   74|       |static NSString *const kAutoCreateKey = @"autoCreate";
   75|       |
   76|       |/** @var kIDTokenKey
   77|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   78|       |        despite it's confusing (backwards compatiable) parameter name.
   79|       | */
   80|       |static NSString *const kIDTokenKey = @"idToken";
   81|       |
   82|       |/** @var kReturnSecureTokenKey
   83|       |    @brief The key for the "returnSecureToken" value in the request.
   84|       | */
   85|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   86|       |
   87|       |/** @var kReturnIDPCredentialKey
   88|       |    @brief The key for the "returnIdpCredential" value in the request.
   89|       | */
   90|       |static NSString *const kReturnIDPCredentialKey = @"returnIdpCredential";
   91|       |
   92|       |/** @var kSessionIDKey
   93|       |    @brief The key for the "sessionID" value in the request.
   94|       | */
   95|       |static NSString *const kSessionIDKey = @"sessionId";
   96|       |
   97|       |@implementation FIRVerifyAssertionRequest
   98|       |
   99|       |- (nullable instancetype)initWithProviderID:(NSString *)providerID
  100|      0|                       requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  101|      0|  self = [super initWithEndpoint:kVerifyAssertionEndpoint
  102|      0|            requestConfiguration:requestConfiguration];
  103|      0|  if (self) {
  104|      0|    _providerID = providerID;
  105|      0|    _returnSecureToken = YES;
  106|      0|    _autoCreate = YES;
  107|      0|    _returnIDPCredential = YES;
  108|      0|  }
  109|      0|  return self;
  110|      0|}
  111|       |
  112|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  113|      0|  NSURLComponents *components = [[NSURLComponents alloc] init];
  114|      0|  NSMutableArray<NSURLQueryItem *> *queryItems = [@[[NSURLQueryItem queryItemWithName:kProviderIDKey
  115|      0|                                                                                value:_providerID]]
  116|      0|                                                  mutableCopy];
  117|      0|
  118|      0|  if (_providerIDToken) {
  119|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderIDTokenKey
  120|      0|                                                      value:_providerIDToken]];
  121|      0|  }
  122|      0|
  123|      0|  if (_providerRawNonce) {
  124|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderNonceKey
  125|      0|                                                      value:_providerRawNonce]];
  126|      0|  }
  127|      0|
  128|      0|  if (_providerAccessToken) {
  129|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderAccessTokenKey
  130|      0|                                                      value:_providerAccessToken]];
  131|      0|  }
  132|      0|
  133|      0|  if (!_providerIDToken && !_providerAccessToken && !_pendingToken && !_requestURI) {
  134|      0|    [NSException raise:NSInvalidArgumentException
  135|      0|        format:@"One of IDToken, accessToken, pendingToken, or requestURI must be supplied."];
  136|      0|  }
  137|      0|
  138|      0|  if (_providerOAuthTokenSecret) {
  139|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderOAuthTokenSecretKey
  140|      0|                                                      value:_providerOAuthTokenSecret]];
  141|      0|  }
  142|      0|
  143|      0|  if (_inputEmail) {
  144|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kIdentifierKey
  145|      0|                                                      value:_inputEmail]];
  146|      0|  }
  147|      0|  [components setQueryItems:queryItems];
  148|      0|  NSMutableDictionary *body = [@{
  149|      0|      kRequestURIKey : _requestURI ?: @"http://localhost", // Unused by server, but required
  150|      0|      kPostBodyKey : [components query]
  151|      0|      } mutableCopy];
  152|      0|
  153|      0|  if (_pendingToken) {
  154|      0|    body[kPendingTokenKey] = _pendingToken;
  155|      0|  }
  156|      0|  if (_accessToken) {
  157|      0|    body[kIDTokenKey] = _accessToken;
  158|      0|  }
  159|      0|  if (_returnSecureToken) {
  160|      0|    body[kReturnSecureTokenKey] = @YES;
  161|      0|  }
  162|      0|
  163|      0|  if (_returnIDPCredential) {
  164|      0|    body[kReturnIDPCredentialKey] = @YES;
  165|      0|  }
  166|      0|
  167|      0|  if (_sessionID) {
  168|      0|    body[kSessionIDKey] = _sessionID;
  169|      0|  }
  170|      0|
  171|      0|  body[kAutoCreateKey] = @(_autoCreate);
  172|      0|
  173|      0|  return body;
  174|      0|}
  175|       |
  176|       |@end
  177|       |
  178|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyAssertionResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyAssertionResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyAssertionResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _federatedID = [dictionary[@"federatedId"] copy];
   26|      0|  _providerID = [dictionary[@"providerId"] copy];
   27|      0|  _localID = [dictionary[@"localId"] copy];
   28|      0|  _emailRecycled = [dictionary[@"emailRecycled"] boolValue];
   29|      0|  _emailVerified = [dictionary[@"emailVerified"] boolValue];
   30|      0|  _email = [dictionary[@"email"] copy];
   31|      0|  _inputEmail = [dictionary[@"inputEmail"] copy];
   32|      0|  _originalEmail = [dictionary[@"originalEmail"] copy];
   33|      0|  _oauthRequestToken = [dictionary[@"oauthRequestToken"] copy];
   34|      0|  _oauthScope = [dictionary[@"oauthScope"] copy];
   35|      0|  _firstName = [dictionary[@"firstName"] copy];
   36|      0|  _lastName = [dictionary[@"lastName"] copy];
   37|      0|  _fullName = [dictionary[@"fullName"] copy];
   38|      0|  _nickName = [dictionary[@"nickName"] copy];
   39|      0|  _displayName = [dictionary[@"displayName"] copy];
   40|      0|  _IDToken = [dictionary[@"idToken"] copy];
   41|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   42|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   43|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   44|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   45|      0|  id rawUserInfo = dictionary[@"rawUserInfo"];
   46|      0|  if ([rawUserInfo isKindOfClass:[NSString class]]) {
   47|      0|    NSData *data = [rawUserInfo dataUsingEncoding:NSUTF8StringEncoding];
   48|      0|    rawUserInfo = [NSJSONSerialization JSONObjectWithData:data
   49|      0|                                                  options:NSJSONReadingMutableLeaves
   50|      0|                                                    error:nil];
   51|      0|  }
   52|      0|  if ([rawUserInfo isKindOfClass:[NSDictionary class]]) {
   53|      0|    _profile = [[NSDictionary alloc] initWithDictionary:rawUserInfo
   54|      0|                                              copyItems:YES];
   55|      0|  }
   56|      0|  _username = [dictionary[@"username"] copy];
   57|      0|  _action = [dictionary[@"action"] copy];
   58|      0|  _language = [dictionary[@"language"] copy];
   59|      0|  _timeZone = [dictionary[@"timeZone"] copy];
   60|      0|  _photoURL = dictionary[@"photoUrl"] ? [NSURL URLWithString:dictionary[@"photoUrl"]] : nil;
   61|      0|  _dateOfBirth = [dictionary[@"dateOfBirth"] copy];
   62|      0|  _context = [dictionary[@"context"] copy];
   63|      0|  _needConfirmation = [dictionary[@"needConfirmation"] boolValue];
   64|      0|  id verifiedProvider = dictionary[@"verifiedProvider"];
   65|      0|  if ([verifiedProvider isKindOfClass:[NSString class]]) {
   66|      0|    NSData *data = [verifiedProvider dataUsingEncoding:NSUTF8StringEncoding];
   67|      0|    verifiedProvider = [NSJSONSerialization JSONObjectWithData:data
   68|      0|                                                       options:NSJSONReadingMutableLeaves
   69|      0|                                                         error:nil];
   70|      0|  }
   71|      0|  if ([verifiedProvider isKindOfClass:[NSArray class]]) {
   72|      0|    _verifiedProvider = [[NSArray alloc] initWithArray:verifiedProvider
   73|      0|                                             copyItems:YES];
   74|      0|  }
   75|      0|  _oauthIDToken = [dictionary[@"oauthIdToken"] copy];
   76|      0|  _oauthExpirationDate =  [dictionary[@"oauthExpireIn"] isKindOfClass:[NSString class]] ?
   77|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"oauthExpireIn"] doubleValue]] : nil;
   78|      0|  _oauthAccessToken = [dictionary[@"oauthAccessToken"] copy];
   79|      0|  _oauthSecretToken = [dictionary[@"oauthTokenSecret"] copy];
   80|      0|  _pendingToken = [dictionary[@"pendingToken"] copy];
   81|      0|  return YES;
   82|      0|}
   83|       |
   84|       |@end
   85|       |
   86|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyClientRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyClientRequest.h"
   18|       |
   19|       |
   20|       |NS_ASSUME_NONNULL_BEGIN
   21|       |
   22|       |/** @var kVerifyClientEndpoint
   23|       |    @brief The endpoint for the verifyClient request.
   24|       | */
   25|       |static NSString *const kVerifyClientEndpoint = @"verifyClient";
   26|       |
   27|       |/** @var kAppTokenKey
   28|       |    @brief The key for the appToken request paramenter.
   29|       | */
   30|       |static NSString *const kAPPTokenKey = @"appToken";
   31|       |
   32|       |/** @var kIsSandboxKey
   33|       |    @brief The key for the isSandbox request parameter
   34|       | */
   35|       |static NSString *const kIsSandboxKey = @"isSandbox";
   36|       |
   37|       |@implementation FIRVerifyClientRequest
   38|       |
   39|       |- (nullable instancetype)initWithAppToken:(nullable NSString *)appToken
   40|       |                                isSandbox:(BOOL)isSandbox
   41|      0|                     requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   42|      0|  self = [super initWithEndpoint:kVerifyClientEndpoint requestConfiguration:requestConfiguration];
   43|      0|  if (self) {
   44|      0|    _appToken = appToken;
   45|      0|    _isSandbox = isSandbox;
   46|      0|  }
   47|      0|  return self;
   48|      0|}
   49|       |
   50|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *__autoreleasing _Nullable *)error {
   51|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   52|      0|  if (_appToken) {
   53|      0|    postBody[kAPPTokenKey] = _appToken;
   54|      0|  }
   55|      0|  if (_isSandbox) {
   56|      0|    postBody[kIsSandboxKey] = @YES;
   57|      0|  }
   58|      0|  return postBody;
   59|      0|}
   60|       |
   61|       |@end
   62|       |
   63|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyClientResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyClientResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyClientResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _receipt = dictionary[@"receipt"];
   26|      0|  _suggestedTimeOutDate = [dictionary[@"suggestedTimeout"] isKindOfClass:[NSString class]] ?
   27|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"suggestedTimeout"] doubleValue]] : nil;
   28|      0|  return YES;
   29|      0|}
   30|       |
   31|       |@end
   32|       |
   33|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyCustomTokenRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyCustomTokenRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kVerifyCustomTokenEndpoint
   22|       |    @brief The "verifyPassword" endpoint.
   23|       | */
   24|       |static NSString *const kVerifyCustomTokenEndpoint = @"verifyCustomToken";
   25|       |
   26|       |/** @var kTokenKey
   27|       |    @brief The key for the "token" value in the request.
   28|       | */
   29|       |static NSString *const kTokenKey = @"token";
   30|       |
   31|       |/** @var kReturnSecureTokenKey
   32|       |    @brief The key for the "returnSecureToken" value in the request.
   33|       | */
   34|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   35|       |
   36|       |@implementation FIRVerifyCustomTokenRequest
   37|       |
   38|       |- (nullable instancetype)initWithToken:(NSString *)token
   39|      0|                  requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   40|      0|  self = [super initWithEndpoint:kVerifyCustomTokenEndpoint
   41|      0|            requestConfiguration:requestConfiguration];
   42|      0|  if (self) {
   43|      0|    _token = [token copy];
   44|      0|    _returnSecureToken = YES;
   45|      0|  }
   46|      0|  return self;
   47|      0|}
   48|       |
   49|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   50|      0|  NSMutableDictionary *body = [@{
   51|      0|    kTokenKey : _token
   52|      0|  } mutableCopy];
   53|      0|  if (_returnSecureToken) {
   54|      0|    body[kReturnSecureTokenKey] = @YES;
   55|      0|  }
   56|      0|  return body;
   57|      0|}
   58|       |
   59|       |@end
   60|       |
   61|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyCustomTokenResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyCustomTokenResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyCustomTokenResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _IDToken = [dictionary[@"idToken"] copy];
   26|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   27|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   28|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   29|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   30|      0|  return YES;
   31|      0|}
   32|       |
   33|       |@end
   34|       |
   35|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyPasswordRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPasswordRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kVerifyPasswordEndpoint
   22|       |    @brief The "verifyPassword" endpoint.
   23|       | */
   24|       |static NSString *const kVerifyPasswordEndpoint = @"verifyPassword";
   25|       |
   26|       |/** @var kEmailKey
   27|       |    @brief The key for the "email" value in the request.
   28|       | */
   29|       |static NSString *const kEmailKey = @"email";
   30|       |
   31|       |/** @var kPasswordKey
   32|       |    @brief The key for the "password" value in the request.
   33|       | */
   34|       |static NSString *const kPasswordKey = @"password";
   35|       |
   36|       |/** @var kPendingIDTokenKey
   37|       |    @brief The key for the "pendingIdToken" value in the request.
   38|       | */
   39|       |static NSString *const kPendingIDTokenKey = @"pendingIdToken";
   40|       |
   41|       |/** @var kCaptchaChallengeKey
   42|       |    @brief The key for the "captchaChallenge" value in the request.
   43|       | */
   44|       |static NSString *const kCaptchaChallengeKey = @"captchaChallenge";
   45|       |
   46|       |/** @var kCaptchaResponseKey
   47|       |    @brief The key for the "captchaResponse" value in the request.
   48|       | */
   49|       |static NSString *const kCaptchaResponseKey = @"captchaResponse";
   50|       |
   51|       |/** @var kReturnSecureTokenKey
   52|       |    @brief The key for the "returnSecureToken" value in the request.
   53|       | */
   54|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   55|       |
   56|       |@implementation FIRVerifyPasswordRequest
   57|       |
   58|       |- (nullable instancetype)initWithEmail:(NSString *)email
   59|       |                              password:(NSString *)password
   60|      0|                  requestConfiguration:(nonnull FIRAuthRequestConfiguration *)requestConfiguration {
   61|      0|  self = [super initWithEndpoint:kVerifyPasswordEndpoint
   62|      0|            requestConfiguration:requestConfiguration];
   63|      0|  if (self) {
   64|      0|    _email = [email copy];
   65|      0|    _password = [password copy];
   66|      0|    _returnSecureToken = YES;
   67|      0|  }
   68|      0|  return self;
   69|      0|}
   70|       |
   71|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   72|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   73|      0|  if (_email) {
   74|      0|    postBody[kEmailKey] = _email;
   75|      0|  }
   76|      0|  if (_password) {
   77|      0|    postBody[kPasswordKey] = _password;
   78|      0|  }
   79|      0|  if (_pendingIDToken) {
   80|      0|    postBody[kPendingIDTokenKey] = _pendingIDToken;
   81|      0|  }
   82|      0|  if (_captchaChallenge) {
   83|      0|    postBody[kCaptchaChallengeKey] = _captchaChallenge;
   84|      0|  }
   85|      0|  if (_captchaResponse) {
   86|      0|    postBody[kCaptchaResponseKey] = _captchaResponse;
   87|      0|  }
   88|      0|  if (_returnSecureToken) {
   89|      0|    postBody[kReturnSecureTokenKey] = @YES;
   90|      0|  }
   91|      0|  return postBody;
   92|      0|}
   93|       |
   94|       |@end
   95|       |
   96|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyPasswordResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPasswordResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyPasswordResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _localID = [dictionary[@"localId"] copy];
   26|      0|  _email = [dictionary[@"email"] copy];
   27|      0|  _displayName = [dictionary[@"displayName"] copy];
   28|      0|  _IDToken = [dictionary[@"idToken"] copy];
   29|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   30|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   31|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   32|      0|  _photoURL = dictionary[@"photoUrl"] ? [NSURL URLWithString:dictionary[@"photoUrl"]] : nil;
   33|      0|  return YES;
   34|      0|}
   35|       |
   36|       |@end
   37|       |
   38|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyPhoneNumberRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPhoneNumberRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kVerifyPhoneNumberEndPoint
   22|       |    @brief The "verifyPhoneNumber" endpoint.
   23|       | */
   24|       |static NSString *const kVerifyPhoneNumberEndPoint = @"verifyPhoneNumber";
   25|       |
   26|       |/** @var kVerificationIDKey
   27|       |    @brief The key for the verification ID parameter in the request.
   28|       | */
   29|       |static NSString *const kVerificationIDKey = @"sessionInfo";
   30|       |
   31|       |/** @var kVerificationCodeKey
   32|       |    @brief The key for the verification code parameter in the request.
   33|       | */
   34|       |static NSString *const kVerificationCodeKey = @"code";
   35|       |
   36|       |/** @var kIDTokenKey
   37|       |    @brief The key for the "ID Token" value in the request.
   38|       | */
   39|       |static NSString *const kIDTokenKey = @"idToken";
   40|       |
   41|       |/** @var kTemporaryProofKey
   42|       |    @brief The key for the temporary proof value in the request.
   43|       | */
   44|       |static NSString *const kTemporaryProofKey = @"temporaryProof";
   45|       |
   46|       |/** @var kPhoneNumberKey
   47|       |    @brief The key for the phone number value in the request.
   48|       | */
   49|       |static NSString *const kPhoneNumberKey = @"phoneNumber";
   50|       |
   51|       |/** @var kOperationKey
   52|       |    @brief The key for the operation value in the request.
   53|       | */
   54|       |static NSString *const kOperationKey = @"operation";
   55|       |
   56|       |@implementation FIRVerifyPhoneNumberRequest
   57|       |
   58|       |- (nullable instancetype)initWithTemporaryProof:(NSString *)temporaryProof
   59|       |                                    phoneNumber:(NSString *)phoneNumber
   60|       |                                      operation:(FIRAuthOperationType)operation
   61|       |                           requestConfiguration:
   62|      0|                              (FIRAuthRequestConfiguration *)requestConfiguration {
   63|      0|  self = [super initWithEndpoint:kVerifyPhoneNumberEndPoint
   64|      0|            requestConfiguration:requestConfiguration];
   65|      0|  if (self) {
   66|      0|    _temporaryProof = [temporaryProof copy];
   67|      0|    _phoneNumber = [phoneNumber copy];
   68|      0|    _operation = operation;
   69|      0|  }
   70|      0|  return self;
   71|      0|}
   72|       |
   73|       |- (nullable instancetype)initWithVerificationID:(NSString *)verificationID
   74|       |                               verificationCode:(NSString *)verificationCode
   75|       |                                      operation:(FIRAuthOperationType)operation
   76|       |                           requestConfiguration:
   77|      0|                              (FIRAuthRequestConfiguration *)requestConfiguration {
   78|      0|  self = [super initWithEndpoint:kVerifyPhoneNumberEndPoint
   79|      0|            requestConfiguration:requestConfiguration];
   80|      0|  if (self) {
   81|      0|    _verificationID = verificationID;
   82|      0|    _verificationCode = verificationCode;
   83|      0|    _operation = operation;
   84|      0|  }
   85|      0|  return self;
   86|      0|}
   87|       |
   88|       |/** @fn FIRAuthOperationString
   89|       |    @brief Returns a string object corresponding to the provided FIRAuthOperationType value.
   90|       |    @param operationType The value of the FIRAuthOperationType enum which will be translated to its
   91|       |        corresponding string value.
   92|       |    @return The string value corresponding to the FIRAuthOperationType argument.
   93|       | */
   94|      0|NSString *const FIRAuthOperationString(FIRAuthOperationType operationType) {
   95|      0|  switch(operationType){
   96|      0|    case FIRAuthOperationTypeUnspecified:
   97|      0|      return @"VERIFY_OP_UNSPECIFIED";
   98|      0|    case FIRAuthOperationTypeSignUpOrSignIn:
   99|      0|      return @"SIGN_UP_OR_IN";
  100|      0|    case FIRAuthOperationTypeReauth:
  101|      0|      return @"REAUTH";
  102|      0|    case FIRAuthOperationTypeLink:
  103|      0|      return @"LINK";
  104|      0|    case FIRAuthOperationTypeUpdate:
  105|      0|      return @"UPDATE";
  106|      0|  }
  107|      0|}
  108|       |
  109|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *__autoreleasing  _Nullable *)error {
  110|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
  111|      0|  if (_verificationID) {
  112|      0|    postBody[kVerificationIDKey] = _verificationID;
  113|      0|  }
  114|      0|  if (_verificationCode) {
  115|      0|    postBody[kVerificationCodeKey] = _verificationCode;
  116|      0|  }
  117|      0|  if (_accessToken) {
  118|      0|    postBody[kIDTokenKey] = _accessToken;
  119|      0|  }
  120|      0|  if (_temporaryProof) {
  121|      0|    postBody[kTemporaryProofKey] = _temporaryProof;
  122|      0|  }
  123|      0|  if (_phoneNumber) {
  124|      0|    postBody[kPhoneNumberKey] = _phoneNumber;
  125|      0|  }
  126|      0|  NSString *operation = FIRAuthOperationString(_operation);
  127|      0|  postBody[kOperationKey] = operation;
  128|      0|  return postBody;
  129|      0|}
  130|       |
  131|       |@end
  132|       |
  133|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Backend/RPC/FIRVerifyPhoneNumberResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPhoneNumberResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyPhoneNumberResponse
   22|       |
   23|      0|- (nullable NSString *)expectedKind {
   24|      0|  return nil;
   25|      0|}
   26|       |
   27|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   28|      0|                    error:(NSError *_Nullable *_Nullable)error {
   29|      0|  _IDToken = [dictionary[@"idToken"] copy];
   30|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   31|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   32|      0|  _localID = [dictionary[@"localId"] copy];
   33|      0|  _phoneNumber = [dictionary[@"phoneNumber"] copy];
   34|      0|  _temporaryProof = [dictionary[@"temporaryProof"] copy];
   35|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   36|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   37|      0|  return YES;
   38|      0|}
   39|       |
   40|       |@end
   41|       |
   42|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Storage/FIRAuthKeychainServices.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthKeychainServices.h"
   18|       |
   19|       |#import <Security/Security.h>
   20|       |
   21|       |#import "FIRAuthErrorUtils.h"
   22|       |#import "FIRAuthUserDefaults.h"
   23|       |
   24|       |/** @var kAccountPrefix
   25|       |    @brief The prefix string for keychain item account attribute before the key.
   26|       |    @remarks A number "1" is encoded in the prefix in case we need to upgrade the scheme in future.
   27|       | */
   28|       |static NSString *const kAccountPrefix = @"firebase_auth_1_";
   29|       |
   30|       |NS_ASSUME_NONNULL_BEGIN
   31|       |
   32|       |@implementation FIRAuthKeychainServices {
   33|       |  /** @var _service
   34|       |      @brief The name of the keychain service.
   35|       |   */
   36|       |  NSString *_service;
   37|       |
   38|       |  /** @var _legacyItemDeletedForKey
   39|       |      @brief Indicates whether or not this class knows that the legacy item for a particular key has
   40|       |          been deleted.
   41|       |      @remarks This dictionary is to avoid unecessary keychain operations against legacy items.
   42|       |   */
   43|       |  NSMutableDictionary *_legacyEntryDeletedForKey;
   44|       |}
   45|       |
   46|      2|- (id<FIRAuthStorage>)initWithService:(NSString *)service {
   47|      2|
   48|      2|  self = [super init];
   49|      2|  if (self) {
   50|      2|    _service = [service copy];
   51|      2|    _legacyEntryDeletedForKey = [[NSMutableDictionary alloc] init];
   52|      2|  }
   53|      2|  return self;
   54|      2|}
   55|       |
   56|      2|- (nullable NSData *)dataForKey:(NSString *)key error:(NSError **_Nullable)error {
   57|      2|  if (!key.length) {
   58|      0|    [NSException raise:NSInvalidArgumentException
   59|      0|                format:@"%@", @"The key cannot be nil or empty."];
   60|      0|    return nil;
   61|      0|  }
   62|      2|  NSData *data = [self itemWithQuery:[self genericPasswordQueryWithKey:key] error:error];
   63|      2|  if (error && *error) {
   64|      0|    return nil;
   65|      0|  }
   66|      2|  if (data) {
   67|      0|    return data;
   68|      0|  }
   69|      2|  // Check for legacy form.
   70|      2|  if (_legacyEntryDeletedForKey[key]) {
   71|      0|    return nil;
   72|      0|  }
   73|      2|  data = [self itemWithQuery:[self legacyGenericPasswordQueryWithKey:key] error:error];
   74|      2|  if (error && *error) {
   75|      0|    return nil;
   76|      0|  }
   77|      2|  if (!data) {
   78|      2|    // Mark legacy data as non-existing so we don't have to query it again.
   79|      2|    _legacyEntryDeletedForKey[key] = @YES;
   80|      2|    return nil;
   81|      2|  }
   82|      0|  // Move the data to current form.
   83|      0|  if (![self setData:data forKey:key error:error]) {
   84|      0|    return nil;
   85|      0|  }
   86|      0|  [self deleteLegacyItemWithKey:key];
   87|      0|  return data;
   88|      0|}
   89|       |
   90|      0|- (BOOL)setData:(NSData *)data forKey:(NSString *)key error:(NSError **_Nullable)error {
   91|      0|  if (!key.length) {
   92|      0|    [NSException raise:NSInvalidArgumentException
   93|      0|                format:@"%@", @"The key cannot be nil or empty."];
   94|      0|    return NO;
   95|      0|  }
   96|      0|  NSDictionary *attributes = @{
   97|      0|    (__bridge id)kSecValueData : data,
   98|      0|    (__bridge id)kSecAttrAccessible : (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly,
   99|      0|  };
  100|      0|  return [self setItemWithQuery:[self genericPasswordQueryWithKey:key]
  101|      0|                     attributes:attributes
  102|      0|                          error:error];
  103|      0|}
  104|       |
  105|      0|- (BOOL)removeDataForKey:(NSString *)key error:(NSError **_Nullable)error {
  106|      0|  if (!key.length) {
  107|      0|    [NSException raise:NSInvalidArgumentException
  108|      0|                format:@"%@", @"The key cannot be nil or empty."];
  109|      0|    return NO;
  110|      0|  }
  111|      0|  if (![self deleteItemWithQuery:[self genericPasswordQueryWithKey:key] error:error]) {
  112|      0|    return NO;
  113|      0|  }
  114|      0|  // Legacy form item, if exists, also needs to be removed, otherwise it will be exposed when
  115|      0|  // current form item is removed, leading to incorrect semantics.
  116|      0|  [self deleteLegacyItemWithKey:key];
  117|      0|  return YES;
  118|      0|}
  119|       |
  120|       |#pragma mark - Private methods for non-sharing keychain operations
  121|       |
  122|      4|- (nullable NSData *)itemWithQuery:(NSDictionary *)query error:(NSError **_Nullable)error {
  123|      4|  NSMutableDictionary *returningQuery = [query mutableCopy];
  124|      4|  returningQuery[(__bridge id)kSecReturnData] = @YES;
  125|      4|  returningQuery[(__bridge id)kSecReturnAttributes] = @YES;
  126|      4|  // Using a match limit of 2 means that we can check whether there is more than one item.
  127|      4|  // If we used a match limit of 1 we would never find out.
  128|      4|  returningQuery[(__bridge id)kSecMatchLimit] = @2;
  129|      4|
  130|      4|  CFArrayRef result = NULL;
  131|      4|  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)returningQuery,
  132|      4|                                        (CFTypeRef *)&result);
  133|      4|
  134|      4|  if (status == noErr && result != NULL) {
  135|      0|    NSArray *items = (__bridge_transfer NSArray *)result;
  136|      0|    if (items.count != 1) {
  137|      0|      if (error) {
  138|      0|        *error = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemCopyMatching"
  139|      0|                                                       status:status];
  140|      0|      }
  141|      0|      return nil;
  142|      0|    }
  143|      0|
  144|      0|    if (error) {
  145|      0|      *error = nil;
  146|      0|    }
  147|      0|    NSDictionary *item = items[0];
  148|      0|    return item[(__bridge id)kSecValueData];
  149|      0|  }
  150|      4|
  151|      4|  if (status == errSecItemNotFound) {
  152|      4|    if (error) {
  153|      4|      *error = nil;
  154|      4|    }
  155|      4|  } else {
  156|      0|    if (error) {
  157|      0|      *error = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemCopyMatching" status:status];
  158|      0|    }
  159|      0|  }
  160|      4|  return nil;
  161|      4|}
  162|       |
  163|       |- (BOOL)setItemWithQuery:(NSDictionary *)query
  164|       |              attributes:(NSDictionary *)attributes
  165|      0|                   error:(NSError **_Nullable)error {
  166|      0|  NSMutableDictionary *combined = [attributes mutableCopy];
  167|      0|  [combined addEntriesFromDictionary:query];
  168|      0|  BOOL hasItem = NO;
  169|      0|  OSStatus status = SecItemAdd((__bridge CFDictionaryRef)combined, NULL);
  170|      0|
  171|      0|  if (status == errSecDuplicateItem) {
  172|      0|    hasItem = YES;
  173|      0|    status = SecItemUpdate((__bridge CFDictionaryRef)query, (__bridge CFDictionaryRef)attributes);
  174|      0|  }
  175|      0|
  176|      0|  if (status == noErr) {
  177|      0|    return YES;
  178|      0|  }
  179|      0|  if (error) {
  180|      0|    NSString *function = hasItem ? @"SecItemUpdate" : @"SecItemAdd";
  181|      0|    *error = [FIRAuthErrorUtils keychainErrorWithFunction:function status:status];
  182|      0|  }
  183|      0|  return NO;
  184|      0|}
  185|       |
  186|      0|- (BOOL)deleteItemWithQuery:(NSDictionary *)query error:(NSError **_Nullable)error {
  187|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)query);
  188|      0|  if (status == noErr || status == errSecItemNotFound) {
  189|      0|    return YES;
  190|      0|  }
  191|      0|  if (error) {
  192|      0|    *error = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemDelete" status:status];
  193|      0|  }
  194|      0|  return NO;
  195|      0|}
  196|       |
  197|       |/** @fn deleteLegacyItemsWithKey:
  198|       |    @brief Deletes legacy item from the keychain if it is not already known to be deleted.
  199|       |    @param key The key for the item.
  200|       | */
  201|      0|- (void)deleteLegacyItemWithKey:(NSString *)key {
  202|      0|  if (_legacyEntryDeletedForKey[key]) {
  203|      0|    return;
  204|      0|  }
  205|      0|  NSDictionary *query = [self legacyGenericPasswordQueryWithKey:key];
  206|      0|  SecItemDelete((__bridge CFDictionaryRef)query);
  207|      0|  _legacyEntryDeletedForKey[key] = @YES;
  208|      0|}
  209|       |
  210|       |/** @fn genericPasswordQueryWithKey:
  211|       |    @brief Returns a keychain query of generic password to be used to manipulate key'ed value.
  212|       |    @param key The key for the value being manipulated, used as the account field in the query.
  213|       | */
  214|      2|- (NSDictionary *)genericPasswordQueryWithKey:(NSString *)key {
  215|      2|  return @{
  216|      2|    (__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword,
  217|      2|    (__bridge id)kSecAttrAccount : [kAccountPrefix stringByAppendingString:key],
  218|      2|    (__bridge id)kSecAttrService : _service,
  219|      2|  };
  220|      2|}
  221|       |
  222|       |/** @fn legacyGenericPasswordQueryWithKey:
  223|       |    @brief Returns a keychain query of generic password without service field, which is used by
  224|       |        previous version of this class.
  225|       |    @param key The key for the value being manipulated, used as the account field in the query.
  226|       | */
  227|      2|- (NSDictionary *)legacyGenericPasswordQueryWithKey:(NSString *)key {
  228|      2|  return @{
  229|      2|    (__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword,
  230|      2|    (__bridge id)kSecAttrAccount : key,
  231|      2|  };
  232|      2|}
  233|       |
  234|       |#pragma mark - Private methods for shared keychain operations
  235|       |
  236|       |- (nullable NSData *)getItemWithQuery:(NSDictionary *)query
  237|      0|                                error:(NSError *_Nullable *_Nullable)outError {
  238|      0|  NSMutableDictionary *mutableQuery = [query mutableCopy];
  239|      0|
  240|      0|  mutableQuery[(__bridge id)kSecReturnData] = @YES;
  241|      0|  mutableQuery[(__bridge id)kSecReturnAttributes] = @YES;
  242|      0|  mutableQuery[(__bridge id)kSecMatchLimit] = @2;
  243|      0|
  244|      0|  CFArrayRef result = NULL;
  245|      0|  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)mutableQuery,
  246|      0|                                        (CFTypeRef *)&result);
  247|      0|
  248|      0|  if (status == noErr && result != NULL) {
  249|      0|    NSArray *items = (__bridge_transfer NSArray *)result;
  250|      0|    if (items.count != 1) {
  251|      0|      if (outError) {
  252|      0|        *outError = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemCopyMatching"
  253|      0|                                                          status:status];
  254|      0|      }
  255|      0|      return nil;
  256|      0|    }
  257|      0|
  258|      0|    if (outError) {
  259|      0|      *outError = nil;
  260|      0|    }
  261|      0|    NSDictionary *item = items[0];
  262|      0|    return item[(__bridge id)kSecValueData];
  263|      0|  }
  264|      0|
  265|      0|  if (status == errSecItemNotFound) {
  266|      0|    if (outError) {
  267|      0|      *outError = nil;
  268|      0|    }
  269|      0|  } else {
  270|      0|    if (outError) {
  271|      0|      *outError = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemCopyMatching" status:status];
  272|      0|    }
  273|      0|  }
  274|      0|  return nil;
  275|      0|}
  276|       |
  277|       |- (BOOL)setItem:(NSData *)item
  278|       |      withQuery:(NSDictionary *)query
  279|      0|          error:(NSError *_Nullable *_Nullable)outError {
  280|      0|  NSData *existingItem = [self getItemWithQuery:query error:outError];
  281|      0|  if (outError && *outError) {
  282|      0|    return NO;
  283|      0|  }
  284|      0|
  285|      0|  OSStatus status;
  286|      0|  if (!existingItem) {
  287|      0|    NSMutableDictionary *queryWithItem = [query mutableCopy];
  288|      0|    [queryWithItem setObject:item forKey:(__bridge id)kSecValueData];
  289|      0|    status = SecItemAdd((__bridge CFDictionaryRef)queryWithItem, NULL);
  290|      0|  } else {
  291|      0|    NSDictionary *attributes = @{(__bridge id)kSecValueData: item};
  292|      0|    status = SecItemUpdate((__bridge CFDictionaryRef)query, (__bridge CFDictionaryRef)attributes);
  293|      0|  }
  294|      0|
  295|      0|  if (status == noErr) {
  296|      0|    if (outError) {
  297|      0|      *outError = nil;
  298|      0|    }
  299|      0|    return YES;
  300|      0|  }
  301|      0|
  302|      0|  NSString *function = existingItem ? @"SecItemUpdate" : @"SecItemAdd";
  303|      0|  if (outError) {
  304|      0|    *outError = [FIRAuthErrorUtils keychainErrorWithFunction:function status:status];
  305|      0|  }
  306|      0|  return NO;
  307|      0|}
  308|       |
  309|      0|- (BOOL)removeItemWithQuery:(NSDictionary *)query error:(NSError *_Nullable *_Nullable)outError {
  310|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)query);
  311|      0|
  312|      0|  if (status == noErr || status == errSecItemNotFound) {
  313|      0|    if (outError) {
  314|      0|      *outError = nil;
  315|      0|    }
  316|      0|    return YES;
  317|      0|  }
  318|      0|
  319|      0|  if (outError) {
  320|      0|    *outError = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemDelete" status:status];
  321|      0|  }
  322|      0|  return NO;
  323|      0|}
  324|       |
  325|       |@end
  326|       |
  327|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Storage/FIRAuthUserDefaults.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthUserDefaults.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |static NSString *const kPersistentDomainNamePrefix = @"com.google.Firebase.Auth.";
   22|       |
   23|       |@implementation FIRAuthUserDefaults {
   24|       |  /** @var _persistentDomainName
   25|       |      @brief The name of the persistent domain in user defaults.
   26|       |   */
   27|       |  NSString *_persistentDomainName;
   28|       |
   29|       |  /** @var _storage
   30|       |      @brief The backing NSUserDefaults storage for this instance.
   31|       |   */
   32|       |  NSUserDefaults *_storage;
   33|       |}
   34|       |
   35|      1|- (instancetype)initWithService:(NSString *)service {
   36|      1|  self = [super init];
   37|      1|  if (self) {
   38|      1|    _persistentDomainName = [kPersistentDomainNamePrefix stringByAppendingString:service];
   39|      1|    _storage = [[NSUserDefaults alloc] init];
   40|      1|  }
   41|      1|  return self;
   42|      1|}
   43|       |
   44|      1|- (nullable NSData *)dataForKey:(NSString *)key error:(NSError **_Nullable)error {
   45|      1|  if (error) {
   46|      1|    *error = nil;
   47|      1|  }
   48|      1|  NSDictionary<NSString *, id> *allData = [_storage persistentDomainForName:_persistentDomainName];
   49|      1|  return allData[key];
   50|      1|}
   51|       |
   52|      0|- (BOOL)setData:(NSData *)data forKey:(NSString *)key error:(NSError **_Nullable)error {
   53|      0|  NSMutableDictionary<NSString *, id> *allData =
   54|      0|      [([_storage persistentDomainForName:_persistentDomainName] ?: @{}) mutableCopy];
   55|      0|  allData[key] = data;
   56|      0|  [_storage setPersistentDomain:allData forName:_persistentDomainName];
   57|      0|  return YES;
   58|      0|}
   59|       |
   60|      0|- (BOOL)removeDataForKey:(NSString *)key error:(NSError **_Nullable)error {
   61|      0|  NSMutableDictionary<NSString *, id> *allData =
   62|      0|      [[_storage persistentDomainForName:_persistentDomainName] mutableCopy];
   63|      0|  [allData removeObjectForKey:key];
   64|      0|  [_storage setPersistentDomain:allData forName:_persistentDomainName];
   65|      0|  return YES;
   66|      0|}
   67|       |
   68|      0|- (void)clear {
   69|      0|  [_storage setPersistentDomain:@{} forName:_persistentDomainName];
   70|      0|}
   71|       |
   72|       |@end
   73|       |
   74|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRAuthAPNSToken.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX
   19|       |
   20|       |#import "FIRAuthAPNSToken.h"
   21|       |
   22|       |NS_ASSUME_NONNULL_BEGIN
   23|       |
   24|       |@implementation FIRAuthAPNSToken {
   25|       |  /** @var _string
   26|       |      @brief The lazy-initialized string form of the token data.
   27|       |   */
   28|       |  NSString *_string;
   29|       |}
   30|       |
   31|      0|- (instancetype)initWithData:(NSData *)data type:(FIRAuthAPNSTokenType)type {
   32|      0|  self = [super init];
   33|      0|  if (self) {
   34|      0|    _data = [data copy];
   35|      0|    _type = type;
   36|      0|  }
   37|      0|  return self;
   38|      0|}
   39|       |
   40|      0|- (NSString *)string {
   41|      0|  if (!_string) {
   42|      0|    NSUInteger capacity = _data.length * 2;
   43|      0|    NSMutableString *tokenString = [NSMutableString stringWithCapacity:capacity];
   44|      0|    const unsigned char *tokenData = _data.bytes;
   45|      0|    for (int idx = 0; idx < _data.length; ++idx) {
   46|      0|      [tokenString appendFormat:@"%02X", (int)tokenData[idx]];
   47|      0|    }
   48|      0|    _string = tokenString;
   49|      0|  }
   50|      0|  return _string;
   51|      0|}
   52|       |
   53|       |@end
   54|       |
   55|       |NS_ASSUME_NONNULL_END
   56|       |
   57|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRAuthAPNSTokenManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX
   19|       |
   20|       |#import "FIRAuthAPNSTokenManager.h"
   21|       |
   22|       |#import <FirebaseCore/FIRLogger.h>
   23|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   24|       |
   25|       |#import "FIRAuthAPNSToken.h"
   26|       |#import "FIRAuthGlobalWorkQueue.h"
   27|       |
   28|       |NS_ASSUME_NONNULL_BEGIN
   29|       |
   30|       |/** @var kRegistrationTimeout
   31|       |    @brief Timeout for registration for remote notification.
   32|       |    @remarks Once we start to handle `application:didFailToRegisterForRemoteNotificationsWithError:`
   33|       |        we probably don't have to use timeout at all.
   34|       | */
   35|       |static const NSTimeInterval kRegistrationTimeout = 5;
   36|       |
   37|       |/** @var kLegacyRegistrationTimeout
   38|       |    @brief Timeout for registration for remote notification on iOS 7.
   39|       | */
   40|       |static const NSTimeInterval kLegacyRegistrationTimeout = 30;
   41|       |
   42|       |@implementation FIRAuthAPNSTokenManager {
   43|       |  /** @var _application
   44|       |      @brief The @c UIApplication to request the token from.
   45|       |   */
   46|       |  UIApplication *_application;
   47|       |
   48|       |  /** @var _pendingCallbacks
   49|       |      @brief The list of all pending callbacks for the APNs token.
   50|       |   */
   51|       |  NSMutableArray<FIRAuthAPNSTokenCallback> *_pendingCallbacks;
   52|       |}
   53|       |
   54|      1|- (instancetype)initWithApplication:(UIApplication *)application {
   55|      1|  self = [super init];
   56|      1|  if (self) {
   57|      1|    _application = application;
   58|      1|    _timeout = [_application respondsToSelector:@selector(registerForRemoteNotifications)] ?
   59|      1|        kRegistrationTimeout : kLegacyRegistrationTimeout;
   60|      1|  }
   61|      1|  return self;
   62|      1|}
   63|       |
   64|      0|- (void)getTokenWithCallback:(FIRAuthAPNSTokenCallback)callback {
   65|      0|  if (_token) {
   66|      0|    callback(_token, nil);
   67|      0|    return;
   68|      0|  }
   69|      0|  if (_pendingCallbacks) {
   70|      0|    [_pendingCallbacks addObject:callback];
   71|      0|    return;
   72|      0|  }
   73|      0|  _pendingCallbacks =
   74|      0|      [[NSMutableArray<FIRAuthAPNSTokenCallback> alloc] initWithObjects:callback, nil];
   75|      0|  dispatch_async(dispatch_get_main_queue(), ^{
   76|      0|    if ([self->_application respondsToSelector:@selector(registerForRemoteNotifications)]) {
   77|      0|      [self->_application registerForRemoteNotifications];
   78|      0|    } else {
   79|      0|#pragma clang diagnostic push
   80|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   81|      0|#if TARGET_OS_IOS
   82|      0|      [self->_application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert];
   83|      0|#endif  // TARGET_OS_IOS
   84|      0|#pragma clang diagnostic pop
   85|      0|    }
   86|      0|  });
   87|      0|  NSArray<FIRAuthAPNSTokenCallback> *applicableCallbacks = _pendingCallbacks;
   88|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_timeout * NSEC_PER_SEC)),
   89|      0|                               FIRAuthGlobalWorkQueue(), ^{
   90|      0|    // Only cancel if the pending callbacks remain the same, i.e., not triggered yet.
   91|      0|    if (applicableCallbacks == self->_pendingCallbacks) {
   92|      0|      [self callBackWithToken:nil error:nil];
   93|      0|    }
   94|      0|  });
   95|      0|}
   96|       |
   97|      0|- (void)setToken:(nullable FIRAuthAPNSToken *)token {
   98|      0|  if (!token) {
   99|      0|    _token = nil;
  100|      0|    return;
  101|      0|  }
  102|      0|  if (token.type == FIRAuthAPNSTokenTypeUnknown) {
  103|      0|    static FIRAuthAPNSTokenType detectedTokenType = FIRAuthAPNSTokenTypeUnknown;
  104|      0|    if (detectedTokenType == FIRAuthAPNSTokenTypeUnknown) {
  105|      0|      detectedTokenType =
  106|      0|          [[self class] isProductionApp] ? FIRAuthAPNSTokenTypeProd : FIRAuthAPNSTokenTypeSandbox;
  107|      0|    }
  108|      0|    token = [[FIRAuthAPNSToken alloc] initWithData:token.data type:detectedTokenType];
  109|      0|  }
  110|      0|  _token = token;
  111|      0|  [self callBackWithToken:token error:nil];
  112|      0|}
  113|       |
  114|      0|- (void)cancelWithError:(NSError *)error {
  115|      0|  [self callBackWithToken:nil error:error];
  116|      0|}
  117|       |
  118|       |#pragma mark - Internal methods
  119|       |
  120|       |/** @fn callBack
  121|       |    @brief Calls back all pending callbacks with APNs token or error.
  122|       |    @param token The APNs token if one is available.
  123|       |    @param error The error occurred, if any.
  124|       | */
  125|      0|- (void)callBackWithToken:(nullable FIRAuthAPNSToken *)token error:(nullable NSError *)error {
  126|      0|  if (!_pendingCallbacks) {
  127|      0|    return;
  128|      0|  }
  129|      0|  NSArray<FIRAuthAPNSTokenCallback> *allCallbacks = _pendingCallbacks;
  130|      0|  _pendingCallbacks = nil;
  131|      0|  for (FIRAuthAPNSTokenCallback callback in allCallbacks) {
  132|      0|    callback(token, error);
  133|      0|  }
  134|      0|};
  135|       |
  136|       |/** @fn isProductionApp
  137|       |    @brief Whether or not the app has production (versus sandbox) provisioning profile.
  138|       |    @remarks This method is adapted from @c FIRInstanceID .
  139|       | */
  140|      0|+ (BOOL)isProductionApp {
  141|      0|  const BOOL defaultAppTypeProd = YES;
  142|      0|
  143|      0|  NSError *error = nil;
  144|      0|
  145|      0|  if ([GULAppEnvironmentUtil isSimulator]) {
  146|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000006", @"Assuming prod APNs token type on simulator.");
  147|      0|    return defaultAppTypeProd;
  148|      0|  }
  149|      0|
  150|      0|  // Apps distributed via AppStore or TestFlight use the Production APNS certificates.
  151|      0|  if ([GULAppEnvironmentUtil isFromAppStore]) {
  152|      0|    return defaultAppTypeProd;
  153|      0|  }
  154|      0|  NSString *path = [[[NSBundle mainBundle] bundlePath]
  155|      0|                    stringByAppendingPathComponent:@"embedded.mobileprovision"];
  156|      0|  if ([GULAppEnvironmentUtil isAppStoreReceiptSandbox] && !path.length) {
  157|      0|    // Distributed via TestFlight
  158|      0|    return defaultAppTypeProd;
  159|      0|  }
  160|      0|
  161|      0|  NSMutableData *profileData = [NSMutableData dataWithContentsOfFile:path options:0 error:&error];
  162|      0|
  163|      0|  if (!profileData.length || error) {
  164|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000007",
  165|      0|               @"Error while reading embedded mobileprovision %@", error);
  166|      0|    return defaultAppTypeProd;
  167|      0|  }
  168|      0|
  169|      0|  // The "embedded.mobileprovision" sometimes contains characters with value 0, which signals the
  170|      0|  // end of a c-string and halts the ASCII parser, or with value > 127, which violates strict 7-bit
  171|      0|  // ASCII. Replace any 0s or invalid characters in the input.
  172|      0|  uint8_t *profileBytes = (uint8_t *)profileData.bytes;
  173|      0|  for (int i = 0; i < profileData.length; i++) {
  174|      0|    uint8_t currentByte = profileBytes[i];
  175|      0|    if (!currentByte || currentByte > 127) {
  176|      0|      profileBytes[i] = '.';
  177|      0|    }
  178|      0|  }
  179|      0|
  180|      0|  NSString *embeddedProfile = [[NSString alloc] initWithBytesNoCopy:profileBytes
  181|      0|                                                             length:profileData.length
  182|      0|                                                           encoding:NSASCIIStringEncoding
  183|      0|                                                       freeWhenDone:NO];
  184|      0|
  185|      0|  if (error || !embeddedProfile.length) {
  186|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000008",
  187|      0|               @"Error while reading embedded mobileprovision %@", error);
  188|      0|    return defaultAppTypeProd;
  189|      0|  }
  190|      0|
  191|      0|  NSScanner *scanner = [NSScanner scannerWithString:embeddedProfile];
  192|      0|  NSString *plistContents;
  193|      0|  if ([scanner scanUpToString:@"<plist" intoString:nil]) {
  194|      0|    if ([scanner scanUpToString:@"</plist>" intoString:&plistContents]) {
  195|      0|      plistContents = [plistContents stringByAppendingString:@"</plist>"];
  196|      0|    }
  197|      0|  }
  198|      0|
  199|      0|  if (!plistContents.length) {
  200|      0|    return defaultAppTypeProd;
  201|      0|  }
  202|      0|
  203|      0|  NSData *data = [plistContents dataUsingEncoding:NSUTF8StringEncoding];
  204|      0|  if (!data.length) {
  205|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000009",
  206|      0|               @"Couldn't read plist fetched from embedded mobileprovision");
  207|      0|    return defaultAppTypeProd;
  208|      0|  }
  209|      0|
  210|      0|  NSError *plistMapError;
  211|      0|  id plistData = [NSPropertyListSerialization propertyListWithData:data
  212|      0|                                                           options:NSPropertyListImmutable
  213|      0|                                                            format:nil
  214|      0|                                                             error:&plistMapError];
  215|      0|  if (plistMapError || ![plistData isKindOfClass:[NSDictionary class]]) {
  216|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000010",
  217|      0|               @"Error while converting assumed plist to dict %@",
  218|      0|               plistMapError.localizedDescription);
  219|      0|    return defaultAppTypeProd;
  220|      0|  }
  221|      0|  NSDictionary *plistMap = (NSDictionary *)plistData;
  222|      0|
  223|      0|  if ([plistMap valueForKeyPath:@"ProvisionedDevices"]) {
  224|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000011",
  225|      0|               @"Provisioning profile has specifically provisioned devices, "
  226|      0|               @"most likely a Dev profile.");
  227|      0|  }
  228|      0|
  229|      0|  NSString *apsEnvironment = [plistMap valueForKeyPath:@"Entitlements.aps-environment"];
  230|      0|  FIRLogDebug(kFIRLoggerAuth, @"I-AUT000012",
  231|      0|              @"APNS Environment in profile: %@", apsEnvironment);
  232|      0|
  233|      0|  // No aps-environment in the profile.
  234|      0|  if (!apsEnvironment.length) {
  235|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000013",
  236|      0|               @"No aps-environment set. If testing on a device APNS is not "
  237|      0|               @"correctly configured. Please recheck your provisioning profiles.");
  238|      0|    return defaultAppTypeProd;
  239|      0|  }
  240|      0|
  241|      0|  if ([apsEnvironment isEqualToString:@"development"]) {
  242|      0|    return NO;
  243|      0|  }
  244|      0|
  245|      0|  return defaultAppTypeProd;
  246|      0|}
  247|       |
  248|       |@end
  249|       |
  250|       |NS_ASSUME_NONNULL_END
  251|       |
  252|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRAuthAppCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthAppCredential.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kReceiptKey
   22|       |    @brief The key used to encode the receipt property for NSSecureCoding.
   23|       | */
   24|       |static NSString *const kReceiptKey = @"receipt";
   25|       |
   26|       |/** @var kSecretKey
   27|       |    @brief The key used to encode the secret property for NSSecureCoding.
   28|       | */
   29|       |static NSString *const kSecretKey = @"secret";
   30|       |
   31|       |@implementation FIRAuthAppCredential
   32|       |
   33|      0|- (instancetype)initWithReceipt:(NSString *)receipt secret:(nullable NSString *)secret {
   34|      0|  self = [super init];
   35|      0|  if (self) {
   36|      0|    _receipt = [receipt copy];
   37|      0|    _secret = [secret copy];
   38|      0|  }
   39|      0|  return self;
   40|      0|}
   41|       |
   42|       |#pragma mark - NSSecureCoding
   43|       |
   44|      0|+ (BOOL)supportsSecureCoding {
   45|      0|  return YES;
   46|      0|}
   47|       |
   48|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   49|      0|  NSString *receipt = [aDecoder decodeObjectOfClass:[NSString class] forKey:kReceiptKey];
   50|      0|  if (!receipt) {
   51|      0|    return nil;
   52|      0|  }
   53|      0|  NSString *secret = [aDecoder decodeObjectOfClass:[NSString class] forKey:kSecretKey];
   54|      0|  return [self initWithReceipt:receipt secret:secret];
   55|      0|}
   56|       |
   57|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   58|      0|  [aCoder encodeObject:_receipt forKey:kReceiptKey];
   59|      0|  [aCoder encodeObject:_secret forKey:kSecretKey];
   60|      0|}
   61|       |
   62|       |@end
   63|       |
   64|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRAuthAppCredentialManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX
   19|       |
   20|       |#import "FIRAuthAppCredentialManager.h"
   21|       |
   22|       |#import "FIRAuthAppCredential.h"
   23|       |#import "FIRAuthGlobalWorkQueue.h"
   24|       |#import "FIRAuthKeychainServices.h"
   25|       |
   26|       |NS_ASSUME_NONNULL_BEGIN
   27|       |
   28|       |/** @var kKeychainDataKey
   29|       |    @brief The keychain key for the data.
   30|       | */
   31|       |static NSString *const kKeychainDataKey = @"app_credentials";
   32|       |
   33|       |/** @var kFullCredentialKey
   34|       |    @brief The data key for the full app credential.
   35|       | */
   36|       |static NSString *const kFullCredentialKey = @"full_credential";
   37|       |
   38|       |/** @var kPendingReceiptsKey
   39|       |    @brief The data key for the array of pending receipts.
   40|       | */
   41|       |static NSString *const kPendingReceiptsKey = @"pending_receipts";
   42|       |
   43|       |/** @var kMaximumNumberOfPendingReceipts
   44|       |    @brief The maximum number of partial credentials kept by this class.
   45|       | */
   46|       |static const NSUInteger kMaximumNumberOfPendingReceipts = 32;
   47|       |
   48|       |@implementation FIRAuthAppCredentialManager {
   49|       |  /** @var _keychainServices
   50|       |      @brief The keychain for app credentials to load from and to save to.
   51|       |   */
   52|       |  FIRAuthKeychainServices *_keychainServices;
   53|       |
   54|       |  /** @var _pendingReceipts
   55|       |      @brief A list of pending receipts sorted in the order they were recorded.
   56|       |   */
   57|       |  NSMutableArray<NSString *> *_pendingReceipts;
   58|       |
   59|       |  /** @var _callbacksByReceipt
   60|       |      @brief A map from pending receipts to callbacks.
   61|       |   */
   62|       |  NSMutableDictionary<NSString *, FIRAuthAppCredentialCallback> *_callbacksByReceipt;
   63|       |}
   64|       |
   65|      1|- (instancetype)initWithKeychain:(FIRAuthKeychainServices *)keychain {
   66|      1|  self = [super init];
   67|      1|  if (self) {
   68|      1|    _keychainServices = keychain;
   69|      1|    // Load the credentials from keychain if possible.
   70|      1|    NSError *error;
   71|      1|    NSData *encodedData = [_keychainServices dataForKey:kKeychainDataKey error:&error];
   72|      1|    if (!error && encodedData) {
   73|      0|      NSKeyedUnarchiver *unarchiver =
   74|      0|          [[NSKeyedUnarchiver alloc] initForReadingWithData:encodedData];
   75|      0|      FIRAuthAppCredential *credential =
   76|      0|          [unarchiver decodeObjectOfClass:[FIRAuthAppCredential class]
   77|      0|                                   forKey:kFullCredentialKey];
   78|      0|      if ([credential isKindOfClass:[FIRAuthAppCredential class]]) {
   79|      0|        _credential = credential;
   80|      0|      }
   81|      0|      NSSet<Class> *allowedClasses =
   82|      0|          [NSSet<Class> setWithObjects:[NSArray class], [NSString class], nil];
   83|      0|      NSArray<NSString *> *pendingReceipts =
   84|      0|          [unarchiver decodeObjectOfClasses:allowedClasses forKey:kPendingReceiptsKey];
   85|      0|      if ([pendingReceipts isKindOfClass:[NSArray class]]) {
   86|      0|        _pendingReceipts = [pendingReceipts mutableCopy];
   87|      0|      }
   88|      0|    }
   89|      1|    if (!_pendingReceipts) {
   90|      1|      _pendingReceipts = [[NSMutableArray<NSString *> alloc] init];
   91|      1|    }
   92|      1|    _callbacksByReceipt =
   93|      1|        [[NSMutableDictionary<NSString *, FIRAuthAppCredentialCallback> alloc] init];
   94|      1|  }
   95|      1|  return self;
   96|      1|}
   97|       |
   98|      0|- (NSUInteger)maximumNumberOfPendingReceipts {
   99|      0|  return kMaximumNumberOfPendingReceipts;
  100|      0|}
  101|       |
  102|       |- (void)didStartVerificationWithReceipt:(NSString *)receipt
  103|       |                                timeout:(NSTimeInterval)timeout
  104|      0|                               callback:(FIRAuthAppCredentialCallback)callback {
  105|      0|  [_pendingReceipts removeObject:receipt];
  106|      0|  if (_pendingReceipts.count >= kMaximumNumberOfPendingReceipts) {
  107|      0|    [_pendingReceipts removeObjectAtIndex:0];
  108|      0|  }
  109|      0|  [_pendingReceipts addObject:receipt];
  110|      0|  _callbacksByReceipt[receipt] = callback;
  111|      0|  [self saveData];
  112|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC)),
  113|      0|                               FIRAuthGlobalWorkQueue(), ^{
  114|      0|    [self callBackWithReceipt:receipt];
  115|      0|  });
  116|      0|}
  117|       |
  118|      0|- (BOOL)canFinishVerificationWithReceipt:(NSString *)receipt secret:(NSString *)secret {
  119|      0|  if (![_pendingReceipts containsObject:receipt]) {
  120|      0|    return NO;
  121|      0|  }
  122|      0|  [_pendingReceipts removeObject:receipt];
  123|      0|  _credential = [[FIRAuthAppCredential alloc] initWithReceipt:receipt secret:secret];
  124|      0|  [self saveData];
  125|      0|  [self callBackWithReceipt:receipt];
  126|      0|  return YES;
  127|      0|}
  128|       |
  129|      0|- (void)clearCredential {
  130|      0|  _credential = nil;
  131|      0|  [self saveData];
  132|      0|}
  133|       |
  134|       |#pragma mark - Internal methods
  135|       |
  136|       |/** @fn saveData
  137|       |    @brief Save the data in memory to the keychain ignoring any errors.
  138|       | */
  139|      0|- (void)saveData {
  140|      0|  NSMutableData *archiveData = [NSMutableData data];
  141|      0|  NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:archiveData];
  142|      0|  [archiver encodeObject:_credential forKey:kFullCredentialKey];
  143|      0|  [archiver encodeObject:_pendingReceipts forKey:kPendingReceiptsKey];
  144|      0|  [archiver finishEncoding];
  145|      0|  [_keychainServices setData:archiveData forKey:kKeychainDataKey error:NULL];
  146|      0|}
  147|       |
  148|       |/** @fn callBackWithReceipt:
  149|       |    @brief Calls the saved callback for the specifc receipt.
  150|       |    @param receipt The receipt associated with the callback.
  151|       | */
  152|      0|- (void)callBackWithReceipt:(NSString *)receipt {
  153|      0|  FIRAuthAppCredentialCallback callback = _callbacksByReceipt[receipt];
  154|      0|  if (!callback) {
  155|      0|    return;
  156|      0|  }
  157|      0|  [_callbacksByReceipt removeObjectForKey:receipt];
  158|      0|  if (_credential) {
  159|      0|    callback(_credential);
  160|      0|  } else {
  161|      0|    callback([[FIRAuthAppCredential alloc] initWithReceipt:receipt secret:nil]);
  162|      0|  }
  163|      0|}
  164|       |
  165|       |@end
  166|       |
  167|       |NS_ASSUME_NONNULL_END
  168|       |
  169|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRAuthNotificationManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX
   19|       |
   20|       |#import "FIRAuthNotificationManager.h"
   21|       |
   22|       |#import <FirebaseCore/FIRLogger.h>
   23|       |#import "FIRAuthAppCredential.h"
   24|       |#import "FIRAuthAppCredentialManager.h"
   25|       |#import "FIRAuthGlobalWorkQueue.h"
   26|       |
   27|       |NS_ASSUME_NONNULL_BEGIN
   28|       |
   29|       |/** @var kNotificationKey
   30|       |    @brief The key to locate payload data in the remote notification.
   31|       | */
   32|       |static NSString *const kNotificationDataKey = @"com.google.firebase.auth";
   33|       |
   34|       |/** @var kNotificationReceiptKey
   35|       |    @brief The key for the receipt in the remote notification payload data.
   36|       | */
   37|       |static NSString *const kNotificationReceiptKey = @"receipt";
   38|       |
   39|       |/** @var kNotificationSecretKey
   40|       |    @brief The key for the secret in the remote notification payload data.
   41|       | */
   42|       |static NSString *const kNotificationSecretKey = @"secret";
   43|       |
   44|       |/** @var kNotificationProberKey
   45|       |    @brief The key for marking the prober in the remote notification payload data.
   46|       | */
   47|       |static NSString *const kNotificationProberKey = @"warning";
   48|       |
   49|       |/** @var kProbingTimeout
   50|       |    @brief Timeout for probing whether the app delegate forwards the remote notification to us.
   51|       | */
   52|       |static const NSTimeInterval kProbingTimeout = 1;
   53|       |
   54|       |@implementation FIRAuthNotificationManager {
   55|       |  /** @var _application
   56|       |      @brief The application.
   57|       |   */
   58|       |  UIApplication *_application;
   59|       |
   60|       |  /** @var _appCredentialManager
   61|       |      @brief The object to handle app credentials delivered via notification.
   62|       |   */
   63|       |  FIRAuthAppCredentialManager *_appCredentialManager;
   64|       |
   65|       |  /** @var _hasCheckedNotificationForwarding
   66|       |      @brief Whether notification forwarding has been checked or not.
   67|       |   */
   68|       |  BOOL _hasCheckedNotificationForwarding;
   69|       |
   70|       |  /** @var _isNotificationBeingForwarded
   71|       |      @brief Whether or not notification is being forwarded
   72|       |   */
   73|       |  BOOL _isNotificationBeingForwarded;
   74|       |
   75|       |  /** @var _pendingCallbacks
   76|       |      @brief All pending callbacks while a check is being performed.
   77|       |   */
   78|       |  NSMutableArray<FIRAuthNotificationForwardingCallback> *_pendingCallbacks;
   79|       |}
   80|       |
   81|       |- (instancetype)initWithApplication:(UIApplication *)application
   82|      1|               appCredentialManager:(FIRAuthAppCredentialManager *)appCredentialManager {
   83|      1|  self = [super init];
   84|      1|  if (self) {
   85|      1|    _application = application;
   86|      1|    _appCredentialManager = appCredentialManager;
   87|      1|    _timeout = kProbingTimeout;
   88|      1|  }
   89|      1|  return self;
   90|      1|}
   91|       |
   92|      0|- (void)checkNotificationForwardingWithCallback:(FIRAuthNotificationForwardingCallback)callback {
   93|      0|  if (_pendingCallbacks) {
   94|      0|    [_pendingCallbacks addObject:callback];
   95|      0|    return;
   96|      0|  }
   97|      0|  if (_hasCheckedNotificationForwarding) {
   98|      0|    callback(_isNotificationBeingForwarded);
   99|      0|    return;
  100|      0|  }
  101|      0|  _hasCheckedNotificationForwarding = YES;
  102|      0|  _pendingCallbacks =
  103|      0|      [[NSMutableArray<FIRAuthNotificationForwardingCallback> alloc] initWithObjects:callback, nil];
  104|      0|  dispatch_async(dispatch_get_main_queue(), ^{
  105|      0|    NSDictionary *proberNotification = @{
  106|      0|      kNotificationDataKey : @{
  107|      0|        kNotificationProberKey : @"This fake notification should be forwarded to Firebase Auth."
  108|      0|      }
  109|      0|    };
  110|      0|    if ([self->_application.delegate respondsToSelector:
  111|      0|            @selector(application:didReceiveRemoteNotification:fetchCompletionHandler:)]) {
  112|      0|      [self->_application.delegate application:self->_application
  113|      0|            didReceiveRemoteNotification:proberNotification
  114|      0|                  fetchCompletionHandler:^(UIBackgroundFetchResult result) {}];
  115|      0|#if !TARGET_OS_TV
  116|      0|    } else if ([self->_application.delegate respondsToSelector:
  117|      0|                   @selector(application:didReceiveRemoteNotification:)]) {
  118|      0|      [self->_application.delegate application:self->_application
  119|      0|            didReceiveRemoteNotification:proberNotification];
  120|      0|#endif
  121|      0|    } else {
  122|      0|      FIRLogWarning(kFIRLoggerAuth, @"I-AUT000015",
  123|      0|                    @"The UIApplicationDelegate must handle remote notification for phone number "
  124|      0|                    @"authentication to work.");
  125|      0|    }
  126|      0|  });
  127|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_timeout * NSEC_PER_SEC)),
  128|      0|                               FIRAuthGlobalWorkQueue(), ^{
  129|      0|    [self callBack];
  130|      0|  });
  131|      0|}
  132|       |
  133|      0|- (BOOL)canHandleNotification:(NSDictionary *)notification {
  134|      0|  NSDictionary *data = notification[kNotificationDataKey];
  135|      0|  if ([data isKindOfClass:[NSString class]]) {
  136|      0|    // Deserialize in case the data is a JSON string.
  137|      0|    NSData *JSONData = [((NSString *)data) dataUsingEncoding:NSUTF8StringEncoding];
  138|      0|    data = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:NULL];
  139|      0|  }
  140|      0|  if (![data isKindOfClass:[NSDictionary class]]) {
  141|      0|    return NO;
  142|      0|  }
  143|      0|  if (data[kNotificationProberKey]) {
  144|      0|    if (!_pendingCallbacks) {
  145|      0|      // The prober notification probably comes from another instance, so pass it along.
  146|      0|      return NO;
  147|      0|    }
  148|      0|    _isNotificationBeingForwarded = YES;
  149|      0|    [self callBack];
  150|      0|    return YES;
  151|      0|  }
  152|      0|  NSString *receipt = data[kNotificationReceiptKey];
  153|      0|  if (![receipt isKindOfClass:[NSString class]]) {
  154|      0|    return NO;
  155|      0|  }
  156|      0|  NSString *secret = data[kNotificationSecretKey];
  157|      0|  if (![receipt isKindOfClass:[NSString class]]) {
  158|      0|    return NO;
  159|      0|  }
  160|      0|  return [_appCredentialManager canFinishVerificationWithReceipt:receipt secret:secret];
  161|      0|}
  162|       |
  163|       |#pragma mark - Internal methods
  164|       |
  165|       |/** @fn callBack
  166|       |    @brief Calls back all pending callbacks with the result of notification forwarding check.
  167|       | */
  168|      0|- (void)callBack {
  169|      0|  if (!_pendingCallbacks) {
  170|      0|    return;
  171|      0|  }
  172|      0|  NSArray<FIRAuthNotificationForwardingCallback> *allCallbacks = _pendingCallbacks;
  173|      0|  _pendingCallbacks = nil;
  174|      0|  for (FIRAuthNotificationForwardingCallback callback in allCallbacks) {
  175|      0|    callback(_isNotificationBeingForwarded);
  176|      0|  }
  177|      0|};
  178|       |
  179|       |@end
  180|       |NS_ASSUME_NONNULL_END
  181|       |
  182|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRAuthStoredUserManager.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthStoredUserManager.h"
   18|       |
   19|       |/** @var kUserAccessGroupKey
   20|       |    @brief Key of user access group stored in user defaults. Used for retrieve the user access
   21|       |        group at launch.
   22|       | */
   23|       |static NSString *kStoredUserAccessGroupKey = @"firebase_auth_stored_user_access_group";
   24|       |
   25|       |/** @var kSharedKeychainAccountValue
   26|       |    @brief Default value for kSecAttrAccount of shared keychain items.
   27|       | */
   28|       |static NSString *kSharedKeychainAccountValue = @"firebase_auth_firebase_user";
   29|       |
   30|       |/** @var kStoredUserCoderKey
   31|       |    @brief The key to encode and decode the stored user.
   32|       | */
   33|       |static NSString *kStoredUserCoderKey = @"firebase_auth_stored_user_coder_key";
   34|       |
   35|       |@implementation FIRAuthStoredUserManager
   36|       |
   37|       |#pragma mark - Initializers
   38|       |
   39|      1|- (instancetype)initWithServiceName:(NSString *)serviceName {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _keychainServices = [[FIRAuthKeychainServices alloc] initWithService:serviceName];
   43|      1|    _userDefaults = [[FIRAuthUserDefaults alloc] initWithService:serviceName];
   44|      1|  }
   45|      1|  return self;
   46|      1|}
   47|       |
   48|       |#pragma mark - User Access Group
   49|       |
   50|      1|- (NSString *_Nullable)getStoredUserAccessGroupWithError:(NSError *_Nullable *_Nullable)outError {
   51|      1|  NSData *data = [self.userDefaults dataForKey:kStoredUserAccessGroupKey error:outError];
   52|      1|  if (data) {
   53|      0|    NSString *userAccessGroup = [NSString stringWithUTF8String:data.bytes];
   54|      0|    return userAccessGroup;
   55|      1|  } else {
   56|      1|    return nil;
   57|      1|  }
   58|      1|}
   59|       |
   60|       |- (BOOL)setStoredUserAccessGroup:(NSString *_Nullable)accessGroup
   61|      0|                           error:(NSError *_Nullable *_Nullable)outError {
   62|      0|  NSData *data = [accessGroup dataUsingEncoding:NSUTF8StringEncoding];
   63|      0|  if (!data) {
   64|      0|    return [self.userDefaults removeDataForKey:kStoredUserAccessGroupKey error:outError];
   65|      0|  } else {
   66|      0|    return [self.userDefaults setData:data forKey:kStoredUserAccessGroupKey error:outError];
   67|      0|  }
   68|      0|}
   69|       |
   70|       |#pragma mark - User for Access Group
   71|       |
   72|       |- (FIRUser *)getStoredUserForAccessGroup:(NSString *)accessGroup
   73|       |                       projectIdentifier:(NSString *)projectIdentifier
   74|      0|                                   error:(NSError *_Nullable *_Nullable)outError {
   75|      0|
   76|      0|
   77|      0|  NSMutableDictionary *query = [[NSMutableDictionary alloc] init];
   78|      0|  query[(__bridge id)kSecClass] = (__bridge id)kSecClassGenericPassword;
   79|      0|
   80|      0|  query[(__bridge id)kSecAttrAccessGroup] = accessGroup;
   81|      0|  query[(__bridge id)kSecAttrService] = projectIdentifier;
   82|      0|  query[(__bridge id)kSecAttrAccount] = kSharedKeychainAccountValue;
   83|      0|
   84|      0|  NSData *data = [self.keychainServices getItemWithQuery:query error:outError];
   85|      0|  NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   86|      0|  FIRUser *user = [unarchiver decodeObjectOfClass:[FIRUser class] forKey:kStoredUserCoderKey];
   87|      0|
   88|      0|  return user;
   89|      0|}
   90|       |
   91|       |- (BOOL)setStoredUser:(FIRUser *)user
   92|       |       forAccessGroup:(NSString *)accessGroup
   93|       |    projectIdentifier:(NSString *)projectIdentifier
   94|      0|                error:(NSError *_Nullable *_Nullable)outError {
   95|      0|  NSMutableDictionary *query = [[NSMutableDictionary alloc] init];
   96|      0|  query[(__bridge id)kSecClass] = (__bridge id)kSecClassGenericPassword;
   97|      0|  query[(__bridge id)kSecAttrAccessible] = (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
   98|      0|
   99|      0|  query[(__bridge id)kSecAttrAccessGroup] = accessGroup;
  100|      0|  query[(__bridge id)kSecAttrService] = projectIdentifier;
  101|      0|  query[(__bridge id)kSecAttrAccount] = kSharedKeychainAccountValue;
  102|      0|
  103|      0|  NSMutableData *data = [NSMutableData data];
  104|      0|  NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
  105|      0|  [archiver encodeObject:user forKey:kStoredUserCoderKey];
  106|      0|  [archiver finishEncoding];
  107|      0|
  108|      0|  return [self.keychainServices setItem:data withQuery:query error:outError];
  109|      0|}
  110|       |
  111|       |- (BOOL)removeStoredUserForAccessGroup:(NSString *)accessGroup
  112|       |                     projectIdentifier:(NSString *)projectIdentifier
  113|      0|                                 error:(NSError *_Nullable *_Nullable)outError {
  114|      0|  NSMutableDictionary *query = [[NSMutableDictionary alloc] init];
  115|      0|  query[(__bridge id)kSecClass] = (__bridge id)kSecClassGenericPassword;
  116|      0|  query[(__bridge id)kSecAttrAccessible] = (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
  117|      0|
  118|      0|  query[(__bridge id)kSecAttrAccessGroup] = accessGroup;
  119|      0|  query[(__bridge id)kSecAttrService] = projectIdentifier;
  120|      0|  query[(__bridge id)kSecAttrAccount] = kSharedKeychainAccountValue;
  121|      0|
  122|      0|  return [self.keychainServices removeItemWithQuery:query error:outError];
  123|      0|}
  124|       |
  125|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/SystemService/FIRSecureTokenService.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureTokenService.h"
   18|       |
   19|       |#import "FIRAuth.h"
   20|       |#import "FIRAuthSerialTaskQueue.h"
   21|       |#import "FIRAuthBackend.h"
   22|       |#import "FIRAuthRequestConfiguration.h"
   23|       |#import "FIRSecureTokenRequest.h"
   24|       |#import "FIRSecureTokenResponse.h"
   25|       |
   26|       |NS_ASSUME_NONNULL_BEGIN
   27|       |
   28|       |/** @var kAPIKeyCodingKey
   29|       |    @brief The key used to encode the APIKey for NSSecureCoding.
   30|       | */
   31|       |static NSString *const kAPIKeyCodingKey = @"APIKey";
   32|       |
   33|       |/** @var kRefreshTokenKey
   34|       |    @brief The key used to encode the refresh token for NSSecureCoding.
   35|       | */
   36|       |static NSString *const kRefreshTokenKey = @"refreshToken";
   37|       |
   38|       |/** @var kAccessTokenKey
   39|       |    @brief The key used to encode the access token for NSSecureCoding.
   40|       | */
   41|       |static NSString *const kAccessTokenKey = @"accessToken";
   42|       |
   43|       |/** @var kAccessTokenExpirationDateKey
   44|       |    @brief The key used to encode the access token expiration date for NSSecureCoding.
   45|       | */
   46|       |static NSString *const kAccessTokenExpirationDateKey = @"accessTokenExpirationDate";
   47|       |
   48|       |/** @var kFiveMinutes
   49|       |    @brief Five minutes (in seconds.)
   50|       | */
   51|       |static const NSTimeInterval kFiveMinutes = 5 * 60;
   52|       |
   53|       |@interface FIRSecureTokenService ()
   54|       |- (instancetype)init NS_DESIGNATED_INITIALIZER;
   55|       |@end
   56|       |
   57|       |@implementation FIRSecureTokenService {
   58|       |  /** @var _taskQueue
   59|       |      @brief Used to serialize all requests for access tokens.
   60|       |   */
   61|       |  FIRAuthSerialTaskQueue *_taskQueue;
   62|       |
   63|       |  /** @var _authorizationCode
   64|       |      @brief An authorization code which needs to be exchanged for Secure Token Service tokens.
   65|       |   */
   66|       |  NSString *_Nullable _authorizationCode;
   67|       |
   68|       |  /** @var _accessToken
   69|       |      @brief The currently cached access token. Or |nil| if no token is currently cached.
   70|       |   */
   71|       |  NSString *_Nullable _accessToken;
   72|       |}
   73|       |
   74|      0|- (instancetype)init {
   75|      0|  self = [super init];
   76|      0|  if (self) {
   77|      0|    _taskQueue = [[FIRAuthSerialTaskQueue alloc] init];
   78|      0|  }
   79|      0|  return self;
   80|      0|}
   81|       |
   82|       |- (instancetype)initWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
   83|      0|                           authorizationCode:(NSString *)authorizationCode {
   84|      0|  self = [self init];
   85|      0|  if (self) {
   86|      0|    _requestConfiguration = requestConfiguration;
   87|      0|    _authorizationCode = [authorizationCode copy];
   88|      0|  }
   89|      0|  return self;
   90|      0|}
   91|       |
   92|       |- (instancetype)initWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
   93|       |                                 accessToken:(nullable NSString *)accessToken
   94|       |                   accessTokenExpirationDate:(nullable NSDate *)accessTokenExpirationDate
   95|      0|                                refreshToken:(NSString *)refreshToken {
   96|      0|  self = [self init];
   97|      0|  if (self) {
   98|      0|    _requestConfiguration = requestConfiguration;
   99|      0|    _accessToken = [accessToken copy];
  100|      0|    _accessTokenExpirationDate = [accessTokenExpirationDate copy];
  101|      0|    _refreshToken = [refreshToken copy];
  102|      0|  }
  103|      0|  return self;
  104|      0|}
  105|       |
  106|       |- (void)fetchAccessTokenForcingRefresh:(BOOL)forceRefresh
  107|      0|                              callback:(FIRFetchAccessTokenCallback)callback {
  108|      0|  [_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock complete) {
  109|      0|    if (!forceRefresh && [self hasValidAccessToken]) {
  110|      0|      complete();
  111|      0|      callback(self->_accessToken, nil, NO);
  112|      0|    } else {
  113|      0|      [self requestAccessToken:^(NSString *_Nullable token,
  114|      0|                                 NSError *_Nullable error,
  115|      0|                                 BOOL tokenUpdated) {
  116|      0|        complete();
  117|      0|        callback(token, error, tokenUpdated);
  118|      0|      }];
  119|      0|    }
  120|      0|  }];
  121|      0|}
  122|       |
  123|      0|- (NSString *)rawAccessToken {
  124|      0|  return _accessToken;
  125|      0|}
  126|       |
  127|       |#pragma mark - NSSecureCoding
  128|       |
  129|      0|+ (BOOL)supportsSecureCoding {
  130|      0|  return YES;
  131|      0|}
  132|       |
  133|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  134|      0|  NSString *refreshToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:kRefreshTokenKey];
  135|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:kAccessTokenKey];
  136|      0|  NSDate *accessTokenExpirationDate =
  137|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kAccessTokenExpirationDateKey];
  138|      0|  if (!refreshToken) {
  139|      0|    return nil;
  140|      0|  }
  141|      0|  self = [self init];
  142|      0|  if (self) {
  143|      0|    _refreshToken = refreshToken;
  144|      0|    _accessToken = accessToken;
  145|      0|    _accessTokenExpirationDate = accessTokenExpirationDate;
  146|      0|  }
  147|      0|  return self;
  148|      0|}
  149|       |
  150|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  151|      0|  // The API key is encoded even it is not used in decoding to be compatible with previous versions
  152|      0|  // of the library.
  153|      0|  [aCoder encodeObject:_requestConfiguration.APIKey forKey:kAPIKeyCodingKey];
  154|      0|  // Authorization code is not encoded because it is not long-lived.
  155|      0|  [aCoder encodeObject:_refreshToken forKey:kRefreshTokenKey];
  156|      0|  [aCoder encodeObject:_accessToken forKey:kAccessTokenKey];
  157|      0|  [aCoder encodeObject:_accessTokenExpirationDate forKey:kAccessTokenExpirationDateKey];
  158|      0|}
  159|       |
  160|       |#pragma mark - Private methods
  161|       |
  162|       |/** @fn requestAccessToken:
  163|       |    @brief Makes a request to STS for an access token.
  164|       |    @details This handles both the case that the token has not been granted yet and that it just
  165|       |        needs to be refreshed. The caller is responsible for making sure that this is occurring in
  166|       |        a @c _taskQueue task.
  167|       |    @param callback Called when the fetch is complete. Invoked asynchronously on the main thread in
  168|       |        the future.
  169|       |    @remarks Because this method is guaranteed to only be called from tasks enqueued in
  170|       |        @c _taskQueue, we do not need any @synchronized guards around access to _accessToken/etc.
  171|       |        since only one of those tasks is ever running at a time, and those tasks are the only
  172|       |        access to and mutation of these instance variables.
  173|       | */
  174|      0|- (void)requestAccessToken:(FIRFetchAccessTokenCallback)callback {
  175|      0|  FIRSecureTokenRequest *request;
  176|      0|  if (_refreshToken.length) {
  177|      0|    request = [FIRSecureTokenRequest refreshRequestWithRefreshToken:_refreshToken
  178|      0|                                               requestConfiguration:_requestConfiguration];
  179|      0|  } else {
  180|      0|    request = [FIRSecureTokenRequest authCodeRequestWithCode:_authorizationCode
  181|      0|                                        requestConfiguration:_requestConfiguration];
  182|      0|  }
  183|      0|  [FIRAuthBackend secureToken:request
  184|      0|                     callback:^(FIRSecureTokenResponse *_Nullable response,
  185|      0|                                NSError *_Nullable error) {
  186|      0|    BOOL tokenUpdated = NO;
  187|      0|    NSString *newAccessToken = response.accessToken;
  188|      0|                       if (newAccessToken.length && ![newAccessToken isEqualToString:self->_accessToken]) {
  189|      0|                         self->_accessToken = [newAccessToken copy];
  190|      0|                         self->_accessTokenExpirationDate = response.approximateExpirationDate;
  191|      0|      tokenUpdated = YES;
  192|      0|    }
  193|      0|    NSString *newRefreshToken = response.refreshToken;
  194|      0|                       if (newRefreshToken.length &&
  195|      0|                           ![newRefreshToken isEqualToString:self->_refreshToken]) {
  196|      0|                         self->_refreshToken = [newRefreshToken copy];
  197|      0|      tokenUpdated = YES;
  198|      0|    }
  199|      0|    callback(newAccessToken, error, tokenUpdated);
  200|      0|  }];
  201|      0|}
  202|       |
  203|      0|- (BOOL)hasValidAccessToken {
  204|      0|  return _accessToken && [_accessTokenExpirationDate timeIntervalSinceNow] > kFiveMinutes;
  205|      0|}
  206|       |
  207|       |@end
  208|       |
  209|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/User/FIRAdditionalUserInfo.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAdditionalUserInfo_Internal.h"
   18|       |
   19|       |#import "FIRVerifyAssertionResponse.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@implementation FIRAdditionalUserInfo
   24|       |
   25|       |/** @var kProviderIDCodingKey
   26|       |    @brief The key used to encode the providerID property for NSSecureCoding.
   27|       | */
   28|       |static NSString *const kProviderIDCodingKey = @"providerID";
   29|       |
   30|       |/** @var kProfileCodingKey
   31|       |    @brief The key used to encode the profile property for NSSecureCoding.
   32|       | */
   33|       |static NSString *const kProfileCodingKey = @"profile";
   34|       |
   35|       |/** @var kUsernameCodingKey
   36|       |    @brief The key used to encode the username property for NSSecureCoding.
   37|       | */
   38|       |static NSString *const kUsernameCodingKey = @"username";
   39|       |
   40|       |/** @var kNewUserKey
   41|       |    @brief The key used to encode the newUser property for NSSecureCoding.
   42|       | */
   43|       |static NSString *const kNewUserKey = @"newUser";
   44|       |
   45|       |+ (nullable instancetype)userInfoWithVerifyAssertionResponse:
   46|      0|    (FIRVerifyAssertionResponse *)verifyAssertionResponse {
   47|      0|  return [[self alloc] initWithProviderID:verifyAssertionResponse.providerID
   48|      0|                                  profile:verifyAssertionResponse.profile
   49|      0|                                 username:verifyAssertionResponse.username
   50|      0|                                isNewUser:verifyAssertionResponse.isNewUser];
   51|      0|}
   52|       |
   53|       |- (nullable instancetype)initWithProviderID:(nullable NSString *)providerID
   54|       |                                    profile:(nullable NSDictionary<NSString *, NSObject *> *)profile
   55|       |                                   username:(nullable NSString *)username
   56|      0|                                  isNewUser:(BOOL)isNewUser {
   57|      0|  self = [super init];
   58|      0|  if (self) {
   59|      0|    _providerID = [providerID copy];
   60|      0|    if (profile) {
   61|      0|      _profile = [[NSDictionary alloc] initWithDictionary:profile copyItems:YES];
   62|      0|    }
   63|      0|    _username = [username copy];
   64|      0|    _newUser = isNewUser;
   65|      0|  }
   66|      0|  return self;
   67|      0|}
   68|       |
   69|       |#pragma mark - NSSecureCoding
   70|       |
   71|      0|+ (BOOL)supportsSecureCoding {
   72|      0|  return YES;
   73|      0|}
   74|       |
   75|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   76|      0|  NSString *providerID =
   77|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kProviderIDCodingKey];
   78|      0|  NSDictionary<NSString *, NSObject *> *profile =
   79|      0|      [aDecoder decodeObjectOfClass:[NSDictionary class] forKey:kProfileCodingKey];
   80|      0|  NSString *username = [aDecoder decodeObjectOfClass:[NSString class] forKey:kUsernameCodingKey];
   81|      0|  NSNumber *isNewUser = [aDecoder decodeObjectOfClass:[NSNumber class] forKey:kNewUserKey];
   82|      0|
   83|      0|  return [self initWithProviderID:providerID
   84|      0|                          profile:profile
   85|      0|                         username:username
   86|      0|                        isNewUser:isNewUser.boolValue];
   87|      0|}
   88|       |
   89|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   90|      0|  [aCoder encodeObject:_providerID forKey:kProviderIDCodingKey];
   91|      0|  [aCoder encodeObject:_profile forKey:kProfileCodingKey];
   92|      0|  [aCoder encodeObject:_username forKey:kUsernameCodingKey];
   93|      0|  [aCoder encodeObject:[NSNumber numberWithBool:_newUser] forKey:kNewUserKey];
   94|      0|}
   95|       |
   96|       |@end
   97|       |
   98|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/User/FIRUser.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRUser_Internal.h"
   18|       |
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |
   21|       |#import "FIRAdditionalUserInfo_Internal.h"
   22|       |#import "FIRAuth.h"
   23|       |#import "FIRAuthCredential_Internal.h"
   24|       |#import "FIRAuthDataResult_Internal.h"
   25|       |#import "FIRAuthErrorUtils.h"
   26|       |#import "FIRAuthGlobalWorkQueue.h"
   27|       |#import "FIRAuthSerialTaskQueue.h"
   28|       |#import "FIRAuthOperationType.h"
   29|       |#import "FIRAuth_Internal.h"
   30|       |#import "FIRAuthBackend.h"
   31|       |#import "FIRAuthRequestConfiguration.h"
   32|       |#import "FIRAuthTokenResult_Internal.h"
   33|       |#import "FIRAuthWebUtils.h"
   34|       |#import "FIRDeleteAccountRequest.h"
   35|       |#import "FIRDeleteAccountResponse.h"
   36|       |#import "FIREmailAuthProvider.h"
   37|       |#import "FIREmailPasswordAuthCredential.h"
   38|       |#import "FIREmailLinkSignInRequest.h"
   39|       |#import "FIRFederatedAuthProvider.h"
   40|       |#import "FIRGameCenterAuthCredential.h"
   41|       |#import "FIRGetAccountInfoRequest.h"
   42|       |#import "FIRGetAccountInfoResponse.h"
   43|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   44|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   45|       |#import "FIROAuthCredential_Internal.h"
   46|       |#import "FIRSecureTokenService.h"
   47|       |#import "FIRSetAccountInfoRequest.h"
   48|       |#import "FIRSetAccountInfoResponse.h"
   49|       |#import "FIRSignInWithGameCenterRequest.h"
   50|       |#import "FIRSignInWithGameCenterResponse.h"
   51|       |#import "FIRUserInfoImpl.h"
   52|       |#import "FIRUserMetadata_Internal.h"
   53|       |#import "FIRVerifyAssertionRequest.h"
   54|       |#import "FIRVerifyAssertionResponse.h"
   55|       |#import "FIRVerifyCustomTokenRequest.h"
   56|       |#import "FIRVerifyCustomTokenResponse.h"
   57|       |#import "FIRVerifyPasswordRequest.h"
   58|       |#import "FIRVerifyPasswordResponse.h"
   59|       |#import "FIRVerifyPhoneNumberRequest.h"
   60|       |#import "FIRVerifyPhoneNumberResponse.h"
   61|       |
   62|       |#if TARGET_OS_IOS
   63|       |#import "FIRPhoneAuthProvider.h"
   64|       |#import "FIRPhoneAuthCredential_Internal.h"
   65|       |#endif
   66|       |
   67|       |NS_ASSUME_NONNULL_BEGIN
   68|       |
   69|       |/** @var kUserIDCodingKey
   70|       |    @brief The key used to encode the user ID for NSSecureCoding.
   71|       | */
   72|       |static NSString *const kUserIDCodingKey = @"userID";
   73|       |
   74|       |/** @var kHasEmailPasswordCredentialCodingKey
   75|       |    @brief The key used to encode the hasEmailPasswordCredential property for NSSecureCoding.
   76|       | */
   77|       |static NSString *const kHasEmailPasswordCredentialCodingKey = @"hasEmailPassword";
   78|       |
   79|       |/** @var kAnonymousCodingKey
   80|       |    @brief The key used to encode the anonymous property for NSSecureCoding.
   81|       | */
   82|       |static NSString *const kAnonymousCodingKey = @"anonymous";
   83|       |
   84|       |/** @var kEmailCodingKey
   85|       |    @brief The key used to encode the email property for NSSecureCoding.
   86|       | */
   87|       |static NSString *const kEmailCodingKey = @"email";
   88|       |
   89|       |/** @var kPhoneNumberCodingKey
   90|       |    @brief The key used to encode the phoneNumber property for NSSecureCoding.
   91|       | */
   92|       |static NSString *const kPhoneNumberCodingKey = @"phoneNumber";
   93|       |
   94|       |/** @var kEmailVerifiedCodingKey
   95|       |    @brief The key used to encode the isEmailVerified property for NSSecureCoding.
   96|       | */
   97|       |static NSString *const kEmailVerifiedCodingKey = @"emailVerified";
   98|       |
   99|       |/** @var kDisplayNameCodingKey
  100|       |    @brief The key used to encode the displayName property for NSSecureCoding.
  101|       | */
  102|       |static NSString *const kDisplayNameCodingKey = @"displayName";
  103|       |
  104|       |/** @var kPhotoURLCodingKey
  105|       |    @brief The key used to encode the photoURL property for NSSecureCoding.
  106|       | */
  107|       |static NSString *const kPhotoURLCodingKey = @"photoURL";
  108|       |
  109|       |/** @var kProviderDataKey
  110|       |    @brief The key used to encode the providerData instance variable for NSSecureCoding.
  111|       | */
  112|       |static NSString *const kProviderDataKey = @"providerData";
  113|       |
  114|       |/** @var kAPIKeyCodingKey
  115|       |    @brief The key used to encode the APIKey instance variable for NSSecureCoding.
  116|       | */
  117|       |static NSString *const kAPIKeyCodingKey = @"APIKey";
  118|       |
  119|       |/** @var kTokenServiceCodingKey
  120|       |    @brief The key used to encode the tokenService instance variable for NSSecureCoding.
  121|       | */
  122|       |static NSString *const kTokenServiceCodingKey = @"tokenService";
  123|       |
  124|       |/** @var kMetadataCodingKey
  125|       |    @brief The key used to encode the metadata instance variable for NSSecureCoding.
  126|       | */
  127|       |static NSString *const kMetadataCodingKey = @"metadata";
  128|       |
  129|       |/** @var kMissingUsersErrorMessage
  130|       |    @brief The error message when there is no users array in the getAccountInfo response.
  131|       | */
  132|       |static NSString *const kMissingUsersErrorMessage = @"users";
  133|       |
  134|       |/** @typedef CallbackWithError
  135|       |    @brief The type for a callback block that only takes an error parameter.
  136|       | */
  137|       |typedef void (^CallbackWithError)(NSError *_Nullable);
  138|       |
  139|       |/** @typedef CallbackWithUserAndError
  140|       |    @brief The type for a callback block that takes a user parameter and an error parameter.
  141|       | */
  142|       |typedef void (^CallbackWithUserAndError)(FIRUser *_Nullable, NSError *_Nullable);
  143|       |
  144|       |/** @typedef CallbackWithUserAndError
  145|       |    @brief The type for a callback block that takes a user parameter and an error parameter.
  146|       | */
  147|       |typedef void (^CallbackWithAuthDataResultAndError)(FIRAuthDataResult *_Nullable,
  148|       |                                                   NSError *_Nullable);
  149|       |
  150|       |/** @var kMissingPasswordReason
  151|       |    @brief The reason why the @c FIRAuthErrorCodeWeakPassword error is thrown.
  152|       |    @remarks This error message will be localized in the future.
  153|       | */
  154|       |static NSString *const kMissingPasswordReason = @"Missing Password";
  155|       |
  156|       |/** @fn callInMainThreadWithError
  157|       |    @brief Calls a callback in main thread with error.
  158|       |    @param callback The callback to be called in main thread.
  159|       |    @param error The error to pass to callback.
  160|       | */
  161|       |static void callInMainThreadWithError(_Nullable CallbackWithError callback,
  162|      0|                                      NSError *_Nullable error) {
  163|      0|  if (callback) {
  164|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  165|      0|      callback(error);
  166|      0|    });
  167|      0|  }
  168|      0|}
  169|       |
  170|       |/** @fn callInMainThreadWithUserAndError
  171|       |    @brief Calls a callback in main thread with user and error.
  172|       |    @param callback The callback to be called in main thread.
  173|       |    @param user The user to pass to callback if there is no error.
  174|       |    @param error The error to pass to callback.
  175|       | */
  176|       |static void callInMainThreadWithUserAndError(_Nullable CallbackWithUserAndError callback,
  177|       |                                             FIRUser *_Nonnull user,
  178|      0|                                             NSError *_Nullable error) {
  179|      0|  if (callback) {
  180|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  181|      0|      callback(error ? nil : user, error);
  182|      0|    });
  183|      0|  }
  184|      0|}
  185|       |
  186|       |/** @fn callInMainThreadWithUserAndError
  187|       |    @brief Calls a callback in main thread with user and error.
  188|       |    @param callback The callback to be called in main thread.
  189|       |    @param result The result to pass to callback if there is no error.
  190|       |    @param error The error to pass to callback.
  191|       | */
  192|       |static void callInMainThreadWithAuthDataResultAndError(
  193|       |    _Nullable CallbackWithAuthDataResultAndError callback,
  194|       |    FIRAuthDataResult *_Nullable result,
  195|      0|    NSError *_Nullable error) {
  196|      0|  if (callback) {
  197|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  198|      0|      callback(result, error);
  199|      0|    });
  200|      0|  }
  201|      0|}
  202|       |
  203|       |@interface FIRUserProfileChangeRequest ()
  204|       |
  205|       |/** @fn initWithUser:
  206|       |    @brief Designated initializer.
  207|       |    @param user The user for which we are updating profile information.
  208|       | */
  209|       |- (nullable instancetype)initWithUser:(FIRUser *)user NS_DESIGNATED_INITIALIZER;
  210|       |
  211|       |@end
  212|       |
  213|       |@interface FIRUser ()
  214|       |
  215|       |/** @property anonymous
  216|       | @brief Whether the current user is anonymous.
  217|       | */
  218|       |@property(nonatomic, readwrite) BOOL anonymous;
  219|       |
  220|       |@end
  221|       |
  222|       |@implementation FIRUser {
  223|       |  /** @var _hasEmailPasswordCredential
  224|       |      @brief Whether or not the user can be authenticated by using Firebase email and password.
  225|       |   */
  226|       |  BOOL _hasEmailPasswordCredential;
  227|       |
  228|       |  /** @var _providerData
  229|       |      @brief Provider specific user data.
  230|       |   */
  231|       |  NSDictionary<NSString *, FIRUserInfoImpl *> *_providerData;
  232|       |
  233|       |  /** @var _taskQueue
  234|       |      @brief Used to serialize the update profile calls.
  235|       |   */
  236|       |  FIRAuthSerialTaskQueue *_taskQueue;
  237|       |
  238|       |  /** @var _tokenService
  239|       |      @brief A secure token service associated with this user. For performing token exchanges and
  240|       |          refreshing access tokens.
  241|       |   */
  242|       |  FIRSecureTokenService *_tokenService;
  243|       |}
  244|       |
  245|       |#pragma mark - Properties
  246|       |
  247|       |// Explicitly @synthesize because these properties are defined in FIRUserInfo protocol.
  248|       |@synthesize uid = _userID;
  249|       |@synthesize displayName = _displayName;
  250|       |@synthesize photoURL = _photoURL;
  251|       |@synthesize email = _email;
  252|       |@synthesize phoneNumber = _phoneNumber;
  253|       |
  254|       |#pragma mark -
  255|       |
  256|       |+ (void)retrieveUserWithAuth:(FIRAuth *)auth
  257|       |                 accessToken:(nullable NSString *)accessToken
  258|       |   accessTokenExpirationDate:(nullable NSDate *)accessTokenExpirationDate
  259|       |                refreshToken:(nullable NSString *)refreshToken
  260|       |                   anonymous:(BOOL)anonymous
  261|      0|                    callback:(FIRRetrieveUserCallback)callback {
  262|      0|  FIRSecureTokenService *tokenService =
  263|      0|      [[FIRSecureTokenService alloc] initWithRequestConfiguration:auth.requestConfiguration
  264|      0|                                                      accessToken:accessToken
  265|      0|                                        accessTokenExpirationDate:accessTokenExpirationDate
  266|      0|                                                     refreshToken:refreshToken];
  267|      0|  FIRUser *user = [[self alloc] initWithTokenService:tokenService];
  268|      0|  user.auth = auth;
  269|      0|  user.requestConfiguration = auth.requestConfiguration;
  270|      0|  [user internalGetTokenWithCallback:^(NSString *_Nullable accessToken, NSError *_Nullable error) {
  271|      0|    if (error) {
  272|      0|      callback(nil, error);
  273|      0|      return;
  274|      0|    }
  275|      0|    FIRGetAccountInfoRequest *getAccountInfoRequest =
  276|      0|        [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
  277|      0|                                         requestConfiguration:auth.requestConfiguration];
  278|      0|    [FIRAuthBackend getAccountInfo:getAccountInfoRequest
  279|      0|                          callback:^(FIRGetAccountInfoResponse *_Nullable response,
  280|      0|                                     NSError *_Nullable error) {
  281|      0|      if (error) {
  282|      0|        // No need to sign out user here for errors because the user hasn't been signed in yet.
  283|      0|        callback(nil, error);
  284|      0|        return;
  285|      0|      }
  286|      0|      user.anonymous = anonymous;
  287|      0|      [user updateWithGetAccountInfoResponse:response];
  288|      0|      callback(user, nil);
  289|      0|    }];
  290|      0|  }];
  291|      0|}
  292|       |
  293|      0|- (instancetype)initWithTokenService:(FIRSecureTokenService *)tokenService {
  294|      0|  self = [super init];
  295|      0|  if (self) {
  296|      0|    _providerData = @{ };
  297|      0|    _taskQueue = [[FIRAuthSerialTaskQueue alloc] init];
  298|      0|    _tokenService = tokenService;
  299|      0|  }
  300|      0|  return self;
  301|      0|}
  302|       |
  303|       |#pragma mark - NSSecureCoding
  304|       |
  305|      0|+ (BOOL)supportsSecureCoding {
  306|      0|  return YES;
  307|      0|}
  308|       |
  309|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  310|      0|  NSString *userID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kUserIDCodingKey];
  311|      0|  BOOL hasAnonymousKey = [aDecoder containsValueForKey:kAnonymousCodingKey];
  312|      0|  BOOL anonymous = [aDecoder decodeBoolForKey:kAnonymousCodingKey];
  313|      0|  BOOL hasEmailPasswordCredential =
  314|      0|      [aDecoder decodeBoolForKey:kHasEmailPasswordCredentialCodingKey];
  315|      0|  NSString *displayName =
  316|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kDisplayNameCodingKey];
  317|      0|  NSURL *photoURL =
  318|      0|      [aDecoder decodeObjectOfClass:[NSURL class] forKey:kPhotoURLCodingKey];
  319|      0|  NSString *email =
  320|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kEmailCodingKey];
  321|      0|  NSString *phoneNumber =
  322|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kPhoneNumberCodingKey];
  323|      0|  BOOL emailVerified = [aDecoder decodeBoolForKey:kEmailVerifiedCodingKey];
  324|      0|  NSSet *providerDataClasses = [NSSet setWithArray:@[
  325|      0|      [NSDictionary class],
  326|      0|      [NSString class],
  327|      0|      [FIRUserInfoImpl class]
  328|      0|  ]];
  329|      0|  NSDictionary<NSString *, FIRUserInfoImpl *> *providerData =
  330|      0|      [aDecoder decodeObjectOfClasses:providerDataClasses forKey:kProviderDataKey];
  331|      0|  FIRSecureTokenService *tokenService =
  332|      0|      [aDecoder decodeObjectOfClass:[FIRSecureTokenService class] forKey:kTokenServiceCodingKey];
  333|      0|  FIRUserMetadata *metadata =
  334|      0|      [aDecoder decodeObjectOfClass:[FIRUserMetadata class] forKey:kMetadataCodingKey];
  335|      0|  NSString *APIKey =
  336|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kAPIKeyCodingKey];
  337|      0|  if (!userID || !tokenService) {
  338|      0|    return nil;
  339|      0|  }
  340|      0|  self = [self initWithTokenService:tokenService];
  341|      0|  if (self) {
  342|      0|    _userID = userID;
  343|      0|    // Previous version of this code didn't save 'anonymous' bit directly but deduced it from
  344|      0|    // 'hasEmailPasswordCredential' and 'providerData' instead, so here backward compatibility is
  345|      0|    // provided to read old format data.
  346|      0|    _anonymous = hasAnonymousKey ? anonymous : (!hasEmailPasswordCredential && !providerData.count);
  347|      0|    _hasEmailPasswordCredential = hasEmailPasswordCredential;
  348|      0|    _email = email;
  349|      0|    _emailVerified = emailVerified;
  350|      0|    _displayName = displayName;
  351|      0|    _photoURL = photoURL;
  352|      0|    _providerData = providerData;
  353|      0|    _phoneNumber = phoneNumber;
  354|      0|    _metadata = metadata ?: [[FIRUserMetadata alloc] initWithCreationDate:nil lastSignInDate:nil];
  355|      0|    _requestConfiguration = [[FIRAuthRequestConfiguration alloc] initWithAPIKey:APIKey];
  356|      0|  }
  357|      0|  return self;
  358|      0|}
  359|       |
  360|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  361|      0|  [aCoder encodeObject:_userID forKey:kUserIDCodingKey];
  362|      0|  [aCoder encodeBool:self.anonymous forKey:kAnonymousCodingKey];
  363|      0|  [aCoder encodeBool:_hasEmailPasswordCredential forKey:kHasEmailPasswordCredentialCodingKey];
  364|      0|  [aCoder encodeObject:_providerData forKey:kProviderDataKey];
  365|      0|  [aCoder encodeObject:_email forKey:kEmailCodingKey];
  366|      0|  [aCoder encodeObject:_phoneNumber forKey:kPhoneNumberCodingKey];
  367|      0|  [aCoder encodeBool:_emailVerified forKey:kEmailVerifiedCodingKey];
  368|      0|  [aCoder encodeObject:_photoURL forKey:kPhotoURLCodingKey];
  369|      0|  [aCoder encodeObject:_displayName forKey:kDisplayNameCodingKey];
  370|      0|  [aCoder encodeObject:_metadata forKey:kMetadataCodingKey];
  371|      0|  [aCoder encodeObject:_auth.requestConfiguration.APIKey forKey:kAPIKeyCodingKey];
  372|      0|  [aCoder encodeObject:_tokenService forKey:kTokenServiceCodingKey];
  373|      0|}
  374|       |
  375|       |#pragma mark -
  376|       |
  377|      0|- (void)setAuth:(nullable FIRAuth *)auth {
  378|      0|  _auth = auth;
  379|      0|  _tokenService.requestConfiguration = auth.requestConfiguration;
  380|      0|}
  381|       |
  382|      0|- (NSString *)providerID {
  383|      0|  return @"Firebase";
  384|      0|}
  385|       |
  386|      0|- (NSArray<id<FIRUserInfo>> *)providerData {
  387|      0|  return _providerData.allValues;
  388|      0|}
  389|       |
  390|       |/** @fn getAccountInfoRefreshingCache:
  391|       |    @brief Gets the users's account data from the server, updating our local values.
  392|       |    @param callback Invoked when the request to getAccountInfo has completed, or when an error has
  393|       |        been detected. Invoked asynchronously on the auth global work queue in the future.
  394|       | */
  395|       |- (void)getAccountInfoRefreshingCache:(void(^)(FIRGetAccountInfoResponseUser *_Nullable user,
  396|      0|                                               NSError *_Nullable error))callback {
  397|      0|  [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken, NSError *_Nullable error) {
  398|      0|    if (error) {
  399|      0|      callback(nil, error);
  400|      0|      return;
  401|      0|    }
  402|      0|    FIRGetAccountInfoRequest *getAccountInfoRequest =
  403|      0|        [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
  404|      0|                                         requestConfiguration:self->_auth.requestConfiguration];
  405|      0|    [FIRAuthBackend getAccountInfo:getAccountInfoRequest
  406|      0|                          callback:^(FIRGetAccountInfoResponse *_Nullable response,
  407|      0|                                     NSError *_Nullable error) {
  408|      0|      if (error) {
  409|      0|        [self signOutIfTokenIsInvalidWithError:error];
  410|      0|        callback(nil, error);
  411|      0|        return;
  412|      0|      }
  413|      0|      [self updateWithGetAccountInfoResponse:response];
  414|      0|      if (![self updateKeychain:&error]) {
  415|      0|        callback(nil, error);
  416|      0|        return;
  417|      0|      }
  418|      0|      callback(response.users.firstObject, nil);
  419|      0|    }];
  420|      0|  }];
  421|      0|}
  422|       |
  423|      0|- (void)updateWithGetAccountInfoResponse:(FIRGetAccountInfoResponse *)response {
  424|      0|  FIRGetAccountInfoResponseUser *user = response.users.firstObject;
  425|      0|  _userID = user.localID;
  426|      0|  _email = user.email;
  427|      0|  _emailVerified = user.emailVerified;
  428|      0|  _displayName = user.displayName;
  429|      0|  _photoURL = user.photoURL;
  430|      0|  _phoneNumber = user.phoneNumber;
  431|      0|  _hasEmailPasswordCredential = user.passwordHash.length > 0;
  432|      0|  _metadata =
  433|      0|      [[FIRUserMetadata alloc]initWithCreationDate:user.creationDate
  434|      0|                                    lastSignInDate:user.lastLoginDate];
  435|      0|  NSMutableDictionary<NSString *, FIRUserInfoImpl *> *providerData =
  436|      0|      [NSMutableDictionary dictionary];
  437|      0|  for (FIRGetAccountInfoResponseProviderUserInfo *providerUserInfo in user.providerUserInfo) {
  438|      0|    FIRUserInfoImpl *userInfo =
  439|      0|        [FIRUserInfoImpl userInfoWithGetAccountInfoResponseProviderUserInfo:providerUserInfo];
  440|      0|    if (userInfo) {
  441|      0|      providerData[providerUserInfo.providerID] = userInfo;
  442|      0|    }
  443|      0|  }
  444|      0|  _providerData = [providerData copy];
  445|      0|}
  446|       |
  447|       |/** @fn executeUserUpdateWithChanges:callback:
  448|       |    @brief Performs a setAccountInfo request by mutating the results of a getAccountInfo response,
  449|       |        atomically in regards to other calls to this method.
  450|       |    @param changeBlock A block responsible for mutating a template @c FIRSetAccountInfoRequest
  451|       |    @param callback A block to invoke when the change is complete. Invoked asynchronously on the
  452|       |        auth global work queue in the future.
  453|       | */
  454|       |- (void)executeUserUpdateWithChanges:(void(^)(FIRGetAccountInfoResponseUser *,
  455|       |                                              FIRSetAccountInfoRequest *))changeBlock
  456|      0|                            callback:(nonnull FIRUserProfileChangeCallback)callback {
  457|      0|  [_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock _Nonnull complete) {
  458|      0|    [self getAccountInfoRefreshingCache:^(FIRGetAccountInfoResponseUser *_Nullable user,
  459|      0|                                          NSError *_Nullable error) {
  460|      0|      if (error) {
  461|      0|        complete();
  462|      0|        callback(error);
  463|      0|        return;
  464|      0|      }
  465|      0|      [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  466|      0|                                           NSError *_Nullable error) {
  467|      0|        if (error) {
  468|      0|          complete();
  469|      0|          callback(error);
  470|      0|          return;
  471|      0|        }
  472|      0|        FIRAuthRequestConfiguration *configuration = self->_auth.requestConfiguration;
  473|      0|        // Mutate setAccountInfoRequest in block:
  474|      0|        FIRSetAccountInfoRequest *setAccountInfoRequest =
  475|      0|            [[FIRSetAccountInfoRequest alloc] initWithRequestConfiguration:configuration];
  476|      0|        setAccountInfoRequest.accessToken = accessToken;
  477|      0|        changeBlock(user, setAccountInfoRequest);
  478|      0|        // Execute request:
  479|      0|        [FIRAuthBackend setAccountInfo:setAccountInfoRequest
  480|      0|                              callback:^(FIRSetAccountInfoResponse *_Nullable response,
  481|      0|                                         NSError *_Nullable error) {
  482|      0|          if (error) {
  483|      0|            [self signOutIfTokenIsInvalidWithError:error];
  484|      0|            complete();
  485|      0|            callback(error);
  486|      0|            return;
  487|      0|          }
  488|      0|          if (response.IDToken && response.refreshToken) {
  489|      0|            FIRSecureTokenService *tokenService = [[FIRSecureTokenService alloc]
  490|      0|                initWithRequestConfiguration:configuration
  491|      0|                                 accessToken:response.IDToken
  492|      0|                   accessTokenExpirationDate:response.approximateExpirationDate
  493|      0|                                refreshToken:response.refreshToken];
  494|      0|            [self setTokenService:tokenService callback:^(NSError *_Nullable error) {
  495|      0|              complete();
  496|      0|              callback(error);
  497|      0|            }];
  498|      0|            return;
  499|      0|          }
  500|      0|          complete();
  501|      0|          callback(nil);
  502|      0|        }];
  503|      0|      }];
  504|      0|    }];
  505|      0|  }];
  506|      0|}
  507|       |
  508|       |/** @fn updateKeychain:
  509|       |    @brief Updates the keychain for user token or info changes.
  510|       |    @param error The error if NO is returned.
  511|       |    @return Whether the operation is successful.
  512|       | */
  513|      0|- (BOOL)updateKeychain:(NSError *_Nullable *_Nullable)error {
  514|      0|  return [_auth updateKeychainWithUser:self error:error];
  515|      0|}
  516|       |
  517|       |/** @fn setTokenService:callback:
  518|       |    @brief Sets a new token service for the @c FIRUser instance.
  519|       |    @param tokenService The new token service object.
  520|       |    @param callback The block to be called in the global auth working queue once finished.
  521|       |    @remarks The method makes sure the token service has access and refresh token and the new tokens
  522|       |        are saved in the keychain before calling back.
  523|       | */
  524|       |- (void)setTokenService:(FIRSecureTokenService *)tokenService
  525|      0|               callback:(nonnull CallbackWithError)callback {
  526|      0|  [tokenService fetchAccessTokenForcingRefresh:NO
  527|      0|                                      callback:^(NSString *_Nullable token,
  528|      0|                                                 NSError *_Nullable error,
  529|      0|                                                 BOOL tokenUpdated) {
  530|      0|    if (error) {
  531|      0|      callback(error);
  532|      0|      return;
  533|      0|    }
  534|      0|    self->_tokenService = tokenService;
  535|      0|    if (![self updateKeychain:&error]) {
  536|      0|      callback(error);
  537|      0|      return;
  538|      0|    }
  539|      0|    callback(nil);
  540|      0|  }];
  541|      0|}
  542|       |
  543|       |#pragma mark -
  544|       |
  545|       |/** @fn updateEmail:password:callback:
  546|       |    @brief Updates email address and/or password for the current user.
  547|       |    @remarks May fail if there is already an email/password-based account for the same email
  548|       |        address.
  549|       |    @param email The email address for the user, if to be updated.
  550|       |    @param password The new password for the user, if to be updated.
  551|       |    @param callback The block called when the user profile change has finished. Invoked
  552|       |        asynchronously on the auth global work queue in the future.
  553|       |    @remarks May fail with a @c FIRAuthErrorCodeRequiresRecentLogin error code.
  554|       |        Call @c reauthentateWithCredential:completion: beforehand to avoid this error case.
  555|       | */
  556|       |- (void)updateEmail:(nullable NSString *)email
  557|       |           password:(nullable NSString *)password
  558|      0|           callback:(nonnull FIRUserProfileChangeCallback)callback {
  559|      0|  if (password && ![password length]) {
  560|      0|    callback([FIRAuthErrorUtils weakPasswordErrorWithServerResponseReason:kMissingPasswordReason]);
  561|      0|    return;
  562|      0|  }
  563|      0|  BOOL hadEmailPasswordCredential = _hasEmailPasswordCredential;
  564|      0|  [self executeUserUpdateWithChanges:^(FIRGetAccountInfoResponseUser *user,
  565|      0|                                       FIRSetAccountInfoRequest *request) {
  566|      0|    if (email) {
  567|      0|      request.email = email;
  568|      0|    }
  569|      0|    if (password) {
  570|      0|      request.password = password;
  571|      0|    }
  572|      0|  }
  573|      0|                            callback:^(NSError *error) {
  574|      0|    if (error) {
  575|      0|      callback(error);
  576|      0|      return;
  577|      0|    }
  578|      0|    if (email) {
  579|      0|      self->_email = [email copy];
  580|      0|    }
  581|      0|    if (self->_email) {
  582|      0|      if (!hadEmailPasswordCredential) {
  583|      0|        // The list of providers need to be updated for the newly added email-password provider.
  584|      0|        [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  585|      0|                                             NSError *_Nullable error) {
  586|      0|          if (error) {
  587|      0|            callback(error);
  588|      0|            return;
  589|      0|          }
  590|      0|          FIRAuthRequestConfiguration *requestConfiguration = self->_auth.requestConfiguration;
  591|      0|          FIRGetAccountInfoRequest *getAccountInfoRequest =
  592|      0|              [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
  593|      0|                                               requestConfiguration:requestConfiguration];
  594|      0|          [FIRAuthBackend getAccountInfo:getAccountInfoRequest
  595|      0|                                callback:^(FIRGetAccountInfoResponse *_Nullable response,
  596|      0|                                           NSError *_Nullable error) {
  597|      0|            if (error) {
  598|      0|              [self signOutIfTokenIsInvalidWithError:error];
  599|      0|              callback(error);
  600|      0|              return;
  601|      0|            }
  602|      0|            for (FIRGetAccountInfoResponseUser *userAccountInfo in response.users) {
  603|      0|              // Set the account to non-anonymous if there are any providers, even if
  604|      0|              // they're not email/password ones.
  605|      0|              if (userAccountInfo.providerUserInfo.count > 0) {
  606|      0|                self.anonymous = NO;
  607|      0|              }
  608|      0|              for (FIRGetAccountInfoResponseProviderUserInfo *providerUserInfo in
  609|      0|                   userAccountInfo.providerUserInfo) {
  610|      0|                if ([providerUserInfo.providerID isEqualToString:FIREmailAuthProviderID]) {
  611|      0|                  self->_hasEmailPasswordCredential = YES;
  612|      0|                  break;
  613|      0|                }
  614|      0|              }
  615|      0|            }
  616|      0|            [self updateWithGetAccountInfoResponse:response];
  617|      0|            if (![self updateKeychain:&error]) {
  618|      0|              callback(error);
  619|      0|              return;
  620|      0|            }
  621|      0|            callback(nil);
  622|      0|          }];
  623|      0|        }];
  624|      0|        return;
  625|      0|      }
  626|      0|    }
  627|      0|    if (![self updateKeychain:&error]) {
  628|      0|      callback(error);
  629|      0|      return;
  630|      0|    }
  631|      0|    callback(nil);
  632|      0|  }];
  633|      0|}
  634|       |
  635|      0|- (void)updateEmail:(NSString *)email completion:(nullable FIRUserProfileChangeCallback)completion {
  636|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  637|      0|    [self updateEmail:email password:nil callback:^(NSError *_Nullable error) {
  638|      0|      callInMainThreadWithError(completion, error);
  639|      0|    }];
  640|      0|  });
  641|      0|}
  642|       |
  643|       |- (void)updatePassword:(NSString *)password
  644|      0|            completion:(nullable FIRUserProfileChangeCallback)completion {
  645|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  646|      0|    [self updateEmail:nil password:password callback:^(NSError *_Nullable error){
  647|      0|      callInMainThreadWithError(completion, error);
  648|      0|    }];
  649|      0|  });
  650|      0|}
  651|       |
  652|       |#if TARGET_OS_IOS
  653|       |/** @fn internalUpdateOrLinkPhoneNumberCredential:completion:
  654|       |    @brief Updates the phone number for the user. On success, the cached user profile data is
  655|       |        updated.
  656|       |
  657|       |    @param phoneAuthCredential The new phone number credential corresponding to the phone number
  658|       |        to be added to the Firebase account, if a phone number is already linked to the account this
  659|       |        new phone number will replace it.
  660|       |    @param isLinkOperation Boolean value indicating whether or not this is a link operation.
  661|       |    @param completion Optionally; the block invoked when the user profile change has finished.
  662|       |        Invoked asynchronously on the global work queue in the future.
  663|       | */
  664|       |- (void)internalUpdateOrLinkPhoneNumberCredential:(FIRPhoneAuthCredential *)phoneAuthCredential
  665|       |                                  isLinkOperation:(BOOL)isLinkOperation
  666|      0|                                       completion:(FIRUserProfileChangeCallback)completion {
  667|      0|  [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  668|      0|                                       NSError *_Nullable error) {
  669|      0|    if (error) {
  670|      0|      completion(error);
  671|      0|      return;
  672|      0|    }
  673|      0|    FIRAuthOperationType operation =
  674|      0|        isLinkOperation ? FIRAuthOperationTypeLink : FIRAuthOperationTypeUpdate;
  675|      0|    FIRVerifyPhoneNumberRequest *request = [[FIRVerifyPhoneNumberRequest alloc]
  676|      0|        initWithVerificationID:phoneAuthCredential.verificationID
  677|      0|              verificationCode:phoneAuthCredential.verificationCode
  678|      0|                     operation:operation
  679|      0|          requestConfiguration:self->_auth.requestConfiguration];
  680|      0|    request.accessToken = accessToken;
  681|      0|    [FIRAuthBackend verifyPhoneNumber:request
  682|      0|                             callback:^(FIRVerifyPhoneNumberResponse *_Nullable response,
  683|      0|                                        NSError *_Nullable error) {
  684|      0|      if (error) {
  685|      0|        [self signOutIfTokenIsInvalidWithError:error];
  686|      0|        completion(error);
  687|      0|        return;
  688|      0|      }
  689|      0|      // Get account info to update cached user info.
  690|      0|      [self getAccountInfoRefreshingCache:^(FIRGetAccountInfoResponseUser *_Nullable user,
  691|      0|                                            NSError *_Nullable error) {
  692|      0|        if (error) {
  693|      0|          [self signOutIfTokenIsInvalidWithError:error];
  694|      0|          completion(error);
  695|      0|          return;
  696|      0|        }
  697|      0|        self.anonymous = NO;
  698|      0|        if (![self updateKeychain:&error]) {
  699|      0|          completion(error);
  700|      0|          return;
  701|      0|        }
  702|      0|        completion(nil);
  703|      0|      }];
  704|      0|    }];
  705|      0|  }];
  706|      0|}
  707|       |
  708|       |- (void)updatePhoneNumberCredential:(FIRPhoneAuthCredential *)phoneAuthCredential
  709|      0|                         completion:(nullable FIRUserProfileChangeCallback)completion {
  710|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  711|      0|    [self internalUpdateOrLinkPhoneNumberCredential:phoneAuthCredential
  712|      0|                                    isLinkOperation:NO
  713|      0|                                         completion:^(NSError *_Nullable error) {
  714|      0|       callInMainThreadWithError(completion, error);
  715|      0|    }];
  716|      0|  });
  717|      0|}
  718|       |#endif
  719|       |
  720|      0|- (FIRUserProfileChangeRequest *)profileChangeRequest {
  721|      0|  __block FIRUserProfileChangeRequest *result;
  722|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
  723|      0|    result = [[FIRUserProfileChangeRequest alloc] initWithUser:self];
  724|      0|  });
  725|      0|  return result;
  726|      0|}
  727|       |
  728|      0|- (void)setDisplayName:(NSString *)displayName {
  729|      0|  _displayName = [displayName copy];
  730|      0|}
  731|       |
  732|      0|- (void)setPhotoURL:(NSURL *)photoURL {
  733|      0|  _photoURL = [photoURL copy];
  734|      0|}
  735|       |
  736|      0|- (NSString *)rawAccessToken {
  737|      0|  return _tokenService.rawAccessToken;
  738|      0|}
  739|       |
  740|      0|- (NSDate *)accessTokenExpirationDate {
  741|      0|  return _tokenService.accessTokenExpirationDate;
  742|      0|}
  743|       |
  744|       |#pragma mark -
  745|       |
  746|      0|- (void)reloadWithCompletion:(nullable FIRUserProfileChangeCallback)completion {
  747|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  748|      0|    [self getAccountInfoRefreshingCache:^(FIRGetAccountInfoResponseUser *_Nullable user,
  749|      0|                                          NSError *_Nullable error) {
  750|      0|      callInMainThreadWithError(completion, error);
  751|      0|    }];
  752|      0|  });
  753|      0|}
  754|       |
  755|       |#pragma mark -
  756|       |
  757|       |#pragma clang diagnostic push
  758|       |#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  759|       |- (void)reauthenticateWithCredential:(FIRAuthCredential *) credential
  760|      0|                                         completion:(nullable FIRAuthDataResultCallback) completion {
  761|      0|  [self reauthenticateAndRetrieveDataWithCredential:credential completion:completion];
  762|      0|}
  763|       |#pragma clang diagnostic pop
  764|       |
  765|       |- (void)reauthenticateAndRetrieveDataWithCredential:(FIRAuthCredential *) credential
  766|      0|                                         completion:(nullable FIRAuthDataResultCallback) completion {
  767|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  768|      0|    [self->_auth internalSignInAndRetrieveDataWithCredential:credential
  769|      0|                                          isReauthentication:YES
  770|      0|                                                    callback:^(FIRAuthDataResult *_Nullable
  771|      0|                                                               authResult,
  772|      0|                                                               NSError *_Nullable error) {
  773|      0|      if (error) {
  774|      0|        // If "user not found" error returned by backend, translate to user mismatch error which is
  775|      0|        // more accurate.
  776|      0|        if (error.code == FIRAuthErrorCodeUserNotFound) {
  777|      0|          error = [FIRAuthErrorUtils userMismatchError];
  778|      0|        }
  779|      0|        callInMainThreadWithAuthDataResultAndError(completion, authResult, error);
  780|      0|        return;
  781|      0|      }
  782|      0|      if (![authResult.user.uid isEqual:[self->_auth getUserID]]) {
  783|      0|        callInMainThreadWithAuthDataResultAndError(completion, authResult,
  784|      0|                                                   [FIRAuthErrorUtils userMismatchError]);
  785|      0|        return;
  786|      0|      }
  787|      0|      // Successful reauthenticate
  788|      0|      [self setTokenService:authResult.user->_tokenService callback:^(NSError *_Nullable error) {
  789|      0|        callInMainThreadWithAuthDataResultAndError(completion, authResult, error);
  790|      0|      }];
  791|      0|    }];
  792|      0|  });
  793|      0|}
  794|       |
  795|       |- (void)reauthenticateWithProvider:(id<FIRFederatedAuthProvider>)provider
  796|       |                        UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  797|      0|                        completion:(nullable FIRAuthDataResultCallback)completion {
  798|      0|#if TARGET_OS_IOS
  799|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  800|      0|    [provider getCredentialWithUIDelegate:UIDelegate
  801|      0|                               completion:^(FIRAuthCredential *_Nullable credential,
  802|      0|                                            NSError *_Nullable error) {
  803|      0|                                 [self reauthenticateWithCredential:credential
  804|      0|                                                         completion:completion];
  805|      0|                               }];
  806|      0|  });
  807|      0|#endif  // TARGET_OS_IOS
  808|      0|}
  809|       |
  810|      0|- (nullable NSString *)refreshToken {
  811|      0|  __block NSString *result;
  812|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
  813|      0|    result = self->_tokenService.refreshToken;
  814|      0|  });
  815|      0|  return result;
  816|      0|}
  817|       |
  818|      0|- (void)getIDTokenWithCompletion:(nullable FIRAuthTokenCallback)completion {
  819|      0|  // |getIDTokenForcingRefresh:completion:| is also a public API so there is no need to dispatch to
  820|      0|  // global work queue here.
  821|      0|  [self getIDTokenForcingRefresh:NO completion:completion];
  822|      0|}
  823|       |
  824|       |- (void)getIDTokenForcingRefresh:(BOOL)forceRefresh
  825|      0|                      completion:(nullable FIRAuthTokenCallback)completion {
  826|      0|  [self getIDTokenResultForcingRefresh:forceRefresh
  827|      0|                            completion:^(FIRAuthTokenResult *_Nullable tokenResult,
  828|      0|                                         NSError *_Nullable error) {
  829|      0|
  830|      0|    if (completion) {
  831|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  832|      0|        completion(tokenResult.token, error);
  833|      0|      });
  834|      0|    }
  835|      0|  }];
  836|      0|}
  837|       |
  838|      0|- (void)getIDTokenResultWithCompletion:(nullable FIRAuthTokenResultCallback)completion {
  839|      0|  [self getIDTokenResultForcingRefresh:NO
  840|      0|                            completion:^(FIRAuthTokenResult *_Nullable tokenResult,
  841|      0|                                         NSError *_Nullable error) {
  842|      0|    if (completion) {
  843|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  844|      0|        completion(tokenResult, error);
  845|      0|      });
  846|      0|    }
  847|      0|  }];
  848|      0|}
  849|       |
  850|       |- (void)getIDTokenResultForcingRefresh:(BOOL)forceRefresh
  851|      0|                            completion:(nullable FIRAuthTokenResultCallback)completion {
  852|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  853|      0|    [self internalGetTokenForcingRefresh:forceRefresh
  854|      0|                                callback:^(NSString *_Nullable token, NSError *_Nullable error) {
  855|      0|      FIRAuthTokenResult *tokenResult;
  856|      0|      if (token) {
  857|      0|        tokenResult = [self parseIDToken:token error:&error];
  858|      0|      }
  859|      0|      if (completion) {
  860|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  861|      0|          completion(tokenResult, error);
  862|      0|        });
  863|      0|      }
  864|      0|    }];
  865|      0|  });
  866|      0|}
  867|       |
  868|       |/** @fn parseIDToken:error:
  869|       |    @brief Parses the provided IDToken and returns an instance of FIRAuthTokenResult containing
  870|       |        claims obtained from the IDToken.
  871|       |
  872|       |    @param token The raw text of the Firebase IDToken encoded in base64.
  873|       |    @param error An out parameter which would contain any error that occurs during parsing.
  874|       |    @return An instance of FIRAuthTokenResult containing claims obtained from the IDToken.
  875|       |
  876|       |    @remarks IDToken returned from the backend in some cases is of a length that is not a multiple
  877|       |        of 4. In these cases this function pads the token with as many "=" characters as needed and
  878|       |        then attempts to parse the token. If the token cannot be parsed an error is returned via the
  879|       |        "error" out parameter.
  880|       | */
  881|      0|- (nullable FIRAuthTokenResult *)parseIDToken:(NSString *)token error:(NSError **)error {
  882|      0|  // Though this is an internal method, errors returned here are surfaced in user-visible
  883|      0|  // callbacks.
  884|      0|  if (error) {
  885|      0|    *error = nil;
  886|      0|  }
  887|      0|  NSArray *tokenStringArray = [token componentsSeparatedByString:@"."];
  888|      0|
  889|      0|  // The JWT should have three parts, though we only use the second in this method.
  890|      0|  if (tokenStringArray.count != 3) {
  891|      0|    if (error) {
  892|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:nil];
  893|      0|    }
  894|      0|    return nil;
  895|      0|  }
  896|      0|
  897|      0|  // The token payload is always the second index of the array.
  898|      0|  NSString *idToken = tokenStringArray[1];
  899|      0|
  900|      0|  // Convert the base64URL encoded string to a base64 encoded string.
  901|      0|  // Replace "_" with "/"
  902|      0|  NSMutableString *tokenPayload =
  903|      0|      [[idToken stringByReplacingOccurrencesOfString:@"_" withString:@"/"] mutableCopy];
  904|      0|
  905|      0|  // Replace "-" with "+"
  906|      0|  [tokenPayload replaceOccurrencesOfString:@"-"
  907|      0|                                withString:@"+"
  908|      0|                                   options:kNilOptions
  909|      0|                                     range:NSMakeRange(0, tokenPayload.length)];
  910|      0|
  911|      0|  // Pad the token payload with "=" signs if the payload's length is not a multiple of 4.
  912|      0|  while ((tokenPayload.length % 4) != 0) {
  913|      0|    [tokenPayload appendFormat:@"="];
  914|      0|  }
  915|      0|  NSData *decodedTokenPayloadData =
  916|      0|      [[NSData alloc] initWithBase64EncodedString:tokenPayload
  917|      0|                                          options:NSDataBase64DecodingIgnoreUnknownCharacters];
  918|      0|  if (!decodedTokenPayloadData) {
  919|      0|    if (error) {
  920|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:nil];
  921|      0|    }
  922|      0|    return nil;
  923|      0|  }
  924|      0|  NSError *jsonError = nil;
  925|      0|  NSJSONReadingOptions options = NSJSONReadingMutableContainers|NSJSONReadingAllowFragments;
  926|      0|  NSDictionary *tokenPayloadDictionary =
  927|      0|      [NSJSONSerialization JSONObjectWithData:decodedTokenPayloadData
  928|      0|                                      options:options
  929|      0|                                        error:&jsonError];
  930|      0|  if (jsonError != nil) {
  931|      0|    if (error) {
  932|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:jsonError];
  933|      0|    }
  934|      0|    return nil;
  935|      0|  }
  936|      0|
  937|      0|  if (!tokenPayloadDictionary) {
  938|      0|    if (error) {
  939|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:nil];
  940|      0|    }
  941|      0|    return nil;
  942|      0|  }
  943|      0|
  944|      0|  // These are dates since 00:00:00 January 1 1970, as described by the Terminology section in
  945|      0|  // the JWT spec. https://tools.ietf.org/html/rfc7519
  946|      0|  NSDate *expDate =
  947|      0|      [NSDate dateWithTimeIntervalSince1970:[tokenPayloadDictionary[@"exp"] doubleValue]];
  948|      0|  NSDate *authDate =
  949|      0|      [NSDate dateWithTimeIntervalSince1970:[tokenPayloadDictionary[@"auth_time"] doubleValue]];
  950|      0|  NSDate *issuedDate =
  951|      0|      [NSDate dateWithTimeIntervalSince1970:[tokenPayloadDictionary[@"iat"] doubleValue]];
  952|      0|  FIRAuthTokenResult *result =
  953|      0|     [[FIRAuthTokenResult alloc] initWithToken:token
  954|      0|                                expirationDate:expDate
  955|      0|                                      authDate:authDate
  956|      0|                                  issuedAtDate:issuedDate
  957|      0|                                signInProvider:tokenPayloadDictionary[@"firebase"][@"sign_in_provider"]
  958|      0|                                        claims:tokenPayloadDictionary];
  959|      0|  return result;
  960|      0|}
  961|       |
  962|       |/** @fn internalGetTokenForcingRefresh:callback:
  963|       |    @brief Retrieves the Firebase authentication token, possibly refreshing it if it has expired.
  964|       |    @param callback The block to invoke when the token is available. Invoked asynchronously on the
  965|       |        global work thread in the future.
  966|       | */
  967|      0|- (void)internalGetTokenWithCallback:(nonnull FIRAuthTokenCallback)callback {
  968|      0|  [self internalGetTokenForcingRefresh:NO callback:callback];
  969|      0|}
  970|       |
  971|       |- (void)internalGetTokenForcingRefresh:(BOOL)forceRefresh
  972|      0|                              callback:(nonnull FIRAuthTokenCallback)callback {
  973|      0|  [_tokenService fetchAccessTokenForcingRefresh:forceRefresh
  974|      0|                                       callback:^(NSString *_Nullable token,
  975|      0|                                                  NSError *_Nullable error,
  976|      0|                                                  BOOL tokenUpdated) {
  977|      0|    if (error) {
  978|      0|      [self signOutIfTokenIsInvalidWithError:error];
  979|      0|      callback(nil, error);
  980|      0|      return;
  981|      0|    }
  982|      0|    if (tokenUpdated) {
  983|      0|      if (![self updateKeychain:&error]) {
  984|      0|        callback(nil, error);
  985|      0|        return;
  986|      0|      }
  987|      0|    }
  988|      0|    callback(token, nil);
  989|      0|  }];
  990|      0|}
  991|       |
  992|       |- (void)internalVerifyBeforeUpdateEmailWithNewEmail:(NSString *)newEmail
  993|       |    actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  994|      0|    completion:(FIRVerifyBeforeUpdateEmailCallback)completion {
  995|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  996|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  997|      0|                                         NSError *_Nullable error) {
  998|      0|      if (error) {
  999|      0|        callInMainThreadWithError(completion, error);
 1000|      0|        return;
 1001|      0|      }
 1002|      0|      FIRAuthRequestConfiguration *configuration = self->_auth.requestConfiguration;
 1003|      0|      FIRActionCodeSettings *settings = actionCodeSettings;
 1004|      0|      FIRGetOOBConfirmationCodeRequest *request =
 1005|      0|          [FIRGetOOBConfirmationCodeRequest verifyBeforeUpdateEmailWithAccessToken:accessToken
 1006|      0|                                                                          newEmail:newEmail
 1007|      0|                                                                actionCodeSettings:settings
 1008|      0|                                                              requestConfiguration:configuration];
 1009|      0|      [FIRAuthBackend getOOBConfirmationCode:request
 1010|      0|                                    callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable
 1011|      0|                                                   response,
 1012|      0|                                               NSError *_Nullable error) {
 1013|      0|        callInMainThreadWithError(completion, error);
 1014|      0|      }];
 1015|      0|    }];
 1016|      0|  });
 1017|      0|}
 1018|       |
 1019|       |#pragma clang diagnostic push
 1020|       |#pragma clang diagnostic ignored "-Wdeprecated-declarations"
 1021|       |- (void)linkWithCredential:(FIRAuthCredential *)credential
 1022|      0|                completion:(nullable FIRAuthDataResultCallback)completion {
 1023|      0|  [self linkAndRetrieveDataWithCredential:credential completion:completion];
 1024|      0|}
 1025|       |#pragma clang diagnostic pop
 1026|       |
 1027|       |- (void)linkAndRetrieveDataWithCredential:(FIRAuthCredential *)credential
 1028|      0|                               completion:(nullable FIRAuthDataResultCallback)completion {
 1029|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1030|      0|    if (self->_providerData[credential.provider]) {
 1031|      0|      callInMainThreadWithAuthDataResultAndError(completion,
 1032|      0|                                                 nil,
 1033|      0|                                                 [FIRAuthErrorUtils providerAlreadyLinkedError]);
 1034|      0|      return;
 1035|      0|    }
 1036|      0|    FIRAuthDataResult *result =
 1037|      0|        [[FIRAuthDataResult alloc] initWithUser:self additionalUserInfo:nil];
 1038|      0|    if ([credential isKindOfClass:[FIREmailPasswordAuthCredential class]]) {
 1039|      0|      if (self->_hasEmailPasswordCredential) {
 1040|      0|        callInMainThreadWithAuthDataResultAndError(completion,
 1041|      0|                                                   nil,
 1042|      0|                                                   [FIRAuthErrorUtils providerAlreadyLinkedError]);
 1043|      0|        return;
 1044|      0|      }
 1045|      0|      FIREmailPasswordAuthCredential *emailPasswordCredential =
 1046|      0|          (FIREmailPasswordAuthCredential *)credential;
 1047|      0|      if (emailPasswordCredential.password) {
 1048|      0|        [self updateEmail:emailPasswordCredential.email
 1049|      0|                 password:emailPasswordCredential.password
 1050|      0|                 callback:^(NSError *error) {
 1051|      0|                   if (error) {
 1052|      0|                     callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1053|      0|                   } else {
 1054|      0|                     callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1055|      0|                   }
 1056|      0|                 }];
 1057|      0|      } else {
 1058|      0|        [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1059|      0|                                             NSError *_Nullable error) {
 1060|      0|          NSDictionary<NSString *, NSString *> *queryItems = [FIRAuthWebUtils parseURL:emailPasswordCredential.link];
 1061|      0|          if (![queryItems count]) {
 1062|      0|            NSURLComponents *urlComponents = [NSURLComponents componentsWithString:emailPasswordCredential.link];
 1063|      0|            queryItems = [FIRAuthWebUtils parseURL:urlComponents.query];
 1064|      0|          }
 1065|      0|          NSString *actionCode = queryItems[@"oobCode"];
 1066|      0|          FIRAuthRequestConfiguration *requestConfiguration = self.auth.requestConfiguration;
 1067|      0|          FIREmailLinkSignInRequest *request =
 1068|      0|          [[FIREmailLinkSignInRequest alloc] initWithEmail:emailPasswordCredential.email
 1069|      0|                                                   oobCode:actionCode
 1070|      0|                                      requestConfiguration:requestConfiguration];
 1071|      0|          request.IDToken = accessToken;
 1072|      0|          [FIRAuthBackend emailLinkSignin:request
 1073|      0|                                 callback:^(FIREmailLinkSignInResponse *_Nullable response,
 1074|      0|                                            NSError *_Nullable error) {
 1075|      0|             if (error){
 1076|      0|               callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1077|      0|             } else {
 1078|      0|               [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1079|      0|                                                    NSError *_Nullable error) {
 1080|      0|                 if (error) {
 1081|      0|                   callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1082|      0|                   return;
 1083|      0|                 }
 1084|      0|
 1085|      0|                 FIRGetAccountInfoRequest *getAccountInfoRequest =
 1086|      0|                 [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
 1087|      0|                                                  requestConfiguration:requestConfiguration];
 1088|      0|                 [FIRAuthBackend getAccountInfo:getAccountInfoRequest
 1089|      0|                                       callback:^(FIRGetAccountInfoResponse *_Nullable response,
 1090|      0|                                                  NSError *_Nullable error) {
 1091|      0|                   if (error) {
 1092|      0|                     [self signOutIfTokenIsInvalidWithError:error];
 1093|      0|                     callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1094|      0|                     return;
 1095|      0|                   }
 1096|      0|                   self.anonymous = NO;
 1097|      0|                   [self updateWithGetAccountInfoResponse:response];
 1098|      0|                   if (![self updateKeychain:&error]) {
 1099|      0|                     callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1100|      0|                     return;
 1101|      0|                   }
 1102|      0|                   callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1103|      0|                 }];
 1104|      0|               }];
 1105|      0|             }
 1106|      0|           }];
 1107|      0|        }];
 1108|      0|      }
 1109|      0|      return;
 1110|      0|    }
 1111|      0|
 1112|      0|    if ([credential isKindOfClass:[FIRGameCenterAuthCredential class]]) {
 1113|      0|      FIRGameCenterAuthCredential *gameCenterCredential = (FIRGameCenterAuthCredential *)credential;
 1114|      0|      [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1115|      0|                                           NSError *_Nullable error) {
 1116|      0|        FIRAuthRequestConfiguration *requestConfiguration = self.auth.requestConfiguration;
 1117|      0|        FIRSignInWithGameCenterRequest *gameCenterRequest =
 1118|      0|        [[FIRSignInWithGameCenterRequest alloc] initWithPlayerID:gameCenterCredential.playerID
 1119|      0|                                                    publicKeyURL:gameCenterCredential.publicKeyURL
 1120|      0|                                                       signature:gameCenterCredential.signature
 1121|      0|                                                            salt:gameCenterCredential.salt
 1122|      0|                                                       timestamp:gameCenterCredential.timestamp
 1123|      0|                                                     displayName:gameCenterCredential.displayName
 1124|      0|                                            requestConfiguration:requestConfiguration];
 1125|      0|        gameCenterRequest.accessToken = accessToken;
 1126|      0|
 1127|      0|        [FIRAuthBackend signInWithGameCenter:gameCenterRequest
 1128|      0|                                    callback:^(FIRSignInWithGameCenterResponse *_Nullable response,
 1129|      0|                                               NSError *_Nullable error) {
 1130|      0|          if (error){
 1131|      0|            callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1132|      0|          } else {
 1133|      0|            [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1134|      0|                                                 NSError *_Nullable error) {
 1135|      0|              if (error) {
 1136|      0|                callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1137|      0|                return;
 1138|      0|              }
 1139|      0|
 1140|      0|              FIRGetAccountInfoRequest *getAccountInfoRequest =
 1141|      0|              [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
 1142|      0|                                               requestConfiguration:requestConfiguration];
 1143|      0|              [FIRAuthBackend getAccountInfo:getAccountInfoRequest
 1144|      0|                                    callback:^(FIRGetAccountInfoResponse *_Nullable response,
 1145|      0|                                               NSError *_Nullable error) {
 1146|      0|                                      if (error) {
 1147|      0|                                        [self signOutIfTokenIsInvalidWithError:error];
 1148|      0|                                        callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1149|      0|                                        return;
 1150|      0|                                      }
 1151|      0|                                      self.anonymous = NO;
 1152|      0|                                      [self updateWithGetAccountInfoResponse:response];
 1153|      0|                                      if (![self updateKeychain:&error]) {
 1154|      0|                                        callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1155|      0|                                        return;
 1156|      0|                                      }
 1157|      0|                                      callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1158|      0|                                    }];
 1159|      0|            }];
 1160|      0|          }
 1161|      0|        }];
 1162|      0|      }];
 1163|      0|      return;
 1164|      0|    }
 1165|      0|
 1166|      0|    #if TARGET_OS_IOS
 1167|      0|    if ([credential isKindOfClass:[FIRPhoneAuthCredential class]]) {
 1168|      0|      FIRPhoneAuthCredential *phoneAuthCredential = (FIRPhoneAuthCredential *)credential;
 1169|      0|      [self internalUpdateOrLinkPhoneNumberCredential:phoneAuthCredential
 1170|      0|                                      isLinkOperation:YES
 1171|      0|                                           completion:^(NSError *_Nullable error) {
 1172|      0|        if (error){
 1173|      0|          callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1174|      0|        } else {
 1175|      0|          callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1176|      0|        }
 1177|      0|      }];
 1178|      0|      return;
 1179|      0|    }
 1180|      0|    #endif
 1181|      0|
 1182|      0|    [self->_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock _Nonnull complete) {
 1183|      0|      CallbackWithAuthDataResultAndError completeWithError =
 1184|      0|          ^(FIRAuthDataResult *result, NSError *error) {
 1185|      0|        complete();
 1186|      0|        callInMainThreadWithAuthDataResultAndError(completion, result, error);
 1187|      0|      };
 1188|      0|      [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1189|      0|                                           NSError *_Nullable error) {
 1190|      0|        if (error) {
 1191|      0|          completeWithError(nil, error);
 1192|      0|          return;
 1193|      0|        }
 1194|      0|        FIRAuthRequestConfiguration *requestConfiguration = self->_auth.requestConfiguration;
 1195|      0|        FIRVerifyAssertionRequest *request =
 1196|      0|            [[FIRVerifyAssertionRequest alloc] initWithProviderID:credential.provider
 1197|      0|                                             requestConfiguration:requestConfiguration];
 1198|      0|        [credential prepareVerifyAssertionRequest:request];
 1199|      0|        request.accessToken = accessToken;
 1200|      0|        [FIRAuthBackend verifyAssertion:request
 1201|      0|                               callback:^(FIRVerifyAssertionResponse *response, NSError *error) {
 1202|      0|          if (error) {
 1203|      0|            [self signOutIfTokenIsInvalidWithError:error];
 1204|      0|            completeWithError(nil, error);
 1205|      0|            return;
 1206|      0|          }
 1207|      0|          FIRAdditionalUserInfo *additionalUserInfo =
 1208|      0|              [FIRAdditionalUserInfo userInfoWithVerifyAssertionResponse:response];
 1209|      0|          FIROAuthCredential *updatedOAuthCredential =
 1210|      0|              [[FIROAuthCredential alloc] initWithVerifyAssertionResponse:response];
 1211|      0|          FIRAuthDataResult *result =
 1212|      0|              [[FIRAuthDataResult alloc] initWithUser:self
 1213|      0|                                   additionalUserInfo:additionalUserInfo
 1214|      0|                                           credential:updatedOAuthCredential];
 1215|      0|          // Update the new token and refresh user info again.
 1216|      0|          self->_tokenService = [[FIRSecureTokenService alloc]
 1217|      0|              initWithRequestConfiguration:requestConfiguration
 1218|      0|                               accessToken:response.IDToken
 1219|      0|                 accessTokenExpirationDate:response.approximateExpirationDate
 1220|      0|                              refreshToken:response.refreshToken];
 1221|      0|          [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1222|      0|                                               NSError *_Nullable error) {
 1223|      0|            if (error) {
 1224|      0|              completeWithError(nil, error);
 1225|      0|              return;
 1226|      0|            }
 1227|      0|            FIRGetAccountInfoRequest *getAccountInfoRequest =
 1228|      0|                [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
 1229|      0|                                                 requestConfiguration:requestConfiguration];
 1230|      0|            [FIRAuthBackend getAccountInfo:getAccountInfoRequest
 1231|      0|                                  callback:^(FIRGetAccountInfoResponse *_Nullable response,
 1232|      0|                                             NSError *_Nullable error) {
 1233|      0|              if (error) {
 1234|      0|                [self signOutIfTokenIsInvalidWithError:error];
 1235|      0|                completeWithError(nil, error);
 1236|      0|                return;
 1237|      0|              }
 1238|      0|              self.anonymous = NO;
 1239|      0|              [self updateWithGetAccountInfoResponse:response];
 1240|      0|              if (![self updateKeychain:&error]) {
 1241|      0|                completeWithError(nil, error);
 1242|      0|                return;
 1243|      0|              }
 1244|      0|              completeWithError(result, nil);
 1245|      0|            }];
 1246|      0|          }];
 1247|      0|        }];
 1248|      0|      }];
 1249|      0|    }];
 1250|      0|  });
 1251|      0|}
 1252|       |
 1253|       |- (void)linkWithProvider:(id<FIRFederatedAuthProvider>)provider
 1254|       |              UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
 1255|      0|              completion:(nullable FIRAuthDataResultCallback)completion {
 1256|      0|#if TARGET_OS_IOS
 1257|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1258|      0|    [provider getCredentialWithUIDelegate:UIDelegate
 1259|      0|                               completion:^(FIRAuthCredential *_Nullable credential,
 1260|      0|                                            NSError *_Nullable error) {
 1261|      0|                                 [self linkWithCredential:credential
 1262|      0|                                               completion:completion];
 1263|      0|                               }];
 1264|      0|  });
 1265|      0|#endif  // TARGET_OS_IOS
 1266|      0|}
 1267|       |
 1268|       |- (void)unlinkFromProvider:(NSString *)provider
 1269|      0|                completion:(nullable FIRAuthResultCallback)completion {
 1270|      0|  [_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock _Nonnull complete) {
 1271|      0|    CallbackWithError completeAndCallbackWithError = ^(NSError *error) {
 1272|      0|      complete();
 1273|      0|      callInMainThreadWithUserAndError(completion, self, error);
 1274|      0|    };
 1275|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1276|      0|                                         NSError *_Nullable error) {
 1277|      0|      if (error) {
 1278|      0|        completeAndCallbackWithError(error);
 1279|      0|        return;
 1280|      0|      }
 1281|      0|      FIRAuthRequestConfiguration *requestConfiguration = self->_auth.requestConfiguration;
 1282|      0|      FIRSetAccountInfoRequest *setAccountInfoRequest =
 1283|      0|          [[FIRSetAccountInfoRequest alloc] initWithRequestConfiguration:requestConfiguration];
 1284|      0|      setAccountInfoRequest.accessToken = accessToken;
 1285|      0|
 1286|      0|      if (!self->_providerData[provider]) {
 1287|      0|        completeAndCallbackWithError([FIRAuthErrorUtils noSuchProviderError]);
 1288|      0|        return;
 1289|      0|      }
 1290|      0|      setAccountInfoRequest.deleteProviders = @[ provider ];
 1291|      0|
 1292|      0|      [FIRAuthBackend setAccountInfo:setAccountInfoRequest
 1293|      0|                            callback:^(FIRSetAccountInfoResponse *_Nullable response,
 1294|      0|                                       NSError *_Nullable error) {
 1295|      0|        if (error) {
 1296|      0|          [self signOutIfTokenIsInvalidWithError:error];
 1297|      0|          completeAndCallbackWithError(error);
 1298|      0|          return;
 1299|      0|        }
 1300|      0|
 1301|      0|        // We can't just use the provider info objects in FIRSetAccountInfoResponse because they
 1302|      0|        // don't have localID and email fields. Remove the specific provider manually.
 1303|      0|        NSMutableDictionary *mutableProviderData = [self->_providerData mutableCopy];
 1304|      0|        [mutableProviderData removeObjectForKey:provider];
 1305|      0|        self->_providerData = [mutableProviderData copy];
 1306|      0|
 1307|      0|        if ([provider isEqualToString:FIREmailAuthProviderID]) {
 1308|      0|          self->_hasEmailPasswordCredential = NO;
 1309|      0|        }
 1310|      0|        #if TARGET_OS_IOS
 1311|      0|        // After successfully unlinking a phone auth provider, remove the phone number from the
 1312|      0|        // cached user info.
 1313|      0|        if ([provider isEqualToString:FIRPhoneAuthProviderID]) {
 1314|      0|          self->_phoneNumber = nil;
 1315|      0|        }
 1316|      0|        #endif
 1317|      0|
 1318|      0|        if (response.IDToken && response.refreshToken) {
 1319|      0|          FIRSecureTokenService *tokenService = [[FIRSecureTokenService alloc]
 1320|      0|              initWithRequestConfiguration:requestConfiguration
 1321|      0|                               accessToken:response.IDToken
 1322|      0|                 accessTokenExpirationDate:response.approximateExpirationDate
 1323|      0|                              refreshToken:response.refreshToken];
 1324|      0|          [self setTokenService:tokenService callback:^(NSError *_Nullable error) {
 1325|      0|            completeAndCallbackWithError(error);
 1326|      0|          }];
 1327|      0|          return;
 1328|      0|        }
 1329|      0|        if (![self updateKeychain:&error]) {
 1330|      0|          completeAndCallbackWithError(error);
 1331|      0|          return;
 1332|      0|        }
 1333|      0|        completeAndCallbackWithError(nil);
 1334|      0|      }];
 1335|      0|    }];
 1336|      0|  }];
 1337|      0|}
 1338|       |
 1339|      0|- (void)sendEmailVerificationWithCompletion:(nullable FIRSendEmailVerificationCallback)completion {
 1340|      0|  [self sendEmailVerificationWithNullableActionCodeSettings:nil completion:completion];
 1341|      0|}
 1342|       |
 1343|       |- (void)sendEmailVerificationWithActionCodeSettings:(FIRActionCodeSettings *)actionCodeSettings
 1344|       |                                         completion:(nullable FIRSendEmailVerificationCallback)
 1345|      0|                                                    completion {
 1346|      0|  [self sendEmailVerificationWithNullableActionCodeSettings:actionCodeSettings
 1347|      0|                                                 completion:completion];
 1348|      0|}
 1349|       |
 1350|       |/** @fn sendEmailVerificationWithNullableActionCodeSettings:completion:
 1351|       |    @brief Initiates email verification for the user.
 1352|       |
 1353|       |    @param actionCodeSettings Optionally, a @c FIRActionCodeSettings object containing settings
 1354|       |        related to the handling action codes.
 1355|       | */
 1356|       |- (void)sendEmailVerificationWithNullableActionCodeSettings:(nullable FIRActionCodeSettings *)
 1357|       |                                                            actionCodeSettings
 1358|       |                                                 completion:
 1359|       |                                                         (nullable FIRSendEmailVerificationCallback)
 1360|      0|                                                            completion {
 1361|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1362|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1363|      0|                                         NSError *_Nullable error) {
 1364|      0|      if (error) {
 1365|      0|        callInMainThreadWithError(completion, error);
 1366|      0|        return;
 1367|      0|      }
 1368|      0|      FIRAuthRequestConfiguration *configuration = self->_auth.requestConfiguration;
 1369|      0|      FIRGetOOBConfirmationCodeRequest *request =
 1370|      0|          [FIRGetOOBConfirmationCodeRequest verifyEmailRequestWithAccessToken:accessToken
 1371|      0|                                                           actionCodeSettings:actionCodeSettings
 1372|      0|                                                         requestConfiguration:configuration];
 1373|      0|      [FIRAuthBackend getOOBConfirmationCode:request
 1374|      0|                                    callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable
 1375|      0|                                                   response,
 1376|      0|                                               NSError *_Nullable error) {
 1377|      0|        [self signOutIfTokenIsInvalidWithError:error];
 1378|      0|        callInMainThreadWithError(completion, error);
 1379|      0|      }];
 1380|      0|    }];
 1381|      0|  });
 1382|      0|}
 1383|       |
 1384|      0|- (void)deleteWithCompletion:(nullable FIRUserProfileChangeCallback)completion {
 1385|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1386|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1387|      0|                                         NSError *_Nullable error) {
 1388|      0|      if (error) {
 1389|      0|        callInMainThreadWithError(completion, error);
 1390|      0|        return;
 1391|      0|      }
 1392|      0|      FIRDeleteAccountRequest *deleteUserRequest =
 1393|      0|        [[FIRDeleteAccountRequest alloc] initWitLocalID:self->_userID
 1394|      0|                                            accessToken:accessToken
 1395|      0|                                   requestConfiguration:self->_auth.requestConfiguration];
 1396|      0|      [FIRAuthBackend deleteAccount:deleteUserRequest callback:^(NSError *_Nullable error) {
 1397|      0|        if (error) {
 1398|      0|          callInMainThreadWithError(completion, error);
 1399|      0|          return;
 1400|      0|        }
 1401|      0|        if (![self->_auth signOutByForceWithUserID:self->_userID error:&error]) {
 1402|      0|          callInMainThreadWithError(completion, error);
 1403|      0|          return;
 1404|      0|        }
 1405|      0|        callInMainThreadWithError(completion, error);
 1406|      0|      }];
 1407|      0|    }];
 1408|      0|  });
 1409|      0|}
 1410|       |
 1411|       |/** @fn signOutIfTokenIsInvalidWithError:
 1412|       |    @brief Signs out this user if the user or the token is invalid.
 1413|       |    @param error The error from the server.
 1414|       | */
 1415|      0|- (void)signOutIfTokenIsInvalidWithError:(nullable NSError *)error {
 1416|      0|  NSInteger errorCode = error.code;
 1417|      0|  if (errorCode == FIRAuthErrorCodeUserNotFound ||
 1418|      0|      errorCode == FIRAuthErrorCodeUserDisabled ||
 1419|      0|      errorCode == FIRAuthErrorCodeInvalidUserToken ||
 1420|      0|      errorCode == FIRAuthErrorCodeUserTokenExpired) {
 1421|      0|    FIRLogNotice(kFIRLoggerAuth, @"I-AUT000016",
 1422|      0|                 @"Invalid user token detected, user is automatically signed out.");
 1423|      0|    [_auth signOutByForceWithUserID:_userID error:NULL];
 1424|      0|  }
 1425|      0|}
 1426|       |
 1427|       |@end
 1428|       |
 1429|       |@implementation FIRUserProfileChangeRequest {
 1430|       |  /** @var _user
 1431|       |      @brief The user associated with the change request.
 1432|       |   */
 1433|       |  FIRUser *_user;
 1434|       |
 1435|       |  /** @var _displayName
 1436|       |      @brief The display name value to set if @c _displayNameSet is YES.
 1437|       |   */
 1438|       |  NSString *_displayName;
 1439|       |
 1440|       |  /** @var _displayNameSet
 1441|       |      @brief Indicates the display name should be part of the change request.
 1442|       |   */
 1443|       |  BOOL _displayNameSet;
 1444|       |
 1445|       |  /** @var _photoURL
 1446|       |      @brief The photo URL value to set if @c _displayNameSet is YES.
 1447|       |   */
 1448|       |  NSURL *_photoURL;
 1449|       |
 1450|       |  /** @var _photoURLSet
 1451|       |      @brief Indicates the photo URL should be part of the change request.
 1452|       |   */
 1453|       |  BOOL _photoURLSet;
 1454|       |
 1455|       |  /** @var _consumed
 1456|       |      @brief Indicates the @c commitChangesWithCallback: method has already been invoked.
 1457|       |   */
 1458|       |  BOOL _consumed;
 1459|       |}
 1460|       |
 1461|      0|- (nullable instancetype)initWithUser:(FIRUser *)user {
 1462|      0|  self = [super init];
 1463|      0|  if (self) {
 1464|      0|    _user = user;
 1465|      0|  }
 1466|      0|  return self;
 1467|      0|}
 1468|       |
 1469|      0|- (nullable NSString *)displayName {
 1470|      0|  return _displayName;
 1471|      0|}
 1472|       |
 1473|      0|- (void)setDisplayName:(nullable NSString *)displayName {
 1474|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1475|      0|    if (self->_consumed) {
 1476|      0|      [NSException raise:NSInternalInconsistencyException
 1477|      0|                  format:@"%@",
 1478|      0|                         @"Invalid call to setDisplayName: after commitChangesWithCallback:."];
 1479|      0|      return;
 1480|      0|    }
 1481|      0|    self->_displayNameSet = YES;
 1482|      0|    self->_displayName = [displayName copy];
 1483|      0|  });
 1484|      0|}
 1485|       |
 1486|      0|- (nullable NSURL *)photoURL {
 1487|      0|  return _photoURL;
 1488|      0|}
 1489|       |
 1490|      0|- (void)setPhotoURL:(nullable NSURL *)photoURL {
 1491|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1492|      0|    if (self->_consumed) {
 1493|      0|      [NSException raise:NSInternalInconsistencyException
 1494|      0|                  format:@"%@",
 1495|      0|                         @"Invalid call to setPhotoURL: after commitChangesWithCallback:."];
 1496|      0|      return;
 1497|      0|    }
 1498|      0|    self->_photoURLSet = YES;
 1499|      0|    self->_photoURL = [photoURL copy];
 1500|      0|  });
 1501|      0|}
 1502|       |
 1503|       |/** @fn hasUpdates
 1504|       |    @brief Indicates at least one field has a value which needs to be committed.
 1505|       | */
 1506|      0|- (BOOL)hasUpdates {
 1507|      0|  return _displayNameSet || _photoURLSet;
 1508|      0|}
 1509|       |
 1510|      0|- (void)commitChangesWithCompletion:(nullable FIRUserProfileChangeCallback)completion {
 1511|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1512|      0|    if (self->_consumed) {
 1513|      0|      [NSException raise:NSInternalInconsistencyException
 1514|      0|                  format:@"%@",
 1515|      0|                         @"commitChangesWithCallback: should only be called once."];
 1516|      0|      return;
 1517|      0|    }
 1518|      0|    self->_consumed = YES;
 1519|      0|    // Return fast if there is nothing to update:
 1520|      0|    if (![self hasUpdates]) {
 1521|      0|      callInMainThreadWithError(completion, nil);
 1522|      0|      return;
 1523|      0|    }
 1524|      0|    NSString *displayName = [self->_displayName copy];
 1525|      0|    BOOL displayNameWasSet = self->_displayNameSet;
 1526|      0|    NSURL *photoURL = [self->_photoURL copy];
 1527|      0|    BOOL photoURLWasSet = self->_photoURLSet;
 1528|      0|    [self->_user executeUserUpdateWithChanges:^(FIRGetAccountInfoResponseUser *user,
 1529|      0|                                                FIRSetAccountInfoRequest *request) {
 1530|      0|      if (photoURLWasSet) {
 1531|      0|        request.photoURL = photoURL;
 1532|      0|      }
 1533|      0|      if (displayNameWasSet) {
 1534|      0|        request.displayName = displayName;
 1535|      0|      }
 1536|      0|    }
 1537|      0|                               callback:^(NSError *_Nullable error) {
 1538|      0|      if (error) {
 1539|      0|        callInMainThreadWithError(completion, error);
 1540|      0|        return;
 1541|      0|      }
 1542|      0|      if (displayNameWasSet) {
 1543|      0|        [self->_user setDisplayName:displayName];
 1544|      0|      }
 1545|      0|      if (photoURLWasSet) {
 1546|      0|        [self->_user setPhotoURL:photoURL];
 1547|      0|      }
 1548|      0|      if (![self->_user updateKeychain:&error]) {
 1549|      0|        callInMainThreadWithError(completion, error);
 1550|      0|        return;
 1551|      0|      }
 1552|      0|      callInMainThreadWithError(completion, nil);
 1553|      0|    }];
 1554|      0|  });
 1555|      0|}
 1556|       |
 1557|       |@end
 1558|       |
 1559|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/User/FIRUserInfoImpl.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRUserInfoImpl.h"
   18|       |
   19|       |#import "FIRGetAccountInfoResponse.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kProviderIDCodingKey
   24|       |    @brief The key used to encode the providerID property for NSSecureCoding.
   25|       | */
   26|       |static NSString *const kProviderIDCodingKey = @"providerID";
   27|       |
   28|       |/** @var kUserIDCodingKey
   29|       |    @brief The key used to encode the userID property for NSSecureCoding.
   30|       | */
   31|       |static NSString *const kUserIDCodingKey = @"userID";
   32|       |
   33|       |/** @var kDisplayNameCodingKey
   34|       |    @brief The key used to encode the displayName property for NSSecureCoding.
   35|       | */
   36|       |static NSString *const kDisplayNameCodingKey = @"displayName";
   37|       |
   38|       |/** @var kProfileURLCodingKey
   39|       |    @brief The key used to encode the profileURL property for NSSecureCoding.
   40|       | */
   41|       |static NSString *const kProfileURLCodingKey = @"profileURL";
   42|       |
   43|       |/** @var kPhotoURLCodingKey
   44|       |    @brief The key used to encode the photoURL property for NSSecureCoding.
   45|       | */
   46|       |static NSString *const kPhotoURLCodingKey = @"photoURL";
   47|       |
   48|       |/** @var kEmailCodingKey
   49|       |    @brief The key used to encode the email property for NSSecureCoding.
   50|       | */
   51|       |static NSString *const kEmailCodingKey = @"email";
   52|       |
   53|       |/** @var kPhoneNumberCodingKey
   54|       |    @brief The key used to encode the phoneNumber property for NSSecureCoding.
   55|       | */
   56|       |static NSString *const kPhoneNumberCodingKey = @"phoneNumber";
   57|       |
   58|       |@implementation FIRUserInfoImpl
   59|       |
   60|       |@synthesize providerID = _providerID;
   61|       |@synthesize uid = _userID;
   62|       |@synthesize displayName = _displayName;
   63|       |@synthesize photoURL = _photoURL;
   64|       |@synthesize email = _email;
   65|       |@synthesize phoneNumber = _phoneNumber;
   66|       |
   67|       |+ (nullable instancetype)userInfoWithGetAccountInfoResponseProviderUserInfo:
   68|      0|    (FIRGetAccountInfoResponseProviderUserInfo *)providerUserInfo {
   69|      0|  return [[self alloc] initWithProviderID:providerUserInfo.providerID
   70|      0|                                   userID:providerUserInfo.federatedID
   71|      0|                              displayName:providerUserInfo.displayName
   72|      0|                                 photoURL:providerUserInfo.photoURL
   73|      0|                                    email:providerUserInfo.email
   74|      0|                              phoneNumber:providerUserInfo.phoneNumber];
   75|      0|}
   76|       |
   77|       |- (nullable instancetype)initWithProviderID:(NSString *)providerID
   78|       |                                     userID:(NSString *)userID
   79|       |                                displayName:(nullable NSString *)displayName
   80|       |                                   photoURL:(nullable NSURL *)photoURL
   81|       |                                      email:(nullable NSString *)email
   82|      0|                                phoneNumber:(nullable NSString *)phoneNumber {
   83|      0|  self = [super init];
   84|      0|  if (self) {
   85|      0|    _providerID = [providerID copy];
   86|      0|    _userID = [userID copy];
   87|      0|    _displayName = [displayName copy];
   88|      0|    _photoURL = [photoURL copy];
   89|      0|    _email = [email copy];
   90|      0|    _phoneNumber = [phoneNumber copy];
   91|      0|  }
   92|      0|  return self;
   93|      0|}
   94|       |
   95|       |#pragma mark - NSSecureCoding
   96|       |
   97|      0|+ (BOOL)supportsSecureCoding {
   98|      0|  return YES;
   99|      0|}
  100|       |
  101|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  102|      0|  NSString *providerID =
  103|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kProviderIDCodingKey];
  104|      0|  NSString *userID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kUserIDCodingKey];
  105|      0|  NSString *displayName =
  106|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kDisplayNameCodingKey];
  107|      0|  NSURL *photoURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:kPhotoURLCodingKey];
  108|      0|  NSString *email = [aDecoder decodeObjectOfClass:[NSString class] forKey:kEmailCodingKey];
  109|      0|  NSString *phoneNumber =
  110|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kPhoneNumberCodingKey];
  111|      0|
  112|      0|  return [self initWithProviderID:providerID
  113|      0|                           userID:userID
  114|      0|                      displayName:displayName
  115|      0|                         photoURL:photoURL
  116|      0|                            email:email
  117|      0|                      phoneNumber:phoneNumber];
  118|      0|}
  119|       |
  120|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  121|      0|  [aCoder encodeObject:_providerID forKey:kProviderIDCodingKey];
  122|      0|  [aCoder encodeObject:_userID forKey:kUserIDCodingKey];
  123|      0|  [aCoder encodeObject:_displayName forKey:kDisplayNameCodingKey];
  124|      0|  [aCoder encodeObject:_photoURL forKey:kPhotoURLCodingKey];
  125|      0|  [aCoder encodeObject:_email forKey:kEmailCodingKey];
  126|      0|  [aCoder encodeObject:_phoneNumber forKey:kPhoneNumberCodingKey];
  127|      0|}
  128|       |
  129|       |@end
  130|       |
  131|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/User/FIRUserMetadata.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRUserMetadata_Internal.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRUserMetadata
   22|       |
   23|       |/** @var kCreationDateCodingKey
   24|       |    @brief The key used to encode the creationDate property for NSSecureCoding.
   25|       | */
   26|       |static NSString *const kCreationDateCodingKey = @"creationDate";
   27|       |
   28|       |/** @var kLastSignInDateCodingKey
   29|       |    @brief The key used to encode the lastSignInDate property for NSSecureCoding.
   30|       | */
   31|       |static NSString *const kLastSignInDateCodingKey = @"lastSignInDate";
   32|       |
   33|       |- (instancetype)initWithCreationDate:(nullable NSDate *)creationDate
   34|      0|                      lastSignInDate:(nullable NSDate *)lastSignInDate {
   35|      0|  self = [super init];
   36|      0|  if (self) {
   37|      0|    _creationDate = [creationDate copy];
   38|      0|    _lastSignInDate = [lastSignInDate copy];
   39|      0|  }
   40|      0|  return self;
   41|      0|}
   42|       |
   43|       |#pragma mark - NSSecureCoding
   44|       |
   45|      0|+ (BOOL)supportsSecureCoding {
   46|      0|  return YES;
   47|      0|}
   48|       |
   49|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   50|      0|  NSDate *creationDate =
   51|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kCreationDateCodingKey];
   52|      0|  NSDate *lastSignInDate =
   53|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kLastSignInDateCodingKey];
   54|      0|  return [self initWithCreationDate:creationDate lastSignInDate:lastSignInDate];
   55|      0|}
   56|       |
   57|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   58|      0|  [aCoder encodeObject:_creationDate forKey:kCreationDateCodingKey];
   59|      0|  [aCoder encodeObject:_lastSignInDate forKey:kLastSignInDateCodingKey];
   60|      0|}
   61|       |
   62|       |@end
   63|       |
   64|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthDefaultUIDelegate.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX
   19|       |
   20|       |#import "FIRAuthDefaultUIDelegate.h"
   21|       |
   22|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   23|       |#import <UIKit/UIKit.h>
   24|       |
   25|       |NS_ASSUME_NONNULL_BEGIN
   26|       |
   27|       |@interface FIRAuthDefaultUIDelegate ()
   28|       |
   29|       |/** @fn initWithViewController:
   30|       |    @brief Initializes the instance with a view controller.
   31|       |    @param viewController The view controller as the presenting view controller in @c
   32|       |        FIRAuthUIDelegate.
   33|       |    @return The initialized instance.
   34|       | */
   35|       |- (instancetype)initWithViewController:(nullable UIViewController *)viewController NS_DESIGNATED_INITIALIZER;
   36|       |
   37|       |@end
   38|       |
   39|       |@implementation FIRAuthDefaultUIDelegate {
   40|       |  /** @var _viewController
   41|       |      @brief The presenting view controller.
   42|       |   */
   43|       |  UIViewController *_viewController;
   44|       |}
   45|       |
   46|      0|- (instancetype)initWithViewController:(nullable UIViewController *)viewController {
   47|      0|  self = [super init];
   48|      0|  if (self) {
   49|      0|    _viewController = viewController;
   50|      0|  }
   51|      0|  return self;
   52|      0|}
   53|       |
   54|       |- (void)presentViewController:(UIViewController *)viewControllerToPresent
   55|       |                     animated:(BOOL)flag
   56|      0|                   completion:(nullable void (^)(void))completion {
   57|      0|  [_viewController presentViewController:viewControllerToPresent
   58|      0|                                animated:flag
   59|      0|                              completion:completion];
   60|      0|}
   61|       |
   62|      0|- (void)dismissViewControllerAnimated:(BOOL)flag completion:(nullable void (^)(void))completion {
   63|      0|  [_viewController dismissViewControllerAnimated:flag completion:completion];
   64|      0|}
   65|       |
   66|      0|+ (id<FIRAuthUIDelegate>)defaultUIDelegate {
   67|      0|  // iOS App extensions should not call [UIApplication sharedApplication], even if UIApplication
   68|      0|  // responds to it.
   69|      0|  static Class applicationClass = nil;
   70|      0|  if (![GULAppEnvironmentUtil isAppExtension]) {
   71|      0|    Class cls = NSClassFromString(@"UIApplication");
   72|      0|    if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
   73|      0|      applicationClass = cls;
   74|      0|    }
   75|      0|  }
   76|      0|
   77|      0|  UIViewController *topViewController;
   78|      0|#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
   79|      0|  if (@available(iOS 13.0, tvOS 13.0, *)) {
   80|      0|    UIApplication *application = [applicationClass sharedApplication];
   81|      0|    NSSet<UIScene *> * connectedScenes = application.connectedScenes;
   82|      0|    for (UIScene *scene in connectedScenes) {
   83|      0|      if ([scene isKindOfClass:[UIWindowScene class]]) {
   84|      0|        UIWindowScene *windowScene = (UIWindowScene *)scene;
   85|      0|        for (UIWindow *window in windowScene.windows) {
   86|      0|          if (window.isKeyWindow) {
   87|      0|            topViewController = window.rootViewController;
   88|      0|          }
   89|      0|        }
   90|      0|      }
   91|      0|    }
   92|      0|  } else {
   93|      0|    UIApplication *application = [applicationClass sharedApplication];
   94|      0|    topViewController = application.keyWindow.rootViewController;
   95|      0|  }
   96|       |#else
   97|       |  UIApplication *application = [applicationClass sharedApplication];
   98|       |  topViewController = application.keyWindow.rootViewController;
   99|       |#endif
  100|       |
  101|      0|  while (true){
  102|      0|    if (topViewController.presentedViewController) {
  103|      0|      topViewController = topViewController.presentedViewController;
  104|      0|    } else if ([topViewController isKindOfClass:[UINavigationController class]]) {
  105|      0|      UINavigationController *nav = (UINavigationController *)topViewController;
  106|      0|      topViewController = nav.topViewController;
  107|      0|    } else if ([topViewController isKindOfClass:[UITabBarController class]]) {
  108|      0|      UITabBarController *tab = (UITabBarController *)topViewController;
  109|      0|      topViewController = tab.selectedViewController;
  110|      0|    } else {
  111|      0|      break;
  112|      0|    }
  113|      0|  }
  114|      0|  return [[FIRAuthDefaultUIDelegate alloc] initWithViewController:topViewController];
  115|      0|}
  116|       |
  117|       |@end
  118|       |
  119|       |NS_ASSUME_NONNULL_END
  120|       |
  121|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthErrorUtils.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthErrorUtils.h"
   18|       |
   19|       |#import "FIRAuthCredential.h"
   20|       |#import "FIRAuthInternalErrors.h"
   21|       |
   22|       |NS_ASSUME_NONNULL_BEGIN
   23|       |
   24|       |NSString *const FIRAuthErrorDomain = @"FIRAuthErrorDomain";
   25|       |
   26|       |NSString *const FIRAuthInternalErrorDomain = @"FIRAuthInternalErrorDomain";
   27|       |
   28|       |NSString *const FIRAuthErrorUserInfoDeserializedResponseKey =
   29|       |    @"FIRAuthErrorUserInfoDeserializedResponseKey";
   30|       |
   31|       |NSString *const FIRAuthErrorUserInfoDataKey = @"FIRAuthErrorUserInfoDataKey";
   32|       |
   33|       |NSString *const FIRAuthErrorUserInfoEmailKey = @"FIRAuthErrorUserInfoEmailKey";
   34|       |
   35|       |NSString *const FIRAuthErrorUserInfoUpdatedCredentialKey =
   36|       |    @"FIRAuthErrorUserInfoUpdatedCredentialKey";
   37|       |
   38|       |NSString *const FIRAuthErrorUserInfoNameKey = @"FIRAuthErrorUserInfoNameKey";
   39|       |
   40|       |/** @var kServerErrorDetailMarker
   41|       |    @brief This marker indicates that the server error message contains a detail error message which
   42|       |        should be used instead of the hardcoded client error message.
   43|       | */
   44|       |static NSString *const kServerErrorDetailMarker = @" : ";
   45|       |
   46|       |#pragma mark - URL response error codes
   47|       |
   48|       |/** @var kURLResponseErrorCodeInvalidClientID
   49|       |    @brief Error code that indicates that the client ID provided was invalid.
   50|       | */
   51|       |static NSString *const kURLResponseErrorCodeInvalidClientID = @"auth/invalid-oauth-client-id";
   52|       |
   53|       |/** @var kURLResponseErrorCodeNetworkRequestFailed
   54|       |    @brief Error code that indicates that a network request within the SFSafariViewController or
   55|       |        WKWebView failed.
   56|       | */
   57|       |static NSString *const kURLResponseErrorCodeNetworkRequestFailed = @"auth/network-request-failed";
   58|       |
   59|       |/** @var kURLResponseErrorCodeInternalError
   60|       |    @brief Error code that indicates that an internal error occurred within the
   61|       |        SFSafariViewController or WKWebView failed.
   62|       | */
   63|       |static NSString *const kURLResponseErrorCodeInternalError = @"auth/internal-error";
   64|       |
   65|       |#pragma mark - Standard Error Messages
   66|       |
   67|       |/** @var kFIRAuthErrorMessageInvalidCustomToken
   68|       |    @brief Message for @c FIRAuthErrorCodeInvalidCustomToken error code.
   69|       | */
   70|       |static NSString *const kFIRAuthErrorMessageInvalidCustomToken = @"The custom token format is "
   71|       |    "incorrect. Please check the documentation.";
   72|       |
   73|       |/** @var kFIRAuthErrorMessageCustomTokenMismatch
   74|       |    @brief Message for @c FIRAuthErrorCodeCustomTokenMismatch error code.
   75|       | */
   76|       |static NSString *const kFIRAuthErrorMessageCustomTokenMismatch = @"The custom token corresponds to "
   77|       |    "a different audience.";
   78|       |
   79|       |/** @var kFIRAuthErrorMessageInvalidEmail
   80|       |    @brief Message for @c FIRAuthErrorCodeInvalidEmail error code.
   81|       | */
   82|       |static NSString *const kFIRAuthErrorMessageInvalidEmail = @"The email address is badly formatted.";
   83|       |
   84|       |/** @var kFIRAuthErrorMessageInvalidCredential
   85|       |    @brief Message for @c FIRAuthErrorCodeInvalidCredential error code.
   86|       | */
   87|       |static NSString *const kFIRAuthErrorMessageInvalidCredential = @"The supplied auth credential is "
   88|       |    "malformed or has expired.";
   89|       |
   90|       |/** @var kFIRAuthErrorMessageUserDisabled
   91|       |    @brief Message for @c FIRAuthErrorCodeUserDisabled error code.
   92|       | */
   93|       |static NSString *const kFIRAuthErrorMessageUserDisabled = @"The user account has been disabled by "
   94|       |    "an administrator.";
   95|       |
   96|       |/** @var kFIRAuthErrorMessageEmailAlreadyInUse
   97|       |    @brief Message for @c FIRAuthErrorCodeEmailAlreadyInUse error code.
   98|       | */
   99|       |static NSString *const kFIRAuthErrorMessageEmailAlreadyInUse = @"The email address is already in "
  100|       |    "use by another account.";
  101|       |
  102|       |/** @var kFIRAuthErrorMessageWrongPassword
  103|       |    @brief Message for @c FIRAuthErrorCodeWrongPassword error code.
  104|       | */
  105|       |static NSString *const kFIRAuthErrorMessageWrongPassword = @"The password is invalid or the user "
  106|       |    "does not have a password.";
  107|       |
  108|       |/** @var kFIRAuthErrorMessageTooManyRequests
  109|       |    @brief Message for @c FIRAuthErrorCodeTooManyRequests error code.
  110|       | */
  111|       |static NSString *const kFIRAuthErrorMessageTooManyRequests = @"We have blocked all requests from "
  112|       |    "this device due to unusual activity. Try again later.";
  113|       |
  114|       |/** @var kFIRAuthErrorMessageAccountExistsWithDifferentCredential
  115|       |    @brief Message for @c FIRAuthErrorCodeAccountExistsWithDifferentCredential error code.
  116|       | */
  117|       |static NSString *const kFIRAuthErrorMessageAccountExistsWithDifferentCredential = @"An account "
  118|       |    "already exists with the same email address but different sign-in credentials. Sign in using a "
  119|       |    "provider associated with this email address.";
  120|       |
  121|       |/** @var kFIRAuthErrorMessageRequiresRecentLogin
  122|       |    @brief Message for @c FIRAuthErrorCodeRequiresRecentLogin error code.
  123|       | */
  124|       |static NSString *const kFIRAuthErrorMessageRequiresRecentLogin= @"This operation is sensitive and "
  125|       |    "requires recent authentication. Log in again before retrying this request.";
  126|       |
  127|       |/** @var kFIRAuthErrorMessageProviderAlreadyLinked
  128|       |    @brief Message for @c FIRAuthErrorCodeProviderAlreadyExists error code.
  129|       | */
  130|       |static NSString *const kFIRAuthErrorMessageProviderAlreadyLinked =
  131|       |    @"[ERROR_PROVIDER_ALREADY_LINKED] - User can only be linked to one identity for the given "
  132|       |        "provider.";
  133|       |
  134|       |/** @var kFIRAuthErrorMessageNoSuchProvider
  135|       |    @brief Message for @c FIRAuthErrorCodeNoSuchProvider error code.
  136|       | */
  137|       |static NSString *const kFIRAuthErrorMessageNoSuchProvider = @"User was not linked to an account "
  138|       |    "with the given provider.";
  139|       |
  140|       |/** @var kFIRAuthErrorMessageInvalidUserToken
  141|       |    @brief Message for @c FIRAuthErrorCodeInvalidUserToken error code.
  142|       | */
  143|       |static NSString *const kFIRAuthErrorMessageInvalidUserToken = @"This user's credential isn't valid "
  144|       |    "for this project. This can happen if the user's token has been tampered with, or if the user "
  145|       |    "doesn’t belong to the project associated with the API key used in your request.";
  146|       |
  147|       |/** @var kFIRAuthErrorMessageNetworkError
  148|       |    @brief Message for @c FIRAuthErrorCodeNetworkError error code.
  149|       | */
  150|       |static NSString *const kFIRAuthErrorMessageNetworkError = @"Network error (such as timeout, "
  151|       |    "interrupted connection or unreachable host) has occurred.";
  152|       |
  153|       |/** @var kFIRAuthErrorMessageKeychainError
  154|       |    @brief Message for @c FIRAuthErrorCodeKeychainError error code.
  155|       | */
  156|       |static NSString *const kFIRAuthErrorMessageKeychainError = @"An error occurred when accessing the "
  157|       |    "keychain. The @c NSLocalizedFailureReasonErrorKey field in the @c NSError.userInfo dictionary "
  158|       |    "will contain more information about the error encountered";
  159|       |
  160|       |/** @var kFIRAuthErrorMessageMissingClientIdentifier
  161|       |    @brief Message for @c FIRAuthErrorCodeMissingClientIdentifier error code.
  162|       | */
  163|       |static NSString *const kFIRAuthErrorMessageMissingClientIdentifier = @"The request does not contain "
  164|       |    "any client identifier.";
  165|       |
  166|       |/** @var kFIRAuthErrorMessageUserTokenExpired
  167|       |    @brief Message for @c FIRAuthErrorCodeTokenExpired error code.
  168|       | */
  169|       |static NSString *const kFIRAuthErrorMessageUserTokenExpired = @"The user's credential is no longer "
  170|       |    "valid. The user must sign in again.";
  171|       |
  172|       |/** @var kFIRAuthErrorMessageUserNotFound
  173|       |    @brief Message for @c FIRAuthErrorCodeUserNotFound error code.
  174|       | */
  175|       |static NSString *const kFIRAuthErrorMessageUserNotFound = @"There is no user record corresponding "
  176|       |    "to this identifier. The user may have been deleted.";
  177|       |
  178|       |/** @var kFIRAuthErrorMessageInvalidAPIKey
  179|       |    @brief Message for @c FIRAuthErrorCodeInvalidAPIKey error code.
  180|       |    @remarks This error is not thrown by the server.
  181|       | */
  182|       |static NSString *const kFIRAuthErrorMessageInvalidAPIKey = @"An invalid API Key was supplied in "
  183|       |    "the request.";
  184|       |
  185|       |/** @var kFIRAuthErrorMessageUserMismatch.
  186|       |    @brief Message for @c FIRAuthErrorCodeInvalidAPIKey error code.
  187|       | */
  188|       |static NSString *const FIRAuthErrorMessageUserMismatch = @"The supplied credentials do not "
  189|       |    "correspond to the previously signed in user.";
  190|       |
  191|       |/** @var kFIRAuthErrorMessageCredentialAlreadyInUse
  192|       |    @brief Message for @c FIRAuthErrorCodeCredentialAlreadyInUse error code.
  193|       | */
  194|       |static NSString *const kFIRAuthErrorMessageCredentialAlreadyInUse = @"This credential is already "
  195|       |    "associated with a different user account.";
  196|       |
  197|       |/** @var kFIRAuthErrorMessageOperationNotAllowed
  198|       |    @brief Message for @c FIRAuthErrorCodeOperationNotAllowed error code.
  199|       | */
  200|       |static NSString *const kFIRAuthErrorMessageOperationNotAllowed = @"The given sign-in provider is "
  201|       |    "disabled for this Firebase project. Enable it in the Firebase console, under the sign-in "
  202|       |    "method tab of the Auth section.";
  203|       |
  204|       |/** @var kFIRAuthErrorMessageWeakPassword
  205|       |    @brief Message for @c FIRAuthErrorCodeWeakPassword error code.
  206|       | */
  207|       |static NSString *const kFIRAuthErrorMessageWeakPassword = @"The password must be 6 characters long "
  208|       |    "or more.";
  209|       |
  210|       |/** @var kFIRAuthErrorMessageAppNotAuthorized
  211|       |    @brief Message for @c FIRAuthErrorCodeAppNotAuthorized error code.
  212|       | */
  213|       |static NSString *const kFIRAuthErrorMessageAppNotAuthorized = @"This app is not authorized to use "
  214|       |    "Firebase Authentication with the provided API key. Review your key configuration in the "
  215|       |    "Google API console and ensure that it accepts requests from your app's bundle ID.";
  216|       |
  217|       |/** @var kFIRAuthErrorMessageExpiredActionCode
  218|       |    @brief Message for @c FIRAuthErrorCodeExpiredActionCode error code.
  219|       | */
  220|       |static NSString *const kFIRAuthErrorMessageExpiredActionCode = @"The action code has expired.";
  221|       |
  222|       |/** @var kFIRAuthErrorMessageInvalidActionCode
  223|       |    @brief Message for @c FIRAuthErrorCodeInvalidActionCode error code.
  224|       | */
  225|       |static NSString *const kFIRAuthErrorMessageInvalidActionCode = @"The action code is invalid. This "
  226|       |   "can happen if the code is malformed, expired, or has already been used.";
  227|       |
  228|       |/** @var kFIRAuthErrorMessageInvalidMessagePayload
  229|       |    @brief Message for @c FIRAuthErrorCodeInvalidMessagePayload error code.
  230|       | */
  231|       |static NSString *const kFIRAuthErrorMessageInvalidMessagePayload = @"The action code is invalid. "
  232|       |   "This can happen if the code is malformed, expired, or has already been used.";
  233|       |
  234|       |/** @var kFIRAuthErrorMessageInvalidSender
  235|       |    @brief Message for @c FIRAuthErrorCodeInvalidSender error code.
  236|       | */
  237|       |static NSString *const kFIRAuthErrorMessageInvalidSender = @"The email template corresponding to "
  238|       |    "this action contains invalid characters in its message. Please fix by going to the Auth email "
  239|       |    "templates section in the Firebase Console.";
  240|       |
  241|       |/** @var kFIRAuthErrorMessageInvalidRecipientEmail
  242|       |    @brief Message for @c FIRAuthErrorCodeInvalidRecipient error code.
  243|       | */
  244|       |static NSString *const kFIRAuthErrorMessageInvalidRecipientEmail = @"The action code is invalid. "
  245|       |   "This can happen if the code is malformed, expired, or has already been used.";
  246|       |
  247|       |/** @var kFIRAuthErrorMessageMissingIosBundleID
  248|       |    @brief Message for @c FIRAuthErrorCodeMissingIosbundleID error code.
  249|       | */
  250|       |static NSString *const kFIRAuthErrorMessageMissingIosBundleID =
  251|       |    @"An iOS Bundle ID must be provided if an App Store ID is provided.";
  252|       |
  253|       |/** @var kFIRAuthErrorMessageMissingAndroidPackageName
  254|       |    @brief Message for @c FIRAuthErrorCodeMissingAndroidPackageName error code.
  255|       | */
  256|       |static NSString *const kFIRAuthErrorMessageMissingAndroidPackageName =
  257|       |    @"An Android Package Name must be provided if the Android App is required to be installed.";
  258|       |
  259|       |/** @var kFIRAuthErrorMessageUnauthorizedDomain
  260|       |    @brief Message for @c FIRAuthErrorCodeUnauthorizedDomain error code.
  261|       | */
  262|       |static NSString *const kFIRAuthErrorMessageUnauthorizedDomain = @"The domain of the continue URL "
  263|       |    "is not whitelisted. Please whitelist the domain in the Firebase console.";
  264|       |
  265|       |/** @var kFIRAuthErrorMessageInvalidContinueURI
  266|       |    @brief Message for @c FIRAuthErrorCodeInvalidContinueURI error code.
  267|       | */
  268|       |static NSString *const kFIRAuthErrorMessageInvalidContinueURI =
  269|       |    @"The continue URL provided in the request is invalid.";
  270|       |
  271|       |/** @var kFIRAuthErrorMessageMissingEmail
  272|       |    @brief Message for @c FIRAuthErrorCodeMissingEmail error code.
  273|       | */
  274|       |static NSString *const kFIRAuthErrorMessageMissingEmail = @"An email address must be provided.";
  275|       |
  276|       |/** @var kFIRAuthErrorMessageMissingContinueURI
  277|       |    @brief Message for @c FIRAuthErrorCodeMissingContinueURI error code.
  278|       | */
  279|       |static NSString *const kFIRAuthErrorMessageMissingContinueURI =
  280|       |    @"A continue URL must be provided in the request.";
  281|       |
  282|       |/** @var kFIRAuthErrorMessageMissingPhoneNumber
  283|       |    @brief Message for @c FIRAuthErrorCodeMissingPhoneNumber error code.
  284|       | */
  285|       |static NSString *const kFIRAuthErrorMessageMissingPhoneNumber =
  286|       |    @"To send verification codes, provide a phone number for the recipient.";
  287|       |
  288|       |/** @var kFIRAuthErrorMessageInvalidPhoneNumber
  289|       |    @brief Message for @c FIRAuthErrorCodeInvalidPhoneNumber error code.
  290|       | */
  291|       |static NSString *const kFIRAuthErrorMessageInvalidPhoneNumber =
  292|       |    @"The format of the phone number provided is incorrect. Please enter the phone number in a "
  293|       |    "format that can be parsed into E.164 format. E.164 phone numbers are written in the format "
  294|       |    "[+][country code][subscriber number including area code].";
  295|       |
  296|       |/** @var kFIRAuthErrorMessageMissingVerificationCode
  297|       |    @brief Message for @c FIRAuthErrorCodeMissingVerificationCode error code.
  298|       | */
  299|       |static NSString *const kFIRAuthErrorMessageMissingVerificationCode =
  300|       |    @"The phone auth credential was created with an empty SMS verification Code.";
  301|       |
  302|       |/** @var kFIRAuthErrorMessageInvalidVerificationCode
  303|       |    @brief Message for @c FIRAuthErrorCodeInvalidVerificationCode error code.
  304|       | */
  305|       |static NSString *const kFIRAuthErrorMessageInvalidVerificationCode =
  306|       |    @"The SMS verification code used to create the phone auth credential is invalid. Please resend "
  307|       |    "the verification code SMS and be sure to use the verification code provided by the user.";
  308|       |
  309|       |/** @var kFIRAuthErrorMessageMissingVerificationID
  310|       |    @brief Message for @c FIRAuthErrorCodeInvalidVerificationID error code.
  311|       | */
  312|       |static NSString *const kFIRAuthErrorMessageMissingVerificationID =
  313|       |    @"The phone auth credential was created with an empty verification ID.";
  314|       |
  315|       |/** @var kFIRAuthErrorMessageInvalidVerificationID
  316|       |    @brief Message for @c FIRAuthErrorCodeInvalidVerificationID error code.
  317|       | */
  318|       |static NSString *const kFIRAuthErrorMessageInvalidVerificationID =
  319|       |    @"The verification ID used to create the phone auth credential is invalid.";
  320|       |
  321|       |/** @var kFIRAuthErrorMessageLocalPlayerNotAuthenticated
  322|       |    @brief Message for @c FIRAuthErrorCodeLocalPlayerNotAuthenticated error code.
  323|       | */
  324|       |static NSString *const kFIRAuthErrorMessageLocalPlayerNotAuthenticated =
  325|       |    @"The local player is not authenticated. Please log the local player in to Game Center.";
  326|       |
  327|       |/** @var kFIRAuthErrorMessageGameKitNotLinked
  328|       |    @brief Message for @c kFIRAuthErrorMessageGameKitNotLinked error code.
  329|       | */
  330|       |static NSString *const kFIRAuthErrorMessageGameKitNotLinked =
  331|       |    @"The GameKit framework is not linked. Please turn on the Game Center capability.";
  332|       |
  333|       |/** @var kFIRAuthErrorMessageSessionExpired
  334|       |    @brief Message for @c FIRAuthErrorCodeSessionExpired error code.
  335|       | */
  336|       |static NSString *const kFIRAuthErrorMessageSessionExpired = @"The SMS code has expired. Please "
  337|       |    @"re-send the verification code to try again.";
  338|       |
  339|       |/** @var kFIRAuthErrorMessageMissingAppCredential
  340|       |    @brief Message for @c FIRAuthErrorCodeMissingAppCredential error code.
  341|       | */
  342|       |static NSString *const kFIRAuthErrorMessageMissingAppCredential = @"The phone verification request "
  343|       |    "is missing an APNs Device token. Firebase Auth automatically detects APNs Device Tokens, "
  344|       |    "however, if method swizzling is disabled, the APNs token must be set via the APNSToken "
  345|       |    "property on FIRAuth or by calling setAPNSToken:type on FIRAuth.";
  346|       |
  347|       |/** @var kFIRAuthErrorMessageInvalidAppCredential
  348|       |    @brief Message for @c FIRAuthErrorCodeInvalidAppCredential error code.
  349|       | */
  350|       |static NSString *const kFIRAuthErrorMessageInvalidAppCredential = @"The APNs device token provided "
  351|       |    "is either incorrect or does not match the private certificate uploaded to the Firebase "
  352|       |    "Console.";
  353|       |
  354|       |/** @var kFIRAuthErrorMessageQuotaExceeded
  355|       |    @brief Message for @c FIRAuthErrorCodeQuotaExceeded error code.
  356|       | */
  357|       |static NSString *const kFIRAuthErrorMessageQuotaExceeded = @"The phone verification quota for this "
  358|       |    "project has been exceeded.";
  359|       |
  360|       |/** @var kFIRAuthErrorMessageMissingAppToken
  361|       |    @brief Message for @c FIRAuthErrorCodeMissingAppToken error code.
  362|       | */
  363|       |static NSString *const kFIRAuthErrorMessageMissingAppToken = @"There seems to be a problem with "
  364|       |    "your project's Firebase phone number authentication set-up, please make sure to follow the "
  365|       |    "instructions found at https://firebase.google.com/docs/auth/ios/phone-auth";
  366|       |
  367|       |/** @var kFIRAuthErrorMessageMissingAppToken
  368|       |    @brief Message for @c FIRAuthErrorCodeMissingAppToken error code.
  369|       | */
  370|       |static NSString *const kFIRAuthErrorMessageNotificationNotForwarded = @"If app delegate swizzling "
  371|       |    "is disabled, remote notifications received by UIApplicationDelegate need to be forwarded to "
  372|       |    "FIRAuth's canHandleNotificaton: method.";
  373|       |
  374|       |/** @var kFIRAuthErrorMessageAppNotVerified
  375|       |    @brief Message for @c FIRAuthErrorCodeMissingAppToken error code.
  376|       | */
  377|       |static NSString *const kFIRAuthErrorMessageAppNotVerified = @"Firebase could not retrieve the "
  378|       |    "silent push notification and therefore could not verify your app. Ensure that you configured "
  379|       |    "your app correctly to receive push notifications.";
  380|       |
  381|       |/** @var kFIRAuthErrorMessageCaptchaCheckFailed
  382|       |    @brief Message for @c FIRAuthErrorCodeCaptchaCheckFailed error code.
  383|       | */
  384|       |static NSString *const kFIRAuthErrorMessageCaptchaCheckFailed = @"The reCAPTCHA response token "
  385|       |    "provided is either invalid, expired or already";
  386|       |
  387|       |/** @var kFIRAuthErrorMessageWebContextAlreadyPresented
  388|       |    @brief Message for @c FIRAuthErrorCodeWebContextAlreadyPresented error code.
  389|       | */
  390|       |static NSString *const kFIRAuthErrorMessageWebContextAlreadyPresented = @"User interaction is "
  391|       |    "still ongoing, another view cannot be presented.";
  392|       |
  393|       |/** @var kFIRAuthErrorMessageWebContextCancelled
  394|       |    @brief Message for @c FIRAuthErrorCodeWebContextCancelled error code.
  395|       | */
  396|       |static NSString *const kFIRAuthErrorMessageWebContextCancelled = @"The interaction was cancelled "
  397|       |    "by the user.";
  398|       |
  399|       |/** @var kFIRAuthErrorMessageInvalidClientID
  400|       |    @brief Message for @c FIRAuthErrorCodeInvalidClientID error code.
  401|       | */
  402|       |static NSString *const kFIRAuthErrorMessageInvalidClientID = @"The OAuth client ID provided is "
  403|       |    "either invalid or does not match the specified API key.";
  404|       |
  405|       |/** @var kFIRAuthErrorMessageWebRequestFailed
  406|       |    @brief Message for @c FIRAuthErrorCodeWebRequestFailed error code.
  407|       | */
  408|       |static NSString *const kFIRAuthErrorMessageWebRequestFailed = @"A network error (such as timeout, "
  409|       |    "interrupted connection, or unreachable host) has occurred within the web context.";
  410|       |
  411|       |/** @var kFIRAuthErrorMessageWebInternalError
  412|       |    @brief Message for @c FIRAuthErrorCodeWebInternalError error code.
  413|       | */
  414|       |static NSString *const kFIRAuthErrorMessageWebInternalError = @"An internal error has occurred "
  415|       |    "within the SFSafariViewController or WKWebView.";
  416|       |
  417|       |/** @var kFIRAuthErrorMessageAppVerificationUserInteractionFailure
  418|       |    @brief Message for @c FIRAuthErrorCodeInvalidClientID error code.
  419|       | */
  420|       |static NSString *const kFIRAuthErrorMessageAppVerificationUserInteractionFailure = @"The app "
  421|       |  "verification process has failed, print and inspect the error details for more information";
  422|       |
  423|       |/** @var kFIRAuthErrorMessageNullUser
  424|       |    @brief Message for @c FIRAuthErrorCodeNullUser error code.
  425|       | */
  426|       |static NSString *const kFIRAuthErrorMessageNullUser = @"A null user object was provided as the "
  427|       |    "argument for an operation which requires a non-null user object.";
  428|       |
  429|       |/** @var kFIRAuthErrorMessageInvalidProviderID
  430|       |    @brief Message for @c FIRAuthErrorCodeInvalidProviderID error code.
  431|       | */
  432|       |static NSString *const kFIRAuthErrorMessageInvalidProviderID = @"The provider ID provided for the "
  433|       |    "attempted web operation is invalid.";
  434|       |
  435|       |/** @var kFIRAuthErrorMessageInvalidDynamicLinkDomain
  436|       |    @brief Message for @c kFIRAuthErrorMessageInvalidDynamicLinkDomain error code.
  437|       | */
  438|       |static NSString *const kFIRAuthErrorMessageInvalidDynamicLinkDomain = @"The "
  439|       |    "Firebase Dynamic Link domain used is either not configured or is unauthorized "
  440|       |    "for the current project.";
  441|       |
  442|       |/** @var kFIRAuthErrorMessageInternalError
  443|       |    @brief Message for @c FIRAuthErrorCodeInternalError error code.
  444|       | */
  445|       |static NSString *const kFIRAuthErrorMessageInternalError = @"An internal error has occurred, "
  446|       |    "print and inspect the error details for more information.";
  447|       |
  448|       |/** @var kFIRAuthErrorMessageMalformedJWT
  449|       |    @brief Error message constant describing @c FIRAuthErrorCodeMalformedJWT errors.
  450|       | */
  451|       |static NSString *const kFIRAuthErrorMessageMalformedJWT =
  452|       |    @"Failed to parse JWT. Check the userInfo dictionary for the full token.";
  453|       |
  454|       |/** @var kFIRAuthErrorMessageDynamicLinkNotActivated
  455|       |    @brief Error message constant describing @c FIRAuthErrorCodeDynamicLinkNotActivated errors.
  456|       | */
  457|       |static NSString *const kFIRAuthErrorMessageDynamicLinkNotActivated =
  458|       |    @"Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.";
  459|       |
  460|       |/** @var kFIRAuthErrorMessageRejectedCredential
  461|       |    @brief Error message constant describing @c FIRAuthErrorCodeRejectedCredential errors.
  462|       | */
  463|       |static NSString *const kFIRAuthErrorMessageRejectedCredential =
  464|       |    @"The request contains malformed or mismatching credentials.";
  465|       |
  466|       |/** @var kFIRAuthErrorMessageMissingOrInvalidNonce
  467|       |    @brief Error message constant describing @c FIRAuthErrorCodeMissingOrInvalidNonce errors.
  468|       | */
  469|       |static NSString *const kFIRAuthErrorMessageMissingOrInvalidNonce =
  470|       |    @"The request contains malformed or mismatched credentials.";
  471|       |
  472|       |/** @var FIRAuthErrorDescription
  473|       |    @brief The error descrioption, based on the error code.
  474|       |    @remarks No default case so that we get a compiler warning if a new value was added to the enum.
  475|       | */
  476|      0|static NSString *FIRAuthErrorDescription(FIRAuthErrorCode code) {
  477|      0|  switch (code) {
  478|      0|    case FIRAuthErrorCodeInvalidCustomToken:
  479|      0|      return kFIRAuthErrorMessageInvalidCustomToken;
  480|      0|    case FIRAuthErrorCodeCustomTokenMismatch:
  481|      0|      return kFIRAuthErrorMessageCustomTokenMismatch;
  482|      0|    case FIRAuthErrorCodeInvalidEmail:
  483|      0|      return kFIRAuthErrorMessageInvalidEmail;
  484|      0|    case FIRAuthErrorCodeInvalidCredential:
  485|      0|      return kFIRAuthErrorMessageInvalidCredential;
  486|      0|    case FIRAuthErrorCodeUserDisabled:
  487|      0|      return kFIRAuthErrorMessageUserDisabled;
  488|      0|    case FIRAuthErrorCodeEmailAlreadyInUse:
  489|      0|      return kFIRAuthErrorMessageEmailAlreadyInUse;
  490|      0|    case FIRAuthErrorCodeWrongPassword:
  491|      0|      return kFIRAuthErrorMessageWrongPassword;
  492|      0|    case FIRAuthErrorCodeTooManyRequests:
  493|      0|      return kFIRAuthErrorMessageTooManyRequests;
  494|      0|    case FIRAuthErrorCodeAccountExistsWithDifferentCredential:
  495|      0|      return kFIRAuthErrorMessageAccountExistsWithDifferentCredential;
  496|      0|    case FIRAuthErrorCodeRequiresRecentLogin:
  497|      0|      return kFIRAuthErrorMessageRequiresRecentLogin;
  498|      0|    case FIRAuthErrorCodeProviderAlreadyLinked:
  499|      0|      return kFIRAuthErrorMessageProviderAlreadyLinked;
  500|      0|    case FIRAuthErrorCodeNoSuchProvider:
  501|      0|      return kFIRAuthErrorMessageNoSuchProvider;
  502|      0|    case FIRAuthErrorCodeInvalidUserToken:
  503|      0|      return kFIRAuthErrorMessageInvalidUserToken;
  504|      0|    case FIRAuthErrorCodeNetworkError:
  505|      0|      return kFIRAuthErrorMessageNetworkError;
  506|      0|    case FIRAuthErrorCodeKeychainError:
  507|      0|      return kFIRAuthErrorMessageKeychainError;
  508|      0|    case FIRAuthErrorCodeMissingClientIdentifier:
  509|      0|      return kFIRAuthErrorMessageMissingClientIdentifier;
  510|      0|    case FIRAuthErrorCodeUserTokenExpired:
  511|      0|      return kFIRAuthErrorMessageUserTokenExpired;
  512|      0|    case FIRAuthErrorCodeUserNotFound:
  513|      0|      return kFIRAuthErrorMessageUserNotFound;
  514|      0|    case FIRAuthErrorCodeInvalidAPIKey:
  515|      0|      return kFIRAuthErrorMessageInvalidAPIKey;
  516|      0|    case FIRAuthErrorCodeCredentialAlreadyInUse:
  517|      0|      return kFIRAuthErrorMessageCredentialAlreadyInUse;
  518|      0|    case FIRAuthErrorCodeInternalError:
  519|      0|      return kFIRAuthErrorMessageInternalError;
  520|      0|    case FIRAuthErrorCodeUserMismatch:
  521|      0|      return FIRAuthErrorMessageUserMismatch;
  522|      0|    case FIRAuthErrorCodeOperationNotAllowed:
  523|      0|      return kFIRAuthErrorMessageOperationNotAllowed;
  524|      0|    case FIRAuthErrorCodeWeakPassword:
  525|      0|      return kFIRAuthErrorMessageWeakPassword;
  526|      0|    case FIRAuthErrorCodeAppNotAuthorized:
  527|      0|      return kFIRAuthErrorMessageAppNotAuthorized;
  528|      0|    case FIRAuthErrorCodeExpiredActionCode:
  529|      0|      return kFIRAuthErrorMessageExpiredActionCode;
  530|      0|    case FIRAuthErrorCodeInvalidActionCode:
  531|      0|      return kFIRAuthErrorMessageInvalidActionCode;
  532|      0|    case FIRAuthErrorCodeInvalidSender:
  533|      0|      return kFIRAuthErrorMessageInvalidSender;
  534|      0|    case FIRAuthErrorCodeInvalidMessagePayload:
  535|      0|      return kFIRAuthErrorMessageInvalidMessagePayload;
  536|      0|    case FIRAuthErrorCodeInvalidRecipientEmail:
  537|      0|      return kFIRAuthErrorMessageInvalidRecipientEmail;
  538|      0|    case FIRAuthErrorCodeMissingIosBundleID:
  539|      0|      return kFIRAuthErrorMessageMissingIosBundleID;
  540|      0|    case FIRAuthErrorCodeMissingAndroidPackageName:
  541|      0|      return kFIRAuthErrorMessageMissingAndroidPackageName;
  542|      0|    case FIRAuthErrorCodeUnauthorizedDomain:
  543|      0|      return kFIRAuthErrorMessageUnauthorizedDomain;
  544|      0|    case FIRAuthErrorCodeInvalidContinueURI:
  545|      0|      return kFIRAuthErrorMessageInvalidContinueURI;
  546|      0|    case FIRAuthErrorCodeMissingContinueURI:
  547|      0|      return kFIRAuthErrorMessageMissingContinueURI;
  548|      0|    case FIRAuthErrorCodeMissingEmail:
  549|      0|      return kFIRAuthErrorMessageMissingEmail;
  550|      0|    case FIRAuthErrorCodeMissingPhoneNumber:
  551|      0|      return kFIRAuthErrorMessageMissingPhoneNumber;
  552|      0|    case FIRAuthErrorCodeInvalidPhoneNumber:
  553|      0|      return kFIRAuthErrorMessageInvalidPhoneNumber;
  554|      0|    case FIRAuthErrorCodeMissingVerificationCode:
  555|      0|      return kFIRAuthErrorMessageMissingVerificationCode;
  556|      0|    case FIRAuthErrorCodeInvalidVerificationCode:
  557|      0|      return kFIRAuthErrorMessageInvalidVerificationCode;
  558|      0|    case FIRAuthErrorCodeMissingVerificationID:
  559|      0|      return kFIRAuthErrorMessageMissingVerificationID;
  560|      0|    case FIRAuthErrorCodeInvalidVerificationID:
  561|      0|      return kFIRAuthErrorMessageInvalidVerificationID;
  562|      0|    case FIRAuthErrorCodeSessionExpired:
  563|      0|      return kFIRAuthErrorMessageSessionExpired;
  564|      0|    case FIRAuthErrorCodeMissingAppCredential:
  565|      0|      return kFIRAuthErrorMessageMissingAppCredential;
  566|      0|    case FIRAuthErrorCodeInvalidAppCredential:
  567|      0|      return kFIRAuthErrorMessageInvalidAppCredential;
  568|      0|    case FIRAuthErrorCodeQuotaExceeded:
  569|      0|      return kFIRAuthErrorMessageQuotaExceeded;
  570|      0|    case FIRAuthErrorCodeMissingAppToken:
  571|      0|      return kFIRAuthErrorMessageMissingAppToken;
  572|      0|    case FIRAuthErrorCodeNotificationNotForwarded:
  573|      0|      return kFIRAuthErrorMessageNotificationNotForwarded;
  574|      0|    case FIRAuthErrorCodeAppNotVerified:
  575|      0|      return kFIRAuthErrorMessageAppNotVerified;
  576|      0|    case FIRAuthErrorCodeCaptchaCheckFailed:
  577|      0|      return kFIRAuthErrorMessageCaptchaCheckFailed;
  578|      0|    case FIRAuthErrorCodeWebContextAlreadyPresented:
  579|      0|      return kFIRAuthErrorMessageWebContextAlreadyPresented;
  580|      0|    case FIRAuthErrorCodeWebContextCancelled:
  581|      0|      return kFIRAuthErrorMessageWebContextCancelled;
  582|      0|    case FIRAuthErrorCodeInvalidClientID:
  583|      0|      return kFIRAuthErrorMessageInvalidClientID;
  584|      0|    case FIRAuthErrorCodeAppVerificationUserInteractionFailure:
  585|      0|      return kFIRAuthErrorMessageAppVerificationUserInteractionFailure;
  586|      0|    case FIRAuthErrorCodeWebNetworkRequestFailed:
  587|      0|      return kFIRAuthErrorMessageWebRequestFailed;
  588|      0|    case FIRAuthErrorCodeNullUser:
  589|      0|      return kFIRAuthErrorMessageNullUser;
  590|      0|    case FIRAuthErrorCodeInvalidProviderID:
  591|      0|      return kFIRAuthErrorMessageInvalidProviderID;
  592|      0|    case FIRAuthErrorCodeInvalidDynamicLinkDomain:
  593|      0|      return kFIRAuthErrorMessageInvalidDynamicLinkDomain;
  594|      0|    case FIRAuthErrorCodeWebInternalError:
  595|      0|      return kFIRAuthErrorMessageWebInternalError;
  596|      0|    case FIRAuthErrorCodeWebSignInUserInteractionFailure:
  597|      0|      return kFIRAuthErrorMessageAppVerificationUserInteractionFailure;
  598|      0|    case FIRAuthErrorCodeMalformedJWT:
  599|      0|      return kFIRAuthErrorMessageMalformedJWT;
  600|      0|    case FIRAuthErrorCodeLocalPlayerNotAuthenticated:
  601|      0|      return kFIRAuthErrorMessageLocalPlayerNotAuthenticated;
  602|      0|    case FIRAuthErrorCodeGameKitNotLinked:
  603|      0|      return kFIRAuthErrorMessageGameKitNotLinked;
  604|      0|    case FIRAuthErrorCodeDynamicLinkNotActivated:
  605|      0|      return kFIRAuthErrorMessageDynamicLinkNotActivated;
  606|      0|    case FIRAuthErrorCodeRejectedCredential:
  607|      0|      return kFIRAuthErrorMessageRejectedCredential;
  608|      0|    case FIRAuthErrorCodeMissingOrInvalidNonce:
  609|      0|      return kFIRAuthErrorMessageMissingOrInvalidNonce;
  610|      0|  }
  611|      0|}
  612|       |
  613|       |/** @var FIRAuthErrorCodeString
  614|       |    @brief The the error short string, based on the error code.
  615|       |    @remarks No default case so that we get a compiler warning if a new value was added to the enum.
  616|       | */
  617|      0|static NSString *const FIRAuthErrorCodeString(FIRAuthErrorCode code) {
  618|      0|  switch (code) {
  619|      0|    case FIRAuthErrorCodeInvalidCustomToken:
  620|      0|      return @"ERROR_INVALID_CUSTOM_TOKEN";
  621|      0|    case FIRAuthErrorCodeCustomTokenMismatch:
  622|      0|      return @"ERROR_CUSTOM_TOKEN_MISMATCH";
  623|      0|    case FIRAuthErrorCodeInvalidEmail:
  624|      0|      return @"ERROR_INVALID_EMAIL";
  625|      0|    case FIRAuthErrorCodeInvalidCredential:
  626|      0|      return @"ERROR_INVALID_CREDENTIAL";
  627|      0|    case FIRAuthErrorCodeUserDisabled:
  628|      0|      return @"ERROR_USER_DISABLED";
  629|      0|    case FIRAuthErrorCodeEmailAlreadyInUse:
  630|      0|      return @"ERROR_EMAIL_ALREADY_IN_USE";
  631|      0|    case FIRAuthErrorCodeWrongPassword:
  632|      0|      return @"ERROR_WRONG_PASSWORD";
  633|      0|    case FIRAuthErrorCodeTooManyRequests:
  634|      0|      return @"ERROR_TOO_MANY_REQUESTS";
  635|      0|    case FIRAuthErrorCodeAccountExistsWithDifferentCredential:
  636|      0|      return @"ERROR_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL";
  637|      0|    case FIRAuthErrorCodeRequiresRecentLogin:
  638|      0|      return @"ERROR_REQUIRES_RECENT_LOGIN";
  639|      0|    case FIRAuthErrorCodeProviderAlreadyLinked:
  640|      0|      return @"ERROR_PROVIDER_ALREADY_LINKED";
  641|      0|    case FIRAuthErrorCodeNoSuchProvider:
  642|      0|      return @"ERROR_NO_SUCH_PROVIDER";
  643|      0|    case FIRAuthErrorCodeInvalidUserToken:
  644|      0|      return @"ERROR_INVALID_USER_TOKEN";
  645|      0|    case FIRAuthErrorCodeNetworkError:
  646|      0|      return @"ERROR_NETWORK_REQUEST_FAILED";
  647|      0|    case FIRAuthErrorCodeKeychainError:
  648|      0|      return @"ERROR_KEYCHAIN_ERROR";
  649|      0|    case FIRAuthErrorCodeMissingClientIdentifier:
  650|      0|      return @"ERROR_MISSING_CLIENT_IDENTIFIER";
  651|      0|    case FIRAuthErrorCodeUserTokenExpired:
  652|      0|      return @"ERROR_USER_TOKEN_EXPIRED";
  653|      0|    case FIRAuthErrorCodeUserNotFound:
  654|      0|      return @"ERROR_USER_NOT_FOUND";
  655|      0|    case FIRAuthErrorCodeInvalidAPIKey:
  656|      0|      return @"ERROR_INVALID_API_KEY";
  657|      0|    case FIRAuthErrorCodeCredentialAlreadyInUse:
  658|      0|      return @"ERROR_CREDENTIAL_ALREADY_IN_USE";
  659|      0|    case FIRAuthErrorCodeInternalError:
  660|      0|      return @"ERROR_INTERNAL_ERROR";
  661|      0|    case FIRAuthErrorCodeUserMismatch:
  662|      0|      return @"ERROR_USER_MISMATCH";
  663|      0|    case FIRAuthErrorCodeOperationNotAllowed:
  664|      0|      return @"ERROR_OPERATION_NOT_ALLOWED";
  665|      0|    case FIRAuthErrorCodeWeakPassword:
  666|      0|      return @"ERROR_WEAK_PASSWORD";
  667|      0|    case FIRAuthErrorCodeAppNotAuthorized:
  668|      0|      return @"ERROR_APP_NOT_AUTHORIZED";
  669|      0|    case FIRAuthErrorCodeExpiredActionCode:
  670|      0|      return @"ERROR_EXPIRED_ACTION_CODE";
  671|      0|    case FIRAuthErrorCodeInvalidActionCode:
  672|      0|      return @"ERROR_INVALID_ACTION_CODE";
  673|      0|    case FIRAuthErrorCodeInvalidMessagePayload:
  674|      0|      return @"ERROR_INVALID_MESSAGE_PAYLOAD";
  675|      0|    case FIRAuthErrorCodeInvalidSender:
  676|      0|      return @"ERROR_INVALID_SENDER";
  677|      0|    case FIRAuthErrorCodeInvalidRecipientEmail:
  678|      0|      return @"ERROR_INVALID_RECIPIENT_EMAIL";
  679|      0|    case FIRAuthErrorCodeMissingIosBundleID:
  680|      0|      return @"ERROR_MISSING_IOS_BUNDLE_ID";
  681|      0|    case FIRAuthErrorCodeMissingAndroidPackageName:
  682|      0|      return @"ERROR_MISSING_ANDROID_PKG_NAME";
  683|      0|    case FIRAuthErrorCodeUnauthorizedDomain:
  684|      0|      return @"ERROR_UNAUTHORIZED_DOMAIN";
  685|      0|    case FIRAuthErrorCodeInvalidContinueURI:
  686|      0|      return @"ERROR_INVALID_CONTINUE_URI";
  687|      0|    case FIRAuthErrorCodeMissingContinueURI:
  688|      0|      return @"ERROR_MISSING_CONTINUE_URI";
  689|      0|    case FIRAuthErrorCodeMissingEmail:
  690|      0|      return @"ERROR_MISSING_EMAIL";
  691|      0|    case FIRAuthErrorCodeMissingPhoneNumber:
  692|      0|      return @"ERROR_MISSING_PHONE_NUMBER";
  693|      0|    case FIRAuthErrorCodeInvalidPhoneNumber:
  694|      0|      return @"ERROR_INVALID_PHONE_NUMBER";
  695|      0|    case FIRAuthErrorCodeMissingVerificationCode:
  696|      0|      return @"ERROR_MISSING_VERIFICATION_CODE";
  697|      0|    case FIRAuthErrorCodeInvalidVerificationCode:
  698|      0|      return @"ERROR_INVALID_VERIFICATION_CODE";
  699|      0|    case FIRAuthErrorCodeMissingVerificationID:
  700|      0|      return @"ERROR_MISSING_VERIFICATION_ID";
  701|      0|    case FIRAuthErrorCodeInvalidVerificationID:
  702|      0|      return @"ERROR_INVALID_VERIFICATION_ID";
  703|      0|    case FIRAuthErrorCodeSessionExpired:
  704|      0|      return @"ERROR_SESSION_EXPIRED";
  705|      0|    case FIRAuthErrorCodeMissingAppCredential:
  706|      0|      return @"MISSING_APP_CREDENTIAL";
  707|      0|    case FIRAuthErrorCodeInvalidAppCredential:
  708|      0|      return @"INVALID_APP_CREDENTIAL";
  709|      0|    case FIRAuthErrorCodeQuotaExceeded:
  710|      0|      return @"ERROR_QUOTA_EXCEEDED";
  711|      0|    case FIRAuthErrorCodeMissingAppToken:
  712|      0|      return @"ERROR_MISSING_APP_TOKEN";
  713|      0|    case FIRAuthErrorCodeNotificationNotForwarded:
  714|      0|      return @"ERROR_NOTIFICATION_NOT_FORWARDED";
  715|      0|    case FIRAuthErrorCodeAppNotVerified:
  716|      0|      return @"ERROR_APP_NOT_VERIFIED";
  717|      0|    case FIRAuthErrorCodeCaptchaCheckFailed:
  718|      0|      return @"ERROR_CAPTCHA_CHECK_FAILED";
  719|      0|    case FIRAuthErrorCodeWebContextAlreadyPresented:
  720|      0|      return @"ERROR_WEB_CONTEXT_ALREADY_PRESENTED";
  721|      0|    case FIRAuthErrorCodeWebContextCancelled:
  722|      0|      return @"ERROR_WEB_CONTEXT_CANCELLED";
  723|      0|    case FIRAuthErrorCodeInvalidClientID:
  724|      0|      return @"ERROR_INVALID_CLIENT_ID";
  725|      0|    case FIRAuthErrorCodeAppVerificationUserInteractionFailure:
  726|      0|      return @"ERROR_APP_VERIFICATION_FAILED";
  727|      0|    case FIRAuthErrorCodeWebNetworkRequestFailed:
  728|      0|      return @"ERROR_WEB_NETWORK_REQUEST_FAILED";
  729|      0|    case FIRAuthErrorCodeNullUser:
  730|      0|      return @"ERROR_NULL_USER";
  731|      0|    case FIRAuthErrorCodeInvalidProviderID:
  732|      0|      return @"ERROR_INVALID_PROVIDER_ID";
  733|      0|    case FIRAuthErrorCodeInvalidDynamicLinkDomain:
  734|      0|      return @"ERROR_INVALID_DYNAMIC_LINK_DOMAIN";
  735|      0|    case FIRAuthErrorCodeWebInternalError:
  736|      0|      return @"ERROR_WEB_INTERNAL_ERROR";
  737|      0|    case FIRAuthErrorCodeWebSignInUserInteractionFailure:
  738|      0|      return @"ERROR_WEB_USER_INTERACTION_FAILURE";
  739|      0|    case FIRAuthErrorCodeMalformedJWT:
  740|      0|      return @"ERROR_MALFORMED_JWT";
  741|      0|    case FIRAuthErrorCodeLocalPlayerNotAuthenticated:
  742|      0|      return @"ERROR_LOCAL_PLAYER_NOT_AUTHENTICATED";
  743|      0|    case FIRAuthErrorCodeGameKitNotLinked:
  744|      0|      return @"ERROR_GAME_KIT_NOT_LINKED";
  745|      0|    case FIRAuthErrorCodeDynamicLinkNotActivated:
  746|      0|      return @"ERROR_DYNAMIC_LINK_NOT_ACTIVATED";
  747|      0|    case FIRAuthErrorCodeRejectedCredential:
  748|      0|      return @"ERROR_REJECTED_CREDENTIAL";
  749|      0|    case FIRAuthErrorCodeMissingOrInvalidNonce:
  750|      0|      return @"ERROR_MISSING_OR_INVALID_NONCE";
  751|      0|  }
  752|      0|}
  753|       |
  754|       |@implementation FIRAuthErrorUtils
  755|       |
  756|      0|+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code {
  757|      0|  return [self errorWithCode:code message:nil];
  758|      0|}
  759|       |
  760|       |+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code
  761|      0|                   message:(nullable NSString *)message {
  762|      0|  NSDictionary *userInfo = nil;
  763|      0|  if (message.length) {
  764|      0|    userInfo = @{
  765|      0|      NSLocalizedDescriptionKey : message
  766|      0|    };
  767|      0|  }
  768|      0|  return [self errorWithCode:code userInfo:userInfo];
  769|      0|}
  770|       |
  771|       |+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code
  772|      0|           underlyingError:(nullable NSError *)underlyingError {
  773|      0|  NSDictionary *errorUserInfo;
  774|      0|  if (underlyingError) {
  775|      0|    errorUserInfo = @{
  776|      0|      NSUnderlyingErrorKey : underlyingError
  777|      0|    };
  778|      0|  }
  779|      0|  return [self errorWithCode:code userInfo:errorUserInfo];
  780|      0|}
  781|       |
  782|       |+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code
  783|      0|                  userInfo:(nullable NSDictionary *)userInfo {
  784|      0|  BOOL isPublic = (code & FIRAuthPublicErrorCodeFlag) == FIRAuthPublicErrorCodeFlag;
  785|      0|  if (isPublic) {
  786|      0|    // This is a public error. Return it as a public error and add a description.
  787|      0|    NSInteger errorCode = code & ~FIRAuthPublicErrorCodeFlag;
  788|      0|    NSMutableDictionary *errorUserInfo = [NSMutableDictionary dictionary];
  789|      0|    if (userInfo) {
  790|      0|      [errorUserInfo addEntriesFromDictionary:userInfo];
  791|      0|    }
  792|      0|    if (!errorUserInfo[NSLocalizedDescriptionKey]) {
  793|      0|      errorUserInfo[NSLocalizedDescriptionKey] = FIRAuthErrorDescription(errorCode);
  794|      0|    }
  795|      0|    errorUserInfo[FIRAuthErrorUserInfoNameKey] = FIRAuthErrorCodeString(errorCode);
  796|      0|    return [NSError errorWithDomain:FIRAuthErrorDomain code:errorCode userInfo:errorUserInfo];
  797|      0|  } else {
  798|      0|    // This is an internal error. Wrap it in an internal error.
  799|      0|    NSError *error =
  800|      0|        [NSError errorWithDomain:FIRAuthInternalErrorDomain code:code userInfo:userInfo];
  801|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeInternalError underlyingError:error];
  802|      0|  }
  803|      0|}
  804|       |
  805|      0|+ (NSError *)RPCRequestEncodingErrorWithUnderlyingError:(NSError *)underlyingError {
  806|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeRPCRequestEncodingError
  807|      0|             underlyingError:underlyingError];
  808|      0|}
  809|       |
  810|      0|+ (NSError *)JSONSerializationErrorForUnencodableType {
  811|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeJSONSerializationError];
  812|      0|}
  813|       |
  814|      0|+ (NSError *)JSONSerializationErrorWithUnderlyingError:(NSError *)underlyingError {
  815|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeJSONSerializationError
  816|      0|             underlyingError:underlyingError];
  817|      0|}
  818|       |
  819|      0|+ (NSError *)networkErrorWithUnderlyingError:(NSError *)underlyingError {
  820|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNetworkError
  821|      0|             underlyingError:underlyingError];
  822|      0|}
  823|       |
  824|       |+ (NSError *)unexpectedErrorResponseWithData:(NSData *)data
  825|      0|                             underlyingError:(NSError *)underlyingError {
  826|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  827|      0|  if (data) {
  828|      0|    userInfo[FIRAuthErrorUserInfoDataKey] = data;
  829|      0|  }
  830|      0|  if (underlyingError) {
  831|      0|    userInfo[NSUnderlyingErrorKey] = underlyingError;
  832|      0|  }
  833|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedErrorResponse
  834|      0|                    userInfo:[userInfo copy]];
  835|      0|}
  836|       |
  837|      0|+ (NSError *)unexpectedErrorResponseWithDeserializedResponse:(id)deserializedResponse {
  838|      0|  NSDictionary *userInfo;
  839|      0|  if (deserializedResponse) {
  840|      0|    userInfo = @{
  841|      0|      FIRAuthErrorUserInfoDeserializedResponseKey : deserializedResponse,
  842|      0|    };
  843|      0|  }
  844|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedErrorResponse userInfo:userInfo];
  845|      0|}
  846|       |
  847|       |+ (NSError *)malformedJWTErrorWithToken:(NSString *)token
  848|      0|                        underlyingError:(NSError *_Nullable)underlyingError {
  849|      0|  NSMutableDictionary *userInfo =
  850|      0|      [NSMutableDictionary dictionaryWithObject:kFIRAuthErrorMessageMalformedJWT
  851|      0|                                         forKey:NSLocalizedDescriptionKey];
  852|      0|  [userInfo setObject:token forKey:FIRAuthErrorUserInfoDataKey];
  853|      0|  if (underlyingError != nil) {
  854|      0|    [userInfo setObject:underlyingError forKey:NSUnderlyingErrorKey];
  855|      0|  }
  856|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMalformedJWT userInfo:[userInfo copy]];
  857|      0|}
  858|       |
  859|       |+ (NSError *)unexpectedResponseWithData:(NSData *)data
  860|      0|                        underlyingError:(NSError *)underlyingError {
  861|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  862|      0|  if (data) {
  863|      0|    userInfo[FIRAuthErrorUserInfoDataKey] = data;
  864|      0|  }
  865|      0|  if (underlyingError) {
  866|      0|    userInfo[NSUnderlyingErrorKey] = underlyingError;
  867|      0|  }
  868|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedResponse userInfo:[userInfo copy]];
  869|      0|}
  870|       |
  871|      0|+ (NSError *)unexpectedResponseWithDeserializedResponse:(id)deserializedResponse {
  872|      0|  NSDictionary *userInfo;
  873|      0|  if (deserializedResponse) {
  874|      0|    userInfo = @{
  875|      0|      FIRAuthErrorUserInfoDeserializedResponseKey : deserializedResponse,
  876|      0|    };
  877|      0|  }
  878|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedResponse userInfo:userInfo];
  879|      0|}
  880|       |
  881|       |+ (NSError *)unexpectedResponseWithDeserializedResponse:(nullable id)deserializedResponse
  882|      0|                                        underlyingError:(NSError *)underlyingError {
  883|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  884|      0|  if (deserializedResponse) {
  885|      0|    userInfo[FIRAuthErrorUserInfoDeserializedResponseKey] = deserializedResponse;
  886|      0|  }
  887|      0|  if (underlyingError) {
  888|      0|    userInfo[NSUnderlyingErrorKey] = underlyingError;
  889|      0|  }
  890|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedResponse userInfo:[userInfo copy]];
  891|      0|}
  892|       |
  893|       |+ (NSError *)RPCResponseDecodingErrorWithDeserializedResponse:(id)deserializedResponse
  894|      0|                                              underlyingError:(NSError *)underlyingError {
  895|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  896|      0|  if (deserializedResponse) {
  897|      0|    userInfo[FIRAuthErrorUserInfoDeserializedResponseKey] = deserializedResponse;
  898|      0|  }
  899|      0|  if (underlyingError) {
  900|      0|    userInfo[NSUnderlyingErrorKey] = underlyingError;
  901|      0|  }
  902|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeRPCResponseDecodingError
  903|      0|                    userInfo:[userInfo copy]];
  904|      0|}
  905|       |
  906|      0|+ (NSError *)emailAlreadyInUseErrorWithEmail:(nullable NSString *)email {
  907|      0|  NSDictionary *userInfo;
  908|      0|  if (email.length) {
  909|      0|    userInfo = @{
  910|      0|      FIRAuthErrorUserInfoEmailKey : email,
  911|      0|    };
  912|      0|  }
  913|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeEmailAlreadyInUse userInfo:userInfo];
  914|      0|}
  915|       |
  916|      0|+ (NSError *)userDisabledErrorWithMessage:(nullable NSString *)message {
  917|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserDisabled message:message];
  918|      0|}
  919|       |
  920|      0|+ (NSError *)wrongPasswordErrorWithMessage:(nullable NSString *)message {
  921|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWrongPassword message:message];
  922|      0|}
  923|       |
  924|      0|+ (NSError *)tooManyRequestsErrorWithMessage:(nullable NSString *)message {
  925|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeTooManyRequests message:message];
  926|      0|}
  927|       |
  928|      0|+ (NSError *)invalidCustomTokenErrorWithMessage:(nullable NSString *)message {
  929|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidCustomToken message:message];
  930|      0|}
  931|       |
  932|      0|+ (NSError *)customTokenMistmatchErrorWithMessage:(nullable NSString *)message {
  933|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeCustomTokenMismatch message:message];
  934|      0|}
  935|       |
  936|      0|+ (NSError *)invalidCredentialErrorWithMessage:(nullable NSString *)message {
  937|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidCredential message:message];
  938|      0|}
  939|       |
  940|      0|+ (NSError *)requiresRecentLoginErrorWithMessage:(nullable NSString *)message {
  941|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeRequiresRecentLogin message:message];
  942|      0|}
  943|       |
  944|      0|+ (NSError *)invalidUserTokenErrorWithMessage:(nullable NSString *)message {
  945|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidUserToken message:message];
  946|      0|}
  947|       |
  948|      0|+ (NSError *)invalidEmailErrorWithMessage:(nullable NSString *)message {
  949|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidEmail message:message];
  950|      0|}
  951|       |
  952|       |+ (NSError *)accountExistsWithDifferentCredentialErrorWithEmail:(nullable NSString *)email
  953|      0|    updatedCredential:(nullable FIRAuthCredential *)updatedCredential {
  954|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  955|      0|  if (email) {
  956|      0|    userInfo[FIRAuthErrorUserInfoEmailKey] = email;
  957|      0|  }
  958|      0|  if (updatedCredential) {
  959|      0|    userInfo[FIRAuthErrorUserInfoUpdatedCredentialKey] = updatedCredential;
  960|      0|  }
  961|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAccountExistsWithDifferentCredential
  962|      0|                    userInfo:userInfo];
  963|      0|}
  964|       |
  965|      0|+ (NSError *)providerAlreadyLinkedError {
  966|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeProviderAlreadyLinked];
  967|      0|}
  968|       |
  969|      0|+ (NSError *)noSuchProviderError {
  970|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNoSuchProvider];
  971|      0|}
  972|       |
  973|      0|+ (NSError *)userTokenExpiredErrorWithMessage:(nullable NSString *)message {
  974|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserTokenExpired message:message];
  975|      0|}
  976|       |
  977|      0|+ (NSError *)userNotFoundErrorWithMessage:(nullable NSString *)message {
  978|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserNotFound message:message];
  979|      0|}
  980|       |
  981|      0|+ (NSError *)invalidAPIKeyError {
  982|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidAPIKey];
  983|      0|}
  984|       |
  985|      0|+ (NSError *)userMismatchError {
  986|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserMismatch];
  987|      0|}
  988|       |
  989|       |+ (NSError *)credentialAlreadyInUseErrorWithMessage:(nullable NSString *)message
  990|       |                                         credential:(nullable FIRAuthCredential *)credential
  991|      0|                                              email:(nullable NSString *)email {
  992|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  993|      0|  if (credential) {
  994|      0|    userInfo[FIRAuthErrorUserInfoUpdatedCredentialKey] = credential;
  995|      0|  }
  996|      0|  if (email.length) {
  997|      0|    userInfo[FIRAuthErrorUserInfoEmailKey] = email;
  998|      0|  }
  999|      0|  if (userInfo.count) {
 1000|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeCredentialAlreadyInUse
 1001|      0|                      userInfo:userInfo];
 1002|      0|  }
 1003|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeCredentialAlreadyInUse message:message];
 1004|      0|}
 1005|       |
 1006|      0|+ (NSError *)operationNotAllowedErrorWithMessage:(nullable NSString *)message {
 1007|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeOperationNotAllowed message:message];
 1008|      0|}
 1009|       |
 1010|      0|+ (NSError *)weakPasswordErrorWithServerResponseReason:(nullable NSString *)reason {
 1011|      0|  NSDictionary *userInfo;
 1012|      0|  if (reason.length) {
 1013|      0|    userInfo = @{
 1014|      0|      NSLocalizedFailureReasonErrorKey : reason,
 1015|      0|    };
 1016|      0|  }
 1017|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWeakPassword userInfo:userInfo];
 1018|      0|}
 1019|       |
 1020|      0|+ (NSError *)appNotAuthorizedError {
 1021|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAppNotAuthorized];
 1022|      0|}
 1023|       |
 1024|      0|+ (NSError *)expiredActionCodeErrorWithMessage:(nullable NSString *)message {
 1025|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeExpiredActionCode message:message];
 1026|      0|}
 1027|       |
 1028|      0|+ (NSError *)invalidActionCodeErrorWithMessage:(nullable NSString *)message {
 1029|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidActionCode message:message];
 1030|      0|}
 1031|       |
 1032|      0|+ (NSError *)invalidMessagePayloadErrorWithMessage:(nullable NSString *)message {
 1033|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidMessagePayload message:message];
 1034|      0|}
 1035|       |
 1036|      0|+ (NSError *)invalidSenderErrorWithMessage:(nullable NSString *)message {
 1037|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidSender message:message];
 1038|      0|}
 1039|       |
 1040|      0|+ (NSError *)invalidRecipientEmailErrorWithMessage:(nullable NSString *)message {
 1041|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidRecipientEmail message:message];
 1042|      0|}
 1043|       |
 1044|      0|+ (NSError *)missingIosBundleIDErrorWithMessage:(nullable NSString *)message {
 1045|      0|  return [self errorWithCode:FIRAuthinternalErrorCodeMissingIosBundleID message:message];
 1046|      0|}
 1047|       |
 1048|      0|+ (NSError *)missingAndroidPackageNameErrorWithMessage:(nullable NSString *)message {
 1049|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingAndroidPackageName message:message];
 1050|      0|}
 1051|       |
 1052|      0|+ (NSError *)unauthorizedDomainErrorWithMessage:(nullable NSString *)message {
 1053|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnauthorizedDomain message:message];
 1054|      0|}
 1055|       |
 1056|      0|+ (NSError *)invalidContinueURIErrorWithMessage:(nullable NSString *)message {
 1057|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidContinueURI message:message];
 1058|      0|}
 1059|       |
 1060|      0|+ (NSError *)missingContinueURIErrorWithMessage:(nullable NSString *)message {
 1061|      0|  return[self errorWithCode:FIRAuthInternalErrorCodeMissingContinueURI message:message];
 1062|      0|}
 1063|       |
 1064|      0|+ (NSError *)missingEmailErrorWithMessage:(nullable NSString *)message {
 1065|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingEmail message:message];
 1066|      0|}
 1067|       |
 1068|      0|+ (NSError *)missingPhoneNumberErrorWithMessage:(nullable NSString *)message {
 1069|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingPhoneNumber message:message];
 1070|      0|}
 1071|       |
 1072|      0|+ (NSError *)invalidPhoneNumberErrorWithMessage:(nullable NSString *)message {
 1073|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidPhoneNumber message:message];
 1074|      0|}
 1075|       |
 1076|      0|+ (NSError *)missingVerificationCodeErrorWithMessage:(nullable NSString *)message {
 1077|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingVerificationCode message:message];
 1078|      0|}
 1079|       |
 1080|      0|+ (NSError *)invalidVerificationCodeErrorWithMessage:(nullable NSString *)message {
 1081|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidVerificationCode message:message];
 1082|      0|}
 1083|       |
 1084|      0|+ (NSError *)missingVerificationIDErrorWithMessage:(nullable NSString *)message {
 1085|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingVerificationID message:message];
 1086|      0|}
 1087|       |
 1088|      0|+ (NSError *)invalidVerificationIDErrorWithMessage:(nullable NSString *)message {
 1089|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidVerificationID message:message];
 1090|      0|}
 1091|       |
 1092|      0|+ (NSError *)sessionExpiredErrorWithMessage:(nullable NSString *)message {
 1093|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeSessionExpired message:message];
 1094|      0|}
 1095|       |
 1096|      0|+ (NSError *)missingAppCredentialWithMessage:(nullable NSString *)message {
 1097|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingAppCredential message:message];
 1098|      0|}
 1099|       |
 1100|      0|+ (NSError *)invalidAppCredentialWithMessage:(nullable NSString *)message {
 1101|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidAppCredential message:message];
 1102|      0|}
 1103|       |
 1104|      0|+ (NSError *)quotaExceededErrorWithMessage:(nullable NSString *)message {
 1105|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeQuotaExceeded message:message];
 1106|      0|}
 1107|       |
 1108|      0|+ (NSError *)missingAppTokenErrorWithUnderlyingError:(nullable NSError *)underlyingError {
 1109|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingAppToken
 1110|      0|             underlyingError:underlyingError];
 1111|      0|}
 1112|       |
 1113|      0|+ (NSError *)localPlayerNotAuthenticatedError {
 1114|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeLocalPlayerNotAuthenticated];
 1115|      0|}
 1116|       |
 1117|      0|+ (NSError *)gameKitNotLinkedError {
 1118|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeGameKitNotLinked];
 1119|      0|}
 1120|       |
 1121|      0|+ (NSError *)notificationNotForwardedError {
 1122|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNotificationNotForwarded];
 1123|      0|}
 1124|       |
 1125|      0|+ (NSError *)appNotVerifiedErrorWithMessage:(nullable NSString *)message {
 1126|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAppNotVerified message:message];
 1127|      0|}
 1128|       |
 1129|      0|+ (NSError *)missingClientIdentifierErrorWithMessage:(nullable NSString *)message {
 1130|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingClientIdentifier message:message];
 1131|      0|}
 1132|       |
 1133|      0|+ (NSError *)captchaCheckFailedErrorWithMessage:(nullable NSString *)message {
 1134|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeCaptchaCheckFailed message:message];
 1135|      0|}
 1136|       |
 1137|      0|+ (NSError *)webContextAlreadyPresentedErrorWithMessage:(nullable NSString *)message {
 1138|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWebContextAlreadyPresented message:message];
 1139|      0|}
 1140|       |
 1141|      0|+ (NSError *)webContextCancelledErrorWithMessage:(nullable NSString *)message {
 1142|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWebContextCancelled message:message];
 1143|      0|}
 1144|       |
 1145|      0|+ (NSError *)appVerificationUserInteractionFailureWithReason:(NSString *)reason {
 1146|      0|  NSDictionary *userInfo;
 1147|      0|  if (reason.length) {
 1148|      0|    userInfo = @{
 1149|      0|      NSLocalizedFailureReasonErrorKey : reason,
 1150|      0|    };
 1151|      0|  }
 1152|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAppVerificationUserInteractionFailure
 1153|      0|                    userInfo:userInfo];
 1154|      0|}
 1155|       |
 1156|      0|+ (NSError *)webSignInUserInteractionFailureWithReason:(nullable NSString *)reason {
 1157|      0|  NSDictionary *userInfo;
 1158|      0|  if (reason.length) {
 1159|      0|    userInfo = @{
 1160|      0|      NSLocalizedFailureReasonErrorKey : reason,
 1161|      0|    };
 1162|      0|  }
 1163|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWebSignInUserInteractionFailure
 1164|      0|                    userInfo:userInfo];
 1165|      0|}
 1166|       |
 1167|      0|+ (nullable NSError *)URLResponseErrorWithCode:(NSString *)code message:(nullable NSString *)message {
 1168|      0|  if ([code isEqualToString:kURLResponseErrorCodeInvalidClientID]) {
 1169|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeInvalidClientID message:message];
 1170|      0|  }
 1171|      0|  if ([code isEqualToString:kURLResponseErrorCodeNetworkRequestFailed]) {
 1172|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeWebNetworkRequestFailed message:message];
 1173|      0|  }
 1174|      0|  if ([code isEqualToString:kURLResponseErrorCodeInternalError]) {
 1175|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeWebInternalError message:message];
 1176|      0|  }
 1177|      0|  return nil;
 1178|      0|}
 1179|       |
 1180|      0|+ (NSError *)nullUserErrorWithMessage:(nullable NSString *)message {
 1181|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNullUser message:message];
 1182|      0|}
 1183|       |
 1184|      0|+ (NSError *)invalidProviderIDErrorWithMessage:(nullable NSString *)message {
 1185|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidProviderID message:message];
 1186|      0|}
 1187|       |
 1188|      0|+ (NSError *)invalidDynamicLinkDomainErrorWithMessage:(nullable NSString *)message {
 1189|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidDynamicLinkDomain message:message];
 1190|      0|}
 1191|       |
 1192|      0|+ (NSError *)missingOrInvalidNonceErrorWithMessage:(nullable NSString *)message {
 1193|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingOrInvalidNonce message:message];
 1194|      0|}
 1195|       |
 1196|      0|+ (NSError *)keychainErrorWithFunction:(NSString *)keychainFunction status:(OSStatus)status {
 1197|      0|  NSString *failureReason = [NSString stringWithFormat:@"%@ (%li)", keychainFunction, (long)status];
 1198|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeKeychainError userInfo:@{
 1199|      0|    NSLocalizedFailureReasonErrorKey : failureReason,
 1200|      0|  }];
 1201|      0|}
 1202|       |
 1203|       |@end
 1204|       |
 1205|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthExceptionUtils.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthExceptionUtils.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var FIRMethodNotImplementedException
   22|       |    @brief The name of the "Method Not Implemented" exception.
   23|       | */
   24|       |static NSString *const FIRMethodNotImplementedException = @"FIRMethodNotImplementedException";
   25|       |
   26|       |@implementation FIRAuthExceptionUtils
   27|       |
   28|      0|+ (void)raiseInvalidParameterExceptionWithReason:(nullable NSString *)reason {
   29|      0|  [NSException raise:NSInvalidArgumentException format:@"%@", reason];
   30|      0|}
   31|       |
   32|      0|+ (void)raiseMethodNotImplementedExceptionWithReason:(nullable NSString *)reason {
   33|      0|  NSException *exception =
   34|      0|      [NSException exceptionWithName:FIRMethodNotImplementedException reason:reason userInfo:nil];
   35|      0|  [exception raise];
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthURLPresenter.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX && !TARGET_OS_TV
   19|       |
   20|       |#import "FIRAuthURLPresenter.h"
   21|       |
   22|       |#import <SafariServices/SafariServices.h>
   23|       |
   24|       |#import "FIRAuthDefaultUIDelegate.h"
   25|       |#import "FIRAuthErrorUtils.h"
   26|       |#import "FIRAuthGlobalWorkQueue.h"
   27|       |#import "FIRAuthUIDelegate.h"
   28|       |#import "FIRAuthWebViewController.h"
   29|       |
   30|       |NS_ASSUME_NONNULL_BEGIN
   31|       |
   32|       |@interface FIRAuthURLPresenter () <SFSafariViewControllerDelegate,
   33|       |                                   FIRAuthWebViewControllerDelegate>
   34|       |@end
   35|       |
   36|       |// Disable unguarded availability warnings because SFSafariViewController is been used throughout
   37|       |// the code, including as an iVar, which cannot be simply excluded by @available check.
   38|       |#pragma clang diagnostic push
   39|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   40|       |
   41|       |@implementation FIRAuthURLPresenter {
   42|       |  /** @var _isPresenting
   43|       |      @brief Whether or not some web-based content is being presented.
   44|       |   */
   45|       |  BOOL _isPresenting;
   46|       |
   47|       |  /** @var _callbackMatcher
   48|       |      @brief The callback URL matcher for the current presentation, if one is active.
   49|       |   */
   50|       |  FIRAuthURLCallbackMatcher _Nullable _callbackMatcher;
   51|       |
   52|       |  /** @var _safariViewController
   53|       |      @brief The SFSafariViewController used for the current presentation, if any.
   54|       |   */
   55|       |  SFSafariViewController *_Nullable _safariViewController;
   56|       |
   57|       |  /** @var _webViewController
   58|       |      @brief The FIRAuthWebViewController used for the current presentation, if any.
   59|       |   */
   60|       |  FIRAuthWebViewController *_Nullable _webViewController;
   61|       |
   62|       |  /** @var _UIDelegate
   63|       |      @brief The UIDelegate used to present the SFSafariViewController.
   64|       |   */
   65|       |  id<FIRAuthUIDelegate> _UIDelegate;
   66|       |
   67|       |  /** @var _completion
   68|       |      @brief The completion handler for the current presentaion, if one is active.
   69|       |      @remarks This variable is also used as a flag to indicate a presentation is active.
   70|       |   */
   71|       |  FIRAuthURLPresentationCompletion _Nullable _completion;
   72|       |}
   73|       |
   74|       |- (void)presentURL:(NSURL *)URL
   75|       |        UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
   76|       |   callbackMatcher:(FIRAuthURLCallbackMatcher)callbackMatcher
   77|      0|        completion:(FIRAuthURLPresentationCompletion)completion {
   78|      0|  if (_isPresenting) {
   79|      0|    // Unable to start a new presentation on top of another.
   80|      0|    _completion(nil, [FIRAuthErrorUtils webContextAlreadyPresentedErrorWithMessage:nil]);
   81|      0|    return;
   82|      0|  }
   83|      0|  _isPresenting = YES;
   84|      0|  _callbackMatcher = callbackMatcher;
   85|      0|  _completion = completion;
   86|      0|  dispatch_async(dispatch_get_main_queue(), ^() {
   87|      0|    self->_UIDelegate = UIDelegate ?: [FIRAuthDefaultUIDelegate defaultUIDelegate];
   88|      0|    if ([SFSafariViewController class]) {
   89|      0|      self->_safariViewController = [[SFSafariViewController alloc] initWithURL:URL];
   90|      0|      self->_safariViewController.delegate = self;
   91|      0|      [self->_UIDelegate presentViewController:self->_safariViewController
   92|      0|                                      animated:YES
   93|      0|                                    completion:nil];
   94|      0|      return;
   95|      0|    } else {
   96|      0|      self->_webViewController = [[FIRAuthWebViewController alloc] initWithURL:URL delegate:self];
   97|      0|      UINavigationController *navController =
   98|      0|          [[UINavigationController alloc] initWithRootViewController:self->_webViewController];
   99|      0|      [self->_UIDelegate presentViewController:navController animated:YES completion:nil];
  100|      0|    }
  101|      0|  });
  102|      0|}
  103|       |
  104|      0|- (BOOL)canHandleURL:(NSURL *)URL {
  105|      0|  if (_isPresenting && _callbackMatcher && _callbackMatcher(URL)) {
  106|      0|    [self finishPresentationWithURL:URL error:nil];
  107|      0|    return YES;
  108|      0|  }
  109|      0|  return NO;
  110|      0|}
  111|       |
  112|       |#pragma mark - SFSafariViewControllerDelegate
  113|       |
  114|      0|- (void)safariViewControllerDidFinish:(SFSafariViewController *)controller {
  115|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^() {
  116|      0|    if (controller == self->_safariViewController) {
  117|      0|      self->_safariViewController = nil;
  118|      0|      //TODO:Ensure that the SFSafariViewController is actually removed from the screen before
  119|      0|      //invoking finishPresentationWithURL:error:
  120|      0|      [self finishPresentationWithURL:nil
  121|      0|                                error:[FIRAuthErrorUtils webContextCancelledErrorWithMessage:nil]];
  122|      0|    }
  123|      0|  });
  124|      0|}
  125|       |
  126|       |#pragma mark - FIRAuthwebViewControllerDelegate
  127|       |
  128|      0|- (BOOL)webViewController:(FIRAuthWebViewController *)webViewController canHandleURL:(NSURL *)URL {
  129|      0|  __block BOOL result = NO;
  130|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^() {
  131|      0|    if (webViewController == self->_webViewController) {
  132|      0|      result = [self canHandleURL:URL];
  133|      0|    }
  134|      0|  });
  135|      0|  return result;
  136|      0|}
  137|       |
  138|      0|- (void)webViewControllerDidCancel:(FIRAuthWebViewController *)webViewController {
  139|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^() {
  140|      0|    if (webViewController == self->_webViewController) {
  141|      0|      [self finishPresentationWithURL:nil
  142|      0|                                error:[FIRAuthErrorUtils webContextCancelledErrorWithMessage:nil]];
  143|      0|    }
  144|      0|  });
  145|      0|}
  146|       |
  147|       |- (void)webViewController:(FIRAuthWebViewController *)webViewController
  148|      0|         didFailWithError:(NSError *)error {
  149|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^() {
  150|      0|    if (webViewController == self->_webViewController) {
  151|      0|      [self finishPresentationWithURL:nil error:error];
  152|      0|    }
  153|      0|  });
  154|      0|}
  155|       |
  156|       |#pragma mark - Private methods
  157|       |
  158|       |/** @fn finishPresentationWithURL:error:
  159|       |    @brief Finishes the presentation for a given URL, if any.
  160|       |    @param URL The URL to finish presenting.
  161|       |    @param error The error with which to finish presenting, if any.
  162|       | */
  163|       |- (void)finishPresentationWithURL:(nullable NSURL *)URL
  164|      0|                            error:(nullable NSError *)error {
  165|      0|  _callbackMatcher = nil;
  166|      0|  id<FIRAuthUIDelegate> UIDelegate = _UIDelegate;
  167|      0|  _UIDelegate = nil;
  168|      0|  FIRAuthURLPresentationCompletion completion = _completion;
  169|      0|  _completion = nil;
  170|      0|  void (^finishBlock)(void) = ^() {
  171|      0|    self->_isPresenting = NO;
  172|      0|    completion(URL, error);
  173|      0|  };
  174|      0|  SFSafariViewController *safariViewController = _safariViewController;
  175|      0|  _safariViewController = nil;
  176|      0|  FIRAuthWebViewController *webViewController = _webViewController;
  177|      0|  _webViewController = nil;
  178|      0|  if (safariViewController || webViewController) {
  179|      0|    dispatch_async(dispatch_get_main_queue(), ^() {
  180|      0|      [UIDelegate dismissViewControllerAnimated:YES completion:^() {
  181|      0|        dispatch_async(FIRAuthGlobalWorkQueue(), finishBlock);
  182|      0|      }];
  183|      0|    });
  184|      0|  } else {
  185|      0|    finishBlock();
  186|      0|  }
  187|      0|}
  188|       |
  189|       |#pragma clang diagnostic pop  // ignored "-Wunguarded-availability"
  190|       |
  191|       |@end
  192|       |
  193|       |NS_ASSUME_NONNULL_END
  194|       |
  195|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthWebUtils.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthWebUtils.h"
   18|       |
   19|       |#import "FIRAuthBackend.h"
   20|       |#import "FIRAuthErrorUtils.h"
   21|       |#import "FIRGetProjectConfigRequest.h"
   22|       |#import "FIRGetProjectConfigResponse.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@implementation FIRAuthWebUtils
   27|       |
   28|      0|+ (NSArray<NSString *> *)supportedAuthDomains {
   29|      0|  return @[@"firebaseapp.com", @"web.app"];
   30|      0|}
   31|       |
   32|      0|+ (NSString *)randomStringWithLength:(NSUInteger)length {
   33|      0|  NSMutableString *randomString = [[NSMutableString alloc] init];
   34|      0|  for (int i=0; i < length; i++) {
   35|      0|    [randomString appendString:
   36|      0|        [NSString stringWithFormat:@"%c", 'a' + arc4random_uniform('z' - 'a' + 1)]];
   37|      0|  }
   38|      0|  return randomString;
   39|      0|}
   40|       |
   41|      0|+ (BOOL)isCallbackSchemeRegisteredForCustomURLScheme:(NSString *)URLScheme {
   42|      0|  NSString *expectedCustomScheme = [URLScheme lowercaseString];
   43|      0|  NSArray *urlTypes = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleURLTypes"];
   44|      0|  for (NSDictionary *urlType in urlTypes) {
   45|      0|    NSArray *urlTypeSchemes = urlType[@"CFBundleURLSchemes"];
   46|      0|    for (NSString *urlTypeScheme in urlTypeSchemes) {
   47|      0|      if ([urlTypeScheme.lowercaseString isEqualToString:expectedCustomScheme]) {
   48|      0|        return YES;
   49|      0|      }
   50|      0|    }
   51|      0|  }
   52|      0|  return NO;
   53|      0|}
   54|       |
   55|       |+ (BOOL)isExpectedCallbackURL:(nullable NSURL *)URL
   56|       |                      eventID:(NSString *)eventID
   57|       |                     authType:(NSString *)authType
   58|      0|               callbackScheme:(NSString *)callbackScheme {
   59|      0| if (!URL) {
   60|      0|    return NO;
   61|      0|  }
   62|      0|  NSURLComponents *actualURLComponents =
   63|      0|      [NSURLComponents componentsWithURL:URL resolvingAgainstBaseURL:NO];
   64|      0|  actualURLComponents.query = nil;
   65|      0|  actualURLComponents.fragment = nil;
   66|      0|
   67|      0|  NSURLComponents *expectedURLComponents = [[NSURLComponents alloc] init];
   68|      0|  expectedURLComponents.scheme = callbackScheme;
   69|      0|  expectedURLComponents.host = @"firebaseauth";
   70|      0|  expectedURLComponents.path = @"/link";
   71|      0|
   72|      0|  if (![expectedURLComponents.URL isEqual:actualURLComponents.URL]) {
   73|      0|    return NO;
   74|      0|  }
   75|      0|  NSDictionary<NSString *, NSString *> *URLQueryItems =
   76|      0|      [self dictionaryWithHttpArgumentsString:URL.query];
   77|      0|  NSURL *deeplinkURL = [NSURL URLWithString:URLQueryItems[@"deep_link_id"]];
   78|      0|  NSDictionary<NSString *, NSString *> *deeplinkQueryItems =
   79|      0|      [self dictionaryWithHttpArgumentsString:deeplinkURL.query];
   80|      0|  if ([deeplinkQueryItems[@"authType"] isEqualToString:authType] &&
   81|      0|      [deeplinkQueryItems[@"eventId"] isEqualToString:eventID]) {
   82|      0|    return YES;
   83|      0|  }
   84|      0|  return NO;
   85|      0|}
   86|       |
   87|       |+ (void)fetchAuthDomainWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
   88|      0|                                     completion:(FIRFetchAuthDomainCallback)completion {
   89|      0|  FIRGetProjectConfigRequest *request =
   90|      0|      [[FIRGetProjectConfigRequest alloc] initWithRequestConfiguration:requestConfiguration];
   91|      0|
   92|      0|  [FIRAuthBackend getProjectConfig:request
   93|      0|                          callback:^(FIRGetProjectConfigResponse *_Nullable response,
   94|      0|                                     NSError *_Nullable error) {
   95|      0|    if (error) {
   96|      0|      completion(nil, error);
   97|      0|      return;
   98|      0|    }
   99|      0|    // Look up an authorized domain ends with one of the supportedAuthDomains.
  100|      0|    // The sequence of supportedAuthDomains matters. ("firebaseapp.com", "web.app")
  101|      0|    // The searching ends once the first valid suportedAuthDomain is found.
  102|      0|    NSString *authDomain;
  103|      0|    for (NSString *domain in response.authorizedDomains) {
  104|      0|      for (NSString *suportedAuthDomain in [self supportedAuthDomains]) {
  105|      0|        NSInteger index = domain.length - suportedAuthDomain.length;
  106|      0|        if (index >= 2) {
  107|      0|          if ([domain hasSuffix:suportedAuthDomain] && domain.length >= suportedAuthDomain.length + 2) {
  108|      0|            authDomain = domain;
  109|      0|            break;
  110|      0|          }
  111|      0|        }
  112|      0|      }
  113|      0|      if (authDomain != nil) {
  114|      0|        break;
  115|      0|      }
  116|      0|    }
  117|      0|    if (!authDomain.length) {
  118|      0|      completion(nil, [FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:response]);
  119|      0|      return;
  120|      0|    }
  121|      0|    completion(authDomain, nil);
  122|      0|  }];
  123|      0|}
  124|       |
  125|       |/** @fn queryItemValue:from:
  126|       | @brief Utility function to get a value from a NSURLQueryItem array.
  127|       | @param name The key.
  128|       | @param queryList The NSURLQueryItem array.
  129|       | @return The value for the key.
  130|       | */
  131|      0|+ (nullable NSString *)queryItemValue:(NSString *)name from:(NSArray<NSURLQueryItem *> *)queryList {
  132|      0|  for (NSURLQueryItem *item in queryList) {
  133|      0|    if ([item.name isEqualToString:name]) {
  134|      0|      return item.value;
  135|      0|    }
  136|      0|  }
  137|      0|  return nil;
  138|      0|}
  139|       |
  140|      0|+ (NSDictionary *)dictionaryWithHttpArgumentsString:(NSString *)argString {
  141|      0|  NSMutableDictionary* ret = [NSMutableDictionary dictionary];
  142|      0|  NSArray* components = [argString componentsSeparatedByString:@"&"];
  143|      0|  NSString* component;
  144|      0|  // Use reverse order so that the first occurrence of a key replaces
  145|      0|  // those subsequent.
  146|      0|  for (component in [components reverseObjectEnumerator]) {
  147|      0|    if (component.length == 0)
  148|      0|      continue;
  149|      0|    NSRange pos = [component rangeOfString:@"="];
  150|      0|    NSString *key;
  151|      0|    NSString *val;
  152|      0|    if (pos.location == NSNotFound) {
  153|      0|      key = [self stringByUnescapingFromURLArgument:component];
  154|      0|      val = @"";
  155|      0|    } else {
  156|      0|      key = [self stringByUnescapingFromURLArgument:[component substringToIndex:pos.location]];
  157|      0|      val = [self stringByUnescapingFromURLArgument:
  158|      0|          [component substringFromIndex:pos.location + pos.length]];
  159|      0|    }
  160|      0|    // returns nil on invalid UTF8 and NSMutableDictionary raises an exception when passed nil
  161|      0|    // values.
  162|      0|    if (!key) key = @"";
  163|      0|    if (!val) val = @"";
  164|      0|    [ret setObject:val forKey:key];
  165|      0|  }
  166|      0|  return ret;
  167|      0|}
  168|       |
  169|      0|+ (NSString *)stringByUnescapingFromURLArgument:(NSString *)argument {
  170|      0|  NSMutableString *resultString = [NSMutableString stringWithString:argument];
  171|      0|  [resultString replaceOccurrencesOfString:@"+"
  172|      0|                                withString:@" "
  173|      0|                                   options:NSLiteralSearch
  174|      0|                                     range:NSMakeRange(0, [resultString length])];
  175|      0|  return [resultString stringByRemovingPercentEncoding];
  176|      0|}
  177|       |
  178|      0|+ (NSDictionary<NSString *, NSString *> *)parseURL:(NSString *)urlString {
  179|      0|  NSString *linkURL = [NSURLComponents componentsWithString:urlString].query;
  180|      0|  if (!linkURL) {
  181|      0|    return @{};
  182|      0|  }
  183|      0|  NSArray<NSString *> *URLComponents = [linkURL componentsSeparatedByString:@"&"];
  184|      0|  NSMutableDictionary<NSString *, NSString *> *queryItems =
  185|      0|  [[NSMutableDictionary alloc] initWithCapacity:URLComponents.count];
  186|      0|  for (NSString *component in URLComponents) {
  187|      0|    NSRange equalRange = [component rangeOfString:@"="];
  188|      0|    if (equalRange.location != NSNotFound) {
  189|      0|      NSString *queryItemKey =
  190|      0|      [[component substringToIndex:equalRange.location] stringByRemovingPercentEncoding];
  191|      0|      NSString *queryItemValue =
  192|      0|      [[component substringFromIndex:equalRange.location + 1] stringByRemovingPercentEncoding];
  193|      0|      if (queryItemKey && queryItemValue) {
  194|      0|        queryItems[queryItemKey] = queryItemValue;
  195|      0|      }
  196|      0|    }
  197|      0|  }
  198|      0|  return queryItems;
  199|      0|}
  200|       |
  201|       |@end
  202|       |
  203|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthWebView.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX && !TARGET_OS_TV
   19|       |
   20|       |#import "FIRAuthWebView.h"
   21|       |
   22|       |NS_ASSUME_NONNULL_BEGIN
   23|       |
   24|       |@implementation FIRAuthWebView
   25|       |
   26|      0|- (instancetype)initWithFrame:(CGRect)frame {
   27|      0|  self = [super initWithFrame:frame];
   28|      0|  if (self) {
   29|      0|    self.backgroundColor = [UIColor whiteColor];
   30|      0|    [self initializeSubviews];
   31|      0|  }
   32|      0|  return self;
   33|      0|}
   34|       |
   35|       |/** @fn initializeSubviews
   36|       |    @brief Initializes the subviews of this view.
   37|       | */
   38|      0|- (void)initializeSubviews {
   39|      0|  WKWebView *webView = [self createWebView];
   40|      0|  UIActivityIndicatorView *spinner = [self createSpinner];
   41|      0|
   42|      0|  // The order of the following controls z-order.
   43|      0|  [self addSubview:webView];
   44|      0|  [self addSubview:spinner];
   45|      0|
   46|      0|  [self layoutSubviews];
   47|      0|  _webView = webView;
   48|      0|  _spinner = spinner;
   49|      0|}
   50|       |
   51|      0|- (void)layoutSubviews {
   52|      0|  CGFloat height = self.bounds.size.height;
   53|      0|  CGFloat width = self.bounds.size.width;
   54|      0|  _webView.frame = CGRectMake(0, 0, width, height);
   55|      0|  _spinner.center = _webView.center;
   56|      0|}
   57|       |
   58|       |/** @fn createWebView
   59|       |    @brief Creates a web view to be used by this view.
   60|       |    @return The newly created web view.
   61|       | */
   62|      0|- (WKWebView *)createWebView {
   63|      0|  WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero];
   64|      0|  // Trickery to make the web view not do weird things (like showing a black background when
   65|      0|  // the prompt in the navigation bar animates changes.)
   66|      0|  webView.opaque = NO;
   67|      0|  webView.backgroundColor = [UIColor clearColor];
   68|      0|  webView.scrollView.opaque = NO;
   69|      0|  webView.scrollView.backgroundColor = [UIColor clearColor];
   70|      0|  webView.scrollView.bounces = NO;
   71|      0|  webView.scrollView.alwaysBounceVertical = NO;
   72|      0|  webView.scrollView.alwaysBounceHorizontal = NO;
   73|      0|  return webView;
   74|      0|}
   75|       |
   76|       |/** @fn createSpinner
   77|       |    @brief Creates a spinner to be used by this view.
   78|       |    @return The newly created spinner.
   79|       | */
   80|      0|- (UIActivityIndicatorView *)createSpinner {
   81|      0|  UIActivityIndicatorViewStyle spinnerStyle;
   82|      0|#if defined(TARGET_OS_MACCATALYST)
   83|      0|  if (@available(iOS 13.0, *)) {
   84|      0|    spinnerStyle = UIActivityIndicatorViewStyleMedium;
   85|      0|  } else {
   86|      0|    spinnerStyle = UIActivityIndicatorViewStyleGray;
   87|      0|  }
   88|       |#else
   89|       |  spinnerStyle = UIActivityIndicatorViewStyleGray;
   90|       |#endif
   91|       |  UIActivityIndicatorView *spinner =
   92|      0|      [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:spinnerStyle];
   93|      0|  return spinner;
   94|      0|}
   95|       |
   96|       |@end
   97|       |
   98|       |NS_ASSUME_NONNULL_END
   99|       |
  100|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/FIRAuthWebViewController.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#include <TargetConditionals.h>
   18|       |#if !TARGET_OS_OSX && !TARGET_OS_TV
   19|       |
   20|       |#import "FIRAuthWebViewController.h"
   21|       |
   22|       |#import "FIRAuthWebView.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@interface FIRAuthWebViewController () <WKNavigationDelegate>
   27|       |@end
   28|       |
   29|       |@implementation FIRAuthWebViewController {
   30|       |  /** @var _URL
   31|       |      @brief The initial URL to display.
   32|       |   */
   33|       |  NSURL *_URL;
   34|       |
   35|       |  /** @var _delegate
   36|       |      @brief The delegate to call.
   37|       |   */
   38|       |  __weak id<FIRAuthWebViewControllerDelegate> _delegate;
   39|       |
   40|       |  /** @var _webView;
   41|       |      @brief The web view instance for easier access.
   42|       |   */
   43|       |  __weak FIRAuthWebView *_webView;
   44|       |}
   45|       |
   46|       |- (instancetype)initWithURL:(NSURL *)URL
   47|      0|                   delegate:(__weak id<FIRAuthWebViewControllerDelegate>)delegate {
   48|      0|  self = [super initWithNibName:nil bundle:nil];
   49|      0|  if (self) {
   50|      0|    _URL = URL;
   51|      0|    _delegate = delegate;
   52|      0|  }
   53|      0|  return self;
   54|      0|}
   55|       |
   56|       |#pragma mark - Lifecycle
   57|       |
   58|      0|- (void)loadView {
   59|      0|  FIRAuthWebView *webView = [[FIRAuthWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];
   60|      0|  webView.webView.navigationDelegate = self;
   61|      0|  self.view = webView;
   62|      0|  _webView = webView;
   63|      0|  self.navigationItem.leftBarButtonItem =
   64|      0|      [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCancel
   65|      0|                                                    target:self
   66|      0|                                                    action:@selector(cancel)];
   67|      0|}
   68|       |
   69|      0|- (void)viewDidAppear:(BOOL)animated {
   70|      0|  [super viewDidAppear:animated];
   71|      0|
   72|      0|  // Loads the requested URL in the web view.
   73|      0|  [_webView.webView loadRequest:[NSURLRequest requestWithURL:_URL]];
   74|      0|}
   75|       |
   76|       |#pragma mark - UI Targets
   77|       |
   78|      0|- (void)cancel {
   79|      0|  [_delegate webViewControllerDidCancel:self];
   80|      0|}
   81|       |
   82|       |#pragma mark - WKNavigationDelegate
   83|       |
   84|       |- (void)webView:(WKWebView *)webView
   85|       |    decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction
   86|      0|    decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
   87|      0|  [_delegate webViewController:self canHandleURL:navigationAction.request.URL];
   88|      0|  decisionHandler(WKNavigationActionPolicyAllow);
   89|      0|}
   90|       |
   91|       |- (void)webView:(WKWebView *)webView
   92|      0|didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation {
   93|      0|  _webView.spinner.hidden = NO;
   94|      0|  [_webView.spinner startAnimating];
   95|      0|}
   96|       |
   97|       |- (void)webView:(WKWebView *)webView
   98|      0|didFinishNavigation:(null_unspecified WKNavigation *)navigation {
   99|      0|  _webView.spinner.hidden = YES;
  100|      0|  [_webView.spinner stopAnimating];
  101|      0|}
  102|       |
  103|       |- (void)webView:(WKWebView *)webView
  104|       |didFailNavigation:(null_unspecified WKNavigation *)navigation
  105|      0|      withError:(NSError *)error {
  106|      0|  if ([error.domain isEqualToString:NSURLErrorDomain] && error.code == NSURLErrorCancelled) {
  107|      0|    // It's okay for the page to be redirected before it is completely loaded.  See b/32028062 .
  108|      0|    return;
  109|      0|  }
  110|      0|  // Forward notification to our delegate.
  111|      0|  [self webView:webView didFinishNavigation:navigation];
  112|      0|  [_delegate webViewController:self didFailWithError:error];
  113|      0|}
  114|       |
  115|       |@end
  116|       |
  117|       |NS_ASSUME_NONNULL_END
  118|       |
  119|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseAuth/Firebase/Auth/Source/Utilities/NSData+FIRBase64.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "NSData+FIRBase64.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation NSData (FIRBase64)
   22|       |
   23|      0|- (NSString *)fir_base64URLEncodedStringWithOptions:(NSDataBase64EncodingOptions)options {
   24|      0|  NSString *string = [self base64EncodedStringWithOptions:options];
   25|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
   26|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
   27|      0|  string = [string stringByReplacingOccurrencesOfString:@"=" withString:@""];
   28|      0|  return string;
   29|      0|}
   30|       |
   31|       |@end
   32|       |
   33|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRAnalyticsConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRAnalyticsConfiguration.h"
   18|       |
   19|       |#pragma clang diagnostic push
   20|       |#pragma clang diagnostic ignored "-Wdeprecated-implementations"
   21|       |@implementation FIRAnalyticsConfiguration
   22|       |#pragma clang diagnostic pop
   23|       |
   24|      1|+ (FIRAnalyticsConfiguration *)sharedInstance {
   25|      1|  static FIRAnalyticsConfiguration *sharedInstance = nil;
   26|      1|  static dispatch_once_t onceToken;
   27|      1|  dispatch_once(&onceToken, ^{
   28|      1|    sharedInstance = [[FIRAnalyticsConfiguration alloc] init];
   29|      1|  });
   30|      1|  return sharedInstance;
   31|      1|}
   32|       |
   33|      0|- (void)postNotificationName:(NSString *)name value:(id)value {
   34|      0|  if (!name.length || !value) {
   35|      0|    return;
   36|      0|  }
   37|      0|  [[NSNotificationCenter defaultCenter] postNotificationName:name
   38|      0|                                                      object:self
   39|      0|                                                    userInfo:@{name : value}];
   40|      0|}
   41|       |
   42|      0|- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled {
   43|      0|  [self setAnalyticsCollectionEnabled:analyticsCollectionEnabled persistSetting:YES];
   44|      0|}
   45|       |
   46|       |- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled
   47|      0|                       persistSetting:(BOOL)shouldPersist {
   48|      0|  // Persist the measurementEnabledState. Use FIRAnalyticsEnabledState values instead of YES/NO.
   49|      0|  FIRAnalyticsEnabledState analyticsEnabledState =
   50|      0|      analyticsCollectionEnabled ? kFIRAnalyticsEnabledStateSetYes : kFIRAnalyticsEnabledStateSetNo;
   51|      0|  if (shouldPersist) {
   52|      0|    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
   53|      0|    [userDefaults setObject:@(analyticsEnabledState)
   54|      0|                     forKey:kFIRAPersistedConfigMeasurementEnabledStateKey];
   55|      0|    [userDefaults synchronize];
   56|      0|  }
   57|      0|
   58|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetEnabledNotification
   59|      0|                       value:@(analyticsCollectionEnabled)];
   60|      0|}
   61|       |
   62|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRApp.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <sys/utsname.h>
   16|       |
   17|       |#if __has_include(<UIKit/UIKit.h>)
   18|       |#import <UIKit/UIKit.h>
   19|       |#endif
   20|       |
   21|       |#if __has_include(<AppKit/AppKit.h>)
   22|       |#import <AppKit/AppKit.h>
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRApp.h>
   26|       |
   27|       |#import "FirebaseCore/Sources/FIRBundleUtil.h"
   28|       |#import "FirebaseCore/Sources/FIRVersion.h"
   29|       |#import "FirebaseCore/Sources/Private/FIRAnalyticsConfiguration.h"
   30|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   31|       |#import "FirebaseCore/Sources/Private/FIRComponentContainerInternal.h"
   32|       |#import "FirebaseCore/Sources/Private/FIRConfigurationInternal.h"
   33|       |#import "FirebaseCore/Sources/Private/FIRCoreDiagnosticsConnector.h"
   34|       |#import "FirebaseCore/Sources/Private/FIRLibrary.h"
   35|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   36|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   37|       |
   38|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   39|       |
   40|       |#import <objc/runtime.h>
   41|       |
   42|       |// The kFIRService strings are only here while transitioning CoreDiagnostics from the Analytics
   43|       |// pod to a Core dependency. These symbols are not used and should be deleted after the transition.
   44|       |NSString *const kFIRServiceAdMob;
   45|       |NSString *const kFIRServiceAuth;
   46|       |NSString *const kFIRServiceAuthUI;
   47|       |NSString *const kFIRServiceCrash;
   48|       |NSString *const kFIRServiceDatabase;
   49|       |NSString *const kFIRServiceDynamicLinks;
   50|       |NSString *const kFIRServiceFirestore;
   51|       |NSString *const kFIRServiceFunctions;
   52|       |NSString *const kFIRServiceInstanceID;
   53|       |NSString *const kFIRServiceInvites;
   54|       |NSString *const kFIRServiceMessaging;
   55|       |NSString *const kFIRServiceMeasurement;
   56|       |NSString *const kFIRServicePerformance;
   57|       |NSString *const kFIRServiceRemoteConfig;
   58|       |NSString *const kFIRServiceStorage;
   59|       |NSString *const kGGLServiceAnalytics;
   60|       |NSString *const kGGLServiceSignIn;
   61|       |
   62|       |NSString *const kFIRDefaultAppName = @"__FIRAPP_DEFAULT";
   63|       |NSString *const kFIRAppReadyToConfigureSDKNotification = @"FIRAppReadyToConfigureSDKNotification";
   64|       |NSString *const kFIRAppDeleteNotification = @"FIRAppDeleteNotification";
   65|       |NSString *const kFIRAppIsDefaultAppKey = @"FIRAppIsDefaultAppKey";
   66|       |NSString *const kFIRAppNameKey = @"FIRAppNameKey";
   67|       |NSString *const kFIRGoogleAppIDKey = @"FIRGoogleAppIDKey";
   68|       |
   69|       |NSString *const kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat =
   70|       |    @"/google/firebase/global_data_collection_enabled:%@";
   71|       |NSString *const kFIRGlobalAppDataCollectionEnabledPlistKey =
   72|       |    @"FirebaseDataCollectionDefaultEnabled";
   73|       |
   74|       |NSString *const kFIRAppDiagnosticsNotification = @"FIRAppDiagnosticsNotification";
   75|       |
   76|       |NSString *const kFIRAppDiagnosticsConfigurationTypeKey = @"ConfigType";
   77|       |NSString *const kFIRAppDiagnosticsErrorKey = @"Error";
   78|       |NSString *const kFIRAppDiagnosticsFIRAppKey = @"FIRApp";
   79|       |NSString *const kFIRAppDiagnosticsSDKNameKey = @"SDKName";
   80|       |NSString *const kFIRAppDiagnosticsSDKVersionKey = @"SDKVersion";
   81|       |
   82|       |// Auth internal notification notification and key.
   83|       |NSString *const FIRAuthStateDidChangeInternalNotification =
   84|       |    @"FIRAuthStateDidChangeInternalNotification";
   85|       |NSString *const FIRAuthStateDidChangeInternalNotificationAppKey =
   86|       |    @"FIRAuthStateDidChangeInternalNotificationAppKey";
   87|       |NSString *const FIRAuthStateDidChangeInternalNotificationTokenKey =
   88|       |    @"FIRAuthStateDidChangeInternalNotificationTokenKey";
   89|       |NSString *const FIRAuthStateDidChangeInternalNotificationUIDKey =
   90|       |    @"FIRAuthStateDidChangeInternalNotificationUIDKey";
   91|       |
   92|       |/**
   93|       | * The URL to download plist files.
   94|       | */
   95|       |static NSString *const kPlistURL = @"https://console.firebase.google.com/";
   96|       |
   97|       |/**
   98|       | * An array of all classes that registered as `FIRCoreConfigurable` in order to receive lifecycle
   99|       | * events from Core.
  100|       | */
  101|       |static NSMutableArray<Class<FIRLibrary>> *sRegisteredAsConfigurable;
  102|       |
  103|       |@interface FIRApp ()
  104|       |
  105|       |#ifdef DEBUG
  106|       |@property(nonatomic) BOOL alreadyOutputDataCollectionFlag;
  107|       |#endif  // DEBUG
  108|       |
  109|       |@end
  110|       |
  111|       |@implementation FIRApp
  112|       |
  113|       |// This is necessary since our custom getter prevents `_options` from being created.
  114|       |@synthesize options = _options;
  115|       |
  116|       |static NSMutableDictionary *sAllApps;
  117|       |static FIRApp *sDefaultApp;
  118|       |static NSMutableDictionary *sLibraryVersions;
  119|       |static dispatch_once_t sFirebaseUserAgentOnceToken;
  120|       |
  121|      1|+ (void)configure {
  122|      1|  FIROptions *options = [FIROptions defaultOptions];
  123|      1|  if (!options) {
  124|      0|    [NSException raise:kFirebaseCoreErrorDomain
  125|      0|                format:@"`[FIRApp configure];` (`FirebaseApp.configure()` in Swift) could not find "
  126|      0|                       @"a valid GoogleService-Info.plist in your project. Please download one "
  127|      0|                       @"from %@.",
  128|      0|                       kPlistURL];
  129|      0|  }
  130|      1|  [FIRApp configureWithOptions:options];
  131|       |#if TARGET_OS_OSX || TARGET_OS_TV
  132|       |  FIRLogNotice(kFIRLoggerCore, @"I-COR000028",
  133|       |               @"tvOS and macOS SDK support is not part of the official Firebase product. "
  134|       |               @"Instead they are community supported. Details at "
  135|       |               @"https://github.com/firebase/firebase-ios-sdk/blob/master/README.md.");
  136|       |#endif
  137|       |}
  138|       |
  139|      1|+ (void)configureWithOptions:(FIROptions *)options {
  140|      1|  if (!options) {
  141|      0|    [NSException raise:kFirebaseCoreErrorDomain
  142|      0|                format:@"Options is nil. Please pass a valid options."];
  143|      0|  }
  144|      1|  [FIRApp configureWithName:kFIRDefaultAppName options:options];
  145|      1|}
  146|       |
  147|      0|+ (NSCharacterSet *)applicationNameAllowedCharacters {
  148|      0|  static NSCharacterSet *applicationNameAllowedCharacters;
  149|      0|  static dispatch_once_t onceToken;
  150|      0|  dispatch_once(&onceToken, ^{
  151|      0|    NSMutableCharacterSet *allowedNameCharacters = [NSMutableCharacterSet alphanumericCharacterSet];
  152|      0|    [allowedNameCharacters addCharactersInString:@"-_"];
  153|      0|    applicationNameAllowedCharacters = [allowedNameCharacters copy];
  154|      0|  });
  155|      0|  return applicationNameAllowedCharacters;
  156|      0|}
  157|       |
  158|      1|+ (void)configureWithName:(NSString *)name options:(FIROptions *)options {
  159|      1|  if (!name || !options) {
  160|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Neither name nor options can be nil."];
  161|      0|  }
  162|      1|  if (name.length == 0) {
  163|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Name cannot be empty."];
  164|      0|  }
  165|      1|
  166|      1|  if ([name isEqualToString:kFIRDefaultAppName]) {
  167|      1|    if (sDefaultApp) {
  168|      0|      // The default app already exixts. Handle duplicate `configure` calls and return.
  169|      0|      [self appWasConfiguredTwice:sDefaultApp usingOptions:options];
  170|      0|      return;
  171|      0|    }
  172|      1|
  173|      1|    FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configuring the default app.");
  174|      1|  } else {
  175|      0|    // Validate the app name and ensure it hasn't been configured already.
  176|      0|    NSCharacterSet *nameCharacters = [NSCharacterSet characterSetWithCharactersInString:name];
  177|      0|
  178|      0|    if (![[self applicationNameAllowedCharacters] isSupersetOfSet:nameCharacters]) {
  179|      0|      [NSException raise:kFirebaseCoreErrorDomain
  180|      0|                  format:@"App name can only contain alphanumeric, "
  181|      0|                         @"hyphen (-), and underscore (_) characters"];
  182|      0|    }
  183|      0|
  184|      0|    @synchronized(self) {
  185|      0|      if (sAllApps && sAllApps[name]) {
  186|      0|        // The app already exists. Handle a duplicate `configure` call and return.
  187|      0|        [self appWasConfiguredTwice:sAllApps[name] usingOptions:options];
  188|      0|        return;
  189|      0|      }
  190|      0|    }
  191|      0|
  192|      0|    FIRLogDebug(kFIRLoggerCore, @"I-COR000002", @"Configuring app named %@", name);
  193|      0|  }
  194|      1|
  195|      1|  @synchronized(self) {
  196|      1|    FIRApp *app = [[FIRApp alloc] initInstanceWithName:name options:options];
  197|      1|    if (app.isDefaultApp) {
  198|      1|      sDefaultApp = app;
  199|      1|    }
  200|      1|
  201|      1|    [FIRApp addAppToAppDictionary:app];
  202|      1|
  203|      1|    // The FIRApp instance is ready to go, `sDefaultApp` is assigned, other SDKs are now ready to be
  204|      1|    // instantiated.
  205|      1|    [app.container instantiateEagerComponents];
  206|      1|    [FIRApp sendNotificationsToSDKs:app];
  207|      1|  }
  208|      1|}
  209|       |
  210|       |/// Called when `configure` has been called multiple times for the same app. This can either throw
  211|       |/// an exception (most cases) or ignore the duplicate configuration in situations where it's allowed
  212|       |/// like an extension.
  213|      0|+ (void)appWasConfiguredTwice:(FIRApp *)app usingOptions:(FIROptions *)options {
  214|      0|  // Only extensions should potentially be able to call `configure` more than once.
  215|      0|  if (![GULAppEnvironmentUtil isAppExtension]) {
  216|      0|    // Throw an exception since this is now an invalid state.
  217|      0|    if (app.isDefaultApp) {
  218|      0|      [NSException raise:kFirebaseCoreErrorDomain
  219|      0|                  format:@"Default app has already been configured."];
  220|      0|    } else {
  221|      0|      [NSException raise:kFirebaseCoreErrorDomain
  222|      0|                  format:@"App named %@ has already been configured.", app.name];
  223|      0|    }
  224|      0|  }
  225|      0|
  226|      0|  // In an extension, the entry point could be called multiple times. As long as the options are
  227|      0|  // identical we should allow multiple `configure` calls.
  228|      0|  if ([options isEqual:app.options]) {
  229|      0|    // Everything is identical but the extension's lifecycle triggered `configure` twice.
  230|      0|    // Ignore duplicate calls and return since everything should still be in a valid state.
  231|      0|    FIRLogDebug(kFIRLoggerCore, @"I-COR000035",
  232|      0|                @"Ignoring second `configure` call in an extension.");
  233|      0|    return;
  234|      0|  } else {
  235|      0|    [NSException raise:kFirebaseCoreErrorDomain
  236|      0|                format:@"App named %@ has already been configured.", app.name];
  237|      0|  }
  238|      0|}
  239|       |
  240|      3|+ (FIRApp *)defaultApp {
  241|      3|  if (sDefaultApp) {
  242|      3|    return sDefaultApp;
  243|      3|  }
  244|      0|  FIRLogError(kFIRLoggerCore, @"I-COR000003",
  245|      0|              @"The default Firebase app has not yet been "
  246|      0|              @"configured. Add `[FIRApp configure];` (`FirebaseApp.configure()` in Swift) to your "
  247|      0|              @"application initialization. Read more: https://goo.gl/ctyzm8.");
  248|      0|  return nil;
  249|      0|}
  250|       |
  251|      0|+ (FIRApp *)appNamed:(NSString *)name {
  252|      0|  @synchronized(self) {
  253|      0|    if (sAllApps) {
  254|      0|      FIRApp *app = sAllApps[name];
  255|      0|      if (app) {
  256|      0|        return app;
  257|      0|      }
  258|      0|    }
  259|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000004", @"App with name %@ does not exist.", name);
  260|      0|    return nil;
  261|      0|  }
  262|      0|}
  263|       |
  264|      2|+ (NSDictionary *)allApps {
  265|      2|  @synchronized(self) {
  266|      2|    if (!sAllApps) {
  267|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000005", @"No app has been configured yet.");
  268|      0|    }
  269|      2|    return [sAllApps copy];
  270|      2|  }
  271|      2|}
  272|       |
  273|       |// Public only for tests
  274|      0|+ (void)resetApps {
  275|      0|  @synchronized(self) {
  276|      0|    sDefaultApp = nil;
  277|      0|    [sAllApps removeAllObjects];
  278|      0|    sAllApps = nil;
  279|      0|    [sLibraryVersions removeAllObjects];
  280|      0|    sLibraryVersions = nil;
  281|      0|    sFirebaseUserAgentOnceToken = 0;
  282|      0|  }
  283|      0|}
  284|       |
  285|      0|- (void)deleteApp:(FIRAppVoidBoolCallback)completion {
  286|      0|  @synchronized([self class]) {
  287|      0|    if (sAllApps && sAllApps[self.name]) {
  288|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000006", @"Deleting app named %@", self.name);
  289|      0|
  290|      0|      // Remove all registered libraries from the container to avoid creating new instances.
  291|      0|      [self.container removeAllComponents];
  292|      0|      // Remove all cached instances from the container before deleting the app.
  293|      0|      [self.container removeAllCachedInstances];
  294|      0|
  295|      0|      [sAllApps removeObjectForKey:self.name];
  296|      0|      [self clearDataCollectionSwitchFromUserDefaults];
  297|      0|      if ([self.name isEqualToString:kFIRDefaultAppName]) {
  298|      0|        sDefaultApp = nil;
  299|      0|      }
  300|      0|      NSDictionary *appInfoDict = @{kFIRAppNameKey : self.name};
  301|      0|      [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppDeleteNotification
  302|      0|                                                          object:[self class]
  303|      0|                                                        userInfo:appInfoDict];
  304|      0|      completion(YES);
  305|      0|    } else {
  306|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000007", @"App does not exist.");
  307|      0|      completion(NO);
  308|      0|    }
  309|      0|  }
  310|      0|}
  311|       |
  312|      1|+ (void)addAppToAppDictionary:(FIRApp *)app {
  313|      1|  if (!sAllApps) {
  314|      1|    sAllApps = [NSMutableDictionary dictionary];
  315|      1|  }
  316|      1|  if ([app configureCore]) {
  317|      1|    sAllApps[app.name] = app;
  318|      1|  } else {
  319|      0|    [NSException raise:kFirebaseCoreErrorDomain
  320|      0|                format:@"Configuration fails. It may be caused by an invalid GOOGLE_APP_ID in "
  321|      0|                       @"GoogleService-Info.plist or set in the customized options."];
  322|      0|  }
  323|      1|}
  324|       |
  325|      1|- (instancetype)initInstanceWithName:(NSString *)name options:(FIROptions *)options {
  326|      1|  self = [super init];
  327|      1|  if (self) {
  328|      1|    _name = [name copy];
  329|      1|    _options = [options copy];
  330|      1|    _options.editingLocked = YES;
  331|      1|    _isDefaultApp = [name isEqualToString:kFIRDefaultAppName];
  332|      1|    _container = [[FIRComponentContainer alloc] initWithApp:self];
  333|      1|  }
  334|      1|  return self;
  335|      1|}
  336|       |
  337|      0|- (void)dealloc {
  338|      0|  [[NSNotificationCenter defaultCenter] removeObserver:self];
  339|      0|}
  340|       |
  341|      1|- (BOOL)configureCore {
  342|      1|  [self checkExpectedBundleID];
  343|      1|  if (![self isAppIDValid]) {
  344|      0|    return NO;
  345|      0|  }
  346|      1|
  347|      1|  [self logCoreTelemetryIfEnabled];
  348|      1|
  349|      1|#if TARGET_OS_IOS
  350|      1|  // Initialize the Analytics once there is a valid options under default app. Analytics should
  351|      1|  // always initialize first by itself before the other SDKs.
  352|      1|  if ([self.name isEqualToString:kFIRDefaultAppName]) {
  353|      1|    Class firAnalyticsClass = NSClassFromString(@"FIRAnalytics");
  354|      1|    if (firAnalyticsClass) {
  355|      1|#pragma clang diagnostic push
  356|      1|#pragma clang diagnostic ignored "-Wundeclared-selector"
  357|      1|      SEL startWithConfigurationSelector = @selector(startWithConfiguration:options:);
  358|      1|#pragma clang diagnostic pop
  359|      1|      if ([firAnalyticsClass respondsToSelector:startWithConfigurationSelector]) {
  360|      1|#pragma clang diagnostic push
  361|      1|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
  362|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  363|      1|        [firAnalyticsClass performSelector:startWithConfigurationSelector
  364|      1|                                withObject:[FIRConfiguration sharedInstance].analyticsConfiguration
  365|      1|                                withObject:_options];
  366|      1|#pragma clang diagnostic pop
  367|      1|      }
  368|      1|    }
  369|      1|  }
  370|      1|#endif
  371|      1|
  372|      1|  [self subscribeForAppDidBecomeActiveNotifications];
  373|      1|
  374|      1|  return YES;
  375|      1|}
  376|       |
  377|      4|- (FIROptions *)options {
  378|      4|  return [_options copy];
  379|      4|}
  380|       |
  381|      0|- (void)setDataCollectionDefaultEnabled:(BOOL)dataCollectionDefaultEnabled {
  382|      0|#ifdef DEBUG
  383|      0|  FIRLogDebug(kFIRLoggerCore, @"I-COR000034", @"Explicitly %@ data collection flag.",
  384|      0|              dataCollectionDefaultEnabled ? @"enabled" : @"disabled");
  385|      0|  self.alreadyOutputDataCollectionFlag = YES;
  386|      0|#endif  // DEBUG
  387|      0|
  388|      0|  NSString *key =
  389|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  390|      0|  [[NSUserDefaults standardUserDefaults] setBool:dataCollectionDefaultEnabled forKey:key];
  391|      0|
  392|      0|  // Core also controls the FirebaseAnalytics flag, so check if the Analytics flags are set
  393|      0|  // within FIROptions and change the Analytics value if necessary. Analytics only works with the
  394|      0|  // default app, so return if this isn't the default app.
  395|      0|  if (!self.isDefaultApp) {
  396|      0|    return;
  397|      0|  }
  398|      0|
  399|      0|  // Check if the Analytics flag is explicitly set. If so, no further actions are necessary.
  400|      0|  if ([self.options isAnalyticsCollectionExplicitlySet]) {
  401|      0|    return;
  402|      0|  }
  403|      0|
  404|      0|  // The Analytics flag has not been explicitly set, so update with the value being set.
  405|      0|#pragma clang diagnostic push
  406|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  407|      0|  [[FIRAnalyticsConfiguration sharedInstance]
  408|      0|      setAnalyticsCollectionEnabled:dataCollectionDefaultEnabled
  409|      0|                     persistSetting:NO];
  410|      0|#pragma clang diagnostic pop
  411|      0|}
  412|       |
  413|      3|- (BOOL)isDataCollectionDefaultEnabled {
  414|      3|  // Check if it's been manually set before in code, and use that as the higher priority value.
  415|      3|  NSNumber *defaultsObject = [[self class] readDataCollectionSwitchFromUserDefaultsForApp:self];
  416|      3|  if (defaultsObject != nil) {
  417|      0|#ifdef DEBUG
  418|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  419|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000031", @"Data Collection flag is %@ in user defaults.",
  420|      0|                  [defaultsObject boolValue] ? @"enabled" : @"disabled");
  421|      0|      self.alreadyOutputDataCollectionFlag = YES;
  422|      0|    }
  423|      0|#endif  // DEBUG
  424|      0|    return [defaultsObject boolValue];
  425|      0|  }
  426|      3|
  427|      3|  // Read the Info.plist to see if the flag is set. If it's not set, it should default to `YES`.
  428|      3|  // As per the implementation of `readDataCollectionSwitchFromPlist`, it's a cached value and has
  429|      3|  // no performance impact calling multiple times.
  430|      3|  NSNumber *collectionEnabledPlistValue = [[self class] readDataCollectionSwitchFromPlist];
  431|      3|  if (collectionEnabledPlistValue != nil) {
  432|      0|#ifdef DEBUG
  433|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  434|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000032", @"Data Collection flag is %@ in plist.",
  435|      0|                  [collectionEnabledPlistValue boolValue] ? @"enabled" : @"disabled");
  436|      0|      self.alreadyOutputDataCollectionFlag = YES;
  437|      0|    }
  438|      0|#endif  // DEBUG
  439|      0|    return [collectionEnabledPlistValue boolValue];
  440|      0|  }
  441|      3|
  442|      3|#ifdef DEBUG
  443|      3|  if (!self.alreadyOutputDataCollectionFlag) {
  444|      1|    FIRLogDebug(kFIRLoggerCore, @"I-COR000033", @"Data Collection flag is not set.");
  445|      1|    self.alreadyOutputDataCollectionFlag = YES;
  446|      1|  }
  447|      3|#endif  // DEBUG
  448|      3|  return YES;
  449|      3|}
  450|       |
  451|       |#pragma mark - private
  452|       |
  453|      1|+ (void)sendNotificationsToSDKs:(FIRApp *)app {
  454|      1|  // TODO: Remove this notification once all SDKs are registered with `FIRCoreConfigurable`.
  455|      1|  NSNumber *isDefaultApp = [NSNumber numberWithBool:app.isDefaultApp];
  456|      1|  NSDictionary *appInfoDict = @{
  457|      1|    kFIRAppNameKey : app.name,
  458|      1|    kFIRAppIsDefaultAppKey : isDefaultApp,
  459|      1|    kFIRGoogleAppIDKey : app.options.googleAppID
  460|      1|  };
  461|      1|  [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppReadyToConfigureSDKNotification
  462|      1|                                                      object:self
  463|      1|                                                    userInfo:appInfoDict];
  464|      1|
  465|      1|  // This is the new way of sending information to SDKs.
  466|      1|  // TODO: Do we want this on a background thread, maybe?
  467|      1|  @synchronized(self) {
  468|      1|    for (Class<FIRLibrary> library in sRegisteredAsConfigurable) {
  469|      0|      [library configureWithApp:app];
  470|      0|    }
  471|      1|  }
  472|      1|}
  473|       |
  474|      0|+ (NSError *)errorForMissingOptions {
  475|      0|  NSDictionary *errorDict = @{
  476|      0|    NSLocalizedDescriptionKey :
  477|      0|        @"Unable to parse GoogleService-Info.plist in order to configure services.",
  478|      0|    NSLocalizedRecoverySuggestionErrorKey :
  479|      0|        @"Check formatting and location of GoogleService-Info.plist."
  480|      0|  };
  481|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  482|      0|                             code:FIRErrorCodeInvalidPlistFile
  483|      0|                         userInfo:errorDict];
  484|      0|}
  485|       |
  486|       |+ (NSError *)errorForSubspecConfigurationFailureWithDomain:(NSString *)domain
  487|       |                                                 errorCode:(FIRErrorCode)code
  488|       |                                                   service:(NSString *)service
  489|      0|                                                    reason:(NSString *)reason {
  490|      0|  NSString *description =
  491|      0|      [NSString stringWithFormat:@"Configuration failed for service %@.", service];
  492|      0|  NSDictionary *errorDict =
  493|      0|      @{NSLocalizedDescriptionKey : description, NSLocalizedFailureReasonErrorKey : reason};
  494|      0|  return [NSError errorWithDomain:domain code:code userInfo:errorDict];
  495|      0|}
  496|       |
  497|      0|+ (NSError *)errorForInvalidAppID {
  498|      0|  NSDictionary *errorDict = @{
  499|      0|    NSLocalizedDescriptionKey : @"Unable to validate Google App ID",
  500|      0|    NSLocalizedRecoverySuggestionErrorKey :
  501|      0|        @"Check formatting and location of GoogleService-Info.plist or GoogleAppID set in the "
  502|      0|        @"customized options."
  503|      0|  };
  504|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  505|      0|                             code:FIRErrorCodeInvalidAppID
  506|      0|                         userInfo:errorDict];
  507|      0|}
  508|       |
  509|      1|+ (BOOL)isDefaultAppConfigured {
  510|      1|  return (sDefaultApp != nil);
  511|      1|}
  512|       |
  513|      8|+ (void)registerLibrary:(nonnull NSString *)name withVersion:(nonnull NSString *)version {
  514|      8|  // Create the set of characters which aren't allowed, only if this feature is used.
  515|      8|  NSMutableCharacterSet *allowedSet = [NSMutableCharacterSet alphanumericCharacterSet];
  516|      8|  [allowedSet addCharactersInString:@"-_."];
  517|      8|  NSCharacterSet *disallowedSet = [allowedSet invertedSet];
  518|      8|  // Make sure the library name and version strings do not contain unexpected characters, and
  519|      8|  // add the name/version pair to the dictionary.
  520|      8|  if ([name rangeOfCharacterFromSet:disallowedSet].location == NSNotFound &&
  521|      8|      [version rangeOfCharacterFromSet:disallowedSet].location == NSNotFound) {
  522|      8|    @synchronized(self) {
  523|      8|      if (!sLibraryVersions) {
  524|      1|        sLibraryVersions = [[NSMutableDictionary alloc] init];
  525|      1|      }
  526|      8|      sLibraryVersions[name] = version;
  527|      8|    }
  528|      8|  } else {
  529|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000027",
  530|      0|                @"The library name (%@) or version number (%@) contain invalid characters. "
  531|      0|                @"Only alphanumeric, dash, underscore and period characters are allowed.",
  532|      0|                name, version);
  533|      0|  }
  534|      8|}
  535|       |
  536|       |+ (void)registerInternalLibrary:(nonnull Class<FIRLibrary>)library
  537|       |                       withName:(nonnull NSString *)name
  538|      4|                    withVersion:(nonnull NSString *)version {
  539|      4|  // This is called at +load time, keep the work to a minimum.
  540|      4|
  541|      4|  // Ensure the class given conforms to the proper protocol.
  542|      4|  if (![(Class)library conformsToProtocol:@protocol(FIRLibrary)] ||
  543|      4|      ![(Class)library respondsToSelector:@selector(componentsToRegister)]) {
  544|      0|    [NSException raise:NSInvalidArgumentException
  545|      0|                format:@"Class %@ attempted to register components, but it does not conform to "
  546|      0|                       @"`FIRLibrary or provide a `componentsToRegister:` method.",
  547|      0|                       library];
  548|      0|  }
  549|      4|
  550|      4|  [FIRComponentContainer registerAsComponentRegistrant:library];
  551|      4|  if ([(Class)library respondsToSelector:@selector(configureWithApp:)]) {
  552|      0|    static dispatch_once_t onceToken;
  553|      0|    dispatch_once(&onceToken, ^{
  554|      0|      sRegisteredAsConfigurable = [[NSMutableArray alloc] init];
  555|      0|    });
  556|      0|    @synchronized(self) {
  557|      0|      [sRegisteredAsConfigurable addObject:library];
  558|      0|    }
  559|      0|  }
  560|      4|  [self registerLibrary:name withVersion:version];
  561|      4|}
  562|       |
  563|      3|+ (NSString *)firebaseUserAgent {
  564|      3|  @synchronized(self) {
  565|      3|    dispatch_once(&sFirebaseUserAgentOnceToken, ^{
  566|      1|      // Report FirebaseCore version for useragent string
  567|      1|      [FIRApp registerLibrary:@"fire-ios"
  568|      1|                  withVersion:[NSString stringWithUTF8String:FIRCoreVersionString]];
  569|      1|
  570|      1|      NSDictionary<NSString *, id> *info = [[NSBundle mainBundle] infoDictionary];
  571|      1|      NSString *xcodeVersion = info[@"DTXcodeBuild"];
  572|      1|      NSString *sdkVersion = info[@"DTSDKBuild"];
  573|      1|      if (xcodeVersion) {
  574|      1|        [FIRApp registerLibrary:@"xcode" withVersion:xcodeVersion];
  575|      1|      }
  576|      1|      if (sdkVersion) {
  577|      1|        [FIRApp registerLibrary:@"apple-sdk" withVersion:sdkVersion];
  578|      1|      }
  579|      1|
  580|      1|      NSString *swiftFlagValue = [self hasSwiftRuntime] ? @"true" : @"false";
  581|      1|      [FIRApp registerLibrary:@"swift" withVersion:swiftFlagValue];
  582|      1|    });
  583|      3|
  584|      3|    NSMutableArray<NSString *> *libraries =
  585|      3|        [[NSMutableArray<NSString *> alloc] initWithCapacity:sLibraryVersions.count];
  586|     24|    for (NSString *libraryName in sLibraryVersions) {
  587|     24|      [libraries addObject:[NSString stringWithFormat:@"%@/%@", libraryName,
  588|     24|                                                      sLibraryVersions[libraryName]]];
  589|     24|    }
  590|      3|    [libraries sortUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
  591|      3|    return [libraries componentsJoinedByString:@" "];
  592|      3|  }
  593|      3|}
  594|       |
  595|      1|+ (BOOL)hasSwiftRuntime {
  596|      1|  // The class
  597|      1|  // [Swift._SwiftObject](https://github.com/apple/swift/blob/5eac3e2818eb340b11232aff83edfbd1c307fa03/stdlib/public/runtime/SwiftObject.h#L35)
  598|      1|  // is a part of Swift runtime, so it should be present if Swift runtime is available.
  599|      1|
  600|      1|  BOOL hasSwiftRuntime =
  601|      1|      objc_lookUpClass("Swift._SwiftObject") != nil ||
  602|      1|      // Swift object class name before
  603|      1|      // https://github.com/apple/swift/commit/9637b4a6e11ddca72f5f6dbe528efc7c92f14d01
  604|      1|      objc_getClass("_TtCs12_SwiftObject") != nil;
  605|      1|
  606|      1|  return hasSwiftRuntime;
  607|      1|}
  608|       |
  609|      1|- (void)checkExpectedBundleID {
  610|      1|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  611|      1|  NSString *expectedBundleID = [self expectedBundleID];
  612|      1|  // The checking is only done when the bundle ID is provided in the serviceInfo dictionary for
  613|      1|  // backward compatibility.
  614|      1|  if (expectedBundleID != nil && ![FIRBundleUtil hasBundleIdentifierPrefix:expectedBundleID
  615|      1|                                                                 inBundles:bundles]) {
  616|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000008",
  617|      0|                @"The project's Bundle ID is inconsistent with "
  618|      0|                @"either the Bundle ID in '%@.%@', or the Bundle ID in the options if you are "
  619|      0|                @"using a customized options. To ensure that everything can be configured "
  620|      0|                @"correctly, you may need to make the Bundle IDs consistent. To continue with this "
  621|      0|                @"plist file, you may change your app's bundle identifier to '%@'. Or you can "
  622|      0|                @"download a new configuration file that matches your bundle identifier from %@ "
  623|      0|                @"and replace the current one.",
  624|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  625|      0|  }
  626|      1|}
  627|       |
  628|       |#pragma mark - private - App ID Validation
  629|       |
  630|       |/**
  631|       | * Validates the format and fingerprint of the app ID contained in GOOGLE_APP_ID in the plist file.
  632|       | * This is the main method for validating app ID.
  633|       | *
  634|       | * @return YES if the app ID fulfills the expected format and fingerprint, NO otherwise.
  635|       | */
  636|      1|- (BOOL)isAppIDValid {
  637|      1|  NSString *appID = _options.googleAppID;
  638|      1|  BOOL isValid = [FIRApp validateAppID:appID];
  639|      1|  if (!isValid) {
  640|      0|    NSString *expectedBundleID = [self expectedBundleID];
  641|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000009",
  642|      0|                @"The GOOGLE_APP_ID either in the plist file "
  643|      0|                @"'%@.%@' or the one set in the customized options is invalid. If you are using "
  644|      0|                @"the plist file, use the iOS version of bundle identifier to download the file, "
  645|      0|                @"and do not manually edit the GOOGLE_APP_ID. You may change your app's bundle "
  646|      0|                @"identifier to '%@'. Or you can download a new configuration file that matches "
  647|      0|                @"your bundle identifier from %@ and replace the current one.",
  648|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  649|      0|  };
  650|      1|  return isValid;
  651|      1|}
  652|       |
  653|      1|+ (BOOL)validateAppID:(NSString *)appID {
  654|      1|  // Failing validation only occurs when we are sure we are looking at a V2 app ID and it does not
  655|      1|  // have a valid fingerprint, otherwise we just warn about the potential issue.
  656|      1|  if (!appID.length) {
  657|      0|    return NO;
  658|      0|  }
  659|      1|
  660|      1|  NSScanner *stringScanner = [NSScanner scannerWithString:appID];
  661|      1|  stringScanner.charactersToBeSkipped = nil;
  662|      1|
  663|      1|  NSString *appIDVersion;
  664|      1|  if (![stringScanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet]
  665|      1|                                 intoString:&appIDVersion]) {
  666|      0|    return NO;
  667|      0|  }
  668|      1|
  669|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  670|      0|    // appIDVersion must be separated by ":"
  671|      0|    return NO;
  672|      0|  }
  673|      1|
  674|      1|  NSArray *knownVersions = @[ @"1" ];
  675|      1|  if (![knownVersions containsObject:appIDVersion]) {
  676|      0|    // Permit unknown yet properly formatted app ID versions.
  677|      0|    FIRLogInfo(kFIRLoggerCore, @"I-COR000010", @"Unknown GOOGLE_APP_ID version: %@", appIDVersion);
  678|      0|    return YES;
  679|      0|  }
  680|      1|
  681|      1|  if (![self validateAppIDFormat:appID withVersion:appIDVersion]) {
  682|      0|    return NO;
  683|      0|  }
  684|      1|
  685|      1|  if (![self validateAppIDFingerprint:appID withVersion:appIDVersion]) {
  686|      0|    return NO;
  687|      0|  }
  688|      1|
  689|      1|  return YES;
  690|      1|}
  691|       |
  692|      0|+ (NSString *)actualBundleID {
  693|      0|  return [[NSBundle mainBundle] bundleIdentifier];
  694|      0|}
  695|       |
  696|       |/**
  697|       | * Validates that the format of the app ID string is what is expected based on the supplied version.
  698|       | * The version must end in ":".
  699|       | *
  700|       | * For v1 app ids the format is expected to be
  701|       | * '<version #>:<project number>:ios:<fingerprint of bundle id>'.
  702|       | *
  703|       | * This method does not verify that the contents of the app id are correct, just that they fulfill
  704|       | * the expected format.
  705|       | *
  706|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  707|       | * @param version Indicates what version of the app id format this string should be.
  708|       | * @return YES if provided string fufills the expected format, NO otherwise.
  709|       | */
  710|      1|+ (BOOL)validateAppIDFormat:(NSString *)appID withVersion:(NSString *)version {
  711|      1|  if (!appID.length || !version.length) {
  712|      0|    return NO;
  713|      0|  }
  714|      1|
  715|      1|  NSScanner *stringScanner = [NSScanner scannerWithString:appID];
  716|      1|  stringScanner.charactersToBeSkipped = nil;
  717|      1|
  718|      1|  // Skip version part
  719|      1|  // '*<version #>*:<project number>:ios:<fingerprint of bundle id>'
  720|      1|  if (![stringScanner scanString:version intoString:NULL]) {
  721|      0|    // The version part is missing or mismatched
  722|      0|    return NO;
  723|      0|  }
  724|      1|
  725|      1|  // Validate version part (see part between '*' symbols below)
  726|      1|  // '<version #>*:*<project number>:ios:<fingerprint of bundle id>'
  727|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  728|      0|    // appIDVersion must be separated by ":"
  729|      0|    return NO;
  730|      0|  }
  731|      1|
  732|      1|  // Validate version part (see part between '*' symbols below)
  733|      1|  // '<version #>:*<project number>*:ios:<fingerprint of bundle id>'.
  734|      1|  NSInteger projectNumber = NSNotFound;
  735|      1|  if (![stringScanner scanInteger:&projectNumber]) {
  736|      0|    // NO project number found.
  737|      0|    return NO;
  738|      0|  }
  739|      1|
  740|      1|  // Validate version part (see part between '*' symbols below)
  741|      1|  // '<version #>:<project number>*:*ios:<fingerprint of bundle id>'.
  742|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  743|      0|    // The project number must be separated by ":"
  744|      0|    return NO;
  745|      0|  }
  746|      1|
  747|      1|  // Validate version part (see part between '*' symbols below)
  748|      1|  // '<version #>:<project number>:*ios*:<fingerprint of bundle id>'.
  749|      1|  NSString *platform;
  750|      1|  if (![stringScanner scanUpToString:@":" intoString:&platform]) {
  751|      0|    return NO;
  752|      0|  }
  753|      1|
  754|      1|  if (![platform isEqualToString:@"ios"]) {
  755|      0|    // The platform must be @"ios"
  756|      0|    return NO;
  757|      0|  }
  758|      1|
  759|      1|  // Validate version part (see part between '*' symbols below)
  760|      1|  // '<version #>:<project number>:ios*:*<fingerprint of bundle id>'.
  761|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  762|      0|    // The platform must be separated by ":"
  763|      0|    return NO;
  764|      0|  }
  765|      1|
  766|      1|  // Validate version part (see part between '*' symbols below)
  767|      1|  // '<version #>:<project number>:ios:*<fingerprint of bundle id>*'.
  768|      1|  unsigned long long fingerprint = NSNotFound;
  769|      1|  if (![stringScanner scanHexLongLong:&fingerprint]) {
  770|      0|    // Fingerprint part is missing
  771|      0|    return NO;
  772|      0|  }
  773|      1|
  774|      1|  if (!stringScanner.isAtEnd) {
  775|      0|    // There are not allowed characters in the fingerprint part
  776|      0|    return NO;
  777|      0|  }
  778|      1|
  779|      1|  return YES;
  780|      1|}
  781|       |
  782|       |/**
  783|       | * Validates that the fingerprint of the app ID string is what is expected based on the supplied
  784|       | * version.
  785|       | *
  786|       | * Note that the v1 hash algorithm is not permitted on the client and cannot be fully validated.
  787|       | *
  788|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  789|       | * @param version Indicates what version of the app id format this string should be.
  790|       | * @return YES if provided string fufills the expected fingerprint and the version is known, NO
  791|       | *         otherwise.
  792|       | */
  793|      1|+ (BOOL)validateAppIDFingerprint:(NSString *)appID withVersion:(NSString *)version {
  794|      1|  // Extract the supplied fingerprint from the supplied app ID.
  795|      1|  // This assumes the app ID format is the same for all known versions below. If the app ID format
  796|      1|  // changes in future versions, the tokenizing of the app ID format will need to take into account
  797|      1|  // the version of the app ID.
  798|      1|  NSArray *components = [appID componentsSeparatedByString:@":"];
  799|      1|  if (components.count != 4) {
  800|      0|    return NO;
  801|      0|  }
  802|      1|
  803|      1|  NSString *suppliedFingerprintString = components[3];
  804|      1|  if (!suppliedFingerprintString.length) {
  805|      0|    return NO;
  806|      0|  }
  807|      1|
  808|      1|  uint64_t suppliedFingerprint;
  809|      1|  NSScanner *scanner = [NSScanner scannerWithString:suppliedFingerprintString];
  810|      1|  if (![scanner scanHexLongLong:&suppliedFingerprint]) {
  811|      0|    return NO;
  812|      0|  }
  813|      1|
  814|      1|  if ([version isEqual:@"1"]) {
  815|      1|    // The v1 hash algorithm is not permitted on the client so the actual hash cannot be validated.
  816|      1|    return YES;
  817|      1|  }
  818|      0|
  819|      0|  // Unknown version.
  820|      0|  return NO;
  821|      0|}
  822|       |
  823|      1|- (NSString *)expectedBundleID {
  824|      1|  return _options.bundleID;
  825|      1|}
  826|       |
  827|       |// end App ID validation
  828|       |
  829|       |#pragma mark - Reading From Plist & User Defaults
  830|       |
  831|       |/**
  832|       | * Clears the data collection switch from the standard NSUserDefaults for easier testing and
  833|       | * readability.
  834|       | */
  835|      0|- (void)clearDataCollectionSwitchFromUserDefaults {
  836|      0|  NSString *key =
  837|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  838|      0|  [[NSUserDefaults standardUserDefaults] removeObjectForKey:key];
  839|      0|}
  840|       |
  841|       |/**
  842|       | * Reads the data collection switch from the standard NSUserDefaults for easier testing and
  843|       | * readability.
  844|       | */
  845|      3|+ (nullable NSNumber *)readDataCollectionSwitchFromUserDefaultsForApp:(FIRApp *)app {
  846|      3|  // Read the object in user defaults, and only return if it's an NSNumber.
  847|      3|  NSString *key =
  848|      3|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, app.name];
  849|      3|  id collectionEnabledDefaultsObject = [[NSUserDefaults standardUserDefaults] objectForKey:key];
  850|      3|  if ([collectionEnabledDefaultsObject isKindOfClass:[NSNumber class]]) {
  851|      0|    return collectionEnabledDefaultsObject;
  852|      0|  }
  853|      3|
  854|      3|  return nil;
  855|      3|}
  856|       |
  857|       |/**
  858|       | * Reads the data collection switch from the Info.plist for easier testing and readability. Will
  859|       | * only read once from the plist and return the cached value.
  860|       | */
  861|      3|+ (nullable NSNumber *)readDataCollectionSwitchFromPlist {
  862|      3|  static NSNumber *collectionEnabledPlistObject;
  863|      3|  static dispatch_once_t onceToken;
  864|      3|  dispatch_once(&onceToken, ^{
  865|      1|    // Read the data from the `Info.plist`, only assign it if it's there and an NSNumber.
  866|      1|    id plistValue = [[NSBundle mainBundle]
  867|      1|        objectForInfoDictionaryKey:kFIRGlobalAppDataCollectionEnabledPlistKey];
  868|      1|    if (plistValue && [plistValue isKindOfClass:[NSNumber class]]) {
  869|      0|      collectionEnabledPlistObject = (NSNumber *)plistValue;
  870|      0|    }
  871|      1|  });
  872|      3|
  873|      3|  return collectionEnabledPlistObject;
  874|      3|}
  875|       |
  876|       |#pragma mark - Sending Logs
  877|       |
  878|       |#pragma clang diagnostic push
  879|       |#pragma clang diagnostic ignored "-Wunused-parameter"
  880|       |- (void)sendLogsWithServiceName:(NSString *)serviceName
  881|       |                        version:(NSString *)version
  882|      0|                          error:(NSError *)error {
  883|      0|  // Do nothing. Please remove calls to this method.
  884|      0|}
  885|       |#pragma clang diagnostic pop
  886|       |
  887|       |#pragma mark - App Life Cycle
  888|       |
  889|      1|- (void)subscribeForAppDidBecomeActiveNotifications {
  890|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  891|      1|  NSNotificationName notificationName = UIApplicationDidBecomeActiveNotification;
  892|       |#elif TARGET_OS_OSX
  893|       |  NSNotificationName notificationName = NSApplicationDidBecomeActiveNotification;
  894|       |#endif
  895|       |
  896|      1|#if !TARGET_OS_WATCH
  897|      1|  [[NSNotificationCenter defaultCenter] addObserver:self
  898|      1|                                           selector:@selector(appDidBecomeActive:)
  899|      1|                                               name:notificationName
  900|      1|                                             object:nil];
  901|      1|#endif
  902|      1|}
  903|       |
  904|      1|- (void)appDidBecomeActive:(NSNotification *)notification {
  905|      1|  [self logCoreTelemetryIfEnabled];
  906|      1|}
  907|       |
  908|      2|- (void)logCoreTelemetryIfEnabled {
  909|      2|  if ([self isDataCollectionDefaultEnabled]) {
  910|      2|    [FIRCoreDiagnosticsConnector logCoreTelemetryWithOptions:_options];
  911|      2|  }
  912|      2|}
  913|       |
  914|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRAppAssociationRegistration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRAppAssociationRegistration.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |@implementation FIRAppAssociationRegistration
   20|       |
   21|       |+ (nullable id)registeredObjectWithHost:(id)host
   22|       |                                    key:(NSString *)key
   23|      0|                          creationBlock:(id _Nullable (^)(void))creationBlock {
   24|      0|  @synchronized(self) {
   25|      0|    SEL dictKey = @selector(registeredObjectWithHost:key:creationBlock:);
   26|      0|    NSMutableDictionary<NSString *, id> *objectsByKey = objc_getAssociatedObject(host, dictKey);
   27|      0|    if (!objectsByKey) {
   28|      0|      objectsByKey = [[NSMutableDictionary alloc] init];
   29|      0|      objc_setAssociatedObject(host, dictKey, objectsByKey, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
   30|      0|    }
   31|      0|    id obj = objectsByKey[key];
   32|      0|    NSValue *creationBlockBeingCalled = [NSValue valueWithPointer:dictKey];
   33|      0|    if (obj) {
   34|      0|      if ([creationBlockBeingCalled isEqual:obj]) {
   35|      0|        [NSException raise:@"Reentering registeredObjectWithHost:key:creationBlock: not allowed"
   36|      0|                    format:@"host: %@ key: %@", host, key];
   37|      0|      }
   38|      0|      return obj;
   39|      0|    }
   40|      0|    objectsByKey[key] = creationBlockBeingCalled;
   41|      0|    obj = creationBlock();
   42|      0|    objectsByKey[key] = obj;
   43|      0|    return obj;
   44|      0|  }
   45|      0|}
   46|       |
   47|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRBundleUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/FIRBundleUtil.h"
   16|       |
   17|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   18|       |
   19|       |@implementation FIRBundleUtil
   20|       |
   21|      2|+ (NSArray *)relevantBundles {
   22|      2|  return @[ [NSBundle mainBundle], [NSBundle bundleForClass:[self class]] ];
   23|      2|}
   24|       |
   25|       |+ (NSString *)optionsDictionaryPathWithResourceName:(NSString *)resourceName
   26|       |                                        andFileType:(NSString *)fileType
   27|      1|                                          inBundles:(NSArray *)bundles {
   28|      1|  // Loop through all bundles to find the config dict.
   29|      1|  for (NSBundle *bundle in bundles) {
   30|      1|    NSString *path = [bundle pathForResource:resourceName ofType:fileType];
   31|      1|    // Use the first one we find.
   32|      1|    if (path) {
   33|      1|      return path;
   34|      1|    }
   35|      1|  }
   36|      1|  return nil;
   37|      1|}
   38|       |
   39|      0|+ (NSArray *)relevantURLSchemes {
   40|      0|  NSMutableArray *result = [[NSMutableArray alloc] init];
   41|      0|  for (NSBundle *bundle in [[self class] relevantBundles]) {
   42|      0|    NSArray *urlTypes = [bundle objectForInfoDictionaryKey:@"CFBundleURLTypes"];
   43|      0|    for (NSDictionary *urlType in urlTypes) {
   44|      0|      [result addObjectsFromArray:urlType[@"CFBundleURLSchemes"]];
   45|      0|    }
   46|      0|  }
   47|      0|  return result;
   48|      0|}
   49|       |
   50|      1|+ (BOOL)hasBundleIdentifierPrefix:(NSString *)bundleIdentifier inBundles:(NSArray *)bundles {
   51|      1|  for (NSBundle *bundle in bundles) {
   52|      1|    // This allows app extensions that have the app's bundle as their prefix to pass this test.
   53|      1|    NSString *applicationBundleIdentifier =
   54|      1|        [GULAppEnvironmentUtil isAppExtension]
   55|      1|            ? [self bundleIdentifierByRemovingLastPartFrom:bundle.bundleIdentifier]
   56|      1|            : bundle.bundleIdentifier;
   57|      1|
   58|      1|    if ([applicationBundleIdentifier isEqualToString:bundleIdentifier]) {
   59|      1|      return YES;
   60|      1|    }
   61|      1|  }
   62|      1|  return NO;
   63|      1|}
   64|       |
   65|      0|+ (NSString *)bundleIdentifierByRemovingLastPartFrom:(NSString *)bundleIdentifier {
   66|      0|  NSString *bundleIDComponentsSeparator = @".";
   67|      0|
   68|      0|  NSMutableArray<NSString *> *bundleIDComponents =
   69|      0|      [[bundleIdentifier componentsSeparatedByString:bundleIDComponentsSeparator] mutableCopy];
   70|      0|  [bundleIDComponents removeLastObject];
   71|      0|
   72|      0|  return [bundleIDComponents componentsJoinedByString:bundleIDComponentsSeparator];
   73|      0|}
   74|       |
   75|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRComponent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRComponent.h"
   18|       |
   19|       |#import "FirebaseCore/Sources/Private/FIRComponentContainer.h"
   20|       |#import "FirebaseCore/Sources/Private/FIRDependency.h"
   21|       |
   22|       |@interface FIRComponent ()
   23|       |
   24|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   25|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   26|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   27|       |                   creationBlock:(FIRComponentCreationBlock)creationBlock;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRComponent
   32|       |
   33|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   34|      0|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   35|      0|  return [[FIRComponent alloc] initWithProtocol:protocol
   36|      0|                            instantiationTiming:FIRInstantiationTimingLazy
   37|      0|                                   dependencies:@[]
   38|      0|                                  creationBlock:creationBlock];
   39|      0|}
   40|       |
   41|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   42|       |                  instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   43|       |                         dependencies:(NSArray<FIRDependency *> *)dependencies
   44|      4|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   45|      4|  return [[FIRComponent alloc] initWithProtocol:protocol
   46|      4|                            instantiationTiming:instantiationTiming
   47|      4|                                   dependencies:dependencies
   48|      4|                                  creationBlock:creationBlock];
   49|      4|}
   50|       |
   51|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   52|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   53|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   54|      4|                   creationBlock:(FIRComponentCreationBlock)creationBlock {
   55|      4|  self = [super init];
   56|      4|  if (self) {
   57|      4|    _protocol = protocol;
   58|      4|    _instantiationTiming = instantiationTiming;
   59|      4|    _dependencies = [dependencies copy];
   60|      4|    _creationBlock = creationBlock;
   61|      4|  }
   62|      4|  return self;
   63|      4|}
   64|       |
   65|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRComponentContainer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRComponentContainer.h"
   18|       |
   19|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   20|       |#import "FirebaseCore/Sources/Private/FIRComponent.h"
   21|       |#import "FirebaseCore/Sources/Private/FIRLibrary.h"
   22|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@interface FIRComponentContainer ()
   27|       |
   28|       |/// The dictionary of components that are registered for a particular app. The key is an `NSString`
   29|       |/// of the protocol.
   30|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, FIRComponentCreationBlock> *components;
   31|       |
   32|       |/// Cached instances of components that requested to be cached.
   33|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, id> *cachedInstances;
   34|       |
   35|       |/// Protocols of components that have requested to be eagerly instantiated.
   36|       |@property(nonatomic, strong, nullable) NSMutableArray<Protocol *> *eagerProtocolsToInstantiate;
   37|       |
   38|       |@end
   39|       |
   40|       |@implementation FIRComponentContainer
   41|       |
   42|       |// Collection of all classes that register to provide components.
   43|       |static NSMutableSet<Class> *sFIRComponentRegistrants;
   44|       |
   45|       |#pragma mark - Public Registration
   46|       |
   47|      4|+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass {
   48|      4|  static dispatch_once_t onceToken;
   49|      4|  dispatch_once(&onceToken, ^{
   50|      1|    sFIRComponentRegistrants = [[NSMutableSet<Class> alloc] init];
   51|      1|  });
   52|      4|
   53|      4|  [self registerAsComponentRegistrant:klass inSet:sFIRComponentRegistrants];
   54|      4|}
   55|       |
   56|       |+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass
   57|      4|                                inSet:(NSMutableSet<Class> *)allRegistrants {
   58|      4|  [allRegistrants addObject:klass];
   59|      4|}
   60|       |
   61|       |#pragma mark - Internal Initialization
   62|       |
   63|      1|- (instancetype)initWithApp:(FIRApp *)app {
   64|      1|  return [self initWithApp:app registrants:sFIRComponentRegistrants];
   65|      1|}
   66|       |
   67|      1|- (instancetype)initWithApp:(FIRApp *)app registrants:(NSMutableSet<Class> *)allRegistrants {
   68|      1|  self = [super init];
   69|      1|  if (self) {
   70|      1|    _app = app;
   71|      1|    _cachedInstances = [NSMutableDictionary<NSString *, id> dictionary];
   72|      1|    _components = [NSMutableDictionary<NSString *, FIRComponentCreationBlock> dictionary];
   73|      1|
   74|      1|    [self populateComponentsFromRegisteredClasses:allRegistrants forApp:app];
   75|      1|  }
   76|      1|  return self;
   77|      1|}
   78|       |
   79|      1|- (void)populateComponentsFromRegisteredClasses:(NSSet<Class> *)classes forApp:(FIRApp *)app {
   80|      1|  // Keep track of any components that need to eagerly instantiate after all components are added.
   81|      1|  self.eagerProtocolsToInstantiate = [[NSMutableArray alloc] init];
   82|      1|
   83|      1|  // Loop through the verified component registrants and populate the components array.
   84|      4|  for (Class<FIRLibrary> klass in classes) {
   85|      4|    // Loop through all the components being registered and store them as appropriate.
   86|      4|    // Classes which do not provide functionality should use a dummy FIRComponentRegistrant
   87|      4|    // protocol.
   88|      4|    for (FIRComponent *component in [klass componentsToRegister]) {
   89|      4|      // Check if the component has been registered before, and error out if so.
   90|      4|      NSString *protocolName = NSStringFromProtocol(component.protocol);
   91|      4|      if (self.components[protocolName]) {
   92|      0|        FIRLogError(kFIRLoggerCore, @"I-COR000029",
   93|      0|                    @"Attempted to register protocol %@, but it already has an implementation.",
   94|      0|                    protocolName);
   95|      0|        continue;
   96|      0|      }
   97|      4|
   98|      4|      // Store the creation block for later usage.
   99|      4|      self.components[protocolName] = component.creationBlock;
  100|      4|
  101|      4|      // Queue any protocols that should be eagerly instantiated. Don't instantiate them yet
  102|      4|      // because they could depend on other components that haven't been added to the components
  103|      4|      // array yet.
  104|      4|      BOOL shouldInstantiateEager =
  105|      4|          (component.instantiationTiming == FIRInstantiationTimingAlwaysEager);
  106|      4|      BOOL shouldInstantiateDefaultEager =
  107|      4|          (component.instantiationTiming == FIRInstantiationTimingEagerInDefaultApp &&
  108|      4|           [app isDefaultApp]);
  109|      4|      if (shouldInstantiateEager || shouldInstantiateDefaultEager) {
  110|      2|        [self.eagerProtocolsToInstantiate addObject:component.protocol];
  111|      2|      }
  112|      4|    }
  113|      4|  }
  114|      1|}
  115|       |
  116|       |#pragma mark - Instance Creation
  117|       |
  118|      1|- (void)instantiateEagerComponents {
  119|      1|  // After all components are registered, instantiate the ones that are requesting eager
  120|      1|  // instantiation.
  121|      1|  @synchronized(self) {
  122|      2|    for (Protocol *protocol in self.eagerProtocolsToInstantiate) {
  123|      2|      // Get an instance for the protocol, which will instantiate it since it couldn't have been
  124|      2|      // cached yet. Ignore the instance coming back since we don't need it.
  125|      2|      __unused id unusedInstance = [self instanceForProtocol:protocol];
  126|      2|    }
  127|      1|
  128|      1|    // All eager instantiation is complete, clear the stored property now.
  129|      1|    self.eagerProtocolsToInstantiate = nil;
  130|      1|  }
  131|      1|}
  132|       |
  133|       |/// Instantiate an instance of a class that conforms to the specified protocol.
  134|       |/// This will:
  135|       |///   - Call the block to create an instance if possible,
  136|       |///   - Validate that the instance returned conforms to the protocol it claims to,
  137|       |///   - Cache the instance if the block requests it
  138|       |///
  139|       |/// Note that this method assumes the caller already has @sychronized on self.
  140|       |- (nullable id)instantiateInstanceForProtocol:(Protocol *)protocol
  141|      2|                                    withBlock:(FIRComponentCreationBlock)creationBlock {
  142|      2|  if (!creationBlock) {
  143|      0|    return nil;
  144|      0|  }
  145|      2|
  146|      2|  // Create an instance using the creation block.
  147|      2|  BOOL shouldCache = NO;
  148|      2|  id instance = creationBlock(self, &shouldCache);
  149|      2|  if (!instance) {
  150|      0|    return nil;
  151|      0|  }
  152|      2|
  153|      2|  // An instance was created, validate that it conforms to the protocol it claims to.
  154|      2|  NSString *protocolName = NSStringFromProtocol(protocol);
  155|      2|  if (![instance conformsToProtocol:protocol]) {
  156|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000030",
  157|      0|                @"An instance conforming to %@ was requested, but the instance provided does not "
  158|      0|                @"conform to the protocol",
  159|      0|                protocolName);
  160|      0|  }
  161|      2|
  162|      2|  // The instance is ready to be returned, but check if it should be cached first before returning.
  163|      2|  if (shouldCache) {
  164|      2|    self.cachedInstances[protocolName] = instance;
  165|      2|  }
  166|      2|
  167|      2|  return instance;
  168|      2|}
  169|       |
  170|       |#pragma mark - Internal Retrieval
  171|       |
  172|      4|- (nullable id)instanceForProtocol:(Protocol *)protocol {
  173|      4|  // Check if there is a cached instance, and return it if so.
  174|      4|  NSString *protocolName = NSStringFromProtocol(protocol);
  175|      4|
  176|      4|  id cachedInstance;
  177|      4|  @synchronized(self) {
  178|      4|    cachedInstance = self.cachedInstances[protocolName];
  179|      4|    if (!cachedInstance) {
  180|      2|      // Use the creation block to instantiate an instance and return it.
  181|      2|      FIRComponentCreationBlock creationBlock = self.components[protocolName];
  182|      2|      cachedInstance = [self instantiateInstanceForProtocol:protocol withBlock:creationBlock];
  183|      2|    }
  184|      4|  }
  185|      4|  return cachedInstance;
  186|      4|}
  187|       |
  188|       |#pragma mark - Lifecycle
  189|       |
  190|      0|- (void)removeAllCachedInstances {
  191|      0|  @synchronized(self) {
  192|      0|    // Loop through the cache and notify each instance that is a maintainer to clean up after
  193|      0|    // itself.
  194|      0|    for (id instance in self.cachedInstances.allValues) {
  195|      0|      if ([instance conformsToProtocol:@protocol(FIRComponentLifecycleMaintainer)] &&
  196|      0|          [instance respondsToSelector:@selector(appWillBeDeleted:)]) {
  197|      0|        [instance appWillBeDeleted:self.app];
  198|      0|      }
  199|      0|    }
  200|      0|
  201|      0|    // Empty the cache.
  202|      0|    [self.cachedInstances removeAllObjects];
  203|      0|  }
  204|      0|}
  205|       |
  206|      0|- (void)removeAllComponents {
  207|      0|  @synchronized(self) {
  208|      0|    [self.components removeAllObjects];
  209|      0|  }
  210|      0|}
  211|       |
  212|       |@end
  213|       |
  214|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRComponentType.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRComponentType.h"
   18|       |
   19|       |#import "FirebaseCore/Sources/Private/FIRComponentContainerInternal.h"
   20|       |
   21|       |@implementation FIRComponentType
   22|       |
   23|      2|+ (id)instanceForProtocol:(Protocol *)protocol inContainer:(FIRComponentContainer *)container {
   24|      2|  // Forward the call to the container.
   25|      2|  return [container instanceForProtocol:protocol];
   26|      2|}
   27|       |
   28|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRConfigurationInternal.h"
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRAnalyticsConfiguration.h"
   18|       |
   19|       |extern void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel);
   20|       |
   21|       |@implementation FIRConfiguration
   22|       |
   23|      1|+ (instancetype)sharedInstance {
   24|      1|  static FIRConfiguration *sharedInstance = nil;
   25|      1|  static dispatch_once_t onceToken;
   26|      1|  dispatch_once(&onceToken, ^{
   27|      1|    sharedInstance = [[FIRConfiguration alloc] init];
   28|      1|  });
   29|      1|  return sharedInstance;
   30|      1|}
   31|       |
   32|      1|- (instancetype)init {
   33|      1|  self = [super init];
   34|      1|  if (self) {
   35|      1|    _analyticsConfiguration = [FIRAnalyticsConfiguration sharedInstance];
   36|      1|  }
   37|      1|  return self;
   38|      1|}
   39|       |
   40|      0|- (void)setLoggerLevel:(FIRLoggerLevel)loggerLevel {
   41|      0|  NSAssert(loggerLevel <= FIRLoggerLevelMax && loggerLevel >= FIRLoggerLevelMin,
   42|      0|           @"Invalid logger level, %ld", (long)loggerLevel);
   43|      0|  FIRSetLoggerLevel(loggerLevel);
   44|      0|}
   45|       |
   46|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRCoreDiagnosticsConnector.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRCoreDiagnosticsConnector.h"
   18|       |
   19|       |#import <FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsInterop.h>
   20|       |
   21|       |#import <FirebaseCore/FIROptions.h>
   22|       |
   23|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   24|       |#import "FirebaseCore/Sources/Private/FIRDiagnosticsData.h"
   25|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   26|       |
   27|       |// Define the interop class symbol declared as an extern in FIRCoreDiagnosticsInterop.
   28|       |Class<FIRCoreDiagnosticsInterop> FIRCoreDiagnosticsImplementation;
   29|       |
   30|       |@implementation FIRCoreDiagnosticsConnector
   31|       |
   32|      1|+ (void)initialize {
   33|      1|  if (!FIRCoreDiagnosticsImplementation) {
   34|      1|    FIRCoreDiagnosticsImplementation = NSClassFromString(@"FIRCoreDiagnostics");
   35|      1|    if (FIRCoreDiagnosticsImplementation) {
   36|      1|      NSAssert([FIRCoreDiagnosticsImplementation
   37|      1|                   conformsToProtocol:@protocol(FIRCoreDiagnosticsInterop)],
   38|      1|               @"If FIRCoreDiagnostics is implemented, it must conform to the interop protocol.");
   39|      1|      NSAssert(
   40|      1|          [FIRCoreDiagnosticsImplementation respondsToSelector:@selector(sendDiagnosticsData:)],
   41|      1|          @"If FIRCoreDiagnostics is implemented, it must implement +sendDiagnosticsData.");
   42|      1|    }
   43|      1|  }
   44|      1|}
   45|       |
   46|      2|+ (void)logCoreTelemetryWithOptions:(FIROptions *)options {
   47|      2|  if (FIRCoreDiagnosticsImplementation) {
   48|      2|    FIRDiagnosticsData *diagnosticsData = [[FIRDiagnosticsData alloc] init];
   49|      2|    [diagnosticsData insertValue:@(YES) forKey:kFIRCDIsDataCollectionDefaultEnabledKey];
   50|      2|    [diagnosticsData insertValue:[FIRApp firebaseUserAgent] forKey:kFIRCDFirebaseUserAgentKey];
   51|      2|    [diagnosticsData insertValue:@(FIRConfigTypeCore) forKey:kFIRCDConfigurationTypeKey];
   52|      2|    [diagnosticsData insertValue:options.googleAppID forKey:kFIRCDGoogleAppIDKey];
   53|      2|    [diagnosticsData insertValue:options.bundleID forKey:kFIRCDBundleIDKey];
   54|      2|    [diagnosticsData insertValue:@(options.usingOptionsFromDefaultPlist)
   55|      2|                          forKey:kFIRCDUsingOptionsFromDefaultPlistKey];
   56|      2|    [diagnosticsData insertValue:options.libraryVersionID forKey:kFIRCDLibraryVersionIDKey];
   57|      2|    [FIRCoreDiagnosticsImplementation sendDiagnosticsData:diagnosticsData];
   58|      2|  }
   59|      2|}
   60|       |
   61|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRDependency.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRDependency.h"
   18|       |
   19|       |@interface FIRDependency ()
   20|       |
   21|       |- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required;
   22|       |
   23|       |@end
   24|       |
   25|       |@implementation FIRDependency
   26|       |
   27|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol {
   28|      0|  return [[self alloc] initWithProtocol:protocol isRequired:YES];
   29|      0|}
   30|       |
   31|      1|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   32|      1|  return [[self alloc] initWithProtocol:protocol isRequired:required];
   33|      1|}
   34|       |
   35|      1|- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   36|      1|  self = [super init];
   37|      1|  if (self) {
   38|      1|    _protocol = protocol;
   39|      1|    _isRequired = required;
   40|      1|  }
   41|      1|  return self;
   42|      1|}
   43|       |
   44|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRDiagnosticsData.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRDiagnosticsData.h"
   18|       |
   19|       |#import <FirebaseCore/FIRApp.h>
   20|       |
   21|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   22|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   23|       |
   24|       |@implementation FIRDiagnosticsData {
   25|       |  /** Backing ivar for the diagnosticObjects property. */
   26|       |  NSMutableDictionary<NSString *, id> *_diagnosticObjects;
   27|       |}
   28|       |
   29|      2|- (instancetype)init {
   30|      2|  self = [super init];
   31|      2|  if (self) {
   32|      2|    _diagnosticObjects = [[NSMutableDictionary alloc] init];
   33|      2|  }
   34|      2|  return self;
   35|      2|}
   36|       |
   37|     14|- (void)insertValue:(nullable id)value forKey:(NSString *)key {
   38|     14|  if (key) {
   39|     14|    _diagnosticObjects[key] = value;
   40|     14|  }
   41|     14|}
   42|       |
   43|       |#pragma mark - FIRCoreDiagnosticsData
   44|       |
   45|      2|- (NSDictionary<NSString *, id> *)diagnosticObjects {
   46|      2|  if (!_diagnosticObjects[kFIRCDllAppsCountKey]) {
   47|      2|    _diagnosticObjects[kFIRCDllAppsCountKey] = @([FIRApp allApps].count);
   48|      2|  }
   49|      2|  if (!_diagnosticObjects[kFIRCDIsDataCollectionDefaultEnabledKey]) {
   50|      0|    _diagnosticObjects[kFIRCDIsDataCollectionDefaultEnabledKey] =
   51|      0|        @([[FIRApp defaultApp] isDataCollectionDefaultEnabled]);
   52|      0|  }
   53|      2|  if (!_diagnosticObjects[kFIRCDFirebaseUserAgentKey]) {
   54|      0|    _diagnosticObjects[kFIRCDFirebaseUserAgentKey] = [FIRApp firebaseUserAgent];
   55|      0|  }
   56|      2|  return _diagnosticObjects;
   57|      2|}
   58|       |
   59|       |#pragma clang diagnostic push
   60|       |#pragma clang diagnostic ignored "-Wunused-parameter"
   61|      0|- (void)setDiagnosticObjects:(NSDictionary<NSString *, id> *)diagnosticObjects {
   62|      0|  NSAssert(NO, @"Please use -insertValue:forKey:");
   63|      0|}
   64|       |#pragma clang diagnostic pop
   65|       |
   66|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRHeartbeatInfo.m:
    1|       |// Copyright 2019 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRHeartbeatInfo.h"
   16|       |#import <GoogleUtilities/GULHeartbeatDateStorage.h>
   17|       |#import <GoogleUtilities/GULLogger.h>
   18|       |
   19|       |const static long secondsInDay = 86400;
   20|       |@implementation FIRHeartbeatInfo : NSObject
   21|       |
   22|       |/** Updates the storage with the heartbeat information corresponding to this tag.
   23|       | * @param heartbeatTag Tag which could either be sdk specific tag or the global tag.
   24|       | * @return Boolean representing whether the heartbeat needs to be sent for this tag or not.
   25|       | */
   26|      2|+ (BOOL)updateIfNeededHeartbeatDateForTag:(NSString *)heartbeatTag {
   27|      2|  @synchronized(self) {
   28|      2|    NSString *const kHeartbeatStorageFile = @"HEARTBEAT_INFO_STORAGE";
   29|      2|    GULHeartbeatDateStorage *dataStorage =
   30|      2|        [[GULHeartbeatDateStorage alloc] initWithFileName:kHeartbeatStorageFile];
   31|      2|    NSDate *heartbeatTime = [dataStorage heartbeatDateForTag:heartbeatTag];
   32|      2|    NSDate *currentDate = [NSDate date];
   33|      2|    if (heartbeatTime != nil) {
   34|      2|      NSTimeInterval secondsBetween = [currentDate timeIntervalSinceDate:heartbeatTime];
   35|      2|      if (secondsBetween < secondsInDay) {
   36|      2|        return false;
   37|      2|      }
   38|      0|    }
   39|      0|    return [dataStorage setHearbeatDate:currentDate forTag:heartbeatTag];
   40|      0|  }
   41|      0|}
   42|       |
   43|      1|+ (FIRHeartbeatInfoCode)heartbeatCodeForTag:(NSString *)heartbeatTag {
   44|      1|  NSString *globalTag = @"GLOBAL";
   45|      1|  BOOL isSdkHeartbeatNeeded = [FIRHeartbeatInfo updateIfNeededHeartbeatDateForTag:heartbeatTag];
   46|      1|  BOOL isGlobalHeartbeatNeeded = [FIRHeartbeatInfo updateIfNeededHeartbeatDateForTag:globalTag];
   47|      1|  if (!isSdkHeartbeatNeeded && !isGlobalHeartbeatNeeded) {
   48|      1|    // Both sdk and global heartbeat not needed.
   49|      1|    return FIRHeartbeatInfoCodeNone;
   50|      1|  } else if (isSdkHeartbeatNeeded && !isGlobalHeartbeatNeeded) {
   51|      0|    // Only SDK heartbeat needed.
   52|      0|    return FIRHeartbeatInfoCodeSDK;
   53|      0|  } else if (!isSdkHeartbeatNeeded && isGlobalHeartbeatNeeded) {
   54|      0|    // Only global heartbeat needed.
   55|      0|    return FIRHeartbeatInfoCodeGlobal;
   56|      0|  } else {
   57|      0|    // Both sdk and global heartbeat are needed.
   58|      0|    return FIRHeartbeatInfoCodeCombined;
   59|      0|  }
   60|      1|}
   61|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIRLogger.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   16|       |
   17|       |#import <FirebaseCore/FIRLoggerLevel.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |
   21|       |#import "FirebaseCore/Sources/FIRVersion.h"
   22|       |
   23|       |FIRLoggerService kFIRLoggerCore = @"[Firebase/Core]";
   24|       |
   25|       |// All the FIRLoggerService definitions should be migrated to clients. Do not add new ones!
   26|       |FIRLoggerService kFIRLoggerABTesting = @"[Firebase/ABTesting]";
   27|       |FIRLoggerService kFIRLoggerAdMob = @"[Firebase/AdMob]";
   28|       |FIRLoggerService kFIRLoggerAnalytics = @"[Firebase/Analytics]";
   29|       |FIRLoggerService kFIRLoggerAuth = @"[Firebase/Auth]";
   30|       |FIRLoggerService kFIRLoggerCrash = @"[Firebase/Crash]";
   31|       |FIRLoggerService kFIRLoggerMLKit = @"[Firebase/MLKit]";
   32|       |FIRLoggerService kFIRLoggerPerf = @"[Firebase/Performance]";
   33|       |FIRLoggerService kFIRLoggerRemoteConfig = @"[Firebase/RemoteConfig]";
   34|       |
   35|       |/// Arguments passed on launch.
   36|       |NSString *const kFIRDisableDebugModeApplicationArgument = @"-FIRDebugDisabled";
   37|       |NSString *const kFIREnableDebugModeApplicationArgument = @"-FIRDebugEnabled";
   38|       |NSString *const kFIRLoggerForceSDTERRApplicationArgument = @"-FIRLoggerForceSTDERR";
   39|       |
   40|       |/// Key for the debug mode bit in NSUserDefaults.
   41|       |NSString *const kFIRPersistedDebugModeKey = @"/google/firebase/debug_mode";
   42|       |
   43|       |/// NSUserDefaults that should be used to store and read variables. If nil, `standardUserDefaults`
   44|       |/// will be used.
   45|       |static NSUserDefaults *sFIRLoggerUserDefaults;
   46|       |
   47|       |static dispatch_once_t sFIRLoggerOnceToken;
   48|       |
   49|       |// The sFIRAnalyticsDebugMode flag is here to support the -FIRDebugEnabled/-FIRDebugDisabled
   50|       |// flags used by Analytics. Users who use those flags expect Analytics to log verbosely,
   51|       |// while the rest of Firebase logs at the default level. This flag is introduced to support
   52|       |// that behavior.
   53|       |static BOOL sFIRAnalyticsDebugMode;
   54|       |
   55|       |#ifdef DEBUG
   56|       |/// The regex pattern for the message code.
   57|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   58|       |static NSRegularExpression *sMessageCodeRegex;
   59|       |#endif
   60|       |
   61|      5|void FIRLoggerInitializeASL() {
   62|      5|  dispatch_once(&sFIRLoggerOnceToken, ^{
   63|      1|    // Register Firebase Version with GULLogger.
   64|      1|    GULLoggerRegisterVersion(FIRVersionString);
   65|      1|
   66|      1|    // Override the aslOptions to ASL_OPT_STDERR if the override argument is passed in.
   67|      1|    NSArray *arguments = [NSProcessInfo processInfo].arguments;
   68|      1|    BOOL overrideSTDERR = [arguments containsObject:kFIRLoggerForceSDTERRApplicationArgument];
   69|      1|
   70|      1|    // Use the standard NSUserDefaults if it hasn't been explicitly set.
   71|      1|    if (sFIRLoggerUserDefaults == nil) {
   72|      1|      sFIRLoggerUserDefaults = [NSUserDefaults standardUserDefaults];
   73|      1|    }
   74|      1|
   75|      1|    BOOL forceDebugMode = NO;
   76|      1|    BOOL debugMode = [sFIRLoggerUserDefaults boolForKey:kFIRPersistedDebugModeKey];
   77|      1|    if ([arguments containsObject:kFIRDisableDebugModeApplicationArgument]) {  // Default mode
   78|      0|      [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
   79|      1|    } else if ([arguments containsObject:kFIREnableDebugModeApplicationArgument] ||
   80|      1|               debugMode) {  // Debug mode
   81|      0|      [sFIRLoggerUserDefaults setBool:YES forKey:kFIRPersistedDebugModeKey];
   82|      0|      forceDebugMode = YES;
   83|      0|    }
   84|      1|    GULLoggerInitializeASL();
   85|      1|    if (overrideSTDERR) {
   86|      0|      GULLoggerEnableSTDERR();
   87|      0|    }
   88|      1|    if (forceDebugMode) {
   89|      0|      GULLoggerForceDebug();
   90|      0|    }
   91|      1|  });
   92|      5|}
   93|       |
   94|      0|__attribute__((no_sanitize("thread"))) void FIRSetAnalyticsDebugMode(BOOL analyticsDebugMode) {
   95|      0|  sFIRAnalyticsDebugMode = analyticsDebugMode;
   96|      0|}
   97|       |
   98|      0|void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel) {
   99|      0|  FIRLoggerInitializeASL();
  100|      0|  GULSetLoggerLevel((GULLoggerLevel)loggerLevel);
  101|      0|}
  102|       |
  103|       |#ifdef DEBUG
  104|      0|void FIRResetLogger() {
  105|      0|  extern void GULResetLogger(void);
  106|      0|  sFIRLoggerOnceToken = 0;
  107|      0|  [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
  108|      0|  sFIRLoggerUserDefaults = nil;
  109|      0|  GULResetLogger();
  110|      0|}
  111|       |
  112|      0|void FIRSetLoggerUserDefaults(NSUserDefaults *defaults) {
  113|      0|  sFIRLoggerUserDefaults = defaults;
  114|      0|}
  115|       |#endif
  116|       |
  117|       |/**
  118|       | * Check if the level is high enough to be loggable.
  119|       | *
  120|       | * Analytics can override the log level with an intentional race condition.
  121|       | * Add the attribute to get a clean thread sanitizer run.
  122|       | */
  123|       |__attribute__((no_sanitize("thread"))) BOOL FIRIsLoggableLevel(FIRLoggerLevel loggerLevel,
  124|      0|                                                               BOOL analyticsComponent) {
  125|      0|  FIRLoggerInitializeASL();
  126|      0|  if (sFIRAnalyticsDebugMode && analyticsComponent) {
  127|      0|    return YES;
  128|      0|  }
  129|      0|  return GULIsLoggableLevel((GULLoggerLevel)loggerLevel);
  130|      0|}
  131|       |
  132|       |void FIRLogBasic(FIRLoggerLevel level,
  133|       |                 FIRLoggerService service,
  134|       |                 NSString *messageCode,
  135|       |                 NSString *message,
  136|      5|                 va_list args_ptr) {
  137|      5|  FIRLoggerInitializeASL();
  138|      5|  GULLogBasic((GULLoggerLevel)level, service,
  139|      5|              sFIRAnalyticsDebugMode && [kFIRLoggerAnalytics isEqualToString:service], messageCode,
  140|      5|              message, args_ptr);
  141|      5|}
  142|       |
  143|       |/**
  144|       | * Generates the logging functions using macros.
  145|       | *
  146|       | * Calling FIRLogError(kFIRLoggerCore, @"I-COR000001", @"Configure %@ failed.", @"blah") shows:
  147|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [Firebase/Core][I-COR000001] Configure blah failed.
  148|       | * Calling FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configure succeed.") shows:
  149|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [Firebase/Core][I-COR000001] Configure succeed.
  150|       | */
  151|       |#define FIR_LOGGING_FUNCTION(level)                                                             \
  152|      5|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  153|      5|    va_list args_ptr;                                                                           \
  154|      5|    va_start(args_ptr, message);                                                                \
  155|      5|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  156|      5|    va_end(args_ptr);                                                                           \
  157|      5|  }
  ------------------
  | Unexecuted instantiation: FIRLogError
  ------------------
  | Unexecuted instantiation: FIRLogWarning
  ------------------
  | Unexecuted instantiation: FIRLogNotice
  ------------------
  | Unexecuted instantiation: FIRLogInfo
  ------------------
  | FIRLogDebug:
  |  152|      5|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  |  153|      5|    va_list args_ptr;                                                                           \
  |  154|      5|    va_start(args_ptr, message);                                                                \
  |  155|      5|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  |  156|      5|    va_end(args_ptr);                                                                           \
  |  157|      5|  }
  ------------------
  158|       |
  159|       |FIR_LOGGING_FUNCTION(Error)
  160|       |FIR_LOGGING_FUNCTION(Warning)
  161|       |FIR_LOGGING_FUNCTION(Notice)
  162|       |FIR_LOGGING_FUNCTION(Info)
  163|       |FIR_LOGGING_FUNCTION(Debug)
  164|       |
  165|       |#undef FIR_MAKE_LOGGER
  166|       |
  167|       |#pragma mark - FIRLoggerWrapper
  168|       |
  169|       |@implementation FIRLoggerWrapper
  170|       |
  171|       |+ (void)logWithLevel:(FIRLoggerLevel)level
  172|       |         withService:(FIRLoggerService)service
  173|       |            withCode:(NSString *)messageCode
  174|       |         withMessage:(NSString *)message
  175|      0|            withArgs:(va_list)args {
  176|      0|  FIRLogBasic(level, service, messageCode, message, args);
  177|      0|}
  178|       |
  179|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCore/FirebaseCore/Sources/FIROptions.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/FIRBundleUtil.h"
   16|       |#import "FirebaseCore/Sources/FIRVersion.h"
   17|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   18|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   19|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   20|       |
   21|       |// Keys for the strings in the plist file.
   22|       |NSString *const kFIRAPIKey = @"API_KEY";
   23|       |NSString *const kFIRTrackingID = @"TRACKING_ID";
   24|       |NSString *const kFIRGoogleAppID = @"GOOGLE_APP_ID";
   25|       |NSString *const kFIRClientID = @"CLIENT_ID";
   26|       |NSString *const kFIRGCMSenderID = @"GCM_SENDER_ID";
   27|       |NSString *const kFIRAndroidClientID = @"ANDROID_CLIENT_ID";
   28|       |NSString *const kFIRDatabaseURL = @"DATABASE_URL";
   29|       |NSString *const kFIRStorageBucket = @"STORAGE_BUCKET";
   30|       |// The key to locate the expected bundle identifier in the plist file.
   31|       |NSString *const kFIRBundleID = @"BUNDLE_ID";
   32|       |// The key to locate the project identifier in the plist file.
   33|       |NSString *const kFIRProjectID = @"PROJECT_ID";
   34|       |
   35|       |NSString *const kFIRIsMeasurementEnabled = @"IS_MEASUREMENT_ENABLED";
   36|       |NSString *const kFIRIsAnalyticsCollectionEnabled = @"FIREBASE_ANALYTICS_COLLECTION_ENABLED";
   37|       |NSString *const kFIRIsAnalyticsCollectionDeactivated = @"FIREBASE_ANALYTICS_COLLECTION_DEACTIVATED";
   38|       |
   39|       |NSString *const kFIRIsAnalyticsEnabled = @"IS_ANALYTICS_ENABLED";
   40|       |NSString *const kFIRIsSignInEnabled = @"IS_SIGNIN_ENABLED";
   41|       |
   42|       |// Library version ID formatted like:
   43|       |// @"5"     // Major version (one or more digits)
   44|       |// @"04"    // Minor version (exactly 2 digits)
   45|       |// @"01"    // Build number (exactly 2 digits)
   46|       |// @"000";  // Fixed "000"
   47|       |NSString *kFIRLibraryVersionID;
   48|       |
   49|       |// Plist file name.
   50|       |NSString *const kServiceInfoFileName = @"GoogleService-Info";
   51|       |// Plist file type.
   52|       |NSString *const kServiceInfoFileType = @"plist";
   53|       |
   54|       |// Exception raised from attempting to modify a FIROptions after it's been copied to a FIRApp.
   55|       |NSString *const kFIRExceptionBadModification =
   56|       |    @"Attempted to modify options after it's set on FIRApp. Please modify all properties before "
   57|       |    @"initializing FIRApp.";
   58|       |
   59|       |@interface FIROptions ()
   60|       |
   61|       |/**
   62|       | * This property maintains the actual configuration key-value pairs.
   63|       | */
   64|       |@property(nonatomic, readwrite) NSMutableDictionary *optionsDictionary;
   65|       |
   66|       |/**
   67|       | * Calls `analyticsOptionsDictionaryWithInfoDictionary:` using [NSBundle mainBundle].infoDictionary.
   68|       | * It combines analytics options from both the infoDictionary and the GoogleService-Info.plist.
   69|       | * Values which are present in the main plist override values from the GoogleService-Info.plist.
   70|       | */
   71|       |@property(nonatomic, readonly) NSDictionary *analyticsOptionsDictionary;
   72|       |
   73|       |/**
   74|       | * Combination of analytics options from both the infoDictionary and the GoogleService-Info.plist.
   75|       | * Values which are present in the infoDictionary override values from the GoogleService-Info.plist.
   76|       | */
   77|       |- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary;
   78|       |
   79|       |/**
   80|       | * Throw exception if editing is locked when attempting to modify an option.
   81|       | */
   82|       |- (void)checkEditingLocked;
   83|       |
   84|       |@end
   85|       |
   86|       |@implementation FIROptions {
   87|       |  /// Backing variable for self.analyticsOptionsDictionary.
   88|       |  NSDictionary *_analyticsOptionsDictionary;
   89|       |}
   90|       |
   91|       |static FIROptions *sDefaultOptions = nil;
   92|       |static NSDictionary *sDefaultOptionsDictionary = nil;
   93|       |
   94|       |#pragma mark - Public only for internal class methods
   95|       |
   96|      1|+ (FIROptions *)defaultOptions {
   97|      1|  if (sDefaultOptions != nil) {
   98|      0|    return sDefaultOptions;
   99|      0|  }
  100|      1|
  101|      1|  NSDictionary *defaultOptionsDictionary = [self defaultOptionsDictionary];
  102|      1|  if (defaultOptionsDictionary == nil) {
  103|      0|    return nil;
  104|      0|  }
  105|      1|
  106|      1|  sDefaultOptions = [[FIROptions alloc] initInternalWithOptionsDictionary:defaultOptionsDictionary];
  107|      1|  return sDefaultOptions;
  108|      1|}
  109|       |
  110|       |#pragma mark - Private class methods
  111|       |
  112|      2|+ (NSDictionary *)defaultOptionsDictionary {
  113|      2|  if (sDefaultOptionsDictionary != nil) {
  114|      1|    return sDefaultOptionsDictionary;
  115|      1|  }
  116|      1|  NSString *plistFilePath = [FIROptions plistFilePathWithName:kServiceInfoFileName];
  117|      1|  if (plistFilePath == nil) {
  118|      0|    return nil;
  119|      0|  }
  120|      1|  sDefaultOptionsDictionary = [NSDictionary dictionaryWithContentsOfFile:plistFilePath];
  121|      1|  if (sDefaultOptionsDictionary == nil) {
  122|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000011",
  123|      0|                @"The configuration file is not a dictionary: "
  124|      0|                @"'%@.%@'.",
  125|      0|                kServiceInfoFileName, kServiceInfoFileType);
  126|      0|  }
  127|      1|  return sDefaultOptionsDictionary;
  128|      1|}
  129|       |
  130|       |// Returns the path of the plist file with a given file name.
  131|      1|+ (NSString *)plistFilePathWithName:(NSString *)fileName {
  132|      1|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  133|      1|  NSString *plistFilePath =
  134|      1|      [FIRBundleUtil optionsDictionaryPathWithResourceName:fileName
  135|      1|                                               andFileType:kServiceInfoFileType
  136|      1|                                                 inBundles:bundles];
  137|      1|  if (plistFilePath == nil) {
  138|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000012", @"Could not locate configuration file: '%@.%@'.",
  139|      0|                fileName, kServiceInfoFileType);
  140|      0|  }
  141|      1|  return plistFilePath;
  142|      1|}
  143|       |
  144|      0|+ (void)resetDefaultOptions {
  145|      0|  sDefaultOptions = nil;
  146|      0|  sDefaultOptionsDictionary = nil;
  147|      0|}
  148|       |
  149|       |#pragma mark - Private instance methods
  150|       |
  151|      1|- (instancetype)initInternalWithOptionsDictionary:(NSDictionary *)optionsDictionary {
  152|      1|  self = [super init];
  153|      1|  if (self) {
  154|      1|    _optionsDictionary = [optionsDictionary mutableCopy];
  155|      1|    _usingOptionsFromDefaultPlist = YES;
  156|      1|  }
  157|      1|  return self;
  158|      1|}
  159|       |
  160|      6|- (id)copyWithZone:(NSZone *)zone {
  161|      6|  FIROptions *newOptions = [[[self class] allocWithZone:zone] init];
  162|      6|  if (newOptions) {
  163|      6|    newOptions.optionsDictionary = self.optionsDictionary;
  164|      6|    newOptions.deepLinkURLScheme = self.deepLinkURLScheme;
  165|      6|    newOptions.appGroupID = self.appGroupID;
  166|      6|    newOptions.editingLocked = self.isEditingLocked;
  167|      6|    newOptions.usingOptionsFromDefaultPlist = self.usingOptionsFromDefaultPlist;
  168|      6|  }
  169|      6|  return newOptions;
  170|      6|}
  171|       |
  172|       |#pragma mark - Public instance methods
  173|       |
  174|      0|- (instancetype)initWithContentsOfFile:(NSString *)plistPath {
  175|      0|  self = [super init];
  176|      0|  if (self) {
  177|      0|    if (plistPath == nil) {
  178|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000013", @"The plist file path is nil.");
  179|      0|      return nil;
  180|      0|    }
  181|      0|    _optionsDictionary = [[NSDictionary dictionaryWithContentsOfFile:plistPath] mutableCopy];
  182|      0|    if (_optionsDictionary == nil) {
  183|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000014",
  184|      0|                  @"The configuration file at %@ does not exist or "
  185|      0|                  @"is not a well-formed plist file.",
  186|      0|                  plistPath);
  187|      0|      return nil;
  188|      0|    }
  189|      0|    // TODO: Do we want to validate the dictionary here? It says we do that already in
  190|      0|    // the public header.
  191|      0|  }
  192|      0|  return self;
  193|      0|}
  194|       |
  195|      0|- (instancetype)initWithGoogleAppID:(NSString *)googleAppID GCMSenderID:(NSString *)GCMSenderID {
  196|      0|  self = [super init];
  197|      0|  if (self) {
  198|      0|    NSMutableDictionary *mutableOptionsDict = [NSMutableDictionary dictionary];
  199|      0|    [mutableOptionsDict setValue:googleAppID forKey:kFIRGoogleAppID];
  200|      0|    [mutableOptionsDict setValue:GCMSenderID forKey:kFIRGCMSenderID];
  201|      0|    [mutableOptionsDict setValue:[[NSBundle mainBundle] bundleIdentifier] forKey:kFIRBundleID];
  202|      0|    self.optionsDictionary = mutableOptionsDict;
  203|      0|  }
  204|      0|  return self;
  205|      0|}
  206|       |
  207|      3|- (NSString *)APIKey {
  208|      3|  return self.optionsDictionary[kFIRAPIKey];
  209|      3|}
  210|       |
  211|     12|- (void)checkEditingLocked {
  212|     12|  if (self.isEditingLocked) {
  213|      0|    [NSException raise:kFirebaseCoreErrorDomain format:kFIRExceptionBadModification];
  214|      0|  }
  215|     12|}
  216|       |
  217|      0|- (void)setAPIKey:(NSString *)APIKey {
  218|      0|  [self checkEditingLocked];
  219|      0|  _optionsDictionary[kFIRAPIKey] = [APIKey copy];
  220|      0|}
  221|       |
  222|      0|- (NSString *)clientID {
  223|      0|  return self.optionsDictionary[kFIRClientID];
  224|      0|}
  225|       |
  226|      0|- (void)setClientID:(NSString *)clientID {
  227|      0|  [self checkEditingLocked];
  228|      0|  _optionsDictionary[kFIRClientID] = [clientID copy];
  229|      0|}
  230|       |
  231|      0|- (NSString *)trackingID {
  232|      0|  return self.optionsDictionary[kFIRTrackingID];
  233|      0|}
  234|       |
  235|      0|- (void)setTrackingID:(NSString *)trackingID {
  236|      0|  [self checkEditingLocked];
  237|      0|  _optionsDictionary[kFIRTrackingID] = [trackingID copy];
  238|      0|}
  239|       |
  240|      1|- (NSString *)GCMSenderID {
  241|      1|  return self.optionsDictionary[kFIRGCMSenderID];
  242|      1|}
  243|       |
  244|      0|- (void)setGCMSenderID:(NSString *)GCMSenderID {
  245|      0|  [self checkEditingLocked];
  246|      0|  _optionsDictionary[kFIRGCMSenderID] = [GCMSenderID copy];
  247|      0|}
  248|       |
  249|      2|- (NSString *)projectID {
  250|      2|  return self.optionsDictionary[kFIRProjectID];
  251|      2|}
  252|       |
  253|      0|- (void)setProjectID:(NSString *)projectID {
  254|      0|  [self checkEditingLocked];
  255|      0|  _optionsDictionary[kFIRProjectID] = [projectID copy];
  256|      0|}
  257|       |
  258|      0|- (NSString *)androidClientID {
  259|      0|  return self.optionsDictionary[kFIRAndroidClientID];
  260|      0|}
  261|       |
  262|      0|- (void)setAndroidClientID:(NSString *)androidClientID {
  263|      0|  [self checkEditingLocked];
  264|      0|  _optionsDictionary[kFIRAndroidClientID] = [androidClientID copy];
  265|      0|}
  266|       |
  267|      8|- (NSString *)googleAppID {
  268|      8|  return self.optionsDictionary[kFIRGoogleAppID];
  269|      8|}
  270|       |
  271|      0|- (void)setGoogleAppID:(NSString *)googleAppID {
  272|      0|  [self checkEditingLocked];
  273|      0|  _optionsDictionary[kFIRGoogleAppID] = [googleAppID copy];
  274|      0|}
  275|       |
  276|      2|- (NSString *)libraryVersionID {
  277|      2|  static dispatch_once_t onceToken;
  278|      2|  dispatch_once(&onceToken, ^{
  279|      1|    // The unit tests are set up to catch anything that does not properly convert.
  280|      1|    NSString *version = [NSString stringWithUTF8String:FIRCoreVersionString];
  281|      1|    NSArray *components = [version componentsSeparatedByString:@"."];
  282|      1|    NSString *major = [components objectAtIndex:0];
  283|      1|    NSString *minor = [NSString stringWithFormat:@"%02d", [[components objectAtIndex:1] intValue]];
  284|      1|    NSString *patch = [NSString stringWithFormat:@"%02d", [[components objectAtIndex:2] intValue]];
  285|      1|    kFIRLibraryVersionID = [NSString stringWithFormat:@"%@%@%@000", major, minor, patch];
  286|      1|  });
  287|      2|  return kFIRLibraryVersionID;
  288|      2|}
  289|       |
  290|      0|- (void)setLibraryVersionID:(NSString *)libraryVersionID {
  291|      0|  _optionsDictionary[kFIRLibraryVersionID] = [libraryVersionID copy];
  292|      0|}
  293|       |
  294|      0|- (NSString *)databaseURL {
  295|      0|  return self.optionsDictionary[kFIRDatabaseURL];
  296|      0|}
  297|       |
  298|      0|- (void)setDatabaseURL:(NSString *)databaseURL {
  299|      0|  [self checkEditingLocked];
  300|      0|
  301|      0|  _optionsDictionary[kFIRDatabaseURL] = [databaseURL copy];
  302|      0|}
  303|       |
  304|      0|- (NSString *)storageBucket {
  305|      0|  return self.optionsDictionary[kFIRStorageBucket];
  306|      0|}
  307|       |
  308|      0|- (void)setStorageBucket:(NSString *)storageBucket {
  309|      0|  [self checkEditingLocked];
  310|      0|  _optionsDictionary[kFIRStorageBucket] = [storageBucket copy];
  311|      0|}
  312|       |
  313|      6|- (void)setDeepLinkURLScheme:(NSString *)deepLinkURLScheme {
  314|      6|  [self checkEditingLocked];
  315|      6|  _deepLinkURLScheme = [deepLinkURLScheme copy];
  316|      6|}
  317|       |
  318|      3|- (NSString *)bundleID {
  319|      3|  return self.optionsDictionary[kFIRBundleID];
  320|      3|}
  321|       |
  322|      0|- (void)setBundleID:(NSString *)bundleID {
  323|      0|  [self checkEditingLocked];
  324|      0|  _optionsDictionary[kFIRBundleID] = [bundleID copy];
  325|      0|}
  326|       |
  327|      6|- (void)setAppGroupID:(NSString *)appGroupID {
  328|      6|  [self checkEditingLocked];
  329|      6|  _appGroupID = [appGroupID copy];
  330|      6|}
  331|       |
  332|       |#pragma mark - Equality
  333|       |
  334|      0|- (BOOL)isEqual:(id)object {
  335|      0|  if (!object || ![object isKindOfClass:[FIROptions class]]) {
  336|      0|    return NO;
  337|      0|  }
  338|      0|
  339|      0|  return [self isEqualToOptions:(FIROptions *)object];
  340|      0|}
  341|       |
  342|      0|- (BOOL)isEqualToOptions:(FIROptions *)options {
  343|      0|  // Skip any non-FIROptions classes.
  344|      0|  if (![options isKindOfClass:[FIROptions class]]) {
  345|      0|    return NO;
  346|      0|  }
  347|      0|
  348|      0|  // Check the internal dictionary and custom properties for differences.
  349|      0|  if (![options.optionsDictionary isEqualToDictionary:self.optionsDictionary]) {
  350|      0|    return NO;
  351|      0|  }
  352|      0|
  353|      0|  // Validate extra properties not contained in the dictionary. Only validate it if one of the
  354|      0|  // objects has the property set.
  355|      0|  if ((options.deepLinkURLScheme != nil || self.deepLinkURLScheme != nil) &&
  356|      0|      ![options.deepLinkURLScheme isEqualToString:self.deepLinkURLScheme]) {
  357|      0|    return NO;
  358|      0|  }
  359|      0|
  360|      0|  if ((options.appGroupID != nil || self.appGroupID != nil) &&
  361|      0|      ![options.appGroupID isEqualToString:self.appGroupID]) {
  362|      0|    return NO;
  363|      0|  }
  364|      0|
  365|      0|  // Validate the Analytics options haven't changed with the Info.plist.
  366|      0|  if (![options.analyticsOptionsDictionary isEqualToDictionary:self.analyticsOptionsDictionary]) {
  367|      0|    return NO;
  368|      0|  }
  369|      0|
  370|      0|  // We don't care about the `editingLocked` or `usingOptionsFromDefaultPlist` properties since
  371|      0|  // those relate to lifecycle and construction, we only care if the contents of the options
  372|      0|  // themselves are equal.
  373|      0|  return YES;
  374|      0|}
  375|       |
  376|      0|- (NSUInteger)hash {
  377|      0|  // This is strongly recommended for any object that implements a custom `isEqual:` method to
  378|      0|  // ensure that dictionary and set behavior matches other `isEqual:` checks.
  379|      0|  // Note: `self.analyticsOptionsDictionary` was left out here since it solely relies on the
  380|      0|  // contents of the main bundle's `Info.plist`. We should avoid reading that file and the contents
  381|      0|  // should be identical.
  382|      0|  return self.optionsDictionary.hash ^ self.deepLinkURLScheme.hash ^ self.appGroupID.hash;
  383|      0|}
  384|       |
  385|       |#pragma mark - Internal instance methods
  386|       |
  387|      5|- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary {
  388|      5|  if (_analyticsOptionsDictionary == nil) {
  389|      1|    NSMutableDictionary *tempAnalyticsOptions = [[NSMutableDictionary alloc] init];
  390|      1|    NSArray *measurementKeys = @[
  391|      1|      kFIRIsMeasurementEnabled, kFIRIsAnalyticsCollectionEnabled,
  392|      1|      kFIRIsAnalyticsCollectionDeactivated
  393|      1|    ];
  394|      3|    for (NSString *key in measurementKeys) {
  395|      3|      id value = infoDictionary[key] ?: self.optionsDictionary[key] ?: nil;
  396|      3|      if (!value) {
  397|      3|        continue;
  398|      3|      }
  399|      0|      tempAnalyticsOptions[key] = value;
  400|      0|    }
  401|      1|    _analyticsOptionsDictionary = tempAnalyticsOptions;
  402|      1|  }
  403|      5|  return _analyticsOptionsDictionary;
  404|      5|}
  405|       |
  406|      5|- (NSDictionary *)analyticsOptionsDictionary {
  407|      5|  return [self analyticsOptionsDictionaryWithInfoDictionary:[NSBundle mainBundle].infoDictionary];
  408|      5|}
  409|       |
  410|       |/**
  411|       | * Whether or not Measurement was enabled. Measurement is enabled unless explicitly disabled in
  412|       | * GoogleService-Info.plist. This uses the old plist flag IS_MEASUREMENT_ENABLED, which should still
  413|       | * be supported.
  414|       | */
  415|      1|- (BOOL)isMeasurementEnabled {
  416|      1|  if (self.isAnalyticsCollectionDeactivated) {
  417|      0|    return NO;
  418|      0|  }
  419|      1|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  420|      1|  if (value == nil) {
  421|      1|    // TODO: This could probably be cleaned up since FIROptions shouldn't know about FIRApp or have
  422|      1|    //       to check if it's the default app. The FIROptions instance can't be modified after
  423|      1|    //       `+configure` is called, so it's not a good place to copy it either in case the flag is
  424|      1|    //       changed at runtime.
  425|      1|
  426|      1|    // If no values are set for Analytics, fall back to the global collection switch in FIRApp.
  427|      1|    // Analytics only supports the default FIRApp, so check that first.
  428|      1|    if (![FIRApp isDefaultAppConfigured]) {
  429|      0|      return NO;
  430|      0|    }
  431|      1|
  432|      1|    // Fall back to the default app's collection switch when the key is not in the dictionary.
  433|      1|    return [FIRApp defaultApp].isDataCollectionDefaultEnabled;
  434|      1|  }
  435|      0|  return [value boolValue];
  436|      0|}
  437|       |
  438|      0|- (BOOL)isAnalyticsCollectionExplicitlySet {
  439|      0|  // If it's de-activated, it classifies as explicity set. If not, it's not a good enough indication
  440|      0|  // that the developer wants FirebaseAnalytics enabled so continue checking.
  441|      0|  if (self.isAnalyticsCollectionDeactivated) {
  442|      0|    return YES;
  443|      0|  }
  444|      0|
  445|      0|  // Check if the current Analytics flag is set.
  446|      0|  id collectionEnabledObject = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  447|      0|  if (collectionEnabledObject && [collectionEnabledObject isKindOfClass:[NSNumber class]]) {
  448|      0|    // It doesn't matter what the value is, it's explicitly set.
  449|      0|    return YES;
  450|      0|  }
  451|      0|
  452|      0|  // Check if the old measurement flag is set.
  453|      0|  id measurementEnabledObject = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  454|      0|  if (measurementEnabledObject && [measurementEnabledObject isKindOfClass:[NSNumber class]]) {
  455|      0|    // It doesn't matter what the value is, it's explicitly set.
  456|      0|    return YES;
  457|      0|  }
  458|      0|
  459|      0|  // No flags are set to explicitly enable or disable FirebaseAnalytics.
  460|      0|  return NO;
  461|      0|}
  462|       |
  463|      1|- (BOOL)isAnalyticsCollectionEnabled {
  464|      1|  if (self.isAnalyticsCollectionDeactivated) {
  465|      0|    return NO;
  466|      0|  }
  467|      1|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  468|      1|  if (value == nil) {
  469|      1|    return self.isMeasurementEnabled;  // Fall back to older plist flag.
  470|      1|  }
  471|      0|  return [value boolValue];
  472|      0|}
  473|       |
  474|      3|- (BOOL)isAnalyticsCollectionDeactivated {
  475|      3|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionDeactivated];
  476|      3|  if (value == nil) {
  477|      3|    return NO;  // Analytics Collection is not deactivated when the key is not in the dictionary.
  478|      3|  }
  479|      0|  return [value boolValue];
  480|      0|}
  481|       |
  482|      0|- (BOOL)isAnalyticsEnabled {
  483|      0|  return [self.optionsDictionary[kFIRIsAnalyticsEnabled] boolValue];
  484|      0|}
  485|       |
  486|      0|- (BOOL)isSignInEnabled {
  487|      0|  return [self.optionsDictionary[kFIRIsSignInEnabled] boolValue];
  488|      0|}
  489|       |
  490|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCoreDiagnostics/Firebase/CoreDiagnostics/FIRCDLibrary/FIRCoreDiagnostics.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |#include <sys/utsname.h>
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |#import <GoogleDataTransport/GDTCOREvent.h>
   22|       |#import <GoogleDataTransport/GDTCORTargets.h>
   23|       |#import <GoogleDataTransport/GDTCORTransport.h>
   24|       |
   25|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   26|       |#import <GoogleUtilities/GULHeartbeatDateStorage.h>
   27|       |#import <GoogleUtilities/GULLogger.h>
   28|       |
   29|       |#import <FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsData.h>
   30|       |#import <FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsInterop.h>
   31|       |
   32|       |#import <nanopb/pb.h>
   33|       |#import <nanopb/pb_decode.h>
   34|       |#import <nanopb/pb_encode.h>
   35|       |
   36|       |#import "FIRCDLibrary/Protogen/nanopb/firebasecore.nanopb.h"
   37|       |
   38|       |/** The logger service string to use when printing to the console. */
   39|       |static GULLoggerService kFIRCoreDiagnostics = @"[FirebaseCoreDiagnostics/FIRCoreDiagnostics]";
   40|       |
   41|       |#ifdef FIREBASE_BUILD_ZIP_FILE
   42|       |static BOOL kUsingZipFile = YES;
   43|       |#else   // FIREBASE_BUILD_ZIP_FILE
   44|       |static BOOL kUsingZipFile = NO;
   45|       |#endif  // FIREBASE_BUILD_ZIP_FILE
   46|       |
   47|       |#ifdef FIREBASE_BUILD_CARTHAGE
   48|       |#define kDeploymentType logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_CARTHAGE
   49|       |#elif FIREBASE_BUILD_ZIP_FILE
   50|       |#define kDeploymentType logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_ZIP_FILE
   51|       |#else
   52|      2|#define kDeploymentType logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_COCOAPODS
   53|       |#endif
   54|       |
   55|       |static NSString *const kFIRServiceMLVisionOnDeviceAutoML = @"MLVisionOnDeviceAutoML";
   56|       |static NSString *const kFIRServiceMLVisionOnDeviceFace = @"MLVisionOnDeviceFace";
   57|       |static NSString *const kFIRServiceMLVisionOnDeviceBarcode = @"MLVisionOnDeviceBarcode";
   58|       |static NSString *const kFIRServiceMLVisionOnDeviceText = @"MLVisionOnDeviceText";
   59|       |static NSString *const kFIRServiceMLVisionOnDeviceLabel = @"MLVisionOnDeviceLabel";
   60|       |static NSString *const kFIRServiceMLVisionOnDeviceObjectDetection =
   61|       |    @"MLVisionOnDeviceObjectDetection";
   62|       |static NSString *const kFIRServiceMLModelInterpreter = @"MLModelInterpreter";
   63|       |
   64|       |static NSString *const kFIRServiceAdMob = @"AdMob";
   65|       |static NSString *const kFIRServiceAuth = @"Auth";
   66|       |static NSString *const kFIRServiceAuthUI = @"AuthUI";
   67|       |static NSString *const kFIRServiceCrash = @"Crash";
   68|       |static NSString *const kFIRServiceDatabase = @"Database";
   69|       |static NSString *const kFIRServiceDynamicLinks = @"DynamicLinks";
   70|       |static NSString *const kFIRServiceFirestore = @"Firestore";
   71|       |static NSString *const kFIRServiceFunctions = @"Functions";
   72|       |static NSString *const kFIRServiceIAM = @"InAppMessaging";
   73|       |static NSString *const kFIRServiceInstanceID = @"InstanceID";
   74|       |static NSString *const kFIRServiceInvites = @"Invites";
   75|       |static NSString *const kFIRServiceMessaging = @"Messaging";
   76|       |static NSString *const kFIRServiceMeasurement = @"Measurement";
   77|       |static NSString *const kFIRServicePerformance = @"Performance";
   78|       |static NSString *const kFIRServiceRemoteConfig = @"RemoteConfig";
   79|       |static NSString *const kFIRServiceStorage = @"Storage";
   80|       |static NSString *const kGGLServiceAnalytics = @"Analytics";
   81|       |static NSString *const kGGLServiceSignIn = @"SignIn";
   82|       |static NSString *const kFIRAppDiagnosticsConfigurationTypeKey =
   83|       |    @"FIRAppDiagnosticsConfigurationTypeKey";
   84|       |static NSString *const kFIRAppDiagnosticsFIRAppKey = @"FIRAppDiagnosticsFIRAppKey";
   85|       |static NSString *const kFIRAppDiagnosticsSDKNameKey = @"FIRAppDiagnosticsSDKNameKey";
   86|       |static NSString *const kFIRAppDiagnosticsSDKVersionKey = @"FIRAppDiagnosticsSDKVersionKey";
   87|       |static NSString *const kFIRCoreDiagnosticsHeartbeatTag = @"FIRCoreDiagnostics";
   88|       |
   89|       |/**
   90|       | * The file name to the recent heartbeat date.
   91|       | */
   92|       |NSString *const kFIRCoreDiagnosticsHeartbeatDateFileName = @"FIREBASE_DIAGNOSTICS_HEARTBEAT_DATE";
   93|       |
   94|       |/**
   95|       | * @note This should implement the GDTCOREventDataObject protocol, but can't because of
   96|       | * weak-linking.
   97|       | */
   98|       |@interface FIRCoreDiagnosticsLog : NSObject
   99|       |
  100|       |/** The config that will be converted to proto bytes. */
  101|       |@property(nonatomic) logs_proto_mobilesdk_ios_ICoreConfiguration config;
  102|       |
  103|       |@end
  104|       |
  105|       |@implementation FIRCoreDiagnosticsLog
  106|       |
  107|      2|- (instancetype)initWithConfig:(logs_proto_mobilesdk_ios_ICoreConfiguration)config {
  108|      2|  self = [super init];
  109|      2|  if (self) {
  110|      2|    _config = config;
  111|      2|  }
  112|      2|  return self;
  113|      2|}
  114|       |
  115|       |// Provided and required by the GDTCOREventDataObject protocol.
  116|      4|- (NSData *)transportBytes {
  117|      4|  pb_ostream_t sizestream = PB_OSTREAM_SIZING;
  118|      4|
  119|      4|  // Encode 1 time to determine the size.
  120|      4|  if (!pb_encode(&sizestream, logs_proto_mobilesdk_ios_ICoreConfiguration_fields, &_config)) {
  121|      0|    GDTCORLogError(GDTCORMCETransportBytesError, @"Error in nanopb encoding for size: %s",
  122|      0|                   PB_GET_ERROR(&sizestream));
  123|      0|  }
  124|      4|
  125|      4|  // Encode a 2nd time to actually get the bytes from it.
  126|      4|  size_t bufferSize = sizestream.bytes_written;
  127|      4|  CFMutableDataRef dataRef = CFDataCreateMutable(CFAllocatorGetDefault(), bufferSize);
  128|      4|  CFDataSetLength(dataRef, bufferSize);
  129|      4|  pb_ostream_t ostream = pb_ostream_from_buffer((void *)CFDataGetBytePtr(dataRef), bufferSize);
  130|      4|  if (!pb_encode(&ostream, logs_proto_mobilesdk_ios_ICoreConfiguration_fields, &_config)) {
  131|      0|    GDTCORLogError(GDTCORMCETransportBytesError, @"Error in nanopb encoding for bytes: %s",
  132|      0|                   PB_GET_ERROR(&ostream));
  133|      0|  }
  134|      4|  CFDataSetLength(dataRef, ostream.bytes_written);
  135|      4|
  136|      4|  return CFBridgingRelease(dataRef);
  137|      4|}
  138|       |
  139|      2|- (void)dealloc {
  140|      2|  pb_release(logs_proto_mobilesdk_ios_ICoreConfiguration_fields, &_config);
  141|      2|}
  142|       |
  143|       |@end
  144|       |
  145|       |NS_ASSUME_NONNULL_BEGIN
  146|       |
  147|       |/** This class produces a protobuf containing diagnostics and usage data to be logged. */
  148|       |@interface FIRCoreDiagnostics : NSObject <FIRCoreDiagnosticsInterop>
  149|       |
  150|       |/** The queue on which all diagnostics collection will occur. */
  151|       |@property(nonatomic, readonly) dispatch_queue_t diagnosticsQueue;
  152|       |
  153|       |/** The transport object used to send data. */
  154|       |@property(nonatomic, readonly) GDTCORTransport *transport;
  155|       |
  156|       |/** The storage to store the date of the last sent heartbeat. */
  157|       |@property(nonatomic, readonly) GULHeartbeatDateStorage *heartbeatDateStorage;
  158|       |
  159|       |@end
  160|       |
  161|       |NS_ASSUME_NONNULL_END
  162|       |
  163|       |@implementation FIRCoreDiagnostics
  164|       |
  165|      2|+ (instancetype)sharedInstance {
  166|      2|  static FIRCoreDiagnostics *sharedInstance;
  167|      2|  static dispatch_once_t onceToken;
  168|      2|  dispatch_once(&onceToken, ^{
  169|      1|    sharedInstance = [[FIRCoreDiagnostics alloc] init];
  170|      1|  });
  171|      2|  return sharedInstance;
  172|      2|}
  173|       |
  174|      1|- (instancetype)init {
  175|      1|  GDTCORTransport *transport = [[GDTCORTransport alloc] initWithMappingID:@"137"
  176|      1|                                                             transformers:nil
  177|      1|                                                                   target:kGDTCORTargetFLL];
  178|      1|
  179|      1|  GULHeartbeatDateStorage *dateStorage =
  180|      1|      [[GULHeartbeatDateStorage alloc] initWithFileName:kFIRCoreDiagnosticsHeartbeatDateFileName];
  181|      1|
  182|      1|  return [self initWithTransport:transport heartbeatDateStorage:dateStorage];
  183|      1|}
  184|       |
  185|       |/** Initializer for unit tests.
  186|       | *
  187|       | * @param transport A `GDTCORTransport` instance which that be used to send event.
  188|       | * @param heartbeatDateStorage An instanse of date storage to track heartbeat sending.
  189|       | * @return Returns the initialized `FIRCoreDiagnostics` instance.
  190|       | */
  191|       |- (instancetype)initWithTransport:(GDTCORTransport *)transport
  192|      1|             heartbeatDateStorage:(GULHeartbeatDateStorage *)heartbeatDateStorage {
  193|      1|  self = [super init];
  194|      1|  if (self) {
  195|      1|    _diagnosticsQueue =
  196|      1|        dispatch_queue_create("com.google.FIRCoreDiagnostics", DISPATCH_QUEUE_SERIAL);
  197|      1|    _transport = transport;
  198|      1|    _heartbeatDateStorage = heartbeatDateStorage;
  199|      1|  }
  200|      1|  return self;
  201|      1|}
  202|       |
  203|       |#pragma mark - Metadata helpers
  204|       |
  205|       |/** Returns the model of iOS device. Sample platform strings are @"iPhone7,1" for iPhone 6 Plus,
  206|       | * @"iPhone7,2" for iPhone 6, etc. Refer to the Hardware strings at
  207|       | * https://en.wikipedia.org/wiki/List_of_iOS_devices
  208|       | *
  209|       | * @return The device model as an NSString.
  210|       | */
  211|      2|+ (NSString *)deviceModel {
  212|      2|  static NSString *deviceModel = nil;
  213|      2|  if (deviceModel == nil) {
  214|      1|    struct utsname systemInfo;
  215|      1|    uname(&systemInfo);
  216|      1|    deviceModel = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];
  217|      1|  }
  218|      2|  return deviceModel;
  219|      2|}
  220|       |
  221|       |#pragma mark - nanopb helper functions
  222|       |
  223|       |/** Mallocs a pb_bytes_array and copies the given NSString's bytes into the bytes array.
  224|       | *
  225|       | * @note Memory needs to be free manually, through pb_free or pb_release.
  226|       | * @param string The string to encode as pb_bytes.
  227|       | */
  228|     16|pb_bytes_array_t *FIREncodeString(NSString *string) {
  229|     16|  NSData *stringBytes = [string dataUsingEncoding:NSUTF8StringEncoding];
  230|     16|  return FIREncodeData(stringBytes);
  231|     16|}
  232|       |
  233|       |/** Mallocs a pb_bytes_array and copies the given NSData bytes into the bytes array.
  234|       | *
  235|       | * @note Memory needs to be free manually, through pb_free or pb_release.
  236|       | * @param data The data to copy into the new bytes array.
  237|       | */
  238|     16|pb_bytes_array_t *FIREncodeData(NSData *data) {
  239|     16|  pb_bytes_array_t *pbBytes = malloc(PB_BYTES_ARRAY_T_ALLOCSIZE(data.length));
  240|     16|  if (pbBytes != NULL) {
  241|     16|    memcpy(pbBytes->bytes, [data bytes], data.length);
  242|     16|    pbBytes->size = (pb_size_t)data.length;
  243|     16|  }
  244|     16|  return pbBytes;
  245|     16|}
  246|       |
  247|       |/** Maps a service string to the representative nanopb enum.
  248|       | *
  249|       | * @param serviceString The SDK service string to convert.
  250|       | * @return The representative nanopb enum.
  251|       | */
  252|       |logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType FIRMapFromServiceStringToTypeEnum(
  253|      6|    NSString *serviceString) {
  254|      6|  static NSDictionary<NSString *, NSNumber *> *serviceStringToTypeEnum;
  255|      6|  if (serviceStringToTypeEnum == nil) {
  256|      1|    serviceStringToTypeEnum = @{
  257|      1|      kFIRServiceAdMob : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ADMOB),
  258|      1|      kFIRServiceMessaging : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MESSAGING),
  259|      1|      kFIRServiceMeasurement :
  260|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MEASUREMENT),
  261|      1|      kFIRServiceRemoteConfig :
  262|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_REMOTE_CONFIG),
  263|      1|      kFIRServiceDatabase : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DATABASE),
  264|      1|      kFIRServiceDynamicLinks :
  265|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DYNAMIC_LINKS),
  266|      1|      kFIRServiceAuth : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH),
  267|      1|      kFIRServiceAuthUI : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH_UI),
  268|      1|      kFIRServiceFirestore : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FIRESTORE),
  269|      1|      kFIRServiceFunctions : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FUNCTIONS),
  270|      1|      kFIRServicePerformance :
  271|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_PERFORMANCE),
  272|      1|      kFIRServiceStorage : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_STORAGE),
  273|      1|      kFIRServiceMLVisionOnDeviceAutoML :
  274|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_AUTOML),
  275|      1|      kFIRServiceMLVisionOnDeviceFace :
  276|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_FACE),
  277|      1|      kFIRServiceMLVisionOnDeviceBarcode :
  278|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_BARCODE),
  279|      1|      kFIRServiceMLVisionOnDeviceText :
  280|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_TEXT),
  281|      1|      kFIRServiceMLVisionOnDeviceLabel :
  282|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_LABEL),
  283|      1|      kFIRServiceMLVisionOnDeviceObjectDetection : @(
  284|      1|          logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION),
  285|      1|      kFIRServiceMLModelInterpreter :
  286|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_MODEL_INTERPRETER),
  287|      1|      kGGLServiceAnalytics : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ANALYTICS),
  288|      1|      kGGLServiceSignIn : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_SIGN_IN),
  289|      1|      kFIRServiceIAM : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_IN_APP_MESSAGING),
  290|      1|    };
  291|      1|  }
  292|      6|  if (serviceStringToTypeEnum[serviceString] != nil) {
  293|      6|    return (int32_t)serviceStringToTypeEnum[serviceString].longLongValue;
  294|      6|  }
  295|      0|  return logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_UNKNOWN_SDK_SERVICE;
  296|      0|}
  297|       |
  298|       |#pragma mark - Proto population functions
  299|       |
  300|       |/** Populates the given proto with data related to an SDK logDiagnostics call from the
  301|       | * diagnosticObjects dictionary.
  302|       | *
  303|       | * @param config The proto to populate
  304|       | * @param diagnosticObjects The dictionary of diagnostics objects.
  305|       | */
  306|       |void FIRPopulateProtoWithInfoFromUserInfoParams(logs_proto_mobilesdk_ios_ICoreConfiguration *config,
  307|      2|                                                NSDictionary<NSString *, id> *diagnosticObjects) {
  308|      2|  NSNumber *configurationType = diagnosticObjects[kFIRCDConfigurationTypeKey];
  309|      2|  if (configurationType != nil) {
  310|      2|    switch (configurationType.integerValue) {
  311|      2|      case logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_CORE:
  312|      2|        config->configuration_type =
  313|      2|            logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_CORE;
  314|      2|        config->has_configuration_type = 1;
  315|      2|        break;
  316|      2|      case logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK:
  317|      0|        config->configuration_type =
  318|      0|            logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK;
  319|      0|        config->has_configuration_type = 1;
  320|      0|        break;
  321|      2|      default:
  322|      0|        break;
  323|      2|    }
  324|      2|  }
  325|      2|
  326|      2|  NSString *sdkName = diagnosticObjects[kFIRCDSdkNameKey];
  327|      2|  if (sdkName) {
  328|      0|    config->sdk_name = FIRMapFromServiceStringToTypeEnum(sdkName);
  329|      0|    config->has_sdk_name = 1;
  330|      0|  }
  331|      2|
  332|      2|  NSString *version = diagnosticObjects[kFIRCDSdkVersionKey];
  333|      2|  if (version) {
  334|      0|    config->sdk_version = FIREncodeString(version);
  335|      0|  }
  336|      2|}
  337|       |
  338|       |/** Populates the given proto with data from the calling FIRApp using the given
  339|       | * diagnosticObjects dictionary.
  340|       | *
  341|       | * @param config The proto to populate
  342|       | * @param diagnosticObjects The dictionary of diagnostics objects.
  343|       | */
  344|       |void FIRPopulateProtoWithCommonInfoFromApp(logs_proto_mobilesdk_ios_ICoreConfiguration *config,
  345|      2|                                           NSDictionary<NSString *, id> *diagnosticObjects) {
  346|      2|  config->pod_name = logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE;
  347|      2|  config->has_pod_name = 1;
  348|      2|
  349|      2|  if (!diagnosticObjects[kFIRCDllAppsCountKey]) {
  350|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"%@",
  351|      0|                   @"App count is a required value in the data dict.");
  352|      0|  }
  353|      2|  config->app_count = (int32_t)[diagnosticObjects[kFIRCDllAppsCountKey] integerValue];
  354|      2|  config->has_app_count = 1;
  355|      2|
  356|      2|  NSString *googleAppID = diagnosticObjects[kFIRCDGoogleAppIDKey];
  357|      2|  if (googleAppID.length) {
  358|      2|    config->app_id = FIREncodeString(googleAppID);
  359|      2|  }
  360|      2|
  361|      2|  NSString *bundleID = diagnosticObjects[kFIRCDBundleIDKey];
  362|      2|  if (bundleID.length) {
  363|      2|    config->bundle_id = FIREncodeString(bundleID);
  364|      2|  }
  365|      2|
  366|      2|  NSString *firebaseUserAgent = diagnosticObjects[kFIRCDFirebaseUserAgentKey];
  367|      2|  if (firebaseUserAgent.length) {
  368|      2|    config->platform_info = FIREncodeString(firebaseUserAgent);
  369|      2|  }
  370|      2|
  371|      2|  NSNumber *usingOptionsFromDefaultPlist = diagnosticObjects[kFIRCDUsingOptionsFromDefaultPlistKey];
  372|      2|  if (usingOptionsFromDefaultPlist != nil) {
  373|      2|    config->use_default_app = [usingOptionsFromDefaultPlist boolValue];
  374|      2|    config->has_use_default_app = 1;
  375|      2|  }
  376|      2|
  377|      2|  NSString *libraryVersionID = diagnosticObjects[kFIRCDLibraryVersionIDKey];
  378|      2|  if (libraryVersionID) {
  379|      2|    config->icore_version = FIREncodeString(libraryVersionID);
  380|      2|  }
  381|      2|
  382|      2|  NSString *deviceModel = [FIRCoreDiagnostics deviceModel];
  383|      2|  if (deviceModel.length) {
  384|      2|    config->device_model = FIREncodeString(deviceModel);
  385|      2|  }
  386|      2|
  387|      2|  NSString *osVersion = [GULAppEnvironmentUtil systemVersion];
  388|      2|  if (osVersion.length) {
  389|      2|    config->os_version = FIREncodeString(osVersion);
  390|      2|  }
  391|      2|
  392|      2|  config->using_zip_file = kUsingZipFile;
  393|      2|  config->has_using_zip_file = 1;
  394|      2|  config->deployment_type = kDeploymentType;
  395|      2|  config->has_deployment_type = 1;
  396|      2|  config->deployed_in_app_store = [GULAppEnvironmentUtil isFromAppStore];
  397|      2|  config->has_deployed_in_app_store = 1;
  398|      2|}
  399|       |
  400|       |/** Populates the given proto with installed services data.
  401|       | *
  402|       | * @param config The proto to populate
  403|       | */
  404|      2|void FIRPopulateProtoWithInstalledServices(logs_proto_mobilesdk_ios_ICoreConfiguration *config) {
  405|      2|  NSMutableArray<NSNumber *> *sdkServiceInstalledArray = [NSMutableArray array];
  406|      2|
  407|      2|  // AdMob
  408|      2|  if (NSClassFromString(@"GADBannerView") != nil) {
  409|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceAdMob))];
  410|      0|  }
  411|      2|  // CloudMessaging
  412|      2|  if (NSClassFromString(@"FIRMessaging") != nil) {
  413|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMessaging))];
  414|      0|  }
  415|      2|  // RemoteConfig
  416|      2|  if (NSClassFromString(@"FIRRemoteConfig") != nil) {
  417|      0|    [sdkServiceInstalledArray
  418|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceRemoteConfig))];
  419|      0|  }
  420|      2|  // Measurement/Analtyics
  421|      2|  if (NSClassFromString(@"FIRAnalytics") != nil) {
  422|      2|    [sdkServiceInstalledArray
  423|      2|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMeasurement))];
  424|      2|  }
  425|      2|  // ML Vision On Device AutoML.
  426|      2|  if (NSClassFromString(@"FIRVisionOnDeviceAutoMLImageLabelerOptions") != nil) {
  427|      0|    [sdkServiceInstalledArray
  428|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceAutoML))];
  429|      0|  }
  430|      2|  // ML Vision On Device Face.
  431|      2|  if (NSClassFromString(@"FIRVisionFaceDetector") != nil &&
  432|      2|      NSClassFromString(@"GMVFaceDetector") != nil) {
  433|      0|    [sdkServiceInstalledArray
  434|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceFace))];
  435|      0|  }
  436|      2|  // ML Vision On Device Barcode.
  437|      2|  if (NSClassFromString(@"FIRVisionBarcodeDetector") != nil &&
  438|      2|      NSClassFromString(@"GMVBarcodeDetector") != nil) {
  439|      0|    [sdkServiceInstalledArray
  440|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceBarcode))];
  441|      0|  }
  442|      2|  // ML Vision On Device Text.
  443|      2|  if (NSClassFromString(@"FIRVisionTextDetector") != nil &&
  444|      2|      NSClassFromString(@"GMVTextDetector") != nil) {
  445|      0|    [sdkServiceInstalledArray
  446|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceText))];
  447|      0|  }
  448|      2|  // ML Vision On Device Image Label.
  449|      2|  if (NSClassFromString(@"FIRVisionLabelDetector") != nil &&
  450|      2|      NSClassFromString(@"GMVLabelDetector") != nil) {
  451|      0|    [sdkServiceInstalledArray
  452|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceLabel))];
  453|      0|  }
  454|      2|  // ML Vision On Device Object.
  455|      2|  if (NSClassFromString(@"FIRVisionObjectDetector") != nil) {
  456|      0|    [sdkServiceInstalledArray
  457|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceObjectDetection))];
  458|      0|  }
  459|      2|  // ML Model Interpreter
  460|      2|  if (NSClassFromString(@"FIRCustomModelInterpreter") != nil) {
  461|      0|    [sdkServiceInstalledArray
  462|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLModelInterpreter))];
  463|      0|  }
  464|      2|  // Database
  465|      2|  if (NSClassFromString(@"FIRDatabase") != nil) {
  466|      2|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceDatabase))];
  467|      2|  }
  468|      2|  // DynamicDeepLink
  469|      2|  if (NSClassFromString(@"FIRDynamicLinks") != nil) {
  470|      0|    [sdkServiceInstalledArray
  471|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceDynamicLinks))];
  472|      0|  }
  473|      2|  // Auth
  474|      2|  if (NSClassFromString(@"FIRAuth") != nil) {
  475|      2|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceAuth))];
  476|      2|  }
  477|      2|  // AuthUI
  478|      2|  if (NSClassFromString(@"FUIAuth") != nil) {
  479|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceAuthUI))];
  480|      0|  }
  481|      2|  // Firestore
  482|      2|  if (NSClassFromString(@"FIRFirestore") != nil) {
  483|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceFirestore))];
  484|      0|  }
  485|      2|  // Functions
  486|      2|  if (NSClassFromString(@"FIRFunctions") != nil) {
  487|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceFunctions))];
  488|      0|  }
  489|      2|  // Performance
  490|      2|  if (NSClassFromString(@"FIRPerformance") != nil) {
  491|      0|    [sdkServiceInstalledArray
  492|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServicePerformance))];
  493|      0|  }
  494|      2|  // Storage
  495|      2|  if (NSClassFromString(@"FIRStorage") != nil) {
  496|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceStorage))];
  497|      0|  }
  498|      2|  // SignIn via Google pod
  499|      2|  if (NSClassFromString(@"GIDSignIn") != nil && NSClassFromString(@"GGLContext") != nil) {
  500|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kGGLServiceSignIn))];
  501|      0|  }
  502|      2|  // Analytics via Google pod
  503|      2|  if (NSClassFromString(@"GAI") != nil && NSClassFromString(@"GGLContext") != nil) {
  504|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kGGLServiceAnalytics))];
  505|      0|  }
  506|      2|
  507|      2|  // In-App Messaging
  508|      2|  if (NSClassFromString(@"FIRInAppMessaging") != nil) {
  509|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceIAM))];
  510|      0|  }
  511|      2|
  512|      2|  logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType *servicesInstalled =
  513|      2|      malloc(sizeof(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType) *
  514|      2|             sdkServiceInstalledArray.count);
  515|      2|  if (servicesInstalled == NULL) {
  516|      0|    return;
  517|      0|  }
  518|      8|  for (NSUInteger i = 0; i < sdkServiceInstalledArray.count; i++) {
  519|      6|    NSNumber *typeEnum = sdkServiceInstalledArray[i];
  520|      6|    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType serviceType =
  521|      6|        (int32_t)typeEnum.integerValue;
  522|      6|    servicesInstalled[i] = serviceType;
  523|      6|  }
  524|      2|
  525|      2|  config->sdk_service_installed = servicesInstalled;
  526|      2|  config->sdk_service_installed_count = (int32_t)sdkServiceInstalledArray.count;
  527|      2|}
  528|       |
  529|       |/** Populates the proto with the number of linked frameworks.
  530|       | *
  531|       | * @param config The proto to populate.
  532|       | */
  533|       |void FIRPopulateProtoWithNumberOfLinkedFrameworks(
  534|      2|    logs_proto_mobilesdk_ios_ICoreConfiguration *config) {
  535|      2|  int numFrameworks = -1;  // Subtract the app binary itself.
  536|      2|  unsigned int numImages;
  537|      2|  const char **imageNames = objc_copyImageNames(&numImages);
  538|    652|  for (unsigned int i = 0; i < numImages; i++) {
  539|    650|    NSString *imageName = [NSString stringWithUTF8String:imageNames[i]];
  540|    650|    if ([imageName rangeOfString:@"System/Library"].length != 0        // Apple .frameworks
  541|    650|        || [imageName rangeOfString:@"Developer/Library"].length != 0  // Xcode debug .frameworks
  542|    650|        || [imageName rangeOfString:@"usr/lib"].length != 0) {         // Public .dylibs
  543|    644|      continue;
  544|    644|    }
  545|      6|    numFrameworks++;
  546|      6|  }
  547|      2|  free(imageNames);
  548|      2|  config->dynamic_framework_count = numFrameworks;
  549|      2|  config->has_dynamic_framework_count = 1;
  550|      2|}
  551|       |
  552|       |/** Populates the proto with Info.plist values.
  553|       | *
  554|       | * @param config The proto to populate.
  555|       | */
  556|      2|void FIRPopulateProtoWithInfoPlistValues(logs_proto_mobilesdk_ios_ICoreConfiguration *config) {
  557|      2|  NSDictionary<NSString *, id> *info = [[NSBundle mainBundle] infoDictionary];
  558|      2|
  559|      2|  NSString *xcodeVersion = info[@"DTXcodeBuild"] ?: @"";
  560|      2|  NSString *sdkVersion = info[@"DTSDKBuild"] ?: @"";
  561|      2|  NSString *combinedVersions = [NSString stringWithFormat:@"%@-%@", xcodeVersion, sdkVersion];
  562|      2|  config->apple_framework_version = FIREncodeString(combinedVersions);
  563|      2|
  564|      2|  NSString *minVersion = info[@"MinimumOSVersion"];
  565|      2|  if (minVersion) {
  566|      2|    config->min_supported_ios_version = FIREncodeString(minVersion);
  567|      2|  }
  568|      2|
  569|      2|  // Apps can turn off swizzling in the Info.plist, check if they've explicitly set the value and
  570|      2|  // report it. It's enabled by default.
  571|      2|  NSNumber *appDelegateSwizzledNum = info[@"FirebaseAppDelegateProxyEnabled"];
  572|      2|  BOOL appDelegateSwizzled = YES;
  573|      2|  if ([appDelegateSwizzledNum isKindOfClass:[NSNumber class]]) {
  574|      0|    appDelegateSwizzled = [appDelegateSwizzledNum boolValue];
  575|      0|  }
  576|      2|  config->swizzling_enabled = appDelegateSwizzled;
  577|      2|  config->has_swizzling_enabled = 1;
  578|      2|}
  579|       |
  580|       |#pragma mark - FIRCoreDiagnosticsInterop
  581|       |
  582|      2|+ (void)sendDiagnosticsData:(nonnull id<FIRCoreDiagnosticsData>)diagnosticsData {
  583|      2|  FIRCoreDiagnostics *diagnostics = [FIRCoreDiagnostics sharedInstance];
  584|      2|  [diagnostics sendDiagnosticsData:diagnosticsData];
  585|      2|}
  586|       |
  587|      2|- (void)sendDiagnosticsData:(nonnull id<FIRCoreDiagnosticsData>)diagnosticsData {
  588|      2|  dispatch_async(self.diagnosticsQueue, ^{
  589|      2|    NSDictionary<NSString *, id> *diagnosticObjects = diagnosticsData.diagnosticObjects;
  590|      2|    NSNumber *isDataCollectionDefaultEnabled =
  591|      2|        diagnosticObjects[kFIRCDIsDataCollectionDefaultEnabledKey];
  592|      2|    if (isDataCollectionDefaultEnabled && ![isDataCollectionDefaultEnabled boolValue]) {
  593|      0|      return;
  594|      0|    }
  595|      2|
  596|      2|    // Create the proto.
  597|      2|    logs_proto_mobilesdk_ios_ICoreConfiguration icore_config =
  598|      2|        logs_proto_mobilesdk_ios_ICoreConfiguration_init_default;
  599|      2|
  600|      2|    icore_config.using_gdt = 1;
  601|      2|    icore_config.has_using_gdt = 1;
  602|      2|
  603|      2|    // Populate the proto with information.
  604|      2|    FIRPopulateProtoWithInfoFromUserInfoParams(&icore_config, diagnosticObjects);
  605|      2|    FIRPopulateProtoWithCommonInfoFromApp(&icore_config, diagnosticObjects);
  606|      2|    FIRPopulateProtoWithInstalledServices(&icore_config);
  607|      2|    FIRPopulateProtoWithNumberOfLinkedFrameworks(&icore_config);
  608|      2|    FIRPopulateProtoWithInfoPlistValues(&icore_config);
  609|      2|    [self setHeartbeatFlagIfNeededToConfig:&icore_config];
  610|      2|
  611|      2|    // This log object is capable of converting the proto to bytes.
  612|      2|    FIRCoreDiagnosticsLog *log = [[FIRCoreDiagnosticsLog alloc] initWithConfig:icore_config];
  613|      2|
  614|      2|    // Send the log as a telemetry event.
  615|      2|    GDTCOREvent *event = [self.transport eventForTransport];
  616|      2|    event.dataObject = (id<GDTCOREventDataObject>)log;
  617|      2|    [self.transport sendTelemetryEvent:event];
  618|      2|  });
  619|      2|}
  620|       |
  621|       |#pragma mark - Heartbeat
  622|       |
  623|      2|- (void)setHeartbeatFlagIfNeededToConfig:(logs_proto_mobilesdk_ios_ICoreConfiguration *)config {
  624|      2|  // Check if need to send a heartbeat.
  625|      2|  NSDate *currentDate = [NSDate date];
  626|      2|  NSDate *lastCheckin =
  627|      2|      [self.heartbeatDateStorage heartbeatDateForTag:kFIRCoreDiagnosticsHeartbeatTag];
  628|      2|  if (lastCheckin) {
  629|      2|    // Ensure the previous checkin was on a different date in the past.
  630|      2|    if ([self isDate:currentDate inSameDayOrBeforeThan:lastCheckin]) {
  631|      2|      return;
  632|      2|    }
  633|      0|  }
  634|      0|
  635|      0|  // Update heartbeat sent date.
  636|      0|  [self.heartbeatDateStorage setHearbeatDate:currentDate forTag:kFIRCoreDiagnosticsHeartbeatTag];
  637|      0|  // Set the flag.
  638|      0|  config->sdk_name = logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ICORE;
  639|      0|  config->has_sdk_name = 1;
  640|      0|}
  641|       |
  642|      2|- (BOOL)isDate:(NSDate *)date1 inSameDayOrBeforeThan:(NSDate *)date2 {
  643|      2|  return [[NSCalendar currentCalendar] isDate:date1 inSameDayAsDate:date2] ||
  644|      2|         [date1 compare:date2] == NSOrderedAscending;
  645|      2|}
  646|       |
  647|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseCoreDiagnostics/Firebase/CoreDiagnostics/FIRCDLibrary/Protogen/nanopb/firebasecore.nanopb.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |/* Automatically generated nanopb header */
   18|       |/* Generated by nanopb-0.3.9.3 */
   19|       |
   20|       |#ifndef PB_LOGS_PROTO_MOBILESDK_IOS_FIREBASECORE_NANOPB_H_INCLUDED
   21|       |#define PB_LOGS_PROTO_MOBILESDK_IOS_FIREBASECORE_NANOPB_H_INCLUDED
   22|       |#include <nanopb/pb.h>
   23|       |
   24|       |/* @@protoc_insertion_point(includes) */
   25|       |#if PB_PROTO_HEADER_VERSION != 30
   26|       |#error Regenerate this file with the current version of nanopb generator.
   27|       |#endif
   28|       |
   29|       |
   30|       |/* Enum definitions */
   31|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType {
   32|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_UNKNOWN_CONFIGURATION_TYPE = 0,
   33|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_CORE = 1,
   34|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK = 2
   35|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType;
   36|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_UNKNOWN_CONFIGURATION_TYPE
   37|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK
   38|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType)(logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK+1))
   39|       |
   40|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType {
   41|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_UNKNOWN_BUILD_TYPE = 0,
   42|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_INTERNAL = 1,
   43|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_EAP = 2,
   44|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_PROD = 3
   45|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType;
   46|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_UNKNOWN_BUILD_TYPE
   47|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_PROD
   48|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType)(logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_PROD+1))
   49|       |
   50|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType {
   51|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_UNKNOWN_SDK_SERVICE = 0,
   52|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ICORE = 1,
   53|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ADMOB = 2,
   54|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_APP_INVITE = 3,
   55|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_SIGN_IN = 5,
   56|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_GCM = 6,
   57|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MAPS = 7,
   58|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_SCION = 8,
   59|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ANALYTICS = 9,
   60|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_APP_INDEXING = 10,
   61|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_CONFIG = 11,
   62|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DURABLE_DEEP_LINKS = 12,
   63|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_CRASH = 13,
   64|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH = 14,
   65|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DATABASE = 15,
   66|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_STORAGE = 16,
   67|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MESSAGING = 17,
   68|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MEASUREMENT = 18,
   69|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_REMOTE_CONFIG = 19,
   70|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DYNAMIC_LINKS = 20,
   71|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_INVITES = 21,
   72|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH_UI = 22,
   73|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FIRESTORE = 23,
   74|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_PERFORMANCE = 24,
   75|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_FACE = 26,
   76|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_BARCODE = 27,
   77|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_TEXT = 28,
   78|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_LABEL = 29,
   79|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_MODEL_INTERPRETER = 30,
   80|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_IN_APP_MESSAGING = 31,
   81|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FUNCTIONS = 32,
   82|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_NATURAL_LANGUAGE = 33,
   83|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_AUTOML = 34,
   84|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION = 35
   85|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType;
   86|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_UNKNOWN_SDK_SERVICE
   87|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION
   88|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType)(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION+1))
   89|       |
   90|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName {
   91|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_UNKNOWN_POD_NAME = 0,
   92|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_GOOGLE = 1,
   93|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE = 2
   94|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_PodName;
   95|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_UNKNOWN_POD_NAME
   96|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE
   97|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_PodName)(logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE+1))
   98|       |
   99|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType {
  100|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_UNKNOWN = 0,
  101|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_COCOAPODS = 1,
  102|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_ZIP_FILE = 2,
  103|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_CARTHAGE = 3,
  104|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_SPM = 4
  105|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType;
  106|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_UNKNOWN
  107|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_SPM
  108|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType)(logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_SPM+1))
  109|       |
  110|       |/* Struct definitions */
  111|       |typedef struct _logs_proto_mobilesdk_ios_ICoreConfiguration {
  112|       |    bool has_configuration_type;
  113|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType configuration_type;
  114|       |    pb_size_t sdk_service_installed_count;
  115|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType *sdk_service_installed;
  116|       |    pb_bytes_array_t *device_model;
  117|       |    pb_bytes_array_t *app_id;
  118|       |    pb_bytes_array_t *bundle_id;
  119|       |    bool has_pod_name;
  120|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName pod_name;
  121|       |    pb_bytes_array_t *icore_version;
  122|       |    pb_bytes_array_t *sdk_version;
  123|       |    bool has_sdk_name;
  124|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType sdk_name;
  125|       |    bool has_app_count;
  126|       |    int32_t app_count;
  127|       |    pb_bytes_array_t *os_version;
  128|       |    pb_bytes_array_t *min_supported_ios_version;
  129|       |    bool has_use_default_app;
  130|       |    bool use_default_app;
  131|       |    bool has_deployed_in_app_store;
  132|       |    bool deployed_in_app_store;
  133|       |    bool has_dynamic_framework_count;
  134|       |    int32_t dynamic_framework_count;
  135|       |    pb_bytes_array_t *apple_framework_version;
  136|       |    bool has_using_zip_file;
  137|       |    bool using_zip_file;
  138|       |    bool has_deployment_type;
  139|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType deployment_type;
  140|       |    pb_bytes_array_t *platform_info;
  141|       |    bool has_swizzling_enabled;
  142|       |    bool swizzling_enabled;
  143|       |    bool has_using_gdt;
  144|       |    bool using_gdt;
  145|       |/* @@protoc_insertion_point(struct:logs_proto_mobilesdk_ios_ICoreConfiguration) */
  146|       |} logs_proto_mobilesdk_ios_ICoreConfiguration;
  147|       |
  148|       |/* Default values for struct fields */
  149|       |
  150|       |/* Initializer values for message structs */
  151|      2|#define logs_proto_mobilesdk_ios_ICoreConfiguration_init_default {false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MIN, 0, NULL, NULL, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MIN, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MIN, false, 0, NULL, NULL, false, 0, false, 0, false, 0, NULL, false, 0, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MIN, NULL, false, 0, false, 0}
  152|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_init_zero {false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MIN, 0, NULL, NULL, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MIN, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MIN, false, 0, NULL, NULL, false, 0, false, 0, false, 0, NULL, false, 0, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MIN, NULL, false, 0, false, 0}
  153|       |
  154|       |/* Field tags (for use in manual encoding/decoding) */
  155|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_pod_name_tag 16
  156|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_configuration_type_tag 1
  157|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_icore_version_tag 18
  158|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_sdk_version_tag 19
  159|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_sdk_service_installed_tag 7
  160|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_sdk_name_tag 20
  161|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_device_model_tag 9
  162|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_os_version_tag 22
  163|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_app_id_tag 10
  164|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_bundle_id_tag 12
  165|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_min_supported_ios_version_tag 24
  166|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_use_default_app_tag 25
  167|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_app_count_tag 21
  168|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_deployed_in_app_store_tag 26
  169|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_dynamic_framework_count_tag 27
  170|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_apple_framework_version_tag 28
  171|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_using_zip_file_tag 29
  172|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_deployment_type_tag 30
  173|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_platform_info_tag 31
  174|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_swizzling_enabled_tag 33
  175|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_using_gdt_tag 36
  176|       |
  177|       |/* Struct field encoding specification for nanopb */
  178|       |extern const pb_field_t logs_proto_mobilesdk_ios_ICoreConfiguration_fields[22];
  179|       |
  180|       |/* Maximum encoded size of messages (where known) */
  181|       |/* logs_proto_mobilesdk_ios_ICoreConfiguration_size depends on runtime parameters */
  182|       |
  183|       |/* Message IDs (where set with "msgid" option) */
  184|       |#ifdef PB_MSGID
  185|       |
  186|       |#define FIREBASECORE_MESSAGES \
  187|       |
  188|       |
  189|       |#endif
  190|       |
  191|       |/* @@protoc_insertion_point(eof) */
  192|       |
  193|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRDataSnapshot.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDataSnapshot.h"
   18|       |#import "FChildrenNode.h"
   19|       |#import "FIRDataSnapshot_Private.h"
   20|       |#import "FIRDatabaseReference.h"
   21|       |#import "FTransformedEnumerator.h"
   22|       |#import "FValidation.h"
   23|       |
   24|       |@interface FIRDataSnapshot ()
   25|       |@property(nonatomic, strong) FIRDatabaseReference *ref;
   26|       |@end
   27|       |
   28|       |@implementation FIRDataSnapshot
   29|       |
   30|      0|- (id)initWithRef:(FIRDatabaseReference *)ref indexedNode:(FIndexedNode *)node {
   31|      0|    self = [super init];
   32|      0|    if (self != nil) {
   33|      0|        self->_ref = ref;
   34|      0|        self->_node = node;
   35|      0|    }
   36|      0|    return self;
   37|      0|}
   38|       |
   39|      0|- (id)value {
   40|      0|    return [self.node.node val];
   41|      0|}
   42|       |
   43|      0|- (id)valueInExportFormat {
   44|      0|    return [self.node.node valForExport:YES];
   45|      0|}
   46|       |
   47|      0|- (FIRDataSnapshot *)childSnapshotForPath:(NSString *)childPathString {
   48|      0|    [FValidation validateFrom:@"child:" validPathString:childPathString];
   49|      0|    FPath *childPath = [[FPath alloc] initWith:childPathString];
   50|      0|    FIRDatabaseReference *childRef = [self.ref child:childPathString];
   51|      0|
   52|      0|    id<FNode> childNode = [self.node.node getChild:childPath];
   53|      0|    return [[FIRDataSnapshot alloc]
   54|      0|        initWithRef:childRef
   55|      0|        indexedNode:[FIndexedNode indexedNodeWithNode:childNode]];
   56|      0|}
   57|       |
   58|      0|- (BOOL)hasChild:(NSString *)childPathString {
   59|      0|    [FValidation validateFrom:@"hasChild:" validPathString:childPathString];
   60|      0|    FPath *childPath = [[FPath alloc] initWith:childPathString];
   61|      0|    return ![[self.node.node getChild:childPath] isEmpty];
   62|      0|}
   63|       |
   64|      0|- (id)priority {
   65|      0|    id<FNode> priority = [self.node.node getPriority];
   66|      0|    return priority.val;
   67|      0|}
   68|       |
   69|      0|- (BOOL)hasChildren {
   70|      0|    if ([self.node.node isLeafNode]) {
   71|      0|        return false;
   72|      0|    } else {
   73|      0|        return ![self.node.node isEmpty];
   74|      0|    }
   75|      0|}
   76|       |
   77|      0|- (BOOL)exists {
   78|      0|    return ![self.node.node isEmpty];
   79|      0|}
   80|       |
   81|      0|- (NSString *)key {
   82|      0|    return [self.ref key];
   83|      0|}
   84|       |
   85|      0|- (NSUInteger)childrenCount {
   86|      0|    return [self.node.node numChildren];
   87|      0|}
   88|       |
   89|      0|- (NSEnumerator<FIRDataSnapshot *> *)children {
   90|      0|    return [[FTransformedEnumerator alloc]
   91|      0|        initWithEnumerator:self.node.childEnumerator
   92|      0|              andTransform:^id(FNamedNode *node) {
   93|      0|                FIRDatabaseReference *childRef = [self.ref child:node.name];
   94|      0|                return [[FIRDataSnapshot alloc]
   95|      0|                    initWithRef:childRef
   96|      0|                    indexedNode:[FIndexedNode indexedNodeWithNode:node.node]];
   97|      0|              }];
   98|      0|}
   99|       |
  100|      0|- (NSString *)description {
  101|      0|    return
  102|      0|        [NSString stringWithFormat:@"Snap (%@) %@", self.key, self.node.node];
  103|      0|}
  104|       |
  105|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRDatabase.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import <FirebaseAuthInterop/FIRAuthInterop.h>
   20|       |#import <FirebaseCore/FIRAppInternal.h>
   21|       |#import <FirebaseCore/FIRComponent.h>
   22|       |#import <FirebaseCore/FIRComponentContainer.h>
   23|       |#import <FirebaseCore/FIRDependency.h>
   24|       |#import <FirebaseCore/FIRLogger.h>
   25|       |#import <FirebaseCore/FIROptions.h>
   26|       |
   27|       |#import "FIRDatabase.h"
   28|       |#import "FIRDatabaseComponent.h"
   29|       |#import "FIRDatabaseConfig_Private.h"
   30|       |#import "FIRDatabaseQuery_Private.h"
   31|       |#import "FIRDatabaseReference_Private.h"
   32|       |#import "FIRDatabase_Private.h"
   33|       |#import "FRepoInfo.h"
   34|       |#import "FValidation.h"
   35|       |
   36|       |@implementation FIRDatabase
   37|       |
   38|       |// The STR and STR_EXPAND macro allow a numeric version passed to he compiler
   39|       |// driver with a -D to be treated as a string instead of an invalid floating
   40|       |// point value.
   41|       |#define STR(x) STR_EXPAND(x)
   42|       |#define STR_EXPAND(x) #x
   43|       |static const char *FIREBASE_SEMVER = (const char *)STR(FIRDatabase_VERSION);
   44|       |
   45|      0|+ (FIRDatabase *)database {
   46|      0|    if (![FIRApp isDefaultAppConfigured]) {
   47|      0|        [NSException raise:@"FIRAppNotConfigured"
   48|      0|                    format:@"Failed to get default Firebase Database instance. "
   49|      0|                           @"Must call `[FIRApp "
   50|      0|                           @"configure]` (`FirebaseApp.configure()` in Swift) "
   51|      0|                           @"before using "
   52|      0|                           @"Firebase Database."];
   53|      0|    }
   54|      0|    return [FIRDatabase databaseForApp:[FIRApp defaultApp]];
   55|      0|}
   56|       |
   57|      0|+ (FIRDatabase *)databaseWithURL:(NSString *)url {
   58|      0|    FIRApp *app = [FIRApp defaultApp];
   59|      0|    if (app == nil) {
   60|      0|        [NSException
   61|      0|             raise:@"FIRAppNotConfigured"
   62|      0|            format:
   63|      0|                @"Failed to get default Firebase Database instance. "
   64|      0|                @"Must call `[FIRApp configure]` (`FirebaseApp.configure()` in "
   65|      0|                @"Swift) before using Firebase Database."];
   66|      0|    }
   67|      0|    return [FIRDatabase databaseForApp:app URL:url];
   68|      0|}
   69|       |
   70|      0|+ (FIRDatabase *)databaseForApp:(FIRApp *)app {
   71|      0|    if (app == nil) {
   72|      0|        [NSException raise:@"InvalidFIRApp"
   73|      0|                    format:@"nil FIRApp instance passed to databaseForApp."];
   74|      0|    }
   75|      0|    return [FIRDatabase databaseForApp:app URL:app.options.databaseURL];
   76|      0|}
   77|       |
   78|      0|+ (FIRDatabase *)databaseForApp:(FIRApp *)app URL:(NSString *)url {
   79|      0|    if (app == nil) {
   80|      0|        [NSException raise:@"InvalidFIRApp"
   81|      0|                    format:@"nil FIRApp instance passed to databaseForApp."];
   82|      0|    }
   83|      0|    if (url == nil) {
   84|      0|        [NSException raise:@"MissingDatabaseURL"
   85|      0|                    format:@"Failed to get FirebaseDatabase instance: "
   86|      0|                           @"Specify DatabaseURL within FIRApp or from your "
   87|      0|                           @"databaseForApp:URL: call."];
   88|      0|    }
   89|      0|    id<FIRDatabaseProvider> provider =
   90|      0|        FIR_COMPONENT(FIRDatabaseProvider, app.container);
   91|      0|    return [provider databaseForApp:app URL:url];
   92|      0|}
   93|       |
   94|      0|+ (NSString *)buildVersion {
   95|      0|    // TODO: Restore git hash when build moves back to git
   96|      0|    return [NSString stringWithFormat:@"%s_%s", FIREBASE_SEMVER, __DATE__];
   97|      0|}
   98|       |
   99|       |+ (FIRDatabase *)createDatabaseForTests:(FRepoInfo *)repoInfo
  100|      0|                                 config:(FIRDatabaseConfig *)config {
  101|      0|    FIRDatabase *db = [[FIRDatabase alloc] initWithApp:nil
  102|      0|                                              repoInfo:repoInfo
  103|      0|                                                config:config];
  104|      0|    [db ensureRepo];
  105|      0|    return db;
  106|      0|}
  107|       |
  108|      1|+ (NSString *)sdkVersion {
  109|      1|    return [NSString stringWithUTF8String:FIREBASE_SEMVER];
  110|      1|}
  111|       |
  112|      0|+ (void)setLoggingEnabled:(BOOL)enabled {
  113|      0|    [FUtilities setLoggingEnabled:enabled];
  114|      0|    FFLog(@"I-RDB024001", @"BUILD Version: %@", [FIRDatabase buildVersion]);
  115|      0|}
  116|       |
  117|       |- (id)initWithApp:(FIRApp *)app
  118|       |         repoInfo:(FRepoInfo *)info
  119|      0|           config:(FIRDatabaseConfig *)config {
  120|      0|    self = [super init];
  121|      0|    if (self != nil) {
  122|      0|        self->_repoInfo = info;
  123|      0|        self->_config = config;
  124|      0|        self->_app = app;
  125|      0|    }
  126|      0|    return self;
  127|      0|}
  128|       |
  129|      0|- (FIRDatabaseReference *)reference {
  130|      0|    [self ensureRepo];
  131|      0|
  132|      0|    return [[FIRDatabaseReference alloc] initWithRepo:self.repo
  133|      0|                                                 path:[FPath empty]];
  134|      0|}
  135|       |
  136|      0|- (FIRDatabaseReference *)referenceWithPath:(NSString *)path {
  137|      0|    [self ensureRepo];
  138|      0|
  139|      0|    [FValidation validateFrom:@"referenceWithPath" validRootPathString:path];
  140|      0|    FPath *childPath = [[FPath alloc] initWith:path];
  141|      0|    return [[FIRDatabaseReference alloc] initWithRepo:self.repo path:childPath];
  142|      0|}
  143|       |
  144|      0|- (FIRDatabaseReference *)referenceFromURL:(NSString *)databaseUrl {
  145|      0|    [self ensureRepo];
  146|      0|
  147|      0|    if (databaseUrl == nil) {
  148|      0|        [NSException raise:@"InvalidDatabaseURL"
  149|      0|                    format:@"Invalid nil url passed to referenceFromURL:"];
  150|      0|    }
  151|      0|    FParsedUrl *parsedUrl = [FUtilities parseUrl:databaseUrl];
  152|      0|    [FValidation validateFrom:@"referenceFromURL:" validURL:parsedUrl];
  153|      0|    if (![parsedUrl.repoInfo.host isEqualToString:_repoInfo.host]) {
  154|      0|        [NSException
  155|      0|             raise:@"InvalidDatabaseURL"
  156|      0|            format:
  157|      0|                @"Invalid URL (%@) passed to getReference(). URL was expected "
  158|      0|                 "to match configured Database URL: %@",
  159|      0|                databaseUrl, [self reference].URL];
  160|      0|    }
  161|      0|    return [[FIRDatabaseReference alloc] initWithRepo:self.repo
  162|      0|                                                 path:parsedUrl.path];
  163|      0|}
  164|       |
  165|      0|- (void)purgeOutstandingWrites {
  166|      0|    [self ensureRepo];
  167|      0|
  168|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  169|      0|      [self.repo purgeOutstandingWrites];
  170|      0|    });
  171|      0|}
  172|       |
  173|      0|- (void)goOnline {
  174|      0|    [self ensureRepo];
  175|      0|
  176|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  177|      0|      [self.repo resume];
  178|      0|    });
  179|      0|}
  180|       |
  181|      0|- (void)goOffline {
  182|      0|    [self ensureRepo];
  183|      0|
  184|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  185|      0|      [self.repo interrupt];
  186|      0|    });
  187|      0|}
  188|       |
  189|      0|- (void)setPersistenceEnabled:(BOOL)persistenceEnabled {
  190|      0|    [self assertUnfrozen:@"setPersistenceEnabled"];
  191|      0|    self->_config.persistenceEnabled = persistenceEnabled;
  192|      0|}
  193|       |
  194|      0|- (BOOL)persistenceEnabled {
  195|      0|    return self->_config.persistenceEnabled;
  196|      0|}
  197|       |
  198|      0|- (void)setPersistenceCacheSizeBytes:(NSUInteger)persistenceCacheSizeBytes {
  199|      0|    [self assertUnfrozen:@"setPersistenceCacheSizeBytes"];
  200|      0|    self->_config.persistenceCacheSizeBytes = persistenceCacheSizeBytes;
  201|      0|}
  202|       |
  203|      0|- (NSUInteger)persistenceCacheSizeBytes {
  204|      0|    return self->_config.persistenceCacheSizeBytes;
  205|      0|}
  206|       |
  207|      0|- (void)setCallbackQueue:(dispatch_queue_t)callbackQueue {
  208|      0|    [self assertUnfrozen:@"setCallbackQueue"];
  209|      0|    self->_config.callbackQueue = callbackQueue;
  210|      0|}
  211|       |
  212|      0|- (dispatch_queue_t)callbackQueue {
  213|      0|    return self->_config.callbackQueue;
  214|      0|}
  215|       |
  216|      0|- (void)assertUnfrozen:(NSString *)methodName {
  217|      0|    if (self.repo != nil) {
  218|      0|        [NSException
  219|      0|             raise:@"FIRDatabaseAlreadyInUse"
  220|      0|            format:@"Calls to %@ must be made before any other usage of "
  221|      0|                    "FIRDatabase instance.",
  222|      0|                   methodName];
  223|      0|    }
  224|      0|}
  225|       |
  226|      0|- (void)ensureRepo {
  227|      0|    if (self.repo == nil) {
  228|      0|        self.repo = [FRepoManager createRepo:self.repoInfo
  229|      0|                                      config:self.config
  230|      0|                                    database:self];
  231|      0|    }
  232|      0|}
  233|       |
  234|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRDatabaseComponent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDatabaseComponent.h"
   18|       |
   19|       |#import "FIRDatabaseConfig_Private.h"
   20|       |#import "FIRDatabase_Private.h"
   21|       |#import "FRepoManager.h"
   22|       |
   23|       |#import <FirebaseAuthInterop/FIRAuthInterop.h>
   24|       |#import <FirebaseCore/FIRAppInternal.h>
   25|       |#import <FirebaseCore/FIRComponent.h>
   26|       |#import <FirebaseCore/FIRComponentContainer.h>
   27|       |#import <FirebaseCore/FIRDependency.h>
   28|       |#import <FirebaseCore/FIRLibrary.h>
   29|       |#import <FirebaseCore/FIROptions.h>
   30|       |
   31|       |NS_ASSUME_NONNULL_BEGIN
   32|       |
   33|       |/** A NSMutableDictionary of FirebaseApp name and FRepoInfo to FirebaseDatabase
   34|       | * instance. */
   35|       |typedef NSMutableDictionary<NSString *, FIRDatabase *> FIRDatabaseDictionary;
   36|       |
   37|       |@interface FIRDatabaseComponent () <FIRComponentLifecycleMaintainer, FIRLibrary>
   38|       |@property(nonatomic) FIRDatabaseDictionary *instances;
   39|       |/// Internal intializer.
   40|       |- (instancetype)initWithApp:(FIRApp *)app;
   41|       |@end
   42|       |
   43|       |@implementation FIRDatabaseComponent
   44|       |
   45|       |#pragma mark - Initialization
   46|       |
   47|      0|- (instancetype)initWithApp:(FIRApp *)app {
   48|      0|    self = [super init];
   49|      0|    if (self) {
   50|      0|        _app = app;
   51|      0|        _instances = [NSMutableDictionary dictionary];
   52|      0|    }
   53|      0|    return self;
   54|      0|}
   55|       |
   56|       |#pragma mark - Lifecycle
   57|       |
   58|      1|+ (void)load {
   59|      1|    [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self
   60|      1|                           withName:@"fire-db"
   61|      1|                        withVersion:[FIRDatabase sdkVersion]];
   62|      1|}
   63|       |
   64|       |#pragma mark - FIRComponentRegistrant
   65|       |
   66|      1|+ (NSArray<FIRComponent *> *)componentsToRegister {
   67|      1|    FIRDependency *authDep =
   68|      1|        [FIRDependency dependencyWithProtocol:@protocol(FIRAuthInterop)
   69|      1|                                   isRequired:NO];
   70|      1|    FIRComponentCreationBlock creationBlock =
   71|      1|        ^id _Nullable(FIRComponentContainer *container, BOOL *isCacheable) {
   72|      0|        *isCacheable = YES;
   73|      0|        return [[FIRDatabaseComponent alloc] initWithApp:container.app];
   74|      0|    };
   75|      1|    FIRComponent *databaseProvider =
   76|      1|        [FIRComponent componentWithProtocol:@protocol(FIRDatabaseProvider)
   77|      1|                        instantiationTiming:FIRInstantiationTimingLazy
   78|      1|                               dependencies:@[ authDep ]
   79|      1|                              creationBlock:creationBlock];
   80|      1|    return @[ databaseProvider ];
   81|      1|}
   82|       |
   83|       |#pragma mark - Instance management.
   84|       |
   85|      0|- (void)appWillBeDeleted:(FIRApp *)app {
   86|      0|    NSString *appName = app.name;
   87|      0|    if (appName == nil) {
   88|      0|        return;
   89|      0|    }
   90|      0|    FIRDatabaseDictionary *instances = [self instances];
   91|      0|    @synchronized(instances) {
   92|      0|        // Clean up the deleted instance in an effort to remove any resources
   93|      0|        // still in use. Note: Any leftover instances of this exact database
   94|      0|        // will be invalid.
   95|      0|        for (FIRDatabase *database in [instances allValues]) {
   96|      0|            [FRepoManager disposeRepos:database.config];
   97|      0|        }
   98|      0|        [instances removeAllObjects];
   99|      0|    }
  100|      0|}
  101|       |
  102|       |#pragma mark - FIRDatabaseProvider Conformance
  103|       |
  104|      0|- (FIRDatabase *)databaseForApp:(FIRApp *)app URL:(NSString *)url {
  105|      0|    if (app == nil) {
  106|      0|        [NSException raise:@"InvalidFIRApp"
  107|      0|                    format:@"nil FIRApp instance passed to databaseForApp."];
  108|      0|    }
  109|      0|
  110|      0|    if (url == nil) {
  111|      0|        [NSException raise:@"MissingDatabaseURL"
  112|      0|                    format:@"Failed to get FirebaseDatabase instance: "
  113|      0|                            "Specify DatabaseURL within FIRApp or from your "
  114|      0|                            "databaseForApp:URL: call."];
  115|      0|    }
  116|      0|
  117|      0|    NSURL *databaseUrl = [NSURL URLWithString:url];
  118|      0|
  119|      0|    if (databaseUrl == nil) {
  120|      0|        [NSException raise:@"InvalidDatabaseURL"
  121|      0|                    format:@"The Database URL '%@' cannot be parsed. "
  122|      0|                            "Specify a valid DatabaseURL within FIRApp or from "
  123|      0|                            "your databaseForApp:URL: call.",
  124|      0|                           databaseUrl];
  125|      0|    } else if (![databaseUrl.path isEqualToString:@""] &&
  126|      0|               ![databaseUrl.path isEqualToString:@"/"]) {
  127|      0|        [NSException
  128|      0|             raise:@"InvalidDatabaseURL"
  129|      0|            format:@"Configured Database URL '%@' is invalid. It should point "
  130|      0|                    "to the root of a Firebase Database but it includes a "
  131|      0|                    "path: %@",
  132|      0|                   databaseUrl, databaseUrl.path];
  133|      0|    }
  134|      0|
  135|      0|    FIRDatabaseDictionary *instances = [self instances];
  136|      0|    @synchronized(instances) {
  137|      0|        FParsedUrl *parsedUrl =
  138|      0|            [FUtilities parseUrl:databaseUrl.absoluteString];
  139|      0|        NSString *urlIndex =
  140|      0|            [NSString stringWithFormat:@"%@:%@", parsedUrl.repoInfo.host,
  141|      0|                                       [parsedUrl.path toString]];
  142|      0|        FIRDatabase *database = instances[urlIndex];
  143|      0|        if (!database) {
  144|      0|            id<FAuthTokenProvider> authTokenProvider = [FAuthTokenProvider
  145|      0|                authTokenProviderWithAuth:FIR_COMPONENT(FIRAuthInterop,
  146|      0|                                                        app.container)];
  147|      0|
  148|      0|            // If this is the default app, don't set the session persistence key
  149|      0|            // so that we use our default ("default") instead of the FIRApp
  150|      0|            // default ("[DEFAULT]") so that we preserve the default location
  151|      0|            // used by the legacy Firebase SDK.
  152|      0|            NSString *sessionIdentifier = @"default";
  153|      0|            if (![FIRApp isDefaultAppConfigured] ||
  154|      0|                app != [FIRApp defaultApp]) {
  155|      0|                sessionIdentifier = app.name;
  156|      0|            }
  157|      0|
  158|      0|            FIRDatabaseConfig *config = [[FIRDatabaseConfig alloc]
  159|      0|                initWithSessionIdentifier:sessionIdentifier
  160|      0|                        authTokenProvider:authTokenProvider];
  161|      0|            database = [[FIRDatabase alloc] initWithApp:app
  162|      0|                                               repoInfo:parsedUrl.repoInfo
  163|      0|                                                 config:config];
  164|      0|            instances[urlIndex] = database;
  165|      0|        }
  166|      0|
  167|      0|        return database;
  168|      0|    }
  169|      0|}
  170|       |
  171|       |@end
  172|       |
  173|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRDatabaseConfig.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDatabaseConfig.h"
   18|       |
   19|       |#import "FAuthTokenProvider.h"
   20|       |#import "FIRDatabaseConfig_Private.h"
   21|       |#import "FIRNoopAuthTokenProvider.h"
   22|       |
   23|       |@interface FIRDatabaseConfig (Private)
   24|       |
   25|       |@property(nonatomic, strong, readwrite) NSString *sessionIdentifier;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIRDatabaseConfig
   30|       |
   31|      0|- (id)init {
   32|      0|    [NSException raise:NSInvalidArgumentException
   33|      0|                format:@"Can't create config objects!"];
   34|      0|    return nil;
   35|      0|}
   36|       |
   37|       |- (id)initWithSessionIdentifier:(NSString *)identifier
   38|      0|              authTokenProvider:(id<FAuthTokenProvider>)authTokenProvider {
   39|      0|    self = [super init];
   40|      0|    if (self != nil) {
   41|      0|        self->_sessionIdentifier = identifier;
   42|      0|        self->_callbackQueue = dispatch_get_main_queue();
   43|      0|        self->_persistenceCacheSizeBytes =
   44|      0|            10 * 1024 * 1024; // Default cache size is 10MB
   45|      0|        self->_authTokenProvider = authTokenProvider;
   46|      0|    }
   47|      0|    return self;
   48|      0|}
   49|       |
   50|      0|- (void)assertUnfrozen {
   51|      0|    if (self.isFrozen) {
   52|      0|        [NSException raise:NSGenericException
   53|      0|                    format:@"Can't modify config objects after they are in use "
   54|      0|                           @"for FIRDatabaseReferences."];
   55|      0|    }
   56|      0|}
   57|       |
   58|      0|- (void)setAuthTokenProvider:(id<FAuthTokenProvider>)authTokenProvider {
   59|      0|    [self assertUnfrozen];
   60|      0|    self->_authTokenProvider = authTokenProvider;
   61|      0|}
   62|       |
   63|      0|- (void)setPersistenceEnabled:(BOOL)persistenceEnabled {
   64|      0|    [self assertUnfrozen];
   65|      0|    self->_persistenceEnabled = persistenceEnabled;
   66|      0|}
   67|       |
   68|      0|- (void)setPersistenceCacheSizeBytes:(NSUInteger)persistenceCacheSizeBytes {
   69|      0|    [self assertUnfrozen];
   70|      0|    // Can't be less than 1MB
   71|      0|    if (persistenceCacheSizeBytes < 1024 * 1024) {
   72|      0|        [NSException raise:NSInvalidArgumentException
   73|      0|                    format:@"The minimum cache size must be at least 1MB"];
   74|      0|    }
   75|      0|    if (persistenceCacheSizeBytes > 100 * 1024 * 1024) {
   76|      0|        [NSException raise:NSInvalidArgumentException
   77|      0|                    format:@"Firebase Database currently doesn't support a "
   78|      0|                           @"cache size larger than 100MB"];
   79|      0|    }
   80|      0|    self->_persistenceCacheSizeBytes = persistenceCacheSizeBytes;
   81|      0|}
   82|       |
   83|      0|- (void)setCallbackQueue:(dispatch_queue_t)callbackQueue {
   84|      0|    [self assertUnfrozen];
   85|      0|    self->_callbackQueue = callbackQueue;
   86|      0|}
   87|       |
   88|      0|- (void)freeze {
   89|      0|    self->_isFrozen = YES;
   90|      0|}
   91|       |
   92|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRDatabaseQuery.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDatabaseQuery.h"
   18|       |#import "FChildEventRegistration.h"
   19|       |#import "FConstants.h"
   20|       |#import "FIRDatabaseQuery_Private.h"
   21|       |#import "FKeyIndex.h"
   22|       |#import "FLeafNode.h"
   23|       |#import "FPath.h"
   24|       |#import "FPathIndex.h"
   25|       |#import "FPriorityIndex.h"
   26|       |#import "FQueryParams.h"
   27|       |#import "FQuerySpec.h"
   28|       |#import "FSnapshotUtilities.h"
   29|       |#import "FValidation.h"
   30|       |#import "FValueEventRegistration.h"
   31|       |#import "FValueIndex.h"
   32|       |
   33|       |@implementation FIRDatabaseQuery
   34|       |
   35|       |@synthesize repo;
   36|       |@synthesize path;
   37|       |@synthesize queryParams;
   38|       |
   39|      0|#define INVALID_QUERY_PARAM_ERROR @"InvalidQueryParameter"
   40|       |
   41|      0|+ (dispatch_queue_t)sharedQueue {
   42|      0|    // We use this shared queue across all of the FQueries so things happen FIFO
   43|      0|    // (as opposed to dispatch_get_global_queue(0, 0) which is concurrent)
   44|      0|    static dispatch_once_t pred;
   45|      0|    static dispatch_queue_t sharedDispatchQueue;
   46|      0|
   47|      0|    dispatch_once(&pred, ^{
   48|      0|      sharedDispatchQueue = dispatch_queue_create("FirebaseWorker", NULL);
   49|      0|    });
   50|      0|
   51|      0|    return sharedDispatchQueue;
   52|      0|}
   53|       |
   54|      0|- (id)initWithRepo:(FRepo *)theRepo path:(FPath *)thePath {
   55|      0|    return [self initWithRepo:theRepo
   56|      0|                         path:thePath
   57|      0|                       params:nil
   58|      0|                orderByCalled:NO
   59|      0|         priorityMethodCalled:NO];
   60|      0|}
   61|       |
   62|       |- (id)initWithRepo:(FRepo *)theRepo
   63|       |                    path:(FPath *)thePath
   64|       |                  params:(FQueryParams *)theParams
   65|       |           orderByCalled:(BOOL)orderByCalled
   66|      0|    priorityMethodCalled:(BOOL)priorityMethodCalled {
   67|      0|    self = [super init];
   68|      0|    if (self) {
   69|      0|        self.repo = theRepo;
   70|      0|        self.path = thePath;
   71|      0|        if (!theParams) {
   72|      0|            theParams = [FQueryParams defaultInstance];
   73|      0|        }
   74|      0|        if (![theParams isValid]) {
   75|      0|            @throw [[NSException alloc]
   76|      0|                initWithName:@"InvalidArgumentError"
   77|      0|                      reason:@"Queries are limited to two constraints"
   78|      0|                    userInfo:nil];
   79|      0|        }
   80|      0|        self.queryParams = theParams;
   81|      0|        self.orderByCalled = orderByCalled;
   82|      0|        self.priorityMethodCalled = priorityMethodCalled;
   83|      0|    }
   84|      0|    return self;
   85|      0|}
   86|       |
   87|      0|- (FQuerySpec *)querySpec {
   88|      0|    return [[FQuerySpec alloc] initWithPath:self.path params:self.queryParams];
   89|      0|}
   90|       |
   91|      0|- (void)validateQueryEndpointsForParams:(FQueryParams *)params {
   92|      0|    if ([params.index isEqual:[FKeyIndex keyIndex]]) {
   93|      0|        if ([params hasStart]) {
   94|      0|            if (params.indexStartKey != [FUtilities minName]) {
   95|      0|                [NSException raise:INVALID_QUERY_PARAM_ERROR
   96|      0|                            format:@"Can't use queryStartingAtValue:childKey: "
   97|      0|                                   @"or queryEqualTo:andChildKey: in "
   98|      0|                                   @"combination with queryOrderedByKey"];
   99|      0|            }
  100|      0|            if (![params.indexStartValue.val isKindOfClass:[NSString class]]) {
  101|      0|                [NSException
  102|      0|                     raise:INVALID_QUERY_PARAM_ERROR
  103|      0|                    format:
  104|      0|                        @"Can't use queryStartingAtValue: with other types "
  105|      0|                        @"than string in combination with queryOrderedByKey"];
  106|      0|            }
  107|      0|        }
  108|      0|        if ([params hasEnd]) {
  109|      0|            if (params.indexEndKey != [FUtilities maxName]) {
  110|      0|                [NSException raise:INVALID_QUERY_PARAM_ERROR
  111|      0|                            format:@"Can't use queryEndingAtValue:childKey: or "
  112|      0|                                   @"queryEqualToValue:childKey: in "
  113|      0|                                   @"combination with queryOrderedByKey"];
  114|      0|            }
  115|      0|            if (![params.indexEndValue.val isKindOfClass:[NSString class]]) {
  116|      0|                [NSException
  117|      0|                     raise:INVALID_QUERY_PARAM_ERROR
  118|      0|                    format:
  119|      0|                        @"Can't use queryEndingAtValue: with other types than "
  120|      0|                        @"string in combination with queryOrderedByKey"];
  121|      0|            }
  122|      0|        }
  123|      0|    } else if ([params.index isEqual:[FPriorityIndex priorityIndex]]) {
  124|      0|        if (([params hasStart] &&
  125|      0|             ![FValidation validatePriorityValue:params.indexStartValue.val]) ||
  126|      0|            ([params hasEnd] &&
  127|      0|             ![FValidation validatePriorityValue:params.indexEndValue.val])) {
  128|      0|            [NSException
  129|      0|                 raise:INVALID_QUERY_PARAM_ERROR
  130|      0|                format:@"When using queryOrderedByPriority, values provided to "
  131|      0|                       @"queryStartingAtValue:, queryEndingAtValue:, or "
  132|      0|                       @"queryEqualToValue: must be valid priorities."];
  133|      0|        }
  134|      0|    }
  135|      0|}
  136|       |
  137|      0|- (void)validateEqualToCall {
  138|      0|    if ([self.queryParams hasStart]) {
  139|      0|        [NSException
  140|      0|             raise:INVALID_QUERY_PARAM_ERROR
  141|      0|            format:
  142|      0|                @"Cannot combine queryEqualToValue: and queryStartingAtValue:"];
  143|      0|    }
  144|      0|    if ([self.queryParams hasEnd]) {
  145|      0|        [NSException
  146|      0|             raise:INVALID_QUERY_PARAM_ERROR
  147|      0|            format:
  148|      0|                @"Cannot combine queryEqualToValue: and queryEndingAtValue:"];
  149|      0|    }
  150|      0|}
  151|       |
  152|      0|- (void)validateNoPreviousOrderByCalled {
  153|      0|    if (self.orderByCalled) {
  154|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  155|      0|                    format:@"Cannot use multiple queryOrderedBy calls!"];
  156|      0|    }
  157|      0|}
  158|       |
  159|      0|- (void)validateIndexValueType:(id)type fromMethod:(NSString *)method {
  160|      0|    if (type != nil && ![type isKindOfClass:[NSNumber class]] &&
  161|      0|        ![type isKindOfClass:[NSString class]] &&
  162|      0|        ![type isKindOfClass:[NSNull class]]) {
  163|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  164|      0|                    format:@"You can only pass nil, NSString or NSNumber to %@",
  165|      0|                           method];
  166|      0|    }
  167|      0|}
  168|       |
  169|      0|- (FIRDatabaseQuery *)queryStartingAtValue:(id)startValue {
  170|      0|    return [self queryStartingAtInternal:startValue
  171|      0|                                childKey:nil
  172|      0|                                    from:@"queryStartingAtValue:"
  173|      0|                          priorityMethod:NO];
  174|      0|}
  175|       |
  176|       |- (FIRDatabaseQuery *)queryStartingAtValue:(id)startValue
  177|      0|                                  childKey:(NSString *)childKey {
  178|      0|    if ([self.queryParams.index isEqual:[FKeyIndex keyIndex]]) {
  179|      0|        @throw [[NSException alloc]
  180|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  181|      0|                  reason:@"You must use queryStartingAtValue: instead of "
  182|      0|                         @"queryStartingAtValue:childKey: when using "
  183|      0|                         @"queryOrderedByKey:"
  184|      0|                userInfo:nil];
  185|      0|    }
  186|      0|    return [self queryStartingAtInternal:startValue
  187|      0|                                childKey:childKey
  188|      0|                                    from:@"queryStartingAtValue:childKey:"
  189|      0|                          priorityMethod:NO];
  190|      0|}
  191|       |
  192|       |- (FIRDatabaseQuery *)queryStartingAtInternal:(id<FNode>)startValue
  193|       |                                     childKey:(NSString *)childKey
  194|       |                                         from:(NSString *)methodName
  195|      0|                               priorityMethod:(BOOL)priorityMethod {
  196|      0|    [self validateIndexValueType:startValue fromMethod:methodName];
  197|      0|    if (childKey != nil) {
  198|      0|        [FValidation validateFrom:methodName validKey:childKey];
  199|      0|    }
  200|      0|    if ([self.queryParams hasStart]) {
  201|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  202|      0|                    format:@"Can't call %@ after queryStartingAtValue or "
  203|      0|                           @"queryEqualToValue was previously called",
  204|      0|                           methodName];
  205|      0|    }
  206|      0|    id<FNode> startNode = [FSnapshotUtilities nodeFrom:startValue];
  207|      0|    FQueryParams *params = [self.queryParams startAt:startNode
  208|      0|                                            childKey:childKey];
  209|      0|    [self validateQueryEndpointsForParams:params];
  210|      0|    return [[FIRDatabaseQuery alloc]
  211|      0|                initWithRepo:self.repo
  212|      0|                        path:self.path
  213|      0|                      params:params
  214|      0|               orderByCalled:self.orderByCalled
  215|      0|        priorityMethodCalled:priorityMethod || self.priorityMethodCalled];
  216|      0|}
  217|       |
  218|      0|- (FIRDatabaseQuery *)queryEndingAtValue:(id)endValue {
  219|      0|    return [self queryEndingAtInternal:endValue
  220|      0|                              childKey:nil
  221|      0|                                  from:@"queryEndingAtValue:"
  222|      0|                        priorityMethod:NO];
  223|      0|}
  224|       |
  225|       |- (FIRDatabaseQuery *)queryEndingAtValue:(id)endValue
  226|      0|                                childKey:(NSString *)childKey {
  227|      0|    if ([self.queryParams.index isEqual:[FKeyIndex keyIndex]]) {
  228|      0|        @throw [[NSException alloc]
  229|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  230|      0|                  reason:@"You must use queryEndingAtValue: instead of "
  231|      0|                         @"queryEndingAtValue:childKey: when using "
  232|      0|                         @"queryOrderedByKey:"
  233|      0|                userInfo:nil];
  234|      0|    }
  235|      0|
  236|      0|    return [self queryEndingAtInternal:endValue
  237|      0|                              childKey:childKey
  238|      0|                                  from:@"queryEndingAtValue:childKey:"
  239|      0|                        priorityMethod:NO];
  240|      0|}
  241|       |
  242|       |- (FIRDatabaseQuery *)queryEndingAtInternal:(id)endValue
  243|       |                                   childKey:(NSString *)childKey
  244|       |                                       from:(NSString *)methodName
  245|      0|                             priorityMethod:(BOOL)priorityMethod {
  246|      0|    [self validateIndexValueType:endValue fromMethod:methodName];
  247|      0|    if (childKey != nil) {
  248|      0|        [FValidation validateFrom:methodName validKey:childKey];
  249|      0|    }
  250|      0|    if ([self.queryParams hasEnd]) {
  251|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  252|      0|                    format:@"Can't call %@ after queryEndingAtValue or "
  253|      0|                           @"queryEqualToValue was previously called",
  254|      0|                           methodName];
  255|      0|    }
  256|      0|    id<FNode> endNode = [FSnapshotUtilities nodeFrom:endValue];
  257|      0|    FQueryParams *params = [self.queryParams endAt:endNode childKey:childKey];
  258|      0|    [self validateQueryEndpointsForParams:params];
  259|      0|    return [[FIRDatabaseQuery alloc]
  260|      0|                initWithRepo:self.repo
  261|      0|                        path:self.path
  262|      0|                      params:params
  263|      0|               orderByCalled:self.orderByCalled
  264|      0|        priorityMethodCalled:priorityMethod || self.priorityMethodCalled];
  265|      0|}
  266|       |
  267|      0|- (FIRDatabaseQuery *)queryEqualToValue:(id)value {
  268|      0|    return [self queryEqualToInternal:value
  269|      0|                             childKey:nil
  270|      0|                                 from:@"queryEqualToValue:"
  271|      0|                       priorityMethod:NO];
  272|      0|}
  273|       |
  274|       |- (FIRDatabaseQuery *)queryEqualToValue:(id)value
  275|      0|                               childKey:(NSString *)childKey {
  276|      0|    if ([self.queryParams.index isEqual:[FKeyIndex keyIndex]]) {
  277|      0|        @throw [[NSException alloc]
  278|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  279|      0|                  reason:@"You must use queryEqualToValue: instead of "
  280|      0|                         @"queryEqualTo:childKey: when using queryOrderedByKey:"
  281|      0|                userInfo:nil];
  282|      0|    }
  283|      0|    return [self queryEqualToInternal:value
  284|      0|                             childKey:childKey
  285|      0|                                 from:@"queryEqualToValue:childKey:"
  286|      0|                       priorityMethod:NO];
  287|      0|}
  288|       |
  289|       |- (FIRDatabaseQuery *)queryEqualToInternal:(id)value
  290|       |                                  childKey:(NSString *)childKey
  291|       |                                      from:(NSString *)methodName
  292|      0|                            priorityMethod:(BOOL)priorityMethod {
  293|      0|    [self validateIndexValueType:value fromMethod:methodName];
  294|      0|    if (childKey != nil) {
  295|      0|        [FValidation validateFrom:methodName validKey:childKey];
  296|      0|    }
  297|      0|    if ([self.queryParams hasEnd] || [self.queryParams hasStart]) {
  298|      0|        [NSException
  299|      0|             raise:INVALID_QUERY_PARAM_ERROR
  300|      0|            format:
  301|      0|                @"Can't call %@ after queryStartingAtValue, queryEndingAtValue "
  302|      0|                @"or queryEqualToValue was previously called",
  303|      0|                methodName];
  304|      0|    }
  305|      0|    id<FNode> node = [FSnapshotUtilities nodeFrom:value];
  306|      0|    FQueryParams *params = [[self.queryParams startAt:node
  307|      0|                                             childKey:childKey] endAt:node
  308|      0|                                                             childKey:childKey];
  309|      0|    [self validateQueryEndpointsForParams:params];
  310|      0|    return [[FIRDatabaseQuery alloc]
  311|      0|                initWithRepo:self.repo
  312|      0|                        path:self.path
  313|      0|                      params:params
  314|      0|               orderByCalled:self.orderByCalled
  315|      0|        priorityMethodCalled:priorityMethod || self.priorityMethodCalled];
  316|      0|}
  317|       |
  318|      0|- (void)validateLimitRange:(NSUInteger)limit {
  319|      0|    // No need to check for negative ranges, since limit is unsigned
  320|      0|    if (limit == 0) {
  321|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  322|      0|                    format:@"Limit can't be zero"];
  323|      0|    }
  324|      0|    if (limit >= 1ul << 31) {
  325|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  326|      0|                    format:@"Limit must be less than 2,147,483,648"];
  327|      0|    }
  328|      0|}
  329|       |
  330|      0|- (FIRDatabaseQuery *)queryLimitedToFirst:(NSUInteger)limit {
  331|      0|    if (self.queryParams.limitSet) {
  332|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  333|      0|                    format:@"Can't call queryLimitedToFirst: if a limit was "
  334|      0|                           @"previously set"];
  335|      0|    }
  336|      0|    [self validateLimitRange:limit];
  337|      0|    FQueryParams *params = [self.queryParams limitToFirst:limit];
  338|      0|    return [[FIRDatabaseQuery alloc] initWithRepo:self.repo
  339|      0|                                             path:self.path
  340|      0|                                           params:params
  341|      0|                                    orderByCalled:self.orderByCalled
  342|      0|                             priorityMethodCalled:self.priorityMethodCalled];
  343|      0|}
  344|       |
  345|      0|- (FIRDatabaseQuery *)queryLimitedToLast:(NSUInteger)limit {
  346|      0|    if (self.queryParams.limitSet) {
  347|      0|        [NSException raise:INVALID_QUERY_PARAM_ERROR
  348|      0|                    format:@"Can't call queryLimitedToLast: if a limit was "
  349|      0|                           @"previously set"];
  350|      0|    }
  351|      0|    [self validateLimitRange:limit];
  352|      0|    FQueryParams *params = [self.queryParams limitToLast:limit];
  353|      0|    return [[FIRDatabaseQuery alloc] initWithRepo:self.repo
  354|      0|                                             path:self.path
  355|      0|                                           params:params
  356|      0|                                    orderByCalled:self.orderByCalled
  357|      0|                             priorityMethodCalled:self.priorityMethodCalled];
  358|      0|}
  359|       |
  360|      0|- (FIRDatabaseQuery *)queryOrderedByChild:(NSString *)indexPathString {
  361|      0|    if ([indexPathString isEqualToString:@"$key"] ||
  362|      0|        [indexPathString isEqualToString:@".key"]) {
  363|      0|        @throw [[NSException alloc]
  364|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  365|      0|                  reason:[NSString stringWithFormat:
  366|      0|                                       @"(queryOrderedByChild:) %@ is invalid. "
  367|      0|                                       @" Use queryOrderedByKey: instead.",
  368|      0|                                       indexPathString]
  369|      0|                userInfo:nil];
  370|      0|    } else if ([indexPathString isEqualToString:@"$priority"] ||
  371|      0|               [indexPathString isEqualToString:@".priority"]) {
  372|      0|        @throw [[NSException alloc]
  373|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  374|      0|                  reason:[NSString stringWithFormat:
  375|      0|                                       @"(queryOrderedByChild:) %@ is invalid. "
  376|      0|                                       @" Use queryOrderedByPriority: instead.",
  377|      0|                                       indexPathString]
  378|      0|                userInfo:nil];
  379|      0|    } else if ([indexPathString isEqualToString:@"$value"] ||
  380|      0|               [indexPathString isEqualToString:@".value"]) {
  381|      0|        @throw [[NSException alloc]
  382|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  383|      0|                  reason:[NSString stringWithFormat:
  384|      0|                                       @"(queryOrderedByChild:) %@ is invalid. "
  385|      0|                                       @" Use queryOrderedByValue: instead.",
  386|      0|                                       indexPathString]
  387|      0|                userInfo:nil];
  388|      0|    }
  389|      0|    [self validateNoPreviousOrderByCalled];
  390|      0|
  391|      0|    [FValidation validateFrom:@"queryOrderedByChild:"
  392|      0|              validPathString:indexPathString];
  393|      0|    FPath *indexPath = [FPath pathWithString:indexPathString];
  394|      0|    if (indexPath.isEmpty) {
  395|      0|        @throw [[NSException alloc]
  396|      0|            initWithName:INVALID_QUERY_PARAM_ERROR
  397|      0|                  reason:[NSString
  398|      0|                             stringWithFormat:@"(queryOrderedByChild:) with an "
  399|      0|                                              @"empty path is invalid.  Use "
  400|      0|                                              @"queryOrderedByValue: instead."]
  401|      0|                userInfo:nil];
  402|      0|    }
  403|      0|    id<FIndex> index = [[FPathIndex alloc] initWithPath:indexPath];
  404|      0|
  405|      0|    FQueryParams *params = [self.queryParams orderBy:index];
  406|      0|    [self validateQueryEndpointsForParams:params];
  407|      0|    return [[FIRDatabaseQuery alloc] initWithRepo:self.repo
  408|      0|                                             path:self.path
  409|      0|                                           params:params
  410|      0|                                    orderByCalled:YES
  411|      0|                             priorityMethodCalled:self.priorityMethodCalled];
  412|      0|}
  413|       |
  414|      0|- (FIRDatabaseQuery *)queryOrderedByKey {
  415|      0|    [self validateNoPreviousOrderByCalled];
  416|      0|    FQueryParams *params = [self.queryParams orderBy:[FKeyIndex keyIndex]];
  417|      0|    [self validateQueryEndpointsForParams:params];
  418|      0|    return [[FIRDatabaseQuery alloc] initWithRepo:self.repo
  419|      0|                                             path:self.path
  420|      0|                                           params:params
  421|      0|                                    orderByCalled:YES
  422|      0|                             priorityMethodCalled:self.priorityMethodCalled];
  423|      0|}
  424|       |
  425|      0|- (FIRDatabaseQuery *)queryOrderedByValue {
  426|      0|    [self validateNoPreviousOrderByCalled];
  427|      0|    FQueryParams *params = [self.queryParams orderBy:[FValueIndex valueIndex]];
  428|      0|    return [[FIRDatabaseQuery alloc] initWithRepo:self.repo
  429|      0|                                             path:self.path
  430|      0|                                           params:params
  431|      0|                                    orderByCalled:YES
  432|      0|                             priorityMethodCalled:self.priorityMethodCalled];
  433|      0|}
  434|       |
  435|      0|- (FIRDatabaseQuery *)queryOrderedByPriority {
  436|      0|    [self validateNoPreviousOrderByCalled];
  437|      0|    FQueryParams *params =
  438|      0|        [self.queryParams orderBy:[FPriorityIndex priorityIndex]];
  439|      0|    return [[FIRDatabaseQuery alloc] initWithRepo:self.repo
  440|      0|                                             path:self.path
  441|      0|                                           params:params
  442|      0|                                    orderByCalled:YES
  443|      0|                             priorityMethodCalled:self.priorityMethodCalled];
  444|      0|}
  445|       |
  446|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  447|      0|                            withBlock:(void (^)(FIRDataSnapshot *))block {
  448|      0|    [FValidation validateFrom:@"observeEventType:withBlock:"
  449|      0|               knownEventType:eventType];
  450|      0|    return [self observeEventType:eventType
  451|      0|                        withBlock:block
  452|      0|                  withCancelBlock:nil];
  453|      0|}
  454|       |
  455|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  456|      0|       andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block {
  457|      0|    [FValidation
  458|      0|          validateFrom:@"observeEventType:andPreviousSiblingKeyWithBlock:"
  459|      0|        knownEventType:eventType];
  460|      0|    return [self observeEventType:eventType
  461|      0|        andPreviousSiblingKeyWithBlock:block
  462|      0|                       withCancelBlock:nil];
  463|      0|}
  464|       |
  465|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  466|       |                            withBlock:(fbt_void_datasnapshot)block
  467|      0|                      withCancelBlock:(fbt_void_nserror)cancelBlock {
  468|      0|    [FValidation validateFrom:@"observeEventType:withBlock:withCancelBlock:"
  469|      0|               knownEventType:eventType];
  470|      0|
  471|      0|    if (eventType == FIRDataEventTypeValue) {
  472|      0|        // Handle FIRDataEventTypeValue specially because they shouldn't have
  473|      0|        // prevName callbacks
  474|      0|        NSUInteger handle = [[FUtilities LUIDGenerator] integerValue];
  475|      0|        [self observeValueEventWithHandle:handle
  476|      0|                                withBlock:block
  477|      0|                           cancelCallback:cancelBlock];
  478|      0|        return handle;
  479|      0|    } else {
  480|      0|        // Wrap up the userCallback so we can treat everything as a callback
  481|      0|        // that has a prevName
  482|      0|        fbt_void_datasnapshot userCallback = [block copy];
  483|      0|        return [self observeEventType:eventType
  484|      0|            andPreviousSiblingKeyWithBlock:^(FIRDataSnapshot *snapshot,
  485|      0|                                             NSString *prevName) {
  486|      0|              if (userCallback != nil) {
  487|      0|                  userCallback(snapshot);
  488|      0|              }
  489|      0|            }
  490|      0|                           withCancelBlock:cancelBlock];
  491|      0|    }
  492|      0|}
  493|       |
  494|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  495|       |       andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block
  496|      0|                      withCancelBlock:(fbt_void_nserror)cancelBlock {
  497|      0|    [FValidation validateFrom:@"observeEventType:"
  498|      0|                              @"andPreviousSiblingKeyWithBlock:withCancelBlock:"
  499|      0|               knownEventType:eventType];
  500|      0|
  501|      0|    if (eventType == FIRDataEventTypeValue) {
  502|      0|        // TODO: This gets hit by observeSingleEventOfType.  Need to fix.
  503|      0|        /*
  504|      0|        @throw [[NSException alloc] initWithName:@"InvalidEventTypeForObserver"
  505|      0|                                          reason:@"(observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:)
  506|      0|        Cannot use
  507|      0|        observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock: with
  508|      0|        FIRDataEventTypeValue. Use observeEventType:withBlock:withCancelBlock:
  509|      0|        instead." userInfo:nil];
  510|      0|        */
  511|      0|    }
  512|      0|
  513|      0|    NSUInteger handle = [[FUtilities LUIDGenerator] integerValue];
  514|      0|    NSDictionary *callbacks =
  515|      0|        @{[NSNumber numberWithInteger:eventType] : [block copy]};
  516|      0|    [self observeChildEventWithHandle:handle
  517|      0|                        withCallbacks:callbacks
  518|      0|                       cancelCallback:cancelBlock];
  519|      0|
  520|      0|    return handle;
  521|      0|}
  522|       |
  523|       |// If we want to distinguish between value event listeners and child event
  524|       |// listeners, like in the Java client, we can consider exporting this. If we do,
  525|       |// add argument validation. Otherwise, arguments are validated in the
  526|       |// public-facing portions of the API. Also, move the FIRDatabaseHandle logic.
  527|       |- (void)observeValueEventWithHandle:(FIRDatabaseHandle)handle
  528|       |                          withBlock:(fbt_void_datasnapshot)block
  529|      0|                     cancelCallback:(fbt_void_nserror)cancelBlock {
  530|      0|    // Note that we don't need to copy the callbacks here, FEventRegistration
  531|      0|    // callback properties set to copy
  532|      0|    FValueEventRegistration *registration =
  533|      0|        [[FValueEventRegistration alloc] initWithRepo:self.repo
  534|      0|                                               handle:handle
  535|      0|                                             callback:block
  536|      0|                                       cancelCallback:cancelBlock];
  537|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  538|      0|      [self.repo addEventRegistration:registration forQuery:self.querySpec];
  539|      0|    });
  540|      0|}
  541|       |
  542|       |// Note: as with the above method, we may wish to expose this at some point.
  543|       |- (void)observeChildEventWithHandle:(FIRDatabaseHandle)handle
  544|       |                      withCallbacks:(NSDictionary *)callbacks
  545|      0|                     cancelCallback:(fbt_void_nserror)cancelBlock {
  546|      0|    // Note that we don't need to copy the callbacks here, FEventRegistration
  547|      0|    // callback properties set to copy
  548|      0|    FChildEventRegistration *registration =
  549|      0|        [[FChildEventRegistration alloc] initWithRepo:self.repo
  550|      0|                                               handle:handle
  551|      0|                                            callbacks:callbacks
  552|      0|                                       cancelCallback:cancelBlock];
  553|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  554|      0|      [self.repo addEventRegistration:registration forQuery:self.querySpec];
  555|      0|    });
  556|      0|}
  557|       |
  558|      0|- (void)removeObserverWithHandle:(FIRDatabaseHandle)handle {
  559|      0|    FValueEventRegistration *event =
  560|      0|        [[FValueEventRegistration alloc] initWithRepo:self.repo
  561|      0|                                               handle:handle
  562|      0|                                             callback:nil
  563|      0|                                       cancelCallback:nil];
  564|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  565|      0|      [self.repo removeEventRegistration:event forQuery:self.querySpec];
  566|      0|    });
  567|      0|}
  568|       |
  569|      0|- (void)removeAllObservers {
  570|      0|    [self removeObserverWithHandle:NSNotFound];
  571|      0|}
  572|       |
  573|      0|- (void)keepSynced:(BOOL)keepSynced {
  574|      0|    if ([self.path.getFront isEqualToString:kDotInfoPrefix]) {
  575|      0|        [NSException raise:NSInvalidArgumentException
  576|      0|                    format:@"Can't keep query on .info tree synced (this "
  577|      0|                           @"already is the case)."];
  578|      0|    }
  579|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  580|      0|      [self.repo keepQuery:self.querySpec synced:keepSynced];
  581|      0|    });
  582|      0|}
  583|       |
  584|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  585|      0|                       withBlock:(fbt_void_datasnapshot)block {
  586|      0|
  587|      0|    [self observeSingleEventOfType:eventType
  588|      0|                         withBlock:block
  589|      0|                   withCancelBlock:nil];
  590|      0|}
  591|       |
  592|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  593|      0|    andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block {
  594|      0|
  595|      0|    [self observeSingleEventOfType:eventType
  596|      0|        andPreviousSiblingKeyWithBlock:block
  597|      0|                       withCancelBlock:nil];
  598|      0|}
  599|       |
  600|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  601|       |                       withBlock:(fbt_void_datasnapshot)block
  602|      0|                 withCancelBlock:(fbt_void_nserror)cancelBlock {
  603|      0|
  604|      0|    // XXX: user reported memory leak in method
  605|      0|
  606|      0|    // "When you copy a block, any references to other blocks from within that
  607|      0|    // block are copied if necessary—an entire tree may be copied (from the
  608|      0|    // top). If you have block variables and you reference a block from within
  609|      0|    // the block, that block will be copied."
  610|      0|    // http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1
  611|      0|    // So... we don't need to do this since inside the on: we copy this block
  612|      0|    // off the stack to the heap.
  613|      0|    // __block fbt_void_datasnapshot userCallback = [callback copy];
  614|      0|
  615|      0|    [self observeSingleEventOfType:eventType
  616|      0|        andPreviousSiblingKeyWithBlock:^(FIRDataSnapshot *snapshot,
  617|      0|                                         NSString *prevName) {
  618|      0|          if (block != nil) {
  619|      0|              block(snapshot);
  620|      0|          }
  621|      0|        }
  622|      0|                       withCancelBlock:cancelBlock];
  623|      0|}
  624|       |
  625|       |/**
  626|       | * Attaches a listener, waits for the first event, and then removes the listener
  627|       | */
  628|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  629|       |    andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block
  630|      0|                   withCancelBlock:(fbt_void_nserror)cancelBlock {
  631|      0|
  632|      0|    // XXX: user reported memory leak in method
  633|      0|
  634|      0|    // "When you copy a block, any references to other blocks from within that
  635|      0|    // block are copied if necessary—an entire tree may be copied (from the
  636|      0|    // top). If you have block variables and you reference a block from within
  637|      0|    // the block, that block will be copied."
  638|      0|    // http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1
  639|      0|    // So... we don't need to do this since inside the on: we copy this block
  640|      0|    // off the stack to the heap.
  641|      0|    // __block fbt_void_datasnapshot userCallback = [callback copy];
  642|      0|
  643|      0|    __block FIRDatabaseHandle handle;
  644|      0|    __block BOOL firstCall = YES;
  645|      0|
  646|      0|    fbt_void_datasnapshot_nsstring callback = [block copy];
  647|      0|    fbt_void_datasnapshot_nsstring wrappedCallback =
  648|      0|        ^(FIRDataSnapshot *snap, NSString *prevName) {
  649|      0|          if (firstCall) {
  650|      0|              firstCall = NO;
  651|      0|              [self removeObserverWithHandle:handle];
  652|      0|              callback(snap, prevName);
  653|      0|          }
  654|      0|        };
  655|      0|
  656|      0|    fbt_void_nserror cancelCallback = [cancelBlock copy];
  657|      0|    handle = [self observeEventType:eventType
  658|      0|        andPreviousSiblingKeyWithBlock:wrappedCallback
  659|      0|                       withCancelBlock:^(NSError *error) {
  660|      0|                         [self removeObserverWithHandle:handle];
  661|      0|
  662|      0|                         if (cancelCallback) {
  663|      0|                             cancelCallback(error);
  664|      0|                         }
  665|      0|                       }];
  666|      0|}
  667|       |
  668|      0|- (NSString *)description {
  669|      0|    return [NSString
  670|      0|        stringWithFormat:@"(%@ %@)", self.path, self.queryParams.description];
  671|      0|}
  672|       |
  673|      0|- (FIRDatabaseReference *)ref {
  674|      0|    return [[FIRDatabaseReference alloc] initWithRepo:self.repo path:self.path];
  675|      0|}
  676|       |
  677|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRMutableData.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRMutableData.h"
   18|       |#import "FChildrenNode.h"
   19|       |#import "FIRMutableData_Private.h"
   20|       |#import "FIndexedNode.h"
   21|       |#import "FNamedNode.h"
   22|       |#import "FSnapshotHolder.h"
   23|       |#import "FSnapshotUtilities.h"
   24|       |#import "FTransformedEnumerator.h"
   25|       |
   26|       |@interface FIRMutableData ()
   27|       |
   28|       |- (id)initWithPrefixPath:(FPath *)path
   29|       |       andSnapshotHolder:(FSnapshotHolder *)snapshotHolder;
   30|       |
   31|       |@property(strong, nonatomic) FSnapshotHolder *data;
   32|       |@property(strong, nonatomic) FPath *prefixPath;
   33|       |
   34|       |@end
   35|       |
   36|       |@implementation FIRMutableData
   37|       |
   38|       |@synthesize data;
   39|       |@synthesize prefixPath;
   40|       |
   41|      0|- (id)initWithNode:(id<FNode>)node {
   42|      0|    FSnapshotHolder *holder = [[FSnapshotHolder alloc] init];
   43|      0|    FPath *path = [FPath empty];
   44|      0|    [holder updateSnapshot:path withNewSnapshot:node];
   45|      0|    return [self initWithPrefixPath:path andSnapshotHolder:holder];
   46|      0|}
   47|       |
   48|       |- (id)initWithPrefixPath:(FPath *)path
   49|      0|       andSnapshotHolder:(FSnapshotHolder *)snapshotHolder {
   50|      0|    self = [super init];
   51|      0|    if (self) {
   52|      0|        self.prefixPath = path;
   53|      0|        self.data = snapshotHolder;
   54|      0|    }
   55|      0|    return self;
   56|      0|}
   57|       |
   58|      0|- (FIRMutableData *)childDataByAppendingPath:(NSString *)path {
   59|      0|    FPath *wholePath = [self.prefixPath childFromString:path];
   60|      0|    return [[FIRMutableData alloc] initWithPrefixPath:wholePath
   61|      0|                                    andSnapshotHolder:self.data];
   62|      0|}
   63|       |
   64|      0|- (FIRMutableData *)parent {
   65|      0|    if ([self.prefixPath isEmpty]) {
   66|      0|        return nil;
   67|      0|    } else {
   68|      0|        FPath *path = [self.prefixPath parent];
   69|      0|        return [[FIRMutableData alloc] initWithPrefixPath:path
   70|      0|                                        andSnapshotHolder:self.data];
   71|      0|    }
   72|      0|}
   73|       |
   74|      0|- (void)setValue:(id)aValue {
   75|      0|    id<FNode> node = [FSnapshotUtilities nodeFrom:aValue
   76|      0|                               withValidationFrom:@"setValue:"];
   77|      0|    [self.data updateSnapshot:self.prefixPath withNewSnapshot:node];
   78|      0|}
   79|       |
   80|      0|- (void)setPriority:(id)aPriority {
   81|      0|    id<FNode> node = [self.data getNode:self.prefixPath];
   82|      0|    id<FNode> pri = [FSnapshotUtilities nodeFrom:aPriority];
   83|      0|    node = [node updatePriority:pri];
   84|      0|    [self.data updateSnapshot:self.prefixPath withNewSnapshot:node];
   85|      0|}
   86|       |
   87|      0|- (id)value {
   88|      0|    return [[self.data getNode:self.prefixPath] val];
   89|      0|}
   90|       |
   91|      0|- (id)priority {
   92|      0|    return [[[self.data getNode:self.prefixPath] getPriority] val];
   93|      0|}
   94|       |
   95|      0|- (BOOL)hasChildren {
   96|      0|    id<FNode> node = [self.data getNode:self.prefixPath];
   97|      0|    return ![node isLeafNode] && ![(FChildrenNode *)node isEmpty];
   98|      0|}
   99|       |
  100|      0|- (BOOL)hasChildAtPath:(NSString *)path {
  101|      0|    id<FNode> node = [self.data getNode:self.prefixPath];
  102|      0|    FPath *childPath = [[FPath alloc] initWith:path];
  103|      0|    return ![[node getChild:childPath] isEmpty];
  104|      0|}
  105|       |
  106|      0|- (NSUInteger)childrenCount {
  107|      0|    return [[self.data getNode:self.prefixPath] numChildren];
  108|      0|}
  109|       |
  110|      0|- (NSString *)key {
  111|      0|    return [self.prefixPath getBack];
  112|      0|}
  113|       |
  114|      0|- (id<FNode>)nodeValue {
  115|      0|    return [self.data getNode:self.prefixPath];
  116|      0|}
  117|       |
  118|      0|- (NSEnumerator<FIRMutableData *> *)children {
  119|      0|    FIndexedNode *indexedNode =
  120|      0|        [FIndexedNode indexedNodeWithNode:self.nodeValue];
  121|      0|    return [[FTransformedEnumerator alloc]
  122|      0|        initWithEnumerator:[indexedNode childEnumerator]
  123|      0|              andTransform:^id(FNamedNode *node) {
  124|      0|                FPath *childPath = [self.prefixPath childFromString:node.name];
  125|      0|                FIRMutableData *childData =
  126|      0|                    [[FIRMutableData alloc] initWithPrefixPath:childPath
  127|      0|                                             andSnapshotHolder:self.data];
  128|      0|                return childData;
  129|      0|              }];
  130|      0|}
  131|       |
  132|      0|- (BOOL)isEqualToData:(FIRMutableData *)other {
  133|      0|    return self.data == other.data &&
  134|      0|           [[self.prefixPath description]
  135|      0|               isEqualToString:[other.prefixPath description]];
  136|      0|}
  137|       |
  138|      0|- (NSString *)description {
  139|      0|    if (self.key == nil) {
  140|      0|        return [NSString
  141|      0|            stringWithFormat:@"FIRMutableData (top-most transaction) %@ %@",
  142|      0|                             self.key, self.value];
  143|      0|    } else {
  144|      0|        return [NSString
  145|      0|            stringWithFormat:@"FIRMutableData (%@) %@", self.key, self.value];
  146|      0|    }
  147|      0|}
  148|       |
  149|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRServerValue.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRServerValue.h"
   18|       |#import "FIRDatabaseReference.h"
   19|       |
   20|       |@implementation FIRServerValue
   21|       |
   22|      0|+ (NSDictionary *)timestamp {
   23|      0|    static NSDictionary *timestamp = nil;
   24|      0|    if (timestamp == nil) {
   25|      0|        timestamp = @{@".sv" : @"timestamp"};
   26|      0|    }
   27|      0|    return timestamp;
   28|      0|}
   29|       |
   30|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Api/FIRTransactionResult.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRTransactionResult.h"
   18|       |#import "FIRTransactionResult_Private.h"
   19|       |
   20|       |@implementation FIRTransactionResult
   21|       |
   22|       |@synthesize update;
   23|       |@synthesize isSuccess;
   24|       |
   25|      0|+ (FIRTransactionResult *)successWithValue:(FIRMutableData *)value {
   26|      0|    FIRTransactionResult *result = [[FIRTransactionResult alloc] init];
   27|      0|    result.isSuccess = YES;
   28|      0|    result.update = value;
   29|      0|    return result;
   30|      0|}
   31|       |
   32|      0|+ (FIRTransactionResult *)abort {
   33|      0|    FIRTransactionResult *result = [[FIRTransactionResult alloc] init];
   34|      0|    result.isSuccess = NO;
   35|      0|    result.update = nil;
   36|      0|    return result;
   37|      0|}
   38|       |
   39|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FCompoundHash.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FCompoundHash.h"
   18|       |#import "FChildrenNode.h"
   19|       |#import "FLeafNode.h"
   20|       |#import "FSnapshotUtilities.h"
   21|       |#import "FStringUtilities.h"
   22|       |
   23|       |@interface FCompoundHashBuilder ()
   24|       |
   25|       |@property(nonatomic, strong) FCompoundHashSplitStrategy splitStrategy;
   26|       |
   27|       |@property(nonatomic, strong) NSMutableArray *currentPaths;
   28|       |@property(nonatomic, strong) NSMutableArray *currentHashes;
   29|       |
   30|       |@end
   31|       |
   32|       |@implementation FCompoundHashBuilder {
   33|       |
   34|       |    // NOTE: We use the existence of this to know if we've started building a
   35|       |    // range (i.e. encountered a leaf node).
   36|       |    NSMutableString *optHashValueBuilder;
   37|       |
   38|       |    // The current path as a stack. This is used in combination with
   39|       |    // currentPathDepth to simultaneously store the last leaf node path. The
   40|       |    // depth is changed when descending and ascending, at the same time the
   41|       |    // current key is set for the current depth. Because the keys are left
   42|       |    // unchanged for ascending the path will also contain the path of the last
   43|       |    // visited leaf node (using lastLeafDepth elements)
   44|       |    NSMutableArray *currentPath;
   45|       |    NSInteger lastLeafDepth;
   46|       |    NSInteger currentPathDepth;
   47|       |
   48|       |    BOOL needsComma;
   49|       |}
   50|       |
   51|      0|- (instancetype)initWithSplitStrategy:(FCompoundHashSplitStrategy)strategy {
   52|      0|    self = [super init];
   53|      0|    if (self != nil) {
   54|      0|        self->_splitStrategy = strategy;
   55|      0|        self->optHashValueBuilder = nil;
   56|      0|        self->currentPath = [NSMutableArray array];
   57|      0|        self->lastLeafDepth = -1;
   58|      0|        self->currentPathDepth = 0;
   59|      0|        self->needsComma = YES;
   60|      0|        self->_currentPaths = [NSMutableArray array];
   61|      0|        self->_currentHashes = [NSMutableArray array];
   62|      0|    }
   63|      0|    return self;
   64|      0|}
   65|       |
   66|      0|- (BOOL)isBuildingRange {
   67|      0|    return self->optHashValueBuilder != nil;
   68|      0|}
   69|       |
   70|      0|- (NSUInteger)currentHashLength {
   71|      0|    return self->optHashValueBuilder.length;
   72|      0|}
   73|       |
   74|      0|- (FPath *)currentPath {
   75|      0|    return [self currentPathWithDepth:self->currentPathDepth];
   76|      0|}
   77|       |
   78|      0|- (FPath *)currentPathWithDepth:(NSInteger)depth {
   79|      0|    NSArray *pieces =
   80|      0|        [self->currentPath subarrayWithRange:NSMakeRange(0, depth)];
   81|      0|    return [[FPath alloc] initWithPieces:pieces andPieceNum:0];
   82|      0|}
   83|       |
   84|       |- (void)enumerateCurrentPathToDepth:(NSInteger)depth
   85|      0|                          withBlock:(void (^)(NSString *key))block {
   86|      0|    for (NSInteger i = 0; i < depth; i++) {
   87|      0|        block(self->currentPath[i]);
   88|      0|    }
   89|      0|}
   90|       |
   91|      0|- (void)appendKey:(NSString *)key toString:(NSMutableString *)string {
   92|      0|    [FSnapshotUtilities appendHashV2RepresentationForString:key
   93|      0|                                                   toString:string];
   94|      0|}
   95|       |
   96|      0|- (void)ensureRange {
   97|      0|    if (![self isBuildingRange]) {
   98|      0|        optHashValueBuilder = [NSMutableString string];
   99|      0|        [optHashValueBuilder appendString:@"("];
  100|      0|        [self
  101|      0|            enumerateCurrentPathToDepth:self->currentPathDepth
  102|      0|                              withBlock:^(NSString *key) {
  103|      0|                                [self appendKey:key
  104|      0|                                       toString:self->optHashValueBuilder];
  105|      0|                                [self->optHashValueBuilder appendString:@":("];
  106|      0|                              }];
  107|      0|        self->needsComma = NO;
  108|      0|    }
  109|      0|}
  110|       |
  111|      0|- (void)processLeaf:(FLeafNode *)leafNode {
  112|      0|    [self ensureRange];
  113|      0|
  114|      0|    self->lastLeafDepth = self->currentPathDepth;
  115|      0|    [FSnapshotUtilities
  116|      0|        appendHashRepresentationForLeafNode:leafNode
  117|      0|                                   toString:self->optHashValueBuilder
  118|      0|                                hashVersion:FDataHashVersionV2];
  119|      0|    self->needsComma = YES;
  120|      0|    if (self.splitStrategy(self)) {
  121|      0|        [self endRange];
  122|      0|    }
  123|      0|}
  124|       |
  125|      0|- (void)startChild:(NSString *)key {
  126|      0|    [self ensureRange];
  127|      0|
  128|      0|    if (self->needsComma) {
  129|      0|        [self->optHashValueBuilder appendString:@","];
  130|      0|    }
  131|      0|    [self appendKey:key toString:self->optHashValueBuilder];
  132|      0|    [self->optHashValueBuilder appendString:@":("];
  133|      0|    if (self->currentPathDepth == currentPath.count) {
  134|      0|        [self->currentPath addObject:key];
  135|      0|    } else {
  136|      0|        self->currentPath[self->currentPathDepth] = key;
  137|      0|    }
  138|      0|    self->currentPathDepth++;
  139|      0|    self->needsComma = NO;
  140|      0|}
  141|       |
  142|      0|- (void)endChild {
  143|      0|    self->currentPathDepth--;
  144|      0|    if ([self isBuildingRange]) {
  145|      0|        [self->optHashValueBuilder appendString:@")"];
  146|      0|    }
  147|      0|    self->needsComma = YES;
  148|      0|}
  149|       |
  150|      0|- (void)finishHashing {
  151|      0|    NSAssert(self->currentPathDepth == 0,
  152|      0|             @"Can't finish hashing in the middle of processing a child");
  153|      0|    if ([self isBuildingRange]) {
  154|      0|        [self endRange];
  155|      0|    }
  156|      0|
  157|      0|    // Always close with the empty hash for the remaining range to allow simple
  158|      0|    // appending
  159|      0|    [self.currentHashes addObject:@""];
  160|      0|}
  161|       |
  162|      0|- (void)endRange {
  163|      0|    NSAssert([self isBuildingRange],
  164|      0|             @"Can't end range without starting a range!");
  165|      0|    // Add closing parenthesis for current depth
  166|      0|    for (NSUInteger i = 0; i < currentPathDepth; i++) {
  167|      0|        [self->optHashValueBuilder appendString:@")"];
  168|      0|    }
  169|      0|    [self->optHashValueBuilder appendString:@")"];
  170|      0|
  171|      0|    FPath *lastLeafPath = [self currentPathWithDepth:self->lastLeafDepth];
  172|      0|    NSString *hash =
  173|      0|        [FStringUtilities base64EncodedSha1:self->optHashValueBuilder];
  174|      0|    [self.currentHashes addObject:hash];
  175|      0|    [self.currentPaths addObject:lastLeafPath];
  176|      0|
  177|      0|    self->optHashValueBuilder = nil;
  178|      0|}
  179|       |
  180|       |@end
  181|       |
  182|       |@interface FCompoundHash ()
  183|       |
  184|       |@property(nonatomic, strong, readwrite) NSArray *posts;
  185|       |@property(nonatomic, strong, readwrite) NSArray *hashes;
  186|       |
  187|       |@end
  188|       |
  189|       |@implementation FCompoundHash
  190|       |
  191|      0|- (id)initWithPosts:(NSArray *)posts hashes:(NSArray *)hashes {
  192|      0|    self = [super init];
  193|      0|    if (self != nil) {
  194|      0|        if (posts.count != hashes.count - 1) {
  195|      0|            [NSException raise:NSInvalidArgumentException
  196|      0|                        format:@"Number of posts need to be n-1 for n hashes "
  197|      0|                               @"in FCompoundHash"];
  198|      0|        }
  199|      0|        self.posts = posts;
  200|      0|        self.hashes = hashes;
  201|      0|    }
  202|      0|    return self;
  203|      0|}
  204|       |
  205|      0|+ (FCompoundHashSplitStrategy)simpleSizeSplitStrategyForNode:(id<FNode>)node {
  206|      0|    NSUInteger estimatedSize =
  207|      0|        [FSnapshotUtilities estimateSerializedNodeSize:node];
  208|      0|
  209|      0|    // Splits for
  210|      0|    // 1k -> 512 (2 parts)
  211|      0|    // 5k -> 715 (7 parts)
  212|      0|    // 100k -> 3.2k (32 parts)
  213|      0|    // 500k -> 7k (71 parts)
  214|      0|    // 5M -> 23k (228 parts)
  215|      0|    NSUInteger splitThreshold = MAX(512, (NSUInteger)sqrt(estimatedSize * 100));
  216|      0|
  217|      0|    return ^BOOL(FCompoundHashBuilder *builder) {
  218|      0|      // Never split on priorities
  219|      0|      return [builder currentHashLength] > splitThreshold &&
  220|      0|             ![[[builder currentPath] getBack] isEqualToString:@".priority"];
  221|      0|    };
  222|      0|}
  223|       |
  224|      0|+ (FCompoundHash *)fromNode:(id<FNode>)node {
  225|      0|    return [FCompoundHash
  226|      0|             fromNode:node
  227|      0|        splitStrategy:[FCompoundHash simpleSizeSplitStrategyForNode:node]];
  228|      0|}
  229|       |
  230|       |+ (FCompoundHash *)fromNode:(id<FNode>)node
  231|      0|              splitStrategy:(FCompoundHashSplitStrategy)strategy {
  232|      0|    if ([node isEmpty]) {
  233|      0|        return [[FCompoundHash alloc] initWithPosts:@[] hashes:@[ @"" ]];
  234|      0|    } else {
  235|      0|        FCompoundHashBuilder *builder =
  236|      0|            [[FCompoundHashBuilder alloc] initWithSplitStrategy:strategy];
  237|      0|        [FCompoundHash processNode:node builder:builder];
  238|      0|        [builder finishHashing];
  239|      0|        return [[FCompoundHash alloc] initWithPosts:builder.currentPaths
  240|      0|                                             hashes:builder.currentHashes];
  241|      0|    }
  242|      0|}
  243|       |
  244|      0|+ (void)processNode:(id<FNode>)node builder:(FCompoundHashBuilder *)builder {
  245|      0|    if ([node isLeafNode]) {
  246|      0|        [builder processLeaf:node];
  247|      0|    } else {
  248|      0|        NSAssert(![node isEmpty], @"Can't calculate hash on empty node!");
  249|      0|        FChildrenNode *childrenNode = (FChildrenNode *)node;
  250|      0|        [childrenNode enumerateChildrenAndPriorityUsingBlock:^(
  251|      0|                          NSString *key, id<FNode> node, BOOL *stop) {
  252|      0|          [builder startChild:key];
  253|      0|          [self processNode:node builder:builder];
  254|      0|          [builder endChild];
  255|      0|        }];
  256|      0|    }
  257|      0|}
  258|       |
  259|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FPersistentConnection.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import <Foundation/Foundation.h>
   17|       |
   18|       |#import "FAtomicNumber.h"
   19|       |#import "FAuthTokenProvider.h"
   20|       |#import "FCompoundHash.h"
   21|       |#import "FConstants.h"
   22|       |#import "FIRDatabaseConfig.h"
   23|       |#import "FIRDatabaseConfig_Private.h"
   24|       |#import "FIRDatabaseReference.h"
   25|       |#import "FIRRetryHelper.h"
   26|       |#import "FIndex.h"
   27|       |#import "FPersistentConnection.h"
   28|       |#import "FQueryParams.h"
   29|       |#import "FQuerySpec.h"
   30|       |#import "FRangeMerge.h"
   31|       |#import "FSnapshotUtilities.h"
   32|       |#import "FSyncTree.h"
   33|       |#import "FTupleCallbackStatus.h"
   34|       |#import "FTupleOnDisconnect.h"
   35|       |#import "FUtilities.h"
   36|       |#import <FirebaseCore/FIRLogger.h>
   37|       |#import <SystemConfiguration/SystemConfiguration.h>
   38|       |#import <dlfcn.h>
   39|       |#import <netinet/in.h>
   40|       |
   41|       |@interface FOutstandingQuery : NSObject
   42|       |
   43|       |@property(nonatomic, strong) FQuerySpec *query;
   44|       |@property(nonatomic, strong) NSNumber *tagId;
   45|       |@property(nonatomic, strong) id<FSyncTreeHash> syncTreeHash;
   46|       |@property(nonatomic, copy) fbt_void_nsstring onComplete;
   47|       |
   48|       |@end
   49|       |
   50|       |@implementation FOutstandingQuery
   51|       |
   52|       |@end
   53|       |
   54|       |@interface FOutstandingPut : NSObject
   55|       |
   56|       |@property(nonatomic, strong) NSString *action;
   57|       |@property(nonatomic, strong) NSDictionary *request;
   58|       |@property(nonatomic, copy) fbt_void_nsstring_nsstring onCompleteBlock;
   59|       |@property(nonatomic) BOOL sent;
   60|       |
   61|       |@end
   62|       |
   63|       |@implementation FOutstandingPut
   64|       |
   65|       |@end
   66|       |
   67|       |typedef enum {
   68|       |    ConnectionStateDisconnected,
   69|       |    ConnectionStateGettingToken,
   70|       |    ConnectionStateConnecting,
   71|       |    ConnectionStateAuthenticating,
   72|       |    ConnectionStateConnected
   73|       |} ConnectionState;
   74|       |
   75|       |@interface FPersistentConnection () {
   76|       |    ConnectionState connectionState;
   77|       |    BOOL firstConnection;
   78|       |    NSTimeInterval reconnectDelay;
   79|       |    NSTimeInterval lastConnectionAttemptTime;
   80|       |    NSTimeInterval lastConnectionEstablishedTime;
   81|       |    SCNetworkReachabilityRef reachability;
   82|       |}
   83|       |
   84|       |- (int)getNextRequestNumber;
   85|       |- (void)onDataPushWithAction:(NSString *)action andBody:(NSDictionary *)body;
   86|       |- (void)handleTimestamp:(NSNumber *)timestamp;
   87|       |- (void)sendOnDisconnectAction:(NSString *)action
   88|       |                       forPath:(NSString *)pathString
   89|       |                      withData:(id)data
   90|       |                   andCallback:(fbt_void_nsstring_nsstring)callback;
   91|       |
   92|       |@property(nonatomic, strong) FConnection *realtime;
   93|       |@property(nonatomic, strong) NSMutableDictionary *listens;
   94|       |@property(nonatomic, strong) NSMutableDictionary *outstandingPuts;
   95|       |@property(nonatomic, strong) NSMutableArray *onDisconnectQueue;
   96|       |@property(nonatomic, strong) FRepoInfo *repoInfo;
   97|       |@property(nonatomic, strong) FAtomicNumber *putCounter;
   98|       |@property(nonatomic, strong) FAtomicNumber *requestNumber;
   99|       |@property(nonatomic, strong) NSMutableDictionary *requestCBHash;
  100|       |@property(nonatomic, strong) FIRDatabaseConfig *config;
  101|       |@property(nonatomic) NSUInteger unackedListensCount;
  102|       |@property(nonatomic, strong) NSMutableArray *putsToAck;
  103|       |@property(nonatomic, strong) dispatch_queue_t dispatchQueue;
  104|       |@property(nonatomic, strong) NSString *lastSessionID;
  105|       |@property(nonatomic, strong) NSMutableSet *interruptReasons;
  106|       |@property(nonatomic, strong) FIRRetryHelper *retryHelper;
  107|       |@property(nonatomic, strong) id<FAuthTokenProvider> authTokenProvider;
  108|       |@property(nonatomic, strong) NSString *authToken;
  109|       |@property(nonatomic) BOOL forceAuthTokenRefresh;
  110|       |@property(nonatomic) NSUInteger currentFetchTokenAttempt;
  111|       |
  112|       |@end
  113|       |
  114|       |@implementation FPersistentConnection
  115|       |
  116|       |- (id)initWithRepoInfo:(FRepoInfo *)repoInfo
  117|       |         dispatchQueue:(dispatch_queue_t)dispatchQueue
  118|      0|                config:(FIRDatabaseConfig *)config {
  119|      0|    self = [super init];
  120|      0|    if (self) {
  121|      0|        self->_config = config;
  122|      0|        self->_repoInfo = repoInfo;
  123|      0|        self->_dispatchQueue = dispatchQueue;
  124|      0|        self->_authTokenProvider = config.authTokenProvider;
  125|      0|        NSAssert(self->_authTokenProvider != nil,
  126|      0|                 @"Expected auth token provider");
  127|      0|        self.interruptReasons = [NSMutableSet set];
  128|      0|
  129|      0|        self.listens = [[NSMutableDictionary alloc] init];
  130|      0|        self.outstandingPuts = [[NSMutableDictionary alloc] init];
  131|      0|        self.onDisconnectQueue = [[NSMutableArray alloc] init];
  132|      0|        self.putCounter = [[FAtomicNumber alloc] init];
  133|      0|        self.requestNumber = [[FAtomicNumber alloc] init];
  134|      0|        self.requestCBHash = [[NSMutableDictionary alloc] init];
  135|      0|        self.unackedListensCount = 0;
  136|      0|        self.putsToAck = [NSMutableArray array];
  137|      0|        connectionState = ConnectionStateDisconnected;
  138|      0|        firstConnection = YES;
  139|      0|        reconnectDelay = kPersistentConnReconnectMinDelay;
  140|      0|
  141|      0|        self->_retryHelper = [[FIRRetryHelper alloc]
  142|      0|                initWithDispatchQueue:dispatchQueue
  143|      0|            minRetryDelayAfterFailure:kPersistentConnReconnectMinDelay
  144|      0|                        maxRetryDelay:kPersistentConnReconnectMaxDelay
  145|      0|                        retryExponent:kPersistentConnReconnectMultiplier
  146|      0|                         jitterFactor:0.7];
  147|      0|
  148|      0|        [self setupNotifications];
  149|      0|        // Make sure we don't actually connect until open is called
  150|      0|        [self interruptForReason:kFInterruptReasonWaitingForOpen];
  151|      0|    }
  152|      0|    // nb: The reason establishConnection isn't called here like the JS version
  153|      0|    // is because callers need to set the delegate first. The ctor can be
  154|      0|    // modified to accept the delegate but that deviates from normal ios
  155|      0|    // conventions. After the delegate has been set, the caller is responsible
  156|      0|    // for calling establishConnection:
  157|      0|    return self;
  158|      0|}
  159|       |
  160|      0|- (void)dealloc {
  161|      0|    if (reachability) {
  162|      0|        // Unschedule the notifications
  163|      0|        SCNetworkReachabilitySetDispatchQueue(reachability, NULL);
  164|      0|        CFRelease(reachability);
  165|      0|    }
  166|      0|}
  167|       |
  168|       |#pragma mark -
  169|       |#pragma mark Public methods
  170|       |
  171|      0|- (void)open {
  172|      0|    [self resumeForReason:kFInterruptReasonWaitingForOpen];
  173|      0|}
  174|       |
  175|       |/**
  176|       | * Note that the listens dictionary has a type of Map[String (pathString),
  177|       | * Map[FQueryParams, FOutstandingQuery]]
  178|       | *
  179|       | * This means, for each path we care about, there are sets of queryParams that
  180|       | * correspond to an FOutstandingQuery object. There can be multiple sets at a
  181|       | * path since we overlap listens for a short time while adding or removing a
  182|       | * query from a location in the tree.
  183|       | */
  184|       |- (void)listen:(FQuerySpec *)query
  185|       |         tagId:(NSNumber *)tagId
  186|       |          hash:(id<FSyncTreeHash>)hash
  187|      0|    onComplete:(fbt_void_nsstring)onComplete {
  188|      0|    FFLog(@"I-RDB034001", @"Listen called for %@", query);
  189|      0|
  190|      0|    NSAssert(self.listens[query] == nil,
  191|      0|             @"listen() called twice for the same query");
  192|      0|    NSAssert(query.isDefault || !query.loadsAllData,
  193|      0|             @"listen called for non-default but complete query");
  194|      0|    FOutstandingQuery *outstanding = [[FOutstandingQuery alloc] init];
  195|      0|    outstanding.query = query;
  196|      0|    outstanding.tagId = tagId;
  197|      0|    outstanding.syncTreeHash = hash;
  198|      0|    outstanding.onComplete = onComplete;
  199|      0|    [self.listens setObject:outstanding forKey:query];
  200|      0|    if ([self connected]) {
  201|      0|        [self sendListen:outstanding];
  202|      0|    }
  203|      0|}
  204|       |
  205|       |- (void)putData:(id)data
  206|       |         forPath:(NSString *)pathString
  207|       |        withHash:(NSString *)hash
  208|      0|    withCallback:(fbt_void_nsstring_nsstring)onComplete {
  209|      0|    [self putInternal:data
  210|      0|            forAction:kFWPRequestActionPut
  211|      0|              forPath:pathString
  212|      0|             withHash:hash
  213|      0|         withCallback:onComplete];
  214|      0|}
  215|       |
  216|       |- (void)mergeData:(id)data
  217|       |          forPath:(NSString *)pathString
  218|      0|     withCallback:(fbt_void_nsstring_nsstring)onComplete {
  219|      0|    [self putInternal:data
  220|      0|            forAction:kFWPRequestActionMerge
  221|      0|              forPath:pathString
  222|      0|             withHash:nil
  223|      0|         withCallback:onComplete];
  224|      0|}
  225|       |
  226|       |- (void)onDisconnectPutData:(id)data
  227|       |                    forPath:(FPath *)path
  228|      0|               withCallback:(fbt_void_nsstring_nsstring)callback {
  229|      0|    if ([self canSendWrites]) {
  230|      0|        [self sendOnDisconnectAction:kFWPRequestActionDisconnectPut
  231|      0|                             forPath:[path description]
  232|      0|                            withData:data
  233|      0|                         andCallback:callback];
  234|      0|    } else {
  235|      0|        FTupleOnDisconnect *tuple = [[FTupleOnDisconnect alloc] init];
  236|      0|        tuple.pathString = [path description];
  237|      0|        tuple.action = kFWPRequestActionDisconnectPut;
  238|      0|        tuple.data = data;
  239|      0|        tuple.onComplete = callback;
  240|      0|        [self.onDisconnectQueue addObject:tuple];
  241|      0|    }
  242|      0|}
  243|       |
  244|       |- (void)onDisconnectMergeData:(id)data
  245|       |                      forPath:(FPath *)path
  246|      0|                 withCallback:(fbt_void_nsstring_nsstring)callback {
  247|      0|    if ([self canSendWrites]) {
  248|      0|        [self sendOnDisconnectAction:kFWPRequestActionDisconnectMerge
  249|      0|                             forPath:[path description]
  250|      0|                            withData:data
  251|      0|                         andCallback:callback];
  252|      0|    } else {
  253|      0|        FTupleOnDisconnect *tuple = [[FTupleOnDisconnect alloc] init];
  254|      0|        tuple.pathString = [path description];
  255|      0|        tuple.action = kFWPRequestActionDisconnectMerge;
  256|      0|        tuple.data = data;
  257|      0|        tuple.onComplete = callback;
  258|      0|        [self.onDisconnectQueue addObject:tuple];
  259|      0|    }
  260|      0|}
  261|       |
  262|       |- (void)onDisconnectCancelPath:(FPath *)path
  263|      0|                  withCallback:(fbt_void_nsstring_nsstring)callback {
  264|      0|    if ([self canSendWrites]) {
  265|      0|        [self sendOnDisconnectAction:kFWPRequestActionDisconnectCancel
  266|      0|                             forPath:[path description]
  267|      0|                            withData:[NSNull null]
  268|      0|                         andCallback:callback];
  269|      0|    } else {
  270|      0|        FTupleOnDisconnect *tuple = [[FTupleOnDisconnect alloc] init];
  271|      0|        tuple.pathString = [path description];
  272|      0|        tuple.action = kFWPRequestActionDisconnectCancel;
  273|      0|        tuple.data = [NSNull null];
  274|      0|        tuple.onComplete = callback;
  275|      0|        [self.onDisconnectQueue addObject:tuple];
  276|      0|    }
  277|      0|}
  278|       |
  279|      0|- (void)unlisten:(FQuerySpec *)query tagId:(NSNumber *)tagId {
  280|      0|    FPath *path = query.path;
  281|      0|    FFLog(@"I-RDB034002", @"Unlistening for %@", query);
  282|      0|
  283|      0|    NSArray *outstanding = [self removeListen:query];
  284|      0|    if (outstanding.count > 0 && [self connected]) {
  285|      0|        [self sendUnlisten:path queryParams:query.params tagId:tagId];
  286|      0|    }
  287|      0|}
  288|       |
  289|      0|- (void)refreshAuthToken:(NSString *)token {
  290|      0|    self.authToken = token;
  291|      0|    if ([self connected]) {
  292|      0|        if (token != nil) {
  293|      0|            [self sendAuthAndRestoreStateAfterComplete:NO];
  294|      0|        } else {
  295|      0|            [self sendUnauth];
  296|      0|        }
  297|      0|    }
  298|      0|}
  299|       |
  300|       |#pragma mark -
  301|       |#pragma mark Connection status
  302|       |
  303|      0|- (BOOL)connected {
  304|      0|    return self->connectionState == ConnectionStateAuthenticating ||
  305|      0|           self->connectionState == ConnectionStateConnected;
  306|      0|}
  307|       |
  308|      0|- (BOOL)canSendWrites {
  309|      0|    return self->connectionState == ConnectionStateConnected;
  310|      0|}
  311|       |
  312|       |#pragma mark -
  313|       |#pragma mark FConnection delegate methods
  314|       |
  315|       |- (void)onReady:(FConnection *)fconnection
  316|       |         atTime:(NSNumber *)timestamp
  317|      0|      sessionID:(NSString *)sessionID {
  318|      0|    FFLog(@"I-RDB034003", @"On ready");
  319|      0|    lastConnectionEstablishedTime = [[NSDate date] timeIntervalSince1970];
  320|      0|    [self handleTimestamp:timestamp];
  321|      0|
  322|      0|    if (firstConnection) {
  323|      0|        [self sendConnectStats];
  324|      0|    }
  325|      0|
  326|      0|    [self restoreAuth];
  327|      0|    firstConnection = NO;
  328|      0|    self.lastSessionID = sessionID;
  329|      0|    dispatch_async(self.dispatchQueue, ^{
  330|      0|      [self.delegate onConnect:self];
  331|      0|    });
  332|      0|}
  333|       |
  334|       |- (void)onDataMessage:(FConnection *)fconnection
  335|      0|          withMessage:(NSDictionary *)message {
  336|      0|    if (message[kFWPRequestNumber] != nil) {
  337|      0|        // this is a response to a request we sent
  338|      0|        NSNumber *rn = [NSNumber
  339|      0|            numberWithInt:[[message objectForKey:kFWPRequestNumber] intValue]];
  340|      0|        if ([self.requestCBHash objectForKey:rn]) {
  341|      0|            void (^callback)(NSDictionary *) =
  342|      0|                [self.requestCBHash objectForKey:rn];
  343|      0|            [self.requestCBHash removeObjectForKey:rn];
  344|      0|
  345|      0|            if (callback) {
  346|      0|                // dispatch_async(self.dispatchQueue, ^{
  347|      0|                callback([message objectForKey:kFWPResponseForRNData]);
  348|      0|                //});
  349|      0|            }
  350|      0|        }
  351|      0|    } else if (message[kFWPRequestError] != nil) {
  352|      0|        NSString *error = [message objectForKey:kFWPRequestError];
  353|      0|        @throw [[NSException alloc] initWithName:@"FirebaseDatabaseServerError"
  354|      0|                                          reason:error
  355|      0|                                        userInfo:nil];
  356|      0|    } else if (message[kFWPAsyncServerAction] != nil) {
  357|      0|        // this is a server push of some sort
  358|      0|        NSString *action = [message objectForKey:kFWPAsyncServerAction];
  359|      0|        NSDictionary *body = [message objectForKey:kFWPAsyncServerPayloadBody];
  360|      0|        [self onDataPushWithAction:action andBody:body];
  361|      0|    }
  362|      0|}
  363|       |
  364|       |- (void)onDisconnect:(FConnection *)fconnection
  365|      0|          withReason:(FDisconnectReason)reason {
  366|      0|    FFLog(@"I-RDB034004", @"Got on disconnect due to %s",
  367|      0|          (reason == DISCONNECT_REASON_SERVER_RESET) ? "server_reset"
  368|      0|                                                     : "other");
  369|      0|    connectionState = ConnectionStateDisconnected;
  370|      0|    // Drop the realtime connection
  371|      0|    self.realtime = nil;
  372|      0|    [self cancelSentTransactions];
  373|      0|    [self.requestCBHash removeAllObjects];
  374|      0|    self.unackedListensCount = 0;
  375|      0|    if ([self shouldReconnect]) {
  376|      0|        NSTimeInterval timeSinceLastConnectSucceeded =
  377|      0|            [[NSDate date] timeIntervalSince1970] -
  378|      0|            lastConnectionEstablishedTime;
  379|      0|        BOOL lastConnectionWasSuccessful;
  380|      0|        if (lastConnectionEstablishedTime > 0) {
  381|      0|            lastConnectionWasSuccessful =
  382|      0|                timeSinceLastConnectSucceeded >
  383|      0|                kPersistentConnSuccessfulConnectionEstablishedDelay;
  384|      0|        } else {
  385|      0|            lastConnectionWasSuccessful = NO;
  386|      0|        }
  387|      0|
  388|      0|        if (reason == DISCONNECT_REASON_SERVER_RESET ||
  389|      0|            lastConnectionWasSuccessful) {
  390|      0|            [self.retryHelper signalSuccess];
  391|      0|        }
  392|      0|        [self tryScheduleReconnect];
  393|      0|    }
  394|      0|    lastConnectionEstablishedTime = 0;
  395|      0|    [self.delegate onDisconnect:self];
  396|      0|}
  397|       |
  398|      0|- (void)onKill:(FConnection *)fconnection withReason:(NSString *)reason {
  399|      0|    FFWarn(@"I-RDB034005",
  400|      0|           @"Firebase Database connection was forcefully killed by the server. "
  401|      0|           @" Will not attempt reconnect. Reason: %@",
  402|      0|           reason);
  403|      0|    [self interruptForReason:kFInterruptReasonServerKill];
  404|      0|}
  405|       |
  406|       |#pragma mark -
  407|       |#pragma mark Connection handling methods
  408|       |
  409|      0|- (void)interruptForReason:(NSString *)reason {
  410|      0|    FFLog(@"I-RDB034006", @"Connection interrupted for: %@", reason);
  411|      0|
  412|      0|    [self.interruptReasons addObject:reason];
  413|      0|    if (self.realtime) {
  414|      0|        // Will call onDisconnect and set the connection state to Disconnected
  415|      0|        [self.realtime close];
  416|      0|        self.realtime = nil;
  417|      0|    } else {
  418|      0|        [self.retryHelper cancel];
  419|      0|        self->connectionState = ConnectionStateDisconnected;
  420|      0|    }
  421|      0|    // Reset timeouts
  422|      0|    [self.retryHelper signalSuccess];
  423|      0|}
  424|       |
  425|      0|- (void)resumeForReason:(NSString *)reason {
  426|      0|    FFLog(@"I-RDB034007", @"Connection no longer interrupted for: %@", reason);
  427|      0|    [self.interruptReasons removeObject:reason];
  428|      0|
  429|      0|    if ([self shouldReconnect] &&
  430|      0|        connectionState == ConnectionStateDisconnected) {
  431|      0|        [self tryScheduleReconnect];
  432|      0|    }
  433|      0|}
  434|       |
  435|      0|- (BOOL)shouldReconnect {
  436|      0|    return self.interruptReasons.count == 0;
  437|      0|}
  438|       |
  439|      0|- (BOOL)isInterruptedForReason:(NSString *)reason {
  440|      0|    return [self.interruptReasons containsObject:reason];
  441|      0|}
  442|       |
  443|       |#pragma mark -
  444|       |#pragma mark Private methods
  445|       |
  446|      0|- (void)tryScheduleReconnect {
  447|      0|    if ([self shouldReconnect]) {
  448|      0|        NSAssert(self->connectionState == ConnectionStateDisconnected,
  449|      0|                 @"Not in disconnected state: %d", self->connectionState);
  450|      0|        BOOL forceRefresh = self.forceAuthTokenRefresh;
  451|      0|        self.forceAuthTokenRefresh = NO;
  452|      0|        FFLog(@"I-RDB034008", @"Scheduling connection attempt");
  453|      0|        [self.retryHelper retry:^{
  454|      0|          FFLog(@"I-RDB034009", @"Trying to fetch auth token");
  455|      0|          NSAssert(self->connectionState == ConnectionStateDisconnected,
  456|      0|                   @"Not in disconnected state: %d", self->connectionState);
  457|      0|          self->connectionState = ConnectionStateGettingToken;
  458|      0|          self.currentFetchTokenAttempt++;
  459|      0|          NSUInteger thisFetchTokenAttempt = self.currentFetchTokenAttempt;
  460|      0|          [self.authTokenProvider
  461|      0|              fetchTokenForcingRefresh:forceRefresh
  462|      0|                          withCallback:^(NSString *token, NSError *error) {
  463|      0|                            if (thisFetchTokenAttempt ==
  464|      0|                                self.currentFetchTokenAttempt) {
  465|      0|                                if (error != nil) {
  466|      0|                                    self->connectionState =
  467|      0|                                        ConnectionStateDisconnected;
  468|      0|                                    FFLog(@"I-RDB034010",
  469|      0|                                          @"Error fetching token: %@", error);
  470|      0|                                    [self tryScheduleReconnect];
  471|      0|                                } else {
  472|      0|                                    // Someone could have interrupted us while
  473|      0|                                    // fetching the token, marking the
  474|      0|                                    // connection as Disconnected
  475|      0|                                    if (self->connectionState ==
  476|      0|                                        ConnectionStateGettingToken) {
  477|      0|                                        FFLog(@"I-RDB034011",
  478|      0|                                              @"Successfully fetched token, "
  479|      0|                                              @"opening connection");
  480|      0|                                        [self openNetworkConnectionWithToken:
  481|      0|                                                  token];
  482|      0|                                    } else {
  483|      0|                                        NSAssert(
  484|      0|                                            self->connectionState ==
  485|      0|                                                ConnectionStateDisconnected,
  486|      0|                                            @"Expected connection state "
  487|      0|                                            @"disconnected, but got %d",
  488|      0|                                            self->connectionState);
  489|      0|                                        FFLog(@"I-RDB034012",
  490|      0|                                              @"Not opening connection after "
  491|      0|                                              @"token refresh, because "
  492|      0|                                              @"connection was set to "
  493|      0|                                              @"disconnected.");
  494|      0|                                    }
  495|      0|                                }
  496|      0|                            } else {
  497|      0|                                FFLog(@"I-RDB034013",
  498|      0|                                      @"Ignoring fetch token result, because "
  499|      0|                                      @"this was not the latest attempt.");
  500|      0|                            }
  501|      0|                          }];
  502|      0|        }];
  503|      0|    }
  504|      0|}
  505|       |
  506|      0|- (void)openNetworkConnectionWithToken:(NSString *)token {
  507|      0|    NSAssert(self->connectionState == ConnectionStateGettingToken,
  508|      0|             @"Trying to open network connection while in wrong state: %d",
  509|      0|             self->connectionState);
  510|      0|    self.authToken = token;
  511|      0|    self->connectionState = ConnectionStateConnecting;
  512|      0|    self.realtime = [[FConnection alloc] initWith:self.repoInfo
  513|      0|                                 andDispatchQueue:self.dispatchQueue
  514|      0|                                    lastSessionID:self.lastSessionID];
  515|      0|    self.realtime.delegate = self;
  516|      0|    [self.realtime open];
  517|      0|}
  518|       |
  519|       |static void reachabilityCallback(SCNetworkReachabilityRef ref,
  520|      0|                                 SCNetworkReachabilityFlags flags, void *info) {
  521|      0|    if (flags & kSCNetworkReachabilityFlagsReachable) {
  522|      0|        FFLog(@"I-RDB034014",
  523|      0|              @"Network became reachable. Trigger a connection attempt");
  524|      0|        FPersistentConnection *self = (__bridge FPersistentConnection *)info;
  525|      0|        // Reset reconnect delay
  526|      0|        [self.retryHelper signalSuccess];
  527|      0|        if (self->connectionState == ConnectionStateDisconnected) {
  528|      0|            [self tryScheduleReconnect];
  529|      0|        }
  530|      0|    } else {
  531|      0|        FFLog(@"I-RDB034015", @"Network is not reachable");
  532|      0|    }
  533|      0|}
  534|       |
  535|      0|- (void)enteringForeground {
  536|      0|    dispatch_async(self.dispatchQueue, ^{
  537|      0|      // Reset reconnect delay
  538|      0|      [self.retryHelper signalSuccess];
  539|      0|      if (self->connectionState == ConnectionStateDisconnected) {
  540|      0|          [self tryScheduleReconnect];
  541|      0|      }
  542|      0|    });
  543|      0|}
  544|       |
  545|      0|- (void)setupNotifications {
  546|      0|
  547|      0|    NSString *const *foregroundConstant = (NSString *const *)dlsym(
  548|      0|        RTLD_DEFAULT, "UIApplicationWillEnterForegroundNotification");
  549|      0|    if (foregroundConstant) {
  550|      0|        [[NSNotificationCenter defaultCenter]
  551|      0|            addObserver:self
  552|      0|               selector:@selector(enteringForeground)
  553|      0|                   name:*foregroundConstant
  554|      0|                 object:nil];
  555|      0|    }
  556|      0|    // An empty address is interpreted a generic internet access
  557|      0|    struct sockaddr_in zeroAddress;
  558|      0|    bzero(&zeroAddress, sizeof(zeroAddress));
  559|      0|    zeroAddress.sin_len = sizeof(zeroAddress);
  560|      0|    zeroAddress.sin_family = AF_INET;
  561|      0|    reachability = SCNetworkReachabilityCreateWithAddress(
  562|      0|        kCFAllocatorDefault, (const struct sockaddr *)&zeroAddress);
  563|      0|    SCNetworkReachabilityContext ctx = {0, (__bridge void *)(self), NULL, NULL,
  564|      0|                                        NULL};
  565|      0|    if (SCNetworkReachabilitySetCallback(reachability, reachabilityCallback,
  566|      0|                                         &ctx)) {
  567|      0|        SCNetworkReachabilitySetDispatchQueue(reachability, self.dispatchQueue);
  568|      0|    } else {
  569|      0|        FFLog(@"I-RDB034016",
  570|      0|              @"Failed to set up network reachability monitoring");
  571|      0|        CFRelease(reachability);
  572|      0|        reachability = NULL;
  573|      0|    }
  574|      0|}
  575|       |
  576|      0|- (void)sendAuthAndRestoreStateAfterComplete:(BOOL)restoreStateAfterComplete {
  577|      0|    NSAssert([self connected], @"Must be connected to send auth");
  578|      0|    NSAssert(self.authToken != nil,
  579|      0|             @"Can't send auth if there is no credential");
  580|      0|
  581|      0|    NSDictionary *requestData = @{kFWPRequestCredential : self.authToken};
  582|      0|    [self sendAction:kFWPRequestActionAuth
  583|      0|                body:requestData
  584|      0|           sensitive:YES
  585|      0|            callback:^(NSDictionary *data) {
  586|      0|              self->connectionState = ConnectionStateConnected;
  587|      0|              NSString *status =
  588|      0|                  [data objectForKey:kFWPResponseForActionStatus];
  589|      0|              id responseData = [data objectForKey:kFWPResponseForActionData];
  590|      0|              if (responseData == nil) {
  591|      0|                  responseData = @"error";
  592|      0|              }
  593|      0|
  594|      0|              BOOL statusOk =
  595|      0|                  [status isEqualToString:kFWPResponseForActionStatusOk];
  596|      0|              if (statusOk) {
  597|      0|                  if (restoreStateAfterComplete) {
  598|      0|                      [self restoreState];
  599|      0|                  }
  600|      0|              } else {
  601|      0|                  self.authToken = nil;
  602|      0|                  self.forceAuthTokenRefresh = YES;
  603|      0|                  if ([status isEqualToString:@"expired_token"]) {
  604|      0|                      FFLog(@"I-RDB034017", @"Authentication failed: %@ (%@)",
  605|      0|                            status, responseData);
  606|      0|                  } else {
  607|      0|                      FFWarn(@"I-RDB034018", @"Authentication failed: %@ (%@)",
  608|      0|                             status, responseData);
  609|      0|                  }
  610|      0|                  [self.realtime close];
  611|      0|              }
  612|      0|            }];
  613|      0|}
  614|       |
  615|      0|- (void)sendUnauth {
  616|      0|    [self sendAction:kFWPRequestActionUnauth
  617|      0|                body:@{}
  618|      0|           sensitive:NO
  619|      0|            callback:nil];
  620|      0|}
  621|       |
  622|       |- (void)onAuthRevokedWithStatus:(NSString *)status
  623|      0|                      andReason:(NSString *)reason {
  624|      0|    // This might be for an earlier token than we just recently sent. But since
  625|      0|    // we need to close the connection anyways, we can set it to null here and
  626|      0|    // we will refresh the token later on reconnect
  627|      0|    if ([status isEqualToString:@"expired_token"]) {
  628|      0|        FFLog(@"I-RDB034019", @"Auth token revoked: %@ (%@)", status, reason);
  629|      0|    } else {
  630|      0|        FFWarn(@"I-RDB034020", @"Auth token revoked: %@ (%@)", status, reason);
  631|      0|    }
  632|      0|    self.authToken = nil;
  633|      0|    self.forceAuthTokenRefresh = YES;
  634|      0|    // Try reconnecting on auth revocation
  635|      0|    [self.realtime close];
  636|      0|}
  637|       |
  638|      0|- (void)onListenRevoked:(FPath *)path {
  639|      0|    NSArray *queries = [self removeAllListensAtPath:path];
  640|      0|    for (FOutstandingQuery *query in queries) {
  641|      0|        query.onComplete(@"permission_denied");
  642|      0|    }
  643|      0|}
  644|       |
  645|       |- (void)sendOnDisconnectAction:(NSString *)action
  646|       |                       forPath:(NSString *)pathString
  647|       |                      withData:(id)data
  648|      0|                   andCallback:(fbt_void_nsstring_nsstring)callback {
  649|      0|
  650|      0|    NSDictionary *request =
  651|      0|        @{kFWPRequestPath : pathString, kFWPRequestData : data};
  652|      0|    FFLog(@"I-RDB034021", @"onDisconnect %@: %@", action, request);
  653|      0|
  654|      0|    [self sendAction:action
  655|      0|                body:request
  656|      0|           sensitive:NO
  657|      0|            callback:^(NSDictionary *data) {
  658|      0|              NSString *status =
  659|      0|                  [data objectForKey:kFWPResponseForActionStatus];
  660|      0|              NSString *errorReason =
  661|      0|                  [data objectForKey:kFWPResponseForActionData];
  662|      0|              callback(status, errorReason);
  663|      0|            }];
  664|      0|}
  665|       |
  666|      0|- (void)sendPut:(NSNumber *)index {
  667|      0|    NSAssert([self canSendWrites],
  668|      0|             @"sendPut called when not able to send writes");
  669|      0|    FOutstandingPut *put = self.outstandingPuts[index];
  670|      0|    assert(put != nil);
  671|      0|    fbt_void_nsstring_nsstring onComplete = put.onCompleteBlock;
  672|      0|
  673|      0|    // Do not async this block; copying the block insinde sendAction: doesn't
  674|      0|    // happen in time (or something) so coredumps
  675|      0|    put.sent = YES;
  676|      0|    [self sendAction:put.action
  677|      0|                body:put.request
  678|      0|           sensitive:NO
  679|      0|            callback:^(NSDictionary *data) {
  680|      0|              FOutstandingPut *currentPut = self.outstandingPuts[index];
  681|      0|              if (currentPut == put) {
  682|      0|                  [self.outstandingPuts removeObjectForKey:index];
  683|      0|
  684|      0|                  if (onComplete != nil) {
  685|      0|                      NSString *status =
  686|      0|                          [data objectForKey:kFWPResponseForActionStatus];
  687|      0|                      NSString *errorReason =
  688|      0|                          [data objectForKey:kFWPResponseForActionData];
  689|      0|                      if (self.unackedListensCount == 0) {
  690|      0|                          onComplete(status, errorReason);
  691|      0|                      } else {
  692|      0|                          FTupleCallbackStatus *putToAck =
  693|      0|                              [[FTupleCallbackStatus alloc] init];
  694|      0|                          putToAck.block = onComplete;
  695|      0|                          putToAck.status = status;
  696|      0|                          putToAck.errorReason = errorReason;
  697|      0|                          [self.putsToAck addObject:putToAck];
  698|      0|                      }
  699|      0|                  }
  700|      0|              } else {
  701|      0|                  FFLog(@"I-RDB034022",
  702|      0|                        @"Ignoring on complete for put %@ because it was "
  703|      0|                        @"already removed",
  704|      0|                        index);
  705|      0|              }
  706|      0|            }];
  707|      0|}
  708|       |
  709|       |- (void)sendUnlisten:(FPath *)path
  710|       |         queryParams:(FQueryParams *)queryParams
  711|      0|               tagId:(NSNumber *)tagId {
  712|      0|    FFLog(@"I-RDB034023", @"Unlisten on %@ for %@", path, queryParams);
  713|      0|
  714|      0|    NSMutableDictionary *request = [NSMutableDictionary
  715|      0|        dictionaryWithObjectsAndKeys:[path toString], kFWPRequestPath, nil];
  716|      0|    if (tagId != nil) {
  717|      0|        [request setObject:queryParams.wireProtocolParams
  718|      0|                    forKey:kFWPRequestQueries];
  719|      0|        [request setObject:tagId forKey:kFWPRequestTag];
  720|      0|    }
  721|      0|
  722|      0|    [self sendAction:kFWPRequestActionTaggedUnlisten
  723|      0|                body:request
  724|      0|           sensitive:NO
  725|      0|            callback:nil];
  726|      0|}
  727|       |
  728|       |- (void)putInternal:(id)data
  729|       |          forAction:(NSString *)action
  730|       |            forPath:(NSString *)pathString
  731|       |           withHash:(NSString *)hash
  732|      0|       withCallback:(fbt_void_nsstring_nsstring)onComplete {
  733|      0|
  734|      0|    NSMutableDictionary *request = [NSMutableDictionary
  735|      0|        dictionaryWithObjectsAndKeys:pathString, kFWPRequestPath, data,
  736|      0|                                     kFWPRequestData, nil];
  737|      0|    if (hash) {
  738|      0|        [request setObject:hash forKey:kFWPRequestHash];
  739|      0|    }
  740|      0|
  741|      0|    FOutstandingPut *put = [[FOutstandingPut alloc] init];
  742|      0|    put.action = action;
  743|      0|    put.request = request;
  744|      0|    put.onCompleteBlock = onComplete;
  745|      0|    put.sent = NO;
  746|      0|
  747|      0|    NSNumber *index = [self.putCounter getAndIncrement];
  748|      0|    self.outstandingPuts[index] = put;
  749|      0|
  750|      0|    if ([self canSendWrites]) {
  751|      0|        FFLog(@"I-RDB034024", @"Was connected, and added as index: %@", index);
  752|      0|        [self sendPut:index];
  753|      0|    } else {
  754|      0|        FFLog(@"I-RDB034025",
  755|      0|              @"Wasn't connected or writes paused, so added to outstanding "
  756|      0|              @"puts only. Path: %@",
  757|      0|              pathString);
  758|      0|    }
  759|      0|}
  760|       |
  761|      0|- (void)sendListen:(FOutstandingQuery *)listenSpec {
  762|      0|    FQuerySpec *query = listenSpec.query;
  763|      0|    FFLog(@"I-RDB034026", @"Listen for %@", query);
  764|      0|    NSMutableDictionary *request =
  765|      0|        [NSMutableDictionary dictionaryWithObject:[query.path toString]
  766|      0|                                           forKey:kFWPRequestPath];
  767|      0|
  768|      0|    // Only bother to send query if it's non-default
  769|      0|    if (listenSpec.tagId != nil) {
  770|      0|        [request setObject:[query.params wireProtocolParams]
  771|      0|                    forKey:kFWPRequestQueries];
  772|      0|        [request setObject:listenSpec.tagId forKey:kFWPRequestTag];
  773|      0|    }
  774|      0|
  775|      0|    [request setObject:[listenSpec.syncTreeHash simpleHash]
  776|      0|                forKey:kFWPRequestHash];
  777|      0|    if ([listenSpec.syncTreeHash includeCompoundHash]) {
  778|      0|        FCompoundHash *compoundHash = [listenSpec.syncTreeHash compoundHash];
  779|      0|        NSMutableArray *posts = [NSMutableArray array];
  780|      0|        for (FPath *path in compoundHash.posts) {
  781|      0|            [posts addObject:path.wireFormat];
  782|      0|        }
  783|      0|        request[kFWPRequestCompoundHash] = @{
  784|      0|            kFWPRequestCompoundHashHashes : compoundHash.hashes,
  785|      0|            kFWPRequestCompoundHashPaths : posts
  786|      0|        };
  787|      0|    }
  788|      0|
  789|      0|    fbt_void_nsdictionary onResponse = ^(NSDictionary *response) {
  790|      0|      FFLog(@"I-RDB034027", @"Listen response %@", response);
  791|      0|      // warn in any case, even if the listener was removed
  792|      0|      [self warnOnListenWarningsForQuery:query
  793|      0|                                 payload:response[kFWPResponseForActionData]];
  794|      0|
  795|      0|      FOutstandingQuery *currentListenSpec = self.listens[query];
  796|      0|
  797|      0|      // only trigger actions if the listen hasn't been removed (and maybe
  798|      0|      // readded)
  799|      0|      if (currentListenSpec == listenSpec) {
  800|      0|          NSString *status = [response objectForKey:kFWPRequestStatus];
  801|      0|          if (![status isEqualToString:@"ok"]) {
  802|      0|              [self removeListen:query];
  803|      0|          }
  804|      0|
  805|      0|          if (listenSpec.onComplete) {
  806|      0|              listenSpec.onComplete(status);
  807|      0|          }
  808|      0|      }
  809|      0|
  810|      0|      self.unackedListensCount--;
  811|      0|      NSAssert(self.unackedListensCount >= 0,
  812|      0|               @"unackedListensCount decremented to be negative.");
  813|      0|      if (self.unackedListensCount == 0) {
  814|      0|          [self ackPuts];
  815|      0|      }
  816|      0|    };
  817|      0|
  818|      0|    [self sendAction:kFWPRequestActionTaggedListen
  819|      0|                body:request
  820|      0|           sensitive:NO
  821|      0|            callback:onResponse];
  822|      0|
  823|      0|    self.unackedListensCount++;
  824|      0|}
  825|       |
  826|      0|- (void)warnOnListenWarningsForQuery:(FQuerySpec *)query payload:(id)payload {
  827|      0|    if (payload != nil && [payload isKindOfClass:[NSDictionary class]]) {
  828|      0|        NSDictionary *payloadDict = payload;
  829|      0|        id warnings = payloadDict[kFWPResponseDataWarnings];
  830|      0|        if (warnings != nil && [warnings isKindOfClass:[NSArray class]]) {
  831|      0|            NSArray *warningsArr = warnings;
  832|      0|            if ([warningsArr containsObject:@"no_index"]) {
  833|      0|                NSString *indexSpec = [NSString
  834|      0|                    stringWithFormat:@"\".indexOn\": \"%@\"",
  835|      0|                                     [query.params.index queryDefinition]];
  836|      0|                NSString *indexPath = [query.path description];
  837|      0|                FFWarn(@"I-RDB034028",
  838|      0|                       @"Using an unspecified index. Your data will be "
  839|      0|                       @"downloaded and filtered on the client. "
  840|      0|                        "Consider adding %@ at %@ to your security rules for "
  841|      0|                        "better performance",
  842|      0|                       indexSpec, indexPath);
  843|      0|            }
  844|      0|        }
  845|      0|    }
  846|      0|}
  847|       |
  848|      0|- (int)getNextRequestNumber {
  849|      0|    return [[self.requestNumber getAndIncrement] intValue];
  850|      0|}
  851|       |
  852|       |- (void)sendAction:(NSString *)action
  853|       |              body:(NSDictionary *)message
  854|       |         sensitive:(BOOL)sensitive
  855|      0|          callback:(void (^)(NSDictionary *data))onMessage {
  856|      0|    // Hold onto the onMessage callback for this request before firing it off
  857|      0|    NSNumber *rn = [NSNumber numberWithInt:[self getNextRequestNumber]];
  858|      0|    NSDictionary *msg = [NSDictionary
  859|      0|        dictionaryWithObjectsAndKeys:rn, kFWPRequestNumber, action,
  860|      0|                                     kFWPRequestAction, message,
  861|      0|                                     kFWPRequestPayloadBody, nil];
  862|      0|
  863|      0|    [self.realtime sendRequest:msg sensitive:sensitive];
  864|      0|
  865|      0|    if (onMessage) {
  866|      0|        // Debug message without a callback; bump the rn, but don't hold onto
  867|      0|        // the cb
  868|      0|        [self.requestCBHash setObject:[onMessage copy] forKey:rn];
  869|      0|    }
  870|      0|}
  871|       |
  872|      0|- (void)cancelSentTransactions {
  873|      0|    NSMutableDictionary<NSNumber *, FOutstandingPut *>
  874|      0|        *cancelledOutstandingPuts = [[NSMutableDictionary alloc] init];
  875|      0|
  876|      0|    for (NSNumber *index in self.outstandingPuts) {
  877|      0|        FOutstandingPut *put = self.outstandingPuts[index];
  878|      0|        if (put.request[kFWPRequestHash] && put.sent) {
  879|      0|            // This is a sent transaction put.
  880|      0|            cancelledOutstandingPuts[index] = put;
  881|      0|        }
  882|      0|    }
  883|      0|
  884|      0|    [cancelledOutstandingPuts
  885|      0|        enumerateKeysAndObjectsUsingBlock:^(
  886|      0|            NSNumber *index, FOutstandingPut *outstandingPut, BOOL *stop) {
  887|      0|          // `onCompleteBlock:` may invoke `rerunTransactionsForPath:` and
  888|      0|          // enqueue new writes. We defer calling it until we have finished
  889|      0|          // enumerating all existing writes.
  890|      0|          outstandingPut.onCompleteBlock(
  891|      0|              kFTransactionDisconnect,
  892|      0|              @"Client was disconnected while running a transaction");
  893|      0|          [self.outstandingPuts removeObjectForKey:index];
  894|      0|        }];
  895|      0|}
  896|       |
  897|      0|- (void)onDataPushWithAction:(NSString *)action andBody:(NSDictionary *)body {
  898|      0|    FFLog(@"I-RDB034029", @"handleServerMessage: %@, %@", action, body);
  899|      0|    id<FPersistentConnectionDelegate> delegate = self.delegate;
  900|      0|    if ([action isEqualToString:kFWPAsyncServerDataUpdate] ||
  901|      0|        [action isEqualToString:kFWPAsyncServerDataMerge]) {
  902|      0|        BOOL isMerge = [action isEqualToString:kFWPAsyncServerDataMerge];
  903|      0|
  904|      0|        if ([body objectForKey:kFWPAsyncServerDataUpdateBodyPath] &&
  905|      0|            [body objectForKey:kFWPAsyncServerDataUpdateBodyData]) {
  906|      0|            NSString *path =
  907|      0|                [body objectForKey:kFWPAsyncServerDataUpdateBodyPath];
  908|      0|            id payloadData =
  909|      0|                [body objectForKey:kFWPAsyncServerDataUpdateBodyData];
  910|      0|            if (isMerge && [payloadData isKindOfClass:[NSDictionary class]] &&
  911|      0|                [payloadData count] == 0) {
  912|      0|                // ignore empty merge
  913|      0|            } else {
  914|      0|                [delegate
  915|      0|                    onDataUpdate:self
  916|      0|                         forPath:path
  917|      0|                         message:payloadData
  918|      0|                         isMerge:isMerge
  919|      0|                           tagId:[body objectForKey:
  920|      0|                                           kFWPAsyncServerDataUpdateBodyTag]];
  921|      0|            }
  922|      0|        } else {
  923|      0|            FFLog(
  924|      0|                @"I-RDB034030",
  925|      0|                @"Malformed data response from server missing path or data: %@",
  926|      0|                body);
  927|      0|        }
  928|      0|    } else if ([action isEqualToString:kFWPAsyncServerDataRangeMerge]) {
  929|      0|        NSString *path = body[kFWPAsyncServerDataUpdateBodyPath];
  930|      0|        NSArray *ranges = body[kFWPAsyncServerDataUpdateBodyData];
  931|      0|        NSNumber *tag = body[kFWPAsyncServerDataUpdateBodyTag];
  932|      0|        NSMutableArray *rangeMerges = [NSMutableArray array];
  933|      0|        for (NSDictionary *range in ranges) {
  934|      0|            NSString *startString = range[kFWPAsyncServerDataUpdateStartPath];
  935|      0|            NSString *endString = range[kFWPAsyncServerDataUpdateEndPath];
  936|      0|            id updateData = range[kFWPAsyncServerDataUpdateRangeMerge];
  937|      0|            id<FNode> updates = [FSnapshotUtilities nodeFrom:updateData];
  938|      0|            FPath *start = (startString != nil)
  939|      0|                               ? [[FPath alloc] initWith:startString]
  940|      0|                               : nil;
  941|      0|            FPath *end =
  942|      0|                (endString != nil) ? [[FPath alloc] initWith:endString] : nil;
  943|      0|            FRangeMerge *merge = [[FRangeMerge alloc] initWithStart:start
  944|      0|                                                                end:end
  945|      0|                                                            updates:updates];
  946|      0|            [rangeMerges addObject:merge];
  947|      0|        }
  948|      0|        [delegate onRangeMerge:rangeMerges forPath:path tagId:tag];
  949|      0|    } else if ([action isEqualToString:kFWPAsyncServerAuthRevoked]) {
  950|      0|        NSString *status = [body objectForKey:kFWPResponseForActionStatus];
  951|      0|        NSString *reason = [body objectForKey:kFWPResponseForActionData];
  952|      0|        [self onAuthRevokedWithStatus:status andReason:reason];
  953|      0|    } else if ([action isEqualToString:kFWPASyncServerListenCancelled]) {
  954|      0|        NSString *pathString =
  955|      0|            [body objectForKey:kFWPAsyncServerDataUpdateBodyPath];
  956|      0|        [self onListenRevoked:[[FPath alloc] initWith:pathString]];
  957|      0|    } else if ([action isEqualToString:kFWPAsyncServerSecurityDebug]) {
  958|      0|        NSString *msg = [body objectForKey:@"msg"];
  959|      0|        if (msg != nil) {
  960|      0|            NSArray *msgs = [msg componentsSeparatedByString:@"\n"];
  961|      0|            for (NSString *m in msgs) {
  962|      0|                FFWarn(@"I-RDB034031", @"%@", m);
  963|      0|            }
  964|      0|        }
  965|      0|    } else {
  966|      0|        // TODO: revoke listens, auth, security debug
  967|      0|        FFLog(@"I-RDB034032", @"Unsupported action from server: %@", action);
  968|      0|    }
  969|      0|}
  970|       |
  971|      0|- (void)restoreAuth {
  972|      0|    FFLog(@"I-RDB034033", @"Calling restore state");
  973|      0|
  974|      0|    NSAssert(self->connectionState == ConnectionStateConnecting,
  975|      0|             @"Wanted to restore auth, but was in wrong state: %d",
  976|      0|             self->connectionState);
  977|      0|    if (self.authToken == nil) {
  978|      0|        FFLog(@"I-RDB034034", @"Not restoring auth because token is nil");
  979|      0|        self->connectionState = ConnectionStateConnected;
  980|      0|        [self restoreState];
  981|      0|    } else {
  982|      0|        FFLog(@"I-RDB034035", @"Restoring auth");
  983|      0|        self->connectionState = ConnectionStateAuthenticating;
  984|      0|        [self sendAuthAndRestoreStateAfterComplete:YES];
  985|      0|    }
  986|      0|}
  987|       |
  988|      0|- (void)restoreState {
  989|      0|    NSAssert(self->connectionState == ConnectionStateConnected,
  990|      0|             @"Should be connected if we're restoring state, but we are: %d",
  991|      0|             self->connectionState);
  992|      0|
  993|      0|    [self.listens enumerateKeysAndObjectsUsingBlock:^(
  994|      0|                      FQuerySpec *query, FOutstandingQuery *outstandingListen,
  995|      0|                      BOOL *stop) {
  996|      0|      FFLog(@"I-RDB034036", @"Restoring listen for %@", query);
  997|      0|      [self sendListen:outstandingListen];
  998|      0|    }];
  999|      0|
 1000|      0|    NSArray *keys = [[self.outstandingPuts allKeys]
 1001|      0|        sortedArrayUsingSelector:@selector(compare:)];
 1002|      0|    for (int i = 0; i < [keys count]; i++) {
 1003|      0|        if ([self.outstandingPuts objectForKey:[keys objectAtIndex:i]] != nil) {
 1004|      0|            FFLog(@"I-RDB034037", @"Restoring put: %d", i);
 1005|      0|            [self sendPut:[keys objectAtIndex:i]];
 1006|      0|        } else {
 1007|      0|            FFLog(@"I-RDB034038", @"Restoring put: skipped nil: %d", i);
 1008|      0|        }
 1009|      0|    }
 1010|      0|
 1011|      0|    for (FTupleOnDisconnect *tuple in self.onDisconnectQueue) {
 1012|      0|        [self sendOnDisconnectAction:tuple.action
 1013|      0|                             forPath:tuple.pathString
 1014|      0|                            withData:tuple.data
 1015|      0|                         andCallback:tuple.onComplete];
 1016|      0|    }
 1017|      0|    [self.onDisconnectQueue removeAllObjects];
 1018|      0|}
 1019|       |
 1020|      0|- (NSArray *)removeListen:(FQuerySpec *)query {
 1021|      0|    NSAssert(query.isDefault || !query.loadsAllData,
 1022|      0|             @"removeListen called for non-default but complete query");
 1023|      0|
 1024|      0|    FOutstandingQuery *outstanding = self.listens[query];
 1025|      0|    if (!outstanding) {
 1026|      0|        FFLog(@"I-RDB034039",
 1027|      0|              @"Trying to remove listener for query %@ but no listener exists",
 1028|      0|              query);
 1029|      0|        return @[];
 1030|      0|    } else {
 1031|      0|        [self.listens removeObjectForKey:query];
 1032|      0|        return @[ outstanding ];
 1033|      0|    }
 1034|      0|}
 1035|       |
 1036|      0|- (NSArray *)removeAllListensAtPath:(FPath *)path {
 1037|      0|    FFLog(@"I-RDB034040", @"Removing all listens at path %@", path);
 1038|      0|    NSMutableArray *removed = [NSMutableArray array];
 1039|      0|    NSMutableArray *toRemove = [NSMutableArray array];
 1040|      0|    [self.listens
 1041|      0|        enumerateKeysAndObjectsUsingBlock:^(
 1042|      0|            FQuerySpec *spec, FOutstandingQuery *outstanding, BOOL *stop) {
 1043|      0|          if ([spec.path isEqual:path]) {
 1044|      0|              [removed addObject:outstanding];
 1045|      0|              [toRemove addObject:spec];
 1046|      0|          }
 1047|      0|        }];
 1048|      0|    [self.listens removeObjectsForKeys:toRemove];
 1049|      0|    return removed;
 1050|      0|}
 1051|       |
 1052|      0|- (void)purgeOutstandingWrites {
 1053|      0|    // We might have unacked puts in our queue that we need to ack now before we
 1054|      0|    // send out any cancels...
 1055|      0|    [self ackPuts];
 1056|      0|    // Cancel in order
 1057|      0|    NSArray *keys = [[self.outstandingPuts allKeys]
 1058|      0|        sortedArrayUsingSelector:@selector(compare:)];
 1059|      0|    for (NSNumber *key in keys) {
 1060|      0|        FOutstandingPut *put = self.outstandingPuts[key];
 1061|      0|        if (put.onCompleteBlock != nil) {
 1062|      0|            put.onCompleteBlock(kFErrorWriteCanceled, nil);
 1063|      0|        }
 1064|      0|    }
 1065|      0|    for (FTupleOnDisconnect *onDisconnect in self.onDisconnectQueue) {
 1066|      0|        if (onDisconnect.onComplete != nil) {
 1067|      0|            onDisconnect.onComplete(kFErrorWriteCanceled, nil);
 1068|      0|        }
 1069|      0|    }
 1070|      0|    [self.outstandingPuts removeAllObjects];
 1071|      0|    [self.onDisconnectQueue removeAllObjects];
 1072|      0|}
 1073|       |
 1074|      0|- (void)ackPuts {
 1075|      0|    for (FTupleCallbackStatus *put in self.putsToAck) {
 1076|      0|        put.block(put.status, put.errorReason);
 1077|      0|    }
 1078|      0|    [self.putsToAck removeAllObjects];
 1079|      0|}
 1080|       |
 1081|      0|- (void)handleTimestamp:(NSNumber *)timestamp {
 1082|      0|    FFLog(@"I-RDB034041", @"Handling timestamp: %@", timestamp);
 1083|      0|    double timestampDeltaMs = [timestamp doubleValue] -
 1084|      0|                              ([[NSDate date] timeIntervalSince1970] * 1000);
 1085|      0|    [self.delegate onServerInfoUpdate:self
 1086|      0|                              updates:@{
 1087|      0|                                  kDotInfoServerTimeOffset : [NSNumber
 1088|      0|                                      numberWithDouble:timestampDeltaMs]
 1089|      0|                              }];
 1090|      0|}
 1091|       |
 1092|      0|- (void)sendStats:(NSDictionary *)stats {
 1093|      0|    if ([stats count] > 0) {
 1094|      0|        NSDictionary *request = @{kFWPRequestCounters : stats};
 1095|      0|        [self sendAction:kFWPRequestActionStats
 1096|      0|                    body:request
 1097|      0|               sensitive:NO
 1098|      0|                callback:^(NSDictionary *data) {
 1099|      0|                  NSString *status =
 1100|      0|                      [data objectForKey:kFWPResponseForActionStatus];
 1101|      0|                  NSString *errorReason =
 1102|      0|                      [data objectForKey:kFWPResponseForActionData];
 1103|      0|                  BOOL statusOk =
 1104|      0|                      [status isEqualToString:kFWPResponseForActionStatusOk];
 1105|      0|                  if (!statusOk) {
 1106|      0|                      FFLog(@"I-RDB034042", @"Failed to send stats: %@",
 1107|      0|                            errorReason);
 1108|      0|                  }
 1109|      0|                }];
 1110|      0|    } else {
 1111|      0|        FFLog(@"I-RDB034043", @"Not sending stats because stats are empty");
 1112|      0|    }
 1113|      0|}
 1114|       |
 1115|      0|- (void)sendConnectStats {
 1116|      0|    NSMutableDictionary *stats = [NSMutableDictionary dictionary];
 1117|      0|
 1118|      0|#if TARGET_OS_IOS || TARGET_OS_TV
 1119|      0|    if (self.config.persistenceEnabled) {
 1120|      0|        stats[@"persistence.ios.enabled"] = @1;
 1121|      0|    }
 1122|       |#elif TARGET_OS_OSX
 1123|       |    if (self.config.persistenceEnabled) {
 1124|       |        stats[@"persistence.osx.enabled"] = @1;
 1125|       |    }
 1126|       |#endif
 1127|       |    NSString *sdkVersion =
 1128|      0|        [[FIRDatabase sdkVersion] stringByReplacingOccurrencesOfString:@"."
 1129|      0|                                                            withString:@"-"];
 1130|      0|    NSString *sdkStatName =
 1131|      0|        [NSString stringWithFormat:@"sdk.objc.%@", sdkVersion];
 1132|      0|    stats[sdkStatName] = @1;
 1133|      0|    FFLog(@"I-RDB034044", @"Sending first connection stats");
 1134|      0|    [self sendStats:stats];
 1135|      0|}
 1136|       |
 1137|      0|- (NSDictionary *)dumpListens {
 1138|      0|    return self.listens;
 1139|      0|}
 1140|       |
 1141|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FQueryParams.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FQueryParams.h"
   18|       |#import "FConstants.h"
   19|       |#import "FIndex.h"
   20|       |#import "FIndexedFilter.h"
   21|       |#import "FLimitedFilter.h"
   22|       |#import "FNode.h"
   23|       |#import "FNodeFilter.h"
   24|       |#import "FPriorityIndex.h"
   25|       |#import "FRangedFilter.h"
   26|       |#import "FSnapshotUtilities.h"
   27|       |#import "FUtilities.h"
   28|       |#import "FValidation.h"
   29|       |
   30|       |@interface FQueryParams ()
   31|       |
   32|       |@property(nonatomic, readwrite) BOOL limitSet;
   33|       |@property(nonatomic, readwrite) NSInteger limit;
   34|       |
   35|       |@property(nonatomic, strong, readwrite) NSString *viewFrom;
   36|       |/**
   37|       | * indexStartValue is anything you can store as a priority / value.
   38|       | */
   39|       |@property(nonatomic, strong, readwrite) id<FNode> indexStartValue;
   40|       |@property(nonatomic, strong, readwrite) NSString *indexStartKey;
   41|       |/**
   42|       | * indexStartValue is anything you can store as a priority / value.
   43|       | */
   44|       |@property(nonatomic, strong, readwrite) id<FNode> indexEndValue;
   45|       |@property(nonatomic, strong, readwrite) NSString *indexEndKey;
   46|       |
   47|       |@property(nonatomic, strong, readwrite) id<FIndex> index;
   48|       |
   49|       |@end
   50|       |
   51|       |@implementation FQueryParams
   52|       |
   53|      0|+ (FQueryParams *)defaultInstance {
   54|      0|    static FQueryParams *defaultParams = nil;
   55|      0|    static dispatch_once_t defaultParamsToken;
   56|      0|    dispatch_once(&defaultParamsToken, ^{
   57|      0|      defaultParams = [[FQueryParams alloc] init];
   58|      0|    });
   59|      0|    return defaultParams;
   60|      0|}
   61|       |
   62|      0|- (id)init {
   63|      0|    self = [super init];
   64|      0|    if (self) {
   65|      0|        self->_limitSet = NO;
   66|      0|        self->_limit = 0;
   67|      0|
   68|      0|        self->_viewFrom = nil;
   69|      0|        self->_indexStartValue = nil;
   70|      0|        self->_indexStartKey = nil;
   71|      0|        self->_indexEndValue = nil;
   72|      0|        self->_indexEndKey = nil;
   73|      0|
   74|      0|        self->_index = [FPriorityIndex priorityIndex];
   75|      0|    }
   76|      0|    return self;
   77|      0|}
   78|       |
   79|       |/**
   80|       | * Only valid if hasStart is true
   81|       | */
   82|      0|- (id)indexStartValue {
   83|      0|    NSAssert([self hasStart], @"Only valid if start has been set");
   84|      0|    return _indexStartValue;
   85|      0|}
   86|       |
   87|       |/**
   88|       | * Only valid if hasStart is true.
   89|       | * @return The starting key name for the range defined by these query parameters
   90|       | */
   91|      0|- (NSString *)indexStartKey {
   92|      0|    NSAssert([self hasStart], @"Only valid if start has been set");
   93|      0|    if (_indexStartKey == nil) {
   94|      0|        return [FUtilities minName];
   95|      0|    } else {
   96|      0|        return _indexStartKey;
   97|      0|    }
   98|      0|}
   99|       |
  100|       |/**
  101|       | * Only valid if hasEnd is true.
  102|       | */
  103|      0|- (id)indexEndValue {
  104|      0|    NSAssert([self hasEnd], @"Only valid if end has been set");
  105|      0|    return _indexEndValue;
  106|      0|}
  107|       |
  108|       |/**
  109|       | * Only valid if hasEnd is true.
  110|       | * @return The end key name for the range defined by these query parameters
  111|       | */
  112|      0|- (NSString *)indexEndKey {
  113|      0|    NSAssert([self hasEnd], @"Only valid if end has been set");
  114|      0|    if (_indexEndKey == nil) {
  115|      0|        return [FUtilities maxName];
  116|      0|    } else {
  117|      0|        return _indexEndKey;
  118|      0|    }
  119|      0|}
  120|       |
  121|       |/**
  122|       | * @return true if a limit has been set and has been explicitly anchored
  123|       | */
  124|      0|- (BOOL)hasAnchoredLimit {
  125|      0|    return self.limitSet && self.viewFrom != nil;
  126|      0|}
  127|       |
  128|       |/**
  129|       | * Only valid to call if limitSet returns true
  130|       | */
  131|      0|- (NSInteger)limit {
  132|      0|    NSAssert(self.limitSet, @"Only valid if limit has been set");
  133|      0|    return _limit;
  134|      0|}
  135|       |
  136|      0|- (BOOL)hasStart {
  137|      0|    return self->_indexStartValue != nil;
  138|      0|}
  139|       |
  140|      0|- (BOOL)hasEnd {
  141|      0|    return self->_indexEndValue != nil;
  142|      0|}
  143|       |
  144|      0|- (id)copyWithZone:(NSZone *)zone {
  145|      0|    // Immutable
  146|      0|    return self;
  147|      0|}
  148|       |
  149|      0|- (id)mutableCopy {
  150|      0|    FQueryParams *other = [[[self class] alloc] init];
  151|      0|    // Maybe need to do extra copying here
  152|      0|    other->_limitSet = _limitSet;
  153|      0|    other->_limit = _limit;
  154|      0|    other->_indexStartValue = _indexStartValue;
  155|      0|    other->_indexStartKey = _indexStartKey;
  156|      0|    other->_indexEndValue = _indexEndValue;
  157|      0|    other->_indexEndKey = _indexEndKey;
  158|      0|    other->_viewFrom = _viewFrom;
  159|      0|    other->_index = _index;
  160|      0|    return other;
  161|      0|}
  162|       |
  163|      0|- (FQueryParams *)limitTo:(NSInteger)newLimit {
  164|      0|    FQueryParams *newParams = [self mutableCopy];
  165|      0|    newParams->_limitSet = YES;
  166|      0|    newParams->_limit = newLimit;
  167|      0|    newParams->_viewFrom = nil;
  168|      0|    return newParams;
  169|      0|}
  170|       |
  171|      0|- (FQueryParams *)limitToFirst:(NSInteger)newLimit {
  172|      0|    FQueryParams *newParams = [self mutableCopy];
  173|      0|    newParams->_limitSet = YES;
  174|      0|    newParams->_limit = newLimit;
  175|      0|    newParams->_viewFrom = kFQPViewFromLeft;
  176|      0|    return newParams;
  177|      0|}
  178|       |
  179|      0|- (FQueryParams *)limitToLast:(NSInteger)newLimit {
  180|      0|    FQueryParams *newParams = [self mutableCopy];
  181|      0|    newParams->_limitSet = YES;
  182|      0|    newParams->_limit = newLimit;
  183|      0|    newParams->_viewFrom = kFQPViewFromRight;
  184|      0|    return newParams;
  185|      0|}
  186|       |
  187|      0|- (FQueryParams *)startAt:(id<FNode>)indexValue childKey:(NSString *)key {
  188|      0|    NSAssert([indexValue isLeafNode] || [indexValue isEmpty], nil);
  189|      0|    FQueryParams *newParams = [self mutableCopy];
  190|      0|    newParams->_indexStartValue = indexValue;
  191|      0|    newParams->_indexStartKey = key;
  192|      0|    return newParams;
  193|      0|}
  194|       |
  195|      0|- (FQueryParams *)startAt:(id<FNode>)indexValue {
  196|      0|    return [self startAt:indexValue childKey:nil];
  197|      0|}
  198|       |
  199|      0|- (FQueryParams *)endAt:(id<FNode>)indexValue childKey:(NSString *)key {
  200|      0|    NSAssert([indexValue isLeafNode] || [indexValue isEmpty], nil);
  201|      0|    FQueryParams *newParams = [self mutableCopy];
  202|      0|    newParams->_indexEndValue = indexValue;
  203|      0|    newParams->_indexEndKey = key;
  204|      0|    return newParams;
  205|      0|}
  206|       |
  207|      0|- (FQueryParams *)endAt:(id<FNode>)indexValue {
  208|      0|    return [self endAt:indexValue childKey:nil];
  209|      0|}
  210|       |
  211|      0|- (FQueryParams *)orderBy:(id)newIndex {
  212|      0|    FQueryParams *newParams = [self mutableCopy];
  213|      0|    newParams->_index = newIndex;
  214|      0|    return newParams;
  215|      0|}
  216|       |
  217|      0|- (NSDictionary *)wireProtocolParams {
  218|      0|    NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];
  219|      0|    if ([self hasStart]) {
  220|      0|        [dict setObject:[self.indexStartValue valForExport:YES]
  221|      0|                 forKey:kFQPIndexStartValue];
  222|      0|
  223|      0|        // Don't use property as it will be [MIN-NAME]
  224|      0|        if (self->_indexStartKey != nil) {
  225|      0|            [dict setObject:self->_indexStartKey forKey:kFQPIndexStartName];
  226|      0|        }
  227|      0|    }
  228|      0|
  229|      0|    if ([self hasEnd]) {
  230|      0|        [dict setObject:[self.indexEndValue valForExport:YES]
  231|      0|                 forKey:kFQPIndexEndValue];
  232|      0|
  233|      0|        // Don't use property as it will be [MAX-NAME]
  234|      0|        if (self->_indexEndKey != nil) {
  235|      0|            [dict setObject:self->_indexEndKey forKey:kFQPIndexEndName];
  236|      0|        }
  237|      0|    }
  238|      0|
  239|      0|    if (self.limitSet) {
  240|      0|        [dict setObject:[NSNumber numberWithInteger:self.limit]
  241|      0|                 forKey:kFQPLimit];
  242|      0|        NSString *vf = self.viewFrom;
  243|      0|        if (vf == nil) {
  244|      0|            // limit() rather than limitToFirst or limitToLast was called.
  245|      0|            // This means that only one of startSet or endSet is true. Use them
  246|      0|            // to calculate which side of the view to anchor to. If neither is
  247|      0|            // set, Anchor to end
  248|      0|            if ([self hasStart]) {
  249|      0|                vf = kFQPViewFromLeft;
  250|      0|            } else {
  251|      0|                vf = kFQPViewFromRight;
  252|      0|            }
  253|      0|        }
  254|      0|        [dict setObject:vf forKey:kFQPViewFrom];
  255|      0|    }
  256|      0|
  257|      0|    // For now, priority index is the default, so we only specify if it's some
  258|      0|    // other index.
  259|      0|    if (![self.index isEqual:[FPriorityIndex priorityIndex]]) {
  260|      0|        [dict setObject:[self.index queryDefinition] forKey:kFQPIndex];
  261|      0|    }
  262|      0|
  263|      0|    return dict;
  264|      0|}
  265|       |
  266|      0|+ (FQueryParams *)fromQueryObject:(NSDictionary *)dict {
  267|      0|    if (dict.count == 0) {
  268|      0|        return [FQueryParams defaultInstance];
  269|      0|    }
  270|      0|
  271|      0|    FQueryParams *params = [[FQueryParams alloc] init];
  272|      0|    if (dict[kFQPLimit] != nil) {
  273|      0|        params->_limitSet = YES;
  274|      0|        params->_limit = [dict[kFQPLimit] integerValue];
  275|      0|    }
  276|      0|
  277|      0|    if (dict[kFQPIndexStartValue] != nil) {
  278|      0|        params->_indexStartValue =
  279|      0|            [FSnapshotUtilities nodeFrom:dict[kFQPIndexStartValue]];
  280|      0|        if (dict[kFQPIndexStartName] != nil) {
  281|      0|            params->_indexStartKey = dict[kFQPIndexStartName];
  282|      0|        }
  283|      0|    }
  284|      0|
  285|      0|    if (dict[kFQPIndexEndValue] != nil) {
  286|      0|        params->_indexEndValue =
  287|      0|            [FSnapshotUtilities nodeFrom:dict[kFQPIndexEndValue]];
  288|      0|        if (dict[kFQPIndexEndName] != nil) {
  289|      0|            params->_indexEndKey = dict[kFQPIndexEndName];
  290|      0|        }
  291|      0|    }
  292|      0|
  293|      0|    if (dict[kFQPViewFrom] != nil) {
  294|      0|        NSString *viewFrom = dict[kFQPViewFrom];
  295|      0|        if (![viewFrom isEqualToString:kFQPViewFromLeft] &&
  296|      0|            ![viewFrom isEqualToString:kFQPViewFromRight]) {
  297|      0|            [NSException raise:NSInvalidArgumentException
  298|      0|                        format:@"Unknown view from paramter: %@", viewFrom];
  299|      0|        }
  300|      0|        params->_viewFrom = viewFrom;
  301|      0|    }
  302|      0|
  303|      0|    NSString *index = dict[kFQPIndex];
  304|      0|    if (index != nil) {
  305|      0|        params->_index = [FIndex indexFromQueryDefinition:index];
  306|      0|    }
  307|      0|
  308|      0|    return params;
  309|      0|}
  310|       |
  311|      0|- (BOOL)isViewFromLeft {
  312|      0|    if (self.viewFrom != nil) {
  313|      0|        // Not null, we can just check
  314|      0|        return [self.viewFrom isEqualToString:kFQPViewFromLeft];
  315|      0|    } else {
  316|      0|        // If start is set, it's view from left. Otherwise not.
  317|      0|        return self.hasStart;
  318|      0|    }
  319|      0|}
  320|       |
  321|      0|- (id<FNodeFilter>)nodeFilter {
  322|      0|    if (self.loadsAllData) {
  323|      0|        return [[FIndexedFilter alloc] initWithIndex:self.index];
  324|      0|    } else if (self.limitSet) {
  325|      0|        return [[FLimitedFilter alloc] initWithQueryParams:self];
  326|      0|    } else {
  327|      0|        return [[FRangedFilter alloc] initWithQueryParams:self];
  328|      0|    }
  329|      0|}
  330|       |
  331|      0|- (BOOL)isValid {
  332|      0|    return !(self.hasStart && self.hasEnd && self.limitSet &&
  333|      0|             !self.hasAnchoredLimit);
  334|      0|}
  335|       |
  336|      0|- (BOOL)loadsAllData {
  337|      0|    return !(self.hasStart || self.hasEnd || self.limitSet);
  338|      0|}
  339|       |
  340|      0|- (BOOL)isDefault {
  341|      0|    return [self loadsAllData] &&
  342|      0|           [self.index isEqual:[FPriorityIndex priorityIndex]];
  343|      0|}
  344|       |
  345|      0|- (NSString *)description {
  346|      0|    return [[self wireProtocolParams] description];
  347|      0|}
  348|       |
  349|      0|- (BOOL)isEqual:(id)obj {
  350|      0|    if (self == obj) {
  351|      0|        return YES;
  352|      0|    }
  353|      0|    if (![obj isKindOfClass:[self class]]) {
  354|      0|        return NO;
  355|      0|    }
  356|      0|    FQueryParams *other = (FQueryParams *)obj;
  357|      0|    if (self->_limitSet != other->_limitSet)
  358|      0|        return NO;
  359|      0|    if (self->_limit != other->_limit)
  360|      0|        return NO;
  361|      0|    if ((self->_index != other->_index) && !
  362|      0|                                           [self->_index isEqual:other->_index])
  363|      0|        return NO;
  364|      0|    if ((self->_indexStartKey != other->_indexStartKey) &&
  365|      0|        ![self->_indexStartKey isEqualToString:other->_indexStartKey])
  366|      0|        return NO;
  367|      0|    if ((self->_indexStartValue != other->_indexStartValue) &&
  368|      0|        ![self->_indexStartValue isEqual:other->_indexStartValue])
  369|      0|        return NO;
  370|      0|    if ((self->_indexEndKey != other->_indexEndKey) &&
  371|      0|        ![self->_indexEndKey isEqualToString:other->_indexEndKey])
  372|      0|        return NO;
  373|      0|    if ((self->_indexEndValue != other->_indexEndValue) &&
  374|      0|        ![self->_indexEndValue isEqual:other->_indexEndValue])
  375|      0|        return NO;
  376|      0|    if ([self isViewFromLeft] != [other isViewFromLeft])
  377|      0|        return NO;
  378|      0|
  379|      0|    return YES;
  380|      0|}
  381|       |
  382|      0|- (NSUInteger)hash {
  383|      0|    NSUInteger result = _limitSet ? _limit : 0;
  384|      0|    result = 31 * result + ([self isViewFromLeft] ? 1231 : 1237);
  385|      0|    result = 31 * result + [_indexStartKey hash];
  386|      0|    result = 31 * result + [_indexStartValue hash];
  387|      0|    result = 31 * result + [_indexEndKey hash];
  388|      0|    result = 31 * result + [_indexEndValue hash];
  389|      0|    result = 31 * result + [_index hash];
  390|      0|    return result;
  391|      0|}
  392|       |
  393|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FQuerySpec.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FQuerySpec.h"
   18|       |
   19|       |@interface FQuerySpec ()
   20|       |
   21|       |@property(nonatomic, strong, readwrite) FPath *path;
   22|       |@property(nonatomic, strong, readwrite) FQueryParams *params;
   23|       |
   24|       |@end
   25|       |
   26|       |@implementation FQuerySpec
   27|       |
   28|      0|- (id)initWithPath:(FPath *)path params:(FQueryParams *)params {
   29|      0|    self = [super init];
   30|      0|    if (self != nil) {
   31|      0|        self->_path = path;
   32|      0|        self->_params = params;
   33|      0|    }
   34|      0|    return self;
   35|      0|}
   36|       |
   37|      0|+ (FQuerySpec *)defaultQueryAtPath:(FPath *)path {
   38|      0|    return [[FQuerySpec alloc] initWithPath:path
   39|      0|                                     params:[FQueryParams defaultInstance]];
   40|      0|}
   41|       |
   42|      0|- (id)copyWithZone:(NSZone *)zone {
   43|      0|    // Immutable
   44|      0|    return self;
   45|      0|}
   46|       |
   47|      0|- (id<FIndex>)index {
   48|      0|    return self.params.index;
   49|      0|}
   50|       |
   51|      0|- (BOOL)isDefault {
   52|      0|    return self.params.isDefault;
   53|      0|}
   54|       |
   55|      0|- (BOOL)loadsAllData {
   56|      0|    return self.params.loadsAllData;
   57|      0|}
   58|       |
   59|      0|- (BOOL)isEqual:(id)object {
   60|      0|    if (self == object) {
   61|      0|        return YES;
   62|      0|    }
   63|      0|
   64|      0|    if (![object isKindOfClass:[FQuerySpec class]]) {
   65|      0|        return NO;
   66|      0|    }
   67|      0|
   68|      0|    FQuerySpec *other = (FQuerySpec *)object;
   69|      0|
   70|      0|    if (![self.path isEqual:other.path]) {
   71|      0|        return NO;
   72|      0|    }
   73|      0|
   74|      0|    return [self.params isEqual:other.params];
   75|      0|}
   76|       |
   77|      0|- (NSUInteger)hash {
   78|      0|    return self.path.hash * 31 + self.params.hash;
   79|      0|}
   80|       |
   81|      0|- (NSString *)description {
   82|      0|    return [NSString stringWithFormat:@"FQuerySpec (path: %@, params: %@)",
   83|      0|                                      self.path, self.params];
   84|      0|}
   85|       |
   86|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FRangeMerge.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FRangeMerge.h"
   18|       |
   19|       |#import "FEmptyNode.h"
   20|       |
   21|       |@interface FRangeMerge ()
   22|       |
   23|       |@property(nonatomic, strong) FPath *optExclusiveStart;
   24|       |@property(nonatomic, strong) FPath *optInclusiveEnd;
   25|       |@property(nonatomic, strong) id<FNode> updates;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FRangeMerge
   30|       |
   31|       |- (instancetype)initWithStart:(FPath *)start
   32|       |                          end:(FPath *)end
   33|      0|                      updates:(id<FNode>)updates {
   34|      0|    self = [super init];
   35|      0|    if (self != nil) {
   36|      0|        self->_optExclusiveStart = start;
   37|      0|        self->_optInclusiveEnd = end;
   38|      0|        self->_updates = updates;
   39|      0|    }
   40|      0|    return self;
   41|      0|}
   42|       |
   43|      0|- (id<FNode>)applyToNode:(id<FNode>)node {
   44|      0|    return [self updateRangeInNode:[FPath empty]
   45|      0|                              node:node
   46|      0|                           updates:self.updates];
   47|      0|}
   48|       |
   49|       |- (id<FNode>)updateRangeInNode:(FPath *)currentPath
   50|       |                          node:(id<FNode>)node
   51|      0|                       updates:(id<FNode>)updates {
   52|      0|    NSComparisonResult startComparison =
   53|      0|        (self.optExclusiveStart == nil)
   54|      0|            ? NSOrderedDescending
   55|      0|            : [currentPath compare:self.optExclusiveStart];
   56|      0|    NSComparisonResult endComparison =
   57|      0|        (self.optInclusiveEnd == nil)
   58|      0|            ? NSOrderedAscending
   59|      0|            : [currentPath compare:self.optInclusiveEnd];
   60|      0|    BOOL startInNode = self.optExclusiveStart != nil &&
   61|      0|                       [currentPath contains:self.optExclusiveStart];
   62|      0|    BOOL endInNode = self.optInclusiveEnd != nil &&
   63|      0|                     [currentPath contains:self.optInclusiveEnd];
   64|      0|    if (startComparison == NSOrderedDescending &&
   65|      0|        endComparison == NSOrderedAscending && !endInNode) {
   66|      0|        // child is completly contained
   67|      0|        return updates;
   68|      0|    } else if (startComparison == NSOrderedDescending && endInNode &&
   69|      0|               [updates isLeafNode]) {
   70|      0|        return updates;
   71|      0|    } else if (startComparison == NSOrderedDescending &&
   72|      0|               endComparison == NSOrderedSame) {
   73|      0|        NSAssert(endInNode, @"End not in node");
   74|      0|        NSAssert(![updates isLeafNode], @"Found leaf node update, this case "
   75|      0|                                        @"should have been handled above.");
   76|      0|        if ([node isLeafNode]) {
   77|      0|            // Update node was not a leaf node, so we can delete it
   78|      0|            return [FEmptyNode emptyNode];
   79|      0|        } else {
   80|      0|            // Unaffected by range, ignore
   81|      0|            return node;
   82|      0|        }
   83|      0|    } else if (startInNode || endInNode) {
   84|      0|        // There is a partial update we need to do, so collect all relevant
   85|      0|        // children
   86|      0|        NSMutableSet *allChildren = [NSMutableSet set];
   87|      0|        [node enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
   88|      0|                                            BOOL *stop) {
   89|      0|          [allChildren addObject:key];
   90|      0|        }];
   91|      0|        [updates enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
   92|      0|                                               BOOL *stop) {
   93|      0|          [allChildren addObject:key];
   94|      0|        }];
   95|      0|
   96|      0|        __block id<FNode> newNode = node;
   97|      0|        void (^action)(id, BOOL *) = ^void(NSString *key, BOOL *stop) {
   98|      0|          id<FNode> currentChild = [node getImmediateChild:key];
   99|      0|          id<FNode> updatedChild =
  100|      0|              [self updateRangeInNode:[currentPath childFromString:key]
  101|      0|                                 node:currentChild
  102|      0|                              updates:[updates getImmediateChild:key]];
  103|      0|          // Only need to update if the node changed
  104|      0|          if (updatedChild != currentChild) {
  105|      0|              newNode = [newNode updateImmediateChild:key
  106|      0|                                         withNewChild:updatedChild];
  107|      0|          }
  108|      0|        };
  109|      0|
  110|      0|        [allChildren enumerateObjectsUsingBlock:action];
  111|      0|
  112|      0|        // Add priority last, so the node is not empty when applying
  113|      0|        if (!updates.getPriority.isEmpty || !node.getPriority.isEmpty) {
  114|      0|            BOOL stop = NO;
  115|      0|            action(@".priority", &stop);
  116|      0|        }
  117|      0|        return newNode;
  118|      0|    } else {
  119|      0|        // Unaffected by this range
  120|      0|        NSAssert(endComparison == NSOrderedDescending ||
  121|      0|                     startComparison <= NSOrderedSame,
  122|      0|                 @"Invalid range for update");
  123|      0|        return node;
  124|      0|    }
  125|      0|}
  126|       |
  127|      0|- (NSString *)description {
  128|      0|    return [NSString stringWithFormat:@"RangeMerge (optExclusiveStart = %@, "
  129|      0|                                      @"optExclusiveEng = %@, updates = %@)",
  130|      0|                                      self.optExclusiveStart,
  131|      0|                                      self.optInclusiveEnd, self.updates];
  132|      0|}
  133|       |
  134|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FRepo.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import "FAtomicNumber.h"
   20|       |#import "FCachePolicy.h"
   21|       |#import "FClock.h"
   22|       |#import "FConstants.h"
   23|       |#import "FEmptyNode.h"
   24|       |#import "FEventRaiser.h"
   25|       |#import "FEventRegistration.h"
   26|       |#import "FIRDataSnapshot.h"
   27|       |#import "FIRDataSnapshot_Private.h"
   28|       |#import "FIRDatabaseConfig_Private.h"
   29|       |#import "FIRDatabaseQuery_Private.h"
   30|       |#import "FIRDatabase_Private.h"
   31|       |#import "FIRMutableData.h"
   32|       |#import "FIRMutableData_Private.h"
   33|       |#import "FIRTransactionResult.h"
   34|       |#import "FIRTransactionResult_Private.h"
   35|       |#import "FLevelDBStorageEngine.h"
   36|       |#import "FListenProvider.h"
   37|       |#import "FPersistenceManager.h"
   38|       |#import "FQuerySpec.h"
   39|       |#import "FRepo.h"
   40|       |#import "FRepoManager.h"
   41|       |#import "FRepo_Private.h"
   42|       |#import "FServerValues.h"
   43|       |#import "FSnapshotHolder.h"
   44|       |#import "FSnapshotUtilities.h"
   45|       |#import "FSyncTree.h"
   46|       |#import "FTree.h"
   47|       |#import "FTupleNodePath.h"
   48|       |#import "FTupleSetIdPath.h"
   49|       |#import "FTupleTransaction.h"
   50|       |#import "FValueEventRegistration.h"
   51|       |#import "FWriteRecord.h"
   52|       |#import <FirebaseCore/FIRLogger.h>
   53|       |#import <dlfcn.h>
   54|       |
   55|       |#if TARGET_OS_IOS || TARGET_OS_TV
   56|       |#import <UIKit/UIKit.h>
   57|       |#endif
   58|       |
   59|       |@interface FRepo ()
   60|       |
   61|       |@property(nonatomic, strong) FOffsetClock *serverClock;
   62|       |@property(nonatomic, strong) FPersistenceManager *persistenceManager;
   63|       |@property(nonatomic, strong) FIRDatabase *database;
   64|       |@property(nonatomic, strong, readwrite) FAuthenticationManager *auth;
   65|       |@property(nonatomic, strong) FSyncTree *infoSyncTree;
   66|       |@property(nonatomic) NSInteger writeIdCounter;
   67|       |@property(nonatomic) BOOL hijackHash;
   68|       |@property(nonatomic, strong) FTree *transactionQueueTree;
   69|       |@property(nonatomic) BOOL loggedTransactionPersistenceWarning;
   70|       |
   71|       |/**
   72|       | * Test only. For load testing the server.
   73|       | */
   74|       |@property(nonatomic, strong) id (^interceptServerDataCallback)
   75|       |    (NSString *pathString, id data);
   76|       |@end
   77|       |
   78|       |@implementation FRepo
   79|       |
   80|       |- (id)initWithRepoInfo:(FRepoInfo *)info
   81|       |                config:(FIRDatabaseConfig *)config
   82|      0|              database:(FIRDatabase *)database {
   83|      0|    self = [super init];
   84|      0|    if (self) {
   85|      0|        self.repoInfo = info;
   86|      0|        self.config = config;
   87|      0|        self.database = database;
   88|      0|
   89|      0|        // Access can occur outside of shared queue, so the clock needs to be
   90|      0|        // initialized here
   91|      0|        self.serverClock =
   92|      0|            [[FOffsetClock alloc] initWithClock:[FSystemClock clock] offset:0];
   93|      0|
   94|      0|        self.connection = [[FPersistentConnection alloc]
   95|      0|            initWithRepoInfo:self.repoInfo
   96|      0|               dispatchQueue:[FIRDatabaseQuery sharedQueue]
   97|      0|                      config:self.config];
   98|      0|
   99|      0|        // Needs to be called before authentication manager is instantiated
  100|      0|        self.eventRaiser =
  101|      0|            [[FEventRaiser alloc] initWithQueue:self.config.callbackQueue];
  102|      0|
  103|      0|        dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  104|      0|          [self deferredInit];
  105|      0|        });
  106|      0|    }
  107|      0|    return self;
  108|      0|}
  109|       |
  110|      0|- (void)deferredInit {
  111|      0|    // TODO: cleanup on dealloc
  112|      0|    __weak FRepo *weakSelf = self;
  113|      0|    [self.config.authTokenProvider listenForTokenChanges:^(NSString *token) {
  114|      0|      [weakSelf.connection refreshAuthToken:token];
  115|      0|    }];
  116|      0|
  117|      0|    // Open connection now so that by the time we are connected the deferred
  118|      0|    // init has run This relies on the fact that all callbacks run on repos
  119|      0|    // queue
  120|      0|    self.connection.delegate = self;
  121|      0|    [self.connection open];
  122|      0|
  123|      0|    self.dataUpdateCount = 0;
  124|      0|    self.rangeMergeUpdateCount = 0;
  125|      0|    self.interceptServerDataCallback = nil;
  126|      0|
  127|      0|    if (self.config.persistenceEnabled) {
  128|      0|        NSString *repoHashString =
  129|      0|            [NSString stringWithFormat:@"%@_%@", self.repoInfo.host,
  130|      0|                                       self.repoInfo.namespace];
  131|      0|        NSString *persistencePrefix =
  132|      0|            [NSString stringWithFormat:@"%@/%@", self.config.sessionIdentifier,
  133|      0|                                       repoHashString];
  134|      0|
  135|      0|        id<FCachePolicy> cachePolicy = [[FLRUCachePolicy alloc]
  136|      0|            initWithMaxSize:self.config.persistenceCacheSizeBytes];
  137|      0|
  138|      0|        id<FStorageEngine> engine;
  139|      0|        if (self.config.forceStorageEngine != nil) {
  140|      0|            engine = self.config.forceStorageEngine;
  141|      0|        } else {
  142|      0|            FLevelDBStorageEngine *levelDBEngine =
  143|      0|                [[FLevelDBStorageEngine alloc] initWithPath:persistencePrefix];
  144|      0|            // We need the repo info to run the legacy migration. Future
  145|      0|            // migrations will be managed by the database itself Remove this
  146|      0|            // once we are confident that no-one is using legacy migration
  147|      0|            // anymore...
  148|      0|            [levelDBEngine runLegacyMigration:self.repoInfo];
  149|      0|            engine = levelDBEngine;
  150|      0|        }
  151|      0|
  152|      0|        self.persistenceManager =
  153|      0|            [[FPersistenceManager alloc] initWithStorageEngine:engine
  154|      0|                                                   cachePolicy:cachePolicy];
  155|      0|    } else {
  156|      0|        self.persistenceManager = nil;
  157|      0|    }
  158|      0|
  159|      0|    [self initTransactions];
  160|      0|
  161|      0|    // A list of data pieces and paths to be set when this client disconnects
  162|      0|    self.onDisconnect = [[FSparseSnapshotTree alloc] init];
  163|      0|    self.infoData = [[FSnapshotHolder alloc] init];
  164|      0|
  165|      0|    FListenProvider *infoListenProvider = [[FListenProvider alloc] init];
  166|      0|    infoListenProvider.startListening =
  167|      0|        ^(FQuerySpec *query, NSNumber *tagId, id<FSyncTreeHash> hash,
  168|      0|          fbt_nsarray_nsstring onComplete) {
  169|      0|          NSArray *infoEvents = @[];
  170|      0|          FRepo *strongSelf = weakSelf;
  171|      0|          id<FNode> node = [strongSelf.infoData getNode:query.path];
  172|      0|          // This is possibly a hack, but we have different semantics for .info
  173|      0|          // endpoints. We don't raise null events on initial data...
  174|      0|          if (![node isEmpty]) {
  175|      0|              infoEvents =
  176|      0|                  [strongSelf.infoSyncTree applyServerOverwriteAtPath:query.path
  177|      0|                                                              newData:node];
  178|      0|              [strongSelf.eventRaiser raiseCallback:^{
  179|      0|                onComplete(kFWPResponseForActionStatusOk);
  180|      0|              }];
  181|      0|          }
  182|      0|          return infoEvents;
  183|      0|        };
  184|      0|    infoListenProvider.stopListening = ^(FQuerySpec *query, NSNumber *tagId) {
  185|      0|    };
  186|      0|    self.infoSyncTree =
  187|      0|        [[FSyncTree alloc] initWithListenProvider:infoListenProvider];
  188|      0|
  189|      0|    FListenProvider *serverListenProvider = [[FListenProvider alloc] init];
  190|      0|    serverListenProvider.startListening =
  191|      0|        ^(FQuerySpec *query, NSNumber *tagId, id<FSyncTreeHash> hash,
  192|      0|          fbt_nsarray_nsstring onComplete) {
  193|      0|          [weakSelf.connection listen:query
  194|      0|                                tagId:tagId
  195|      0|                                 hash:hash
  196|      0|                           onComplete:^(NSString *status) {
  197|      0|                             NSArray *events = onComplete(status);
  198|      0|                             [weakSelf.eventRaiser raiseEvents:events];
  199|      0|                           }];
  200|      0|          // No synchronous events for network-backed sync trees
  201|      0|          return @[];
  202|      0|        };
  203|      0|    serverListenProvider.stopListening = ^(FQuerySpec *query, NSNumber *tag) {
  204|      0|      [weakSelf.connection unlisten:query tagId:tag];
  205|      0|    };
  206|      0|    self.serverSyncTree =
  207|      0|        [[FSyncTree alloc] initWithPersistenceManager:self.persistenceManager
  208|      0|                                       listenProvider:serverListenProvider];
  209|      0|
  210|      0|    [self restoreWrites];
  211|      0|
  212|      0|    [self updateInfo:kDotInfoConnected withValue:@NO];
  213|      0|
  214|      0|    [self setupNotifications];
  215|      0|}
  216|       |
  217|      0|- (void)restoreWrites {
  218|      0|    NSArray *writes = self.persistenceManager.userWrites;
  219|      0|
  220|      0|    NSDictionary *serverValues =
  221|      0|        [FServerValues generateServerValues:self.serverClock];
  222|      0|    __block NSInteger lastWriteId = NSIntegerMin;
  223|      0|    [writes enumerateObjectsUsingBlock:^(FWriteRecord *write, NSUInteger idx,
  224|      0|                                         BOOL *stop) {
  225|      0|      NSInteger writeId = write.writeId;
  226|      0|      fbt_void_nsstring_nsstring callback =
  227|      0|          ^(NSString *status, NSString *errorReason) {
  228|      0|            [self warnIfWriteFailedAtPath:write.path
  229|      0|                                   status:status
  230|      0|                                  message:@"Persisted write"];
  231|      0|            [self ackWrite:writeId
  232|      0|                rerunTransactionsAtPath:write.path
  233|      0|                                 status:status];
  234|      0|          };
  235|      0|      if (lastWriteId >= writeId) {
  236|      0|          [NSException raise:NSInternalInconsistencyException
  237|      0|                      format:@"Restored writes were not in order!"];
  238|      0|      }
  239|      0|      lastWriteId = writeId;
  240|      0|      self.writeIdCounter = writeId + 1;
  241|      0|      if ([write isOverwrite]) {
  242|      0|          FFLog(@"I-RDB038001", @"Restoring overwrite with id %ld",
  243|      0|                (long)write.writeId);
  244|      0|          [self.connection putData:[write.overwrite valForExport:YES]
  245|      0|                           forPath:[write.path toString]
  246|      0|                          withHash:nil
  247|      0|                      withCallback:callback];
  248|      0|          id<FNode> resolved =
  249|      0|              [FServerValues resolveDeferredValueSnapshot:write.overwrite
  250|      0|                                         withServerValues:serverValues];
  251|      0|          [self.serverSyncTree applyUserOverwriteAtPath:write.path
  252|      0|                                                newData:resolved
  253|      0|                                                writeId:writeId
  254|      0|                                              isVisible:YES];
  255|      0|      } else {
  256|      0|          FFLog(@"I-RDB038002", @"Restoring merge with id %ld",
  257|      0|                (long)write.writeId);
  258|      0|          [self.connection mergeData:[write.merge valForExport:YES]
  259|      0|                             forPath:[write.path toString]
  260|      0|                        withCallback:callback];
  261|      0|          FCompoundWrite *resolved =
  262|      0|              [FServerValues resolveDeferredValueCompoundWrite:write.merge
  263|      0|                                              withServerValues:serverValues];
  264|      0|          [self.serverSyncTree applyUserMergeAtPath:write.path
  265|      0|                                    changedChildren:resolved
  266|      0|                                            writeId:writeId];
  267|      0|      }
  268|      0|    }];
  269|      0|}
  270|       |
  271|      0|- (NSString *)name {
  272|      0|    return self.repoInfo.namespace;
  273|      0|}
  274|       |
  275|      0|- (NSString *)description {
  276|      0|    return [self.repoInfo description];
  277|      0|}
  278|       |
  279|      0|- (void)interrupt {
  280|      0|    [self.connection interruptForReason:kFInterruptReasonRepoInterrupt];
  281|      0|}
  282|       |
  283|      0|- (void)resume {
  284|      0|    [self.connection resumeForReason:kFInterruptReasonRepoInterrupt];
  285|      0|}
  286|       |
  287|       |// NOTE: Typically if you're calling this, you should be in an @autoreleasepool
  288|       |// block to make sure that ARC kicks in and cleans up things no longer
  289|       |// referenced (i.e. pendingPutsDB).
  290|      0|- (void)dispose {
  291|      0|    [self.connection interruptForReason:kFInterruptReasonRepoInterrupt];
  292|      0|
  293|      0|    // We need to nil out any references to LevelDB, to make sure the
  294|      0|    // LevelDB exclusive locks are released.
  295|      0|    [self.persistenceManager close];
  296|      0|}
  297|       |
  298|      0|- (NSInteger)nextWriteId {
  299|      0|    return self->_writeIdCounter++;
  300|      0|}
  301|       |
  302|      0|- (NSTimeInterval)serverTime {
  303|      0|    return [self.serverClock currentTime];
  304|      0|}
  305|       |
  306|       |- (void)set:(FPath *)path
  307|       |        withNode:(id<FNode>)node
  308|      0|    withCallback:(fbt_void_nserror_ref)onComplete {
  309|      0|    id value = [node valForExport:YES];
  310|      0|    FFLog(@"I-RDB038003", @"Setting: %@ with %@ pri: %@", [path toString],
  311|      0|          [value description], [[node getPriority] val]);
  312|      0|
  313|      0|    // TODO: Optimize this behavior to either (a) store flag to skip resolving
  314|      0|    // where possible and / or (b) store unresolved paths on JSON parse
  315|      0|    NSDictionary *serverValues =
  316|      0|        [FServerValues generateServerValues:self.serverClock];
  317|      0|    id<FNode> newNode =
  318|      0|        [FServerValues resolveDeferredValueSnapshot:node
  319|      0|                                   withServerValues:serverValues];
  320|      0|
  321|      0|    NSInteger writeId = [self nextWriteId];
  322|      0|    [self.persistenceManager saveUserOverwrite:node
  323|      0|                                        atPath:path
  324|      0|                                       writeId:writeId];
  325|      0|    NSArray *events = [self.serverSyncTree applyUserOverwriteAtPath:path
  326|      0|                                                            newData:newNode
  327|      0|                                                            writeId:writeId
  328|      0|                                                          isVisible:YES];
  329|      0|    [self.eventRaiser raiseEvents:events];
  330|      0|
  331|      0|    [self.connection putData:value
  332|      0|                     forPath:[path toString]
  333|      0|                    withHash:nil
  334|      0|                withCallback:^(NSString *status, NSString *errorReason) {
  335|      0|                  [self warnIfWriteFailedAtPath:path
  336|      0|                                         status:status
  337|      0|                                        message:@"setValue: or removeValue:"];
  338|      0|                  [self ackWrite:writeId
  339|      0|                      rerunTransactionsAtPath:path
  340|      0|                                       status:status];
  341|      0|                  [self callOnComplete:onComplete
  342|      0|                            withStatus:status
  343|      0|                           errorReason:errorReason
  344|      0|                               andPath:path];
  345|      0|                }];
  346|      0|
  347|      0|    FPath *affectedPath = [self abortTransactionsAtPath:path
  348|      0|                                                  error:kFTransactionSet];
  349|      0|    [self rerunTransactionsForPath:affectedPath];
  350|      0|}
  351|       |
  352|       |- (void)update:(FPath *)path
  353|       |       withNodes:(FCompoundWrite *)nodes
  354|      0|    withCallback:(fbt_void_nserror_ref)callback {
  355|      0|    NSDictionary *values = [nodes valForExport:YES];
  356|      0|
  357|      0|    FFLog(@"I-RDB038004", @"Updating: %@ with %@", [path toString],
  358|      0|          [values description]);
  359|      0|    NSDictionary *serverValues =
  360|      0|        [FServerValues generateServerValues:self.serverClock];
  361|      0|    FCompoundWrite *resolved =
  362|      0|        [FServerValues resolveDeferredValueCompoundWrite:nodes
  363|      0|                                        withServerValues:serverValues];
  364|      0|
  365|      0|    if (!resolved.isEmpty) {
  366|      0|        NSInteger writeId = [self nextWriteId];
  367|      0|        [self.persistenceManager saveUserMerge:nodes
  368|      0|                                        atPath:path
  369|      0|                                       writeId:writeId];
  370|      0|        NSArray *events = [self.serverSyncTree applyUserMergeAtPath:path
  371|      0|                                                    changedChildren:resolved
  372|      0|                                                            writeId:writeId];
  373|      0|        [self.eventRaiser raiseEvents:events];
  374|      0|
  375|      0|        [self.connection mergeData:values
  376|      0|                           forPath:[path description]
  377|      0|                      withCallback:^(NSString *status, NSString *errorReason) {
  378|      0|                        [self warnIfWriteFailedAtPath:path
  379|      0|                                               status:status
  380|      0|                                              message:@"updateChildValues:"];
  381|      0|                        [self ackWrite:writeId
  382|      0|                            rerunTransactionsAtPath:path
  383|      0|                                             status:status];
  384|      0|                        [self callOnComplete:callback
  385|      0|                                  withStatus:status
  386|      0|                                 errorReason:errorReason
  387|      0|                                     andPath:path];
  388|      0|                      }];
  389|      0|
  390|      0|        [nodes enumerateWrites:^(FPath *childPath, id<FNode> node, BOOL *stop) {
  391|      0|          FPath *pathFromRoot = [path child:childPath];
  392|      0|          FFLog(@"I-RDB038005", @"Cancelling transactions at path: %@",
  393|      0|                pathFromRoot);
  394|      0|          FPath *affectedPath = [self abortTransactionsAtPath:pathFromRoot
  395|      0|                                                        error:kFTransactionSet];
  396|      0|          [self rerunTransactionsForPath:affectedPath];
  397|      0|        }];
  398|      0|    } else {
  399|      0|        FFLog(@"I-RDB038006", @"update called with empty data. Doing nothing");
  400|      0|        // Do nothing, just call the callback
  401|      0|        [self callOnComplete:callback
  402|      0|                  withStatus:@"ok"
  403|      0|                 errorReason:nil
  404|      0|                     andPath:path];
  405|      0|    }
  406|      0|}
  407|       |
  408|       |- (void)onDisconnectCancel:(FPath *)path
  409|      0|              withCallback:(fbt_void_nserror_ref)callback {
  410|      0|    [self.connection
  411|      0|        onDisconnectCancelPath:path
  412|      0|                  withCallback:^(NSString *status, NSString *errorReason) {
  413|      0|                    BOOL success =
  414|      0|                        [status isEqualToString:kFWPResponseForActionStatusOk];
  415|      0|                    if (success) {
  416|      0|                        [self.onDisconnect forgetPath:path];
  417|      0|                    } else {
  418|      0|                        FFLog(@"I-RDB038007",
  419|      0|                              @"cancelDisconnectOperations: at %@ failed: %@",
  420|      0|                              path, status);
  421|      0|                    }
  422|      0|
  423|      0|                    [self callOnComplete:callback
  424|      0|                              withStatus:status
  425|      0|                             errorReason:errorReason
  426|      0|                                 andPath:path];
  427|      0|                  }];
  428|      0|}
  429|       |
  430|       |- (void)onDisconnectSet:(FPath *)path
  431|       |               withNode:(id<FNode>)node
  432|      0|           withCallback:(fbt_void_nserror_ref)callback {
  433|      0|    [self.connection
  434|      0|        onDisconnectPutData:[node valForExport:YES]
  435|      0|                    forPath:path
  436|      0|               withCallback:^(NSString *status, NSString *errorReason) {
  437|      0|                 BOOL success =
  438|      0|                     [status isEqualToString:kFWPResponseForActionStatusOk];
  439|      0|                 if (success) {
  440|      0|                     [self.onDisconnect rememberData:node onPath:path];
  441|      0|                 } else {
  442|      0|                     FFWarn(@"I-RDB038008",
  443|      0|                            @"onDisconnectSetValue: or "
  444|      0|                            @"onDisconnectRemoveValue: at %@ failed: %@",
  445|      0|                            path, status);
  446|      0|                 }
  447|      0|
  448|      0|                 [self callOnComplete:callback
  449|      0|                           withStatus:status
  450|      0|                          errorReason:errorReason
  451|      0|                              andPath:path];
  452|      0|               }];
  453|      0|}
  454|       |
  455|       |- (void)onDisconnectUpdate:(FPath *)path
  456|       |                 withNodes:(FCompoundWrite *)nodes
  457|      0|              withCallback:(fbt_void_nserror_ref)callback {
  458|      0|    if (!nodes.isEmpty) {
  459|      0|        NSDictionary *values = [nodes valForExport:YES];
  460|      0|
  461|      0|        [self.connection
  462|      0|            onDisconnectMergeData:values
  463|      0|                          forPath:path
  464|      0|                     withCallback:^(NSString *status, NSString *errorReason) {
  465|      0|                       BOOL success = [status
  466|      0|                           isEqualToString:kFWPResponseForActionStatusOk];
  467|      0|                       if (success) {
  468|      0|                           [nodes enumerateWrites:^(FPath *relativePath,
  469|      0|                                                    id<FNode> nodeUnresolved,
  470|      0|                                                    BOOL *stop) {
  471|      0|                             FPath *childPath = [path child:relativePath];
  472|      0|                             [self.onDisconnect rememberData:nodeUnresolved
  473|      0|                                                      onPath:childPath];
  474|      0|                           }];
  475|      0|                       } else {
  476|      0|                           FFWarn(@"I-RDB038009",
  477|      0|                                  @"onDisconnectUpdateChildValues: at %@ "
  478|      0|                                  @"failed %@",
  479|      0|                                  path, status);
  480|      0|                       }
  481|      0|
  482|      0|                       [self callOnComplete:callback
  483|      0|                                 withStatus:status
  484|      0|                                errorReason:errorReason
  485|      0|                                    andPath:path];
  486|      0|                     }];
  487|      0|    } else {
  488|      0|        // Do nothing, just call the callback
  489|      0|        [self callOnComplete:callback
  490|      0|                  withStatus:@"ok"
  491|      0|                 errorReason:nil
  492|      0|                     andPath:path];
  493|      0|    }
  494|      0|}
  495|       |
  496|      0|- (void)purgeOutstandingWrites {
  497|      0|    FFLog(@"I-RDB038010", @"Purging outstanding writes");
  498|      0|    NSArray *events = [self.serverSyncTree removeAllWrites];
  499|      0|    [self.eventRaiser raiseEvents:events];
  500|      0|    // Abort any transactions
  501|      0|    [self abortTransactionsAtPath:[FPath empty] error:kFErrorWriteCanceled];
  502|      0|    // Remove outstanding writes from connection
  503|      0|    [self.connection purgeOutstandingWrites];
  504|      0|}
  505|       |
  506|       |- (void)addEventRegistration:(id<FEventRegistration>)eventRegistration
  507|      0|                    forQuery:(FQuerySpec *)query {
  508|      0|    NSArray *events = nil;
  509|      0|    if ([[query.path getFront] isEqualToString:kDotInfoPrefix]) {
  510|      0|        events = [self.infoSyncTree addEventRegistration:eventRegistration
  511|      0|                                                forQuery:query];
  512|      0|    } else {
  513|      0|        events = [self.serverSyncTree addEventRegistration:eventRegistration
  514|      0|                                                  forQuery:query];
  515|      0|    }
  516|      0|    [self.eventRaiser raiseEvents:events];
  517|      0|}
  518|       |
  519|       |- (void)removeEventRegistration:(id<FEventRegistration>)eventRegistration
  520|      0|                       forQuery:(FQuerySpec *)query {
  521|      0|    // These are guaranteed not to raise events, since we're not passing in a
  522|      0|    // cancelError. However we can future-proof a little bit by handling the
  523|      0|    // return values anyways.
  524|      0|    FFLog(@"I-RDB038011", @"Removing event registration with hande: %lu",
  525|      0|          (unsigned long)eventRegistration.handle);
  526|      0|    NSArray *events = nil;
  527|      0|    if ([[query.path getFront] isEqualToString:kDotInfoPrefix]) {
  528|      0|        events = [self.infoSyncTree removeEventRegistration:eventRegistration
  529|      0|                                                   forQuery:query
  530|      0|                                                cancelError:nil];
  531|      0|    } else {
  532|      0|        events = [self.serverSyncTree removeEventRegistration:eventRegistration
  533|      0|                                                     forQuery:query
  534|      0|                                                  cancelError:nil];
  535|      0|    }
  536|      0|    [self.eventRaiser raiseEvents:events];
  537|      0|}
  538|       |
  539|      0|- (void)keepQuery:(FQuerySpec *)query synced:(BOOL)synced {
  540|      0|    NSAssert(![[query.path getFront] isEqualToString:kDotInfoPrefix],
  541|      0|             @"Can't keep .info tree synced!");
  542|      0|    [self.serverSyncTree keepQuery:query synced:synced];
  543|      0|}
  544|       |
  545|      0|- (void)updateInfo:(NSString *)pathString withValue:(id)value {
  546|      0|    // hack to make serverTimeOffset available in a threadsafe way. Property is
  547|      0|    // marked as atomic
  548|      0|    if ([pathString isEqualToString:kDotInfoServerTimeOffset]) {
  549|      0|        NSTimeInterval offset = [(NSNumber *)value doubleValue] / 1000.0;
  550|      0|        self.serverClock =
  551|      0|            [[FOffsetClock alloc] initWithClock:[FSystemClock clock]
  552|      0|                                         offset:offset];
  553|      0|    }
  554|      0|
  555|      0|    FPath *path = [[FPath alloc]
  556|      0|        initWith:[NSString
  557|      0|                     stringWithFormat:@"%@/%@", kDotInfoPrefix, pathString]];
  558|      0|    id<FNode> newNode = [FSnapshotUtilities nodeFrom:value];
  559|      0|    [self.infoData updateSnapshot:path withNewSnapshot:newNode];
  560|      0|    NSArray *events = [self.infoSyncTree applyServerOverwriteAtPath:path
  561|      0|                                                            newData:newNode];
  562|      0|    [self.eventRaiser raiseEvents:events];
  563|      0|}
  564|       |
  565|       |- (void)callOnComplete:(fbt_void_nserror_ref)onComplete
  566|       |            withStatus:(NSString *)status
  567|       |           errorReason:(NSString *)errorReason
  568|      0|               andPath:(FPath *)path {
  569|      0|    if (onComplete) {
  570|      0|        FIRDatabaseReference *ref =
  571|      0|            [[FIRDatabaseReference alloc] initWithRepo:self path:path];
  572|      0|        BOOL statusOk = [status isEqualToString:kFWPResponseForActionStatusOk];
  573|      0|        NSError *err = nil;
  574|      0|        if (!statusOk) {
  575|      0|            err = [FUtilities errorForStatus:status andReason:errorReason];
  576|      0|        }
  577|      0|        [self.eventRaiser raiseCallback:^{
  578|      0|          onComplete(err, ref);
  579|      0|        }];
  580|      0|    }
  581|      0|}
  582|       |
  583|       |- (void)ackWrite:(NSInteger)writeId
  584|       |    rerunTransactionsAtPath:(FPath *)path
  585|      0|                     status:(NSString *)status {
  586|      0|    if ([status isEqualToString:kFErrorWriteCanceled]) {
  587|      0|        // This write was already removed, we just need to ignore it...
  588|      0|    } else {
  589|      0|        BOOL success = [status isEqualToString:kFWPResponseForActionStatusOk];
  590|      0|        NSArray *clearEvents =
  591|      0|            [self.serverSyncTree ackUserWriteWithWriteId:writeId
  592|      0|                                                  revert:!success
  593|      0|                                                 persist:YES
  594|      0|                                                   clock:self.serverClock];
  595|      0|        if ([clearEvents count] > 0) {
  596|      0|            [self rerunTransactionsForPath:path];
  597|      0|        }
  598|      0|        [self.eventRaiser raiseEvents:clearEvents];
  599|      0|    }
  600|      0|}
  601|       |
  602|       |- (void)warnIfWriteFailedAtPath:(FPath *)path
  603|       |                         status:(NSString *)status
  604|      0|                        message:(NSString *)message {
  605|      0|    if (!([status isEqualToString:kFWPResponseForActionStatusOk] ||
  606|      0|          [status isEqualToString:kFErrorWriteCanceled])) {
  607|      0|        FFWarn(@"I-RDB038012", @"%@ at %@ failed: %@", message, path, status);
  608|      0|    }
  609|      0|}
  610|       |
  611|       |#pragma mark -
  612|       |#pragma mark FPersistentConnectionDelegate methods
  613|       |
  614|       |- (void)onDataUpdate:(FPersistentConnection *)fpconnection
  615|       |             forPath:(NSString *)pathString
  616|       |             message:(id)data
  617|       |             isMerge:(BOOL)isMerge
  618|      0|               tagId:(NSNumber *)tagId {
  619|      0|    FFLog(@"I-RDB038013", @"onDataUpdateForPath: %@ withMessage: %@",
  620|      0|          pathString, data);
  621|      0|
  622|      0|    // For testing.
  623|      0|    self.dataUpdateCount++;
  624|      0|
  625|      0|    FPath *path = [[FPath alloc] initWith:pathString];
  626|      0|    data = self.interceptServerDataCallback
  627|      0|               ? self.interceptServerDataCallback(pathString, data)
  628|      0|               : data;
  629|      0|    NSArray *events = nil;
  630|      0|
  631|      0|    if (tagId != nil) {
  632|      0|        if (isMerge) {
  633|      0|            NSDictionary *message = data;
  634|      0|            FCompoundWrite *taggedChildren =
  635|      0|                [FCompoundWrite compoundWriteWithValueDictionary:message];
  636|      0|            events =
  637|      0|                [self.serverSyncTree applyTaggedQueryMergeAtPath:path
  638|      0|                                                 changedChildren:taggedChildren
  639|      0|                                                           tagId:tagId];
  640|      0|        } else {
  641|      0|            id<FNode> taggedSnap = [FSnapshotUtilities nodeFrom:data];
  642|      0|            events =
  643|      0|                [self.serverSyncTree applyTaggedQueryOverwriteAtPath:path
  644|      0|                                                             newData:taggedSnap
  645|      0|                                                               tagId:tagId];
  646|      0|        }
  647|      0|    } else if (isMerge) {
  648|      0|        NSDictionary *message = data;
  649|      0|        FCompoundWrite *changedChildren =
  650|      0|            [FCompoundWrite compoundWriteWithValueDictionary:message];
  651|      0|        events = [self.serverSyncTree applyServerMergeAtPath:path
  652|      0|                                             changedChildren:changedChildren];
  653|      0|    } else {
  654|      0|        id<FNode> snap = [FSnapshotUtilities nodeFrom:data];
  655|      0|        events = [self.serverSyncTree applyServerOverwriteAtPath:path
  656|      0|                                                         newData:snap];
  657|      0|    }
  658|      0|
  659|      0|    if ([events count] > 0) {
  660|      0|        // Since we have a listener outstanding for each transaction, receiving
  661|      0|        // any events is a proxy for some change having occurred.
  662|      0|        [self rerunTransactionsForPath:path];
  663|      0|    }
  664|      0|
  665|      0|    [self.eventRaiser raiseEvents:events];
  666|      0|}
  667|       |
  668|       |- (void)onRangeMerge:(NSArray *)ranges
  669|       |             forPath:(NSString *)pathString
  670|      0|               tagId:(NSNumber *)tag {
  671|      0|    FFLog(@"I-RDB038014", @"onRangeMerge: %@ => %@", pathString, ranges);
  672|      0|
  673|      0|    // For testing
  674|      0|    self.rangeMergeUpdateCount++;
  675|      0|
  676|      0|    FPath *path = [[FPath alloc] initWith:pathString];
  677|      0|    NSArray *events;
  678|      0|    if (tag != nil) {
  679|      0|        events = [self.serverSyncTree applyTaggedServerRangeMergeAtPath:path
  680|      0|                                                                updates:ranges
  681|      0|                                                                  tagId:tag];
  682|      0|    } else {
  683|      0|        events = [self.serverSyncTree applyServerRangeMergeAtPath:path
  684|      0|                                                          updates:ranges];
  685|      0|    }
  686|      0|    if (events.count > 0) {
  687|      0|        // Since we have a listener outstanding for each transaction, receiving
  688|      0|        // any events is a proxy for some change having occurred.
  689|      0|        [self rerunTransactionsForPath:path];
  690|      0|    }
  691|      0|
  692|      0|    [self.eventRaiser raiseEvents:events];
  693|      0|}
  694|       |
  695|      0|- (void)onConnect:(FPersistentConnection *)fpconnection {
  696|      0|    [self updateInfo:kDotInfoConnected withValue:@YES];
  697|      0|}
  698|       |
  699|      0|- (void)onDisconnect:(FPersistentConnection *)fpconnection {
  700|      0|    [self updateInfo:kDotInfoConnected withValue:@NO];
  701|      0|    [self runOnDisconnectEvents];
  702|      0|}
  703|       |
  704|       |- (void)onServerInfoUpdate:(FPersistentConnection *)fpconnection
  705|      0|                   updates:(NSDictionary *)updates {
  706|      0|    for (NSString *key in updates) {
  707|      0|        id val = [updates objectForKey:key];
  708|      0|        [self updateInfo:key withValue:val];
  709|      0|    }
  710|      0|}
  711|       |
  712|      0|- (void)setupNotifications {
  713|      0|    NSString *const *backgroundConstant = (NSString *const *)dlsym(
  714|      0|        RTLD_DEFAULT, "UIApplicationDidEnterBackgroundNotification");
  715|      0|    if (backgroundConstant) {
  716|      0|        FFLog(@"I-RDB038015", @"Registering for background notification.");
  717|      0|        [[NSNotificationCenter defaultCenter]
  718|      0|            addObserver:self
  719|      0|               selector:@selector(didEnterBackground)
  720|      0|                   name:*backgroundConstant
  721|      0|                 object:nil];
  722|      0|    } else {
  723|      0|        FFLog(@"I-RDB038016",
  724|      0|              @"Skipped registering for background notification.");
  725|      0|    }
  726|      0|}
  727|       |
  728|      0|- (void)didEnterBackground {
  729|      0|    if (!self.config.persistenceEnabled)
  730|      0|        return;
  731|      0|
  732|      0|// Targetted compilation is ONLY for testing. UIKit is weak-linked in actual
  733|      0|// release build.
  734|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  735|      0|    // The idea is to wait until any outstanding sets get written to disk. Since
  736|      0|    // the sets might still be in our dispatch queue, we wait for the dispatch
  737|      0|    // queue to catch up and for persistence to catch up. This may be
  738|      0|    // undesirable though.  The dispatch queue might just be processing a bunch
  739|      0|    // of incoming data or something.  We might want to keep track of whether
  740|      0|    // there are any unpersisted sets or something.
  741|      0|    FFLog(@"I-RDB038017",
  742|      0|          @"Entering background.  Starting background task to finish work.");
  743|      0|    Class uiApplicationClass = NSClassFromString(@"UIApplication");
  744|      0|    assert(uiApplicationClass); // If we are here, we should be on iOS and
  745|      0|                                // UIApplication should be available.
  746|      0|
  747|      0|    UIApplication *application = [uiApplicationClass sharedApplication];
  748|      0|    __block UIBackgroundTaskIdentifier bgTask =
  749|      0|        [application beginBackgroundTaskWithExpirationHandler:^{
  750|      0|          [application endBackgroundTask:bgTask];
  751|      0|        }];
  752|      0|
  753|      0|    NSDate *start = [NSDate date];
  754|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  755|      0|      NSTimeInterval finishTime = [start timeIntervalSinceNow] * -1;
  756|      0|      FFLog(@"I-RDB038018", @"Background task completed.  Queue time: %f",
  757|      0|            finishTime);
  758|      0|      [application endBackgroundTask:bgTask];
  759|      0|    });
  760|      0|#endif
  761|      0|}
  762|       |
  763|       |#pragma mark -
  764|       |#pragma mark Internal methods
  765|       |
  766|       |/**
  767|       | * Applies all the changes stored up in the onDisconnect tree
  768|       | */
  769|      0|- (void)runOnDisconnectEvents {
  770|      0|    FFLog(@"I-RDB038019", @"Running onDisconnectEvents");
  771|      0|    NSDictionary *serverValues =
  772|      0|        [FServerValues generateServerValues:self.serverClock];
  773|      0|    FSparseSnapshotTree *resolvedTree =
  774|      0|        [FServerValues resolveDeferredValueTree:self.onDisconnect
  775|      0|                               withServerValues:serverValues];
  776|      0|    NSMutableArray *events = [[NSMutableArray alloc] init];
  777|      0|
  778|      0|    [resolvedTree
  779|      0|        forEachTreeAtPath:[FPath empty]
  780|      0|                       do:^(FPath *path, id<FNode> node) {
  781|      0|                         [events addObjectsFromArray:
  782|      0|                                     [self.serverSyncTree
  783|      0|                                         applyServerOverwriteAtPath:path
  784|      0|                                                            newData:node]];
  785|      0|                         FPath *affectedPath =
  786|      0|                             [self abortTransactionsAtPath:path
  787|      0|                                                     error:kFTransactionSet];
  788|      0|                         [self rerunTransactionsForPath:affectedPath];
  789|      0|                       }];
  790|      0|
  791|      0|    self.onDisconnect = [[FSparseSnapshotTree alloc] init];
  792|      0|    [self.eventRaiser raiseEvents:events];
  793|      0|}
  794|       |
  795|      0|- (NSDictionary *)dumpListens {
  796|      0|    return [self.connection dumpListens];
  797|      0|}
  798|       |
  799|       |#pragma mark -
  800|       |#pragma mark Transactions
  801|       |
  802|       |/**
  803|       | * Setup the transaction data structures
  804|       | */
  805|      0|- (void)initTransactions {
  806|      0|    self.transactionQueueTree = [[FTree alloc] init];
  807|      0|    self.hijackHash = NO;
  808|      0|    self.loggedTransactionPersistenceWarning = NO;
  809|      0|}
  810|       |
  811|       |/**
  812|       | * Creates a new transaction, add its to the transactions we're tracking, and
  813|       | * sends it to the server if possible
  814|       | */
  815|       |- (void)startTransactionOnPath:(FPath *)path
  816|       |                        update:(fbt_transactionresult_mutabledata)update
  817|       |                    onComplete:(fbt_void_nserror_bool_datasnapshot)onComplete
  818|      0|               withLocalEvents:(BOOL)applyLocally {
  819|      0|    if (self.config.persistenceEnabled &&
  820|      0|        !self.loggedTransactionPersistenceWarning) {
  821|      0|        self.loggedTransactionPersistenceWarning = YES;
  822|      0|        FFInfo(@"I-RDB038020",
  823|      0|               @"runTransactionBlock: usage detected while persistence is "
  824|      0|               @"enabled. Please be aware that transactions "
  825|      0|               @"*will not* be persisted across app restarts. "
  826|      0|               @"See "
  827|      0|               @"https://www.firebase.com/docs/ios/guide/"
  828|      0|               @"offline-capabilities.html#section-handling-transactions-"
  829|      0|               @"offline for more details.");
  830|      0|    }
  831|      0|
  832|      0|    FIRDatabaseReference *watchRef =
  833|      0|        [[FIRDatabaseReference alloc] initWithRepo:self path:path];
  834|      0|    // make sure we're listening on this node
  835|      0|    // Note: we can't do this asynchronously. To preserve event ordering, it has
  836|      0|    // to be done in this block. This is ok, this block is guaranteed to be our
  837|      0|    // own event loop
  838|      0|    NSUInteger handle = [[FUtilities LUIDGenerator] integerValue];
  839|      0|    fbt_void_datasnapshot cb = ^(FIRDataSnapshot *snapshot) {
  840|      0|    };
  841|      0|    FValueEventRegistration *registration =
  842|      0|        [[FValueEventRegistration alloc] initWithRepo:self
  843|      0|                                               handle:handle
  844|      0|                                             callback:cb
  845|      0|                                       cancelCallback:nil];
  846|      0|    [watchRef.repo addEventRegistration:registration
  847|      0|                               forQuery:watchRef.querySpec];
  848|      0|    fbt_void_void unwatcher = ^{
  849|      0|      [watchRef removeObserverWithHandle:handle];
  850|      0|    };
  851|      0|
  852|      0|    // Save all the data that represents this transaction
  853|      0|    FTupleTransaction *transaction = [[FTupleTransaction alloc] init];
  854|      0|    transaction.path = path;
  855|      0|    transaction.update = update;
  856|      0|    transaction.onComplete = onComplete;
  857|      0|    transaction.status = FTransactionInitializing;
  858|      0|    transaction.order = [FUtilities LUIDGenerator];
  859|      0|    transaction.applyLocally = applyLocally;
  860|      0|    transaction.retryCount = 0;
  861|      0|    transaction.unwatcher = unwatcher;
  862|      0|    transaction.currentWriteId = nil;
  863|      0|    transaction.currentInputSnapshot = nil;
  864|      0|    transaction.currentOutputSnapshotRaw = nil;
  865|      0|    transaction.currentOutputSnapshotResolved = nil;
  866|      0|
  867|      0|    // Run transaction initially
  868|      0|    id<FNode> currentState = [self latestStateAtPath:path excludeWriteIds:nil];
  869|      0|    transaction.currentInputSnapshot = currentState;
  870|      0|    FIRMutableData *mutableCurrent =
  871|      0|        [[FIRMutableData alloc] initWithNode:currentState];
  872|      0|    FIRTransactionResult *result = transaction.update(mutableCurrent);
  873|      0|
  874|      0|    if (!result.isSuccess) {
  875|      0|        // Abort the transaction
  876|      0|        transaction.unwatcher();
  877|      0|        transaction.currentOutputSnapshotRaw = nil;
  878|      0|        transaction.currentOutputSnapshotResolved = nil;
  879|      0|        if (transaction.onComplete) {
  880|      0|            FIRDatabaseReference *ref =
  881|      0|                [[FIRDatabaseReference alloc] initWithRepo:self
  882|      0|                                                      path:transaction.path];
  883|      0|            FIndexedNode *indexedNode = [FIndexedNode
  884|      0|                indexedNodeWithNode:transaction.currentInputSnapshot];
  885|      0|            FIRDataSnapshot *snap =
  886|      0|                [[FIRDataSnapshot alloc] initWithRef:ref
  887|      0|                                         indexedNode:indexedNode];
  888|      0|            [self.eventRaiser raiseCallback:^{
  889|      0|              transaction.onComplete(nil, NO, snap);
  890|      0|            }];
  891|      0|        }
  892|      0|    } else {
  893|      0|        // Note: different from js. We don't need to validate, FIRMutableData
  894|      0|        // does validation. We also don't have to worry about priorities. Just
  895|      0|        // mark as run and add to queue.
  896|      0|        transaction.status = FTransactionRun;
  897|      0|        FTree *queueNode = [self.transactionQueueTree subTree:transaction.path];
  898|      0|        NSMutableArray *nodeQueue = [queueNode getValue];
  899|      0|        if (nodeQueue == nil) {
  900|      0|            nodeQueue = [[NSMutableArray alloc] init];
  901|      0|        }
  902|      0|        [nodeQueue addObject:transaction];
  903|      0|        [queueNode setValue:nodeQueue];
  904|      0|
  905|      0|        // Update visibleData and raise events
  906|      0|        // Note: We intentionally raise events after updating all of our
  907|      0|        // transaction state, since the user could start new transactions from
  908|      0|        // the event callbacks
  909|      0|        NSDictionary *serverValues =
  910|      0|            [FServerValues generateServerValues:self.serverClock];
  911|      0|        id<FNode> newValUnresolved = [result.update nodeValue];
  912|      0|        id<FNode> newVal =
  913|      0|            [FServerValues resolveDeferredValueSnapshot:newValUnresolved
  914|      0|                                       withServerValues:serverValues];
  915|      0|        transaction.currentOutputSnapshotRaw = newValUnresolved;
  916|      0|        transaction.currentOutputSnapshotResolved = newVal;
  917|      0|        transaction.currentWriteId =
  918|      0|            [NSNumber numberWithInteger:[self nextWriteId]];
  919|      0|
  920|      0|        NSArray *events = [self.serverSyncTree
  921|      0|            applyUserOverwriteAtPath:path
  922|      0|                             newData:newVal
  923|      0|                             writeId:[transaction.currentWriteId integerValue]
  924|      0|                           isVisible:transaction.applyLocally];
  925|      0|        [self.eventRaiser raiseEvents:events];
  926|      0|
  927|      0|        [self sendAllReadyTransactions];
  928|      0|    }
  929|      0|}
  930|       |
  931|       |/**
  932|       | * @param writeIdsToExclude A specific set to exclude
  933|       | */
  934|       |- (id<FNode>)latestStateAtPath:(FPath *)path
  935|      0|               excludeWriteIds:(NSArray *)writeIdsToExclude {
  936|      0|    id<FNode> latestState =
  937|      0|        [self.serverSyncTree calcCompleteEventCacheAtPath:path
  938|      0|                                          excludeWriteIds:writeIdsToExclude];
  939|      0|    return latestState ? latestState : [FEmptyNode emptyNode];
  940|      0|}
  941|       |
  942|       |/**
  943|       | * Sends any already-run transactions that aren't waiting for outstanding
  944|       | * transactions to complete.
  945|       | *
  946|       | * Externally, call the version with no arguments.
  947|       | * Internally, calls itself recursively with a particular transactionQueueTree
  948|       | * node to recurse through the tree
  949|       | */
  950|      0|- (void)sendAllReadyTransactions {
  951|      0|    FTree *node = self.transactionQueueTree;
  952|      0|
  953|      0|    [self pruneCompletedTransactionsBelowNode:node];
  954|      0|    [self sendReadyTransactionsForTree:node];
  955|      0|}
  956|       |
  957|      0|- (void)sendReadyTransactionsForTree:(FTree *)node {
  958|      0|    NSMutableArray *queue = [node getValue];
  959|      0|    if (queue != nil) {
  960|      0|        queue = [self buildTransactionQueueAtNode:node];
  961|      0|        NSAssert([queue count] > 0, @"Sending zero length transaction queue");
  962|      0|
  963|      0|        NSUInteger notRunIndex = [queue
  964|      0|            indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) {
  965|      0|              return ((FTupleTransaction *)obj).status != FTransactionRun;
  966|      0|            }];
  967|      0|
  968|      0|        // If they're all run (and not sent), we can send them.  Else, we must
  969|      0|        // wait.
  970|      0|        if (notRunIndex == NSNotFound) {
  971|      0|            [self sendTransactionQueue:queue atPath:node.path];
  972|      0|        }
  973|      0|    } else if ([node hasChildren]) {
  974|      0|        [node forEachChild:^(FTree *child) {
  975|      0|          [self sendReadyTransactionsForTree:child];
  976|      0|        }];
  977|      0|    }
  978|      0|}
  979|       |
  980|       |/**
  981|       | * Given a list of run transactions, send them to the server and then handle the
  982|       | * result (success or failure).
  983|       | */
  984|      0|- (void)sendTransactionQueue:(NSMutableArray *)queue atPath:(FPath *)path {
  985|      0|    // Mark transactions as sent and bump the retry count
  986|      0|    NSMutableArray *writeIdsToExclude = [[NSMutableArray alloc] init];
  987|      0|    for (FTupleTransaction *transaction in queue) {
  988|      0|        [writeIdsToExclude addObject:transaction.currentWriteId];
  989|      0|    }
  990|      0|    id<FNode> latestState = [self latestStateAtPath:path
  991|      0|                                    excludeWriteIds:writeIdsToExclude];
  992|      0|    id<FNode> snapToSend = latestState;
  993|      0|    NSString *latestHash = [latestState dataHash];
  994|      0|    for (FTupleTransaction *transaction in queue) {
  995|      0|        NSAssert(
  996|      0|            transaction.status == FTransactionRun,
  997|      0|            @"[FRepo sendTransactionQueue:] items in queue should all be run.");
  998|      0|        FFLog(@"I-RDB038021", @"Transaction at %@ set to SENT",
  999|      0|              transaction.path);
 1000|      0|        transaction.status = FTransactionSent;
 1001|      0|        transaction.retryCount++;
 1002|      0|        FPath *relativePath = [FPath relativePathFrom:path to:transaction.path];
 1003|      0|        // If we've gotten to this point, the output snapshot must be defined.
 1004|      0|        snapToSend =
 1005|      0|            [snapToSend updateChild:relativePath
 1006|      0|                       withNewChild:transaction.currentOutputSnapshotRaw];
 1007|      0|    }
 1008|      0|
 1009|      0|    id dataToSend = [snapToSend valForExport:YES];
 1010|      0|    NSString *pathToSend = [path description];
 1011|      0|    latestHash = self.hijackHash ? @"badhash" : latestHash;
 1012|      0|
 1013|      0|    // Send the put
 1014|      0|    [self.connection
 1015|      0|             putData:dataToSend
 1016|      0|             forPath:pathToSend
 1017|      0|            withHash:latestHash
 1018|      0|        withCallback:^(NSString *status, NSString *errorReason) {
 1019|      0|          FFLog(@"I-RDB038022", @"Transaction put response: %@ : %@",
 1020|      0|                pathToSend, status);
 1021|      0|
 1022|      0|          NSMutableArray *events = [[NSMutableArray alloc] init];
 1023|      0|          if ([status isEqualToString:kFWPResponseForActionStatusOk]) {
 1024|      0|              // Queue up the callbacks and fire them after cleaning up all of
 1025|      0|              // our transaction state, since the callback could trigger more
 1026|      0|              // transactions or sets.
 1027|      0|              NSMutableArray *callbacks = [[NSMutableArray alloc] init];
 1028|      0|              for (FTupleTransaction *transaction in queue) {
 1029|      0|                  transaction.status = FTransactionCompleted;
 1030|      0|                  [events addObjectsFromArray:
 1031|      0|                              [self.serverSyncTree
 1032|      0|                                  ackUserWriteWithWriteId:
 1033|      0|                                      [transaction.currentWriteId integerValue]
 1034|      0|                                                   revert:NO
 1035|      0|                                                  persist:NO
 1036|      0|                                                    clock:self.serverClock]];
 1037|      0|                  if (transaction.onComplete) {
 1038|      0|                      // We never unset the output snapshot, and given that this
 1039|      0|                      // transaction is complete, it should be set
 1040|      0|                      id<FNode> node =
 1041|      0|                          transaction.currentOutputSnapshotResolved;
 1042|      0|                      FIndexedNode *indexedNode =
 1043|      0|                          [FIndexedNode indexedNodeWithNode:node];
 1044|      0|                      FIRDatabaseReference *ref = [[FIRDatabaseReference alloc]
 1045|      0|                          initWithRepo:self
 1046|      0|                                  path:transaction.path];
 1047|      0|                      FIRDataSnapshot *snapshot =
 1048|      0|                          [[FIRDataSnapshot alloc] initWithRef:ref
 1049|      0|                                                   indexedNode:indexedNode];
 1050|      0|                      fbt_void_void cb = ^{
 1051|      0|                        transaction.onComplete(nil, YES, snapshot);
 1052|      0|                      };
 1053|      0|                      [callbacks addObject:[cb copy]];
 1054|      0|                  }
 1055|      0|                  transaction.unwatcher();
 1056|      0|              }
 1057|      0|
 1058|      0|              // Now remove the completed transactions.
 1059|      0|              [self
 1060|      0|                  pruneCompletedTransactionsBelowNode:[self.transactionQueueTree
 1061|      0|                                                          subTree:path]];
 1062|      0|              // There may be pending transactions that we can now send.
 1063|      0|              [self sendAllReadyTransactions];
 1064|      0|
 1065|      0|              // Finally, trigger onComplete callbacks
 1066|      0|              [self.eventRaiser raiseCallbacks:callbacks];
 1067|      0|          } else {
 1068|      0|              // transactions are no longer sent. Update their status
 1069|      0|              // appropriately.
 1070|      0|              if ([status
 1071|      0|                      isEqualToString:kFWPResponseForActionStatusDataStale]) {
 1072|      0|                  for (FTupleTransaction *transaction in queue) {
 1073|      0|                      if (transaction.status == FTransactionSentNeedsAbort) {
 1074|      0|                          transaction.status = FTransactionNeedsAbort;
 1075|      0|                      } else {
 1076|      0|                          transaction.status = FTransactionRun;
 1077|      0|                      }
 1078|      0|                  }
 1079|      0|              } else {
 1080|      0|                  FFWarn(@"I-RDB038023",
 1081|      0|                         @"runTransactionBlock: at %@ failed: %@", path,
 1082|      0|                         status);
 1083|      0|                  for (FTupleTransaction *transaction in queue) {
 1084|      0|                      transaction.status = FTransactionNeedsAbort;
 1085|      0|                      [transaction setAbortStatus:status reason:errorReason];
 1086|      0|                  }
 1087|      0|              }
 1088|      0|          }
 1089|      0|
 1090|      0|          [self rerunTransactionsForPath:path];
 1091|      0|          [self.eventRaiser raiseEvents:events];
 1092|      0|        }];
 1093|      0|}
 1094|       |
 1095|       |/**
 1096|       | * Finds all transactions dependent on the data at changed Path and reruns them.
 1097|       | *
 1098|       | * Should be called any time cached data changes.
 1099|       | *
 1100|       | * Return the highest path that was affected by rerunning transactions. This is
 1101|       | * the path at which events need to be raised for.
 1102|       | */
 1103|      0|- (FPath *)rerunTransactionsForPath:(FPath *)changedPath {
 1104|      0|    // For the common case that there are no transactions going on, skip all
 1105|      0|    // this!
 1106|      0|    if ([self.transactionQueueTree isEmpty]) {
 1107|      0|        return changedPath;
 1108|      0|    } else {
 1109|      0|        FTree *rootMostTransactionNode =
 1110|      0|            [self getAncestorTransactionNodeForPath:changedPath];
 1111|      0|        FPath *path = rootMostTransactionNode.path;
 1112|      0|
 1113|      0|        NSArray *queue =
 1114|      0|            [self buildTransactionQueueAtNode:rootMostTransactionNode];
 1115|      0|        [self rerunTransactionQueue:queue atPath:path];
 1116|      0|
 1117|      0|        return path;
 1118|      0|    }
 1119|      0|}
 1120|       |
 1121|       |/**
 1122|       | * Does all the work of rerunning transactions (as well as cleans up aborted
 1123|       | * transactions and whatnot).
 1124|       | */
 1125|      0|- (void)rerunTransactionQueue:(NSArray *)queue atPath:(FPath *)path {
 1126|      0|    if (queue.count == 0) {
 1127|      0|        return; // nothing to do
 1128|      0|    }
 1129|      0|
 1130|      0|    // Queue up the callbacks and fire them after cleaning up all of our
 1131|      0|    // transaction state, since the callback could trigger more transactions or
 1132|      0|    // sets.
 1133|      0|    NSMutableArray *events = [[NSMutableArray alloc] init];
 1134|      0|    NSMutableArray *callbacks = [[NSMutableArray alloc] init];
 1135|      0|
 1136|      0|    // Ignore, by default, all of the sets in this queue, since we're re-running
 1137|      0|    // all of them. However, we want to include the results of new sets
 1138|      0|    // triggered as part of this re-run, so we don't want to ignore a range,
 1139|      0|    // just these specific sets.
 1140|      0|    NSMutableArray *writeIdsToExclude = [[NSMutableArray alloc] init];
 1141|      0|    for (FTupleTransaction *transaction in queue) {
 1142|      0|        [writeIdsToExclude addObject:transaction.currentWriteId];
 1143|      0|    }
 1144|      0|
 1145|      0|    for (FTupleTransaction *transaction in queue) {
 1146|      0|        FPath *relativePath __unused =
 1147|      0|            [FPath relativePathFrom:path to:transaction.path];
 1148|      0|        BOOL abortTransaction = NO;
 1149|      0|        NSAssert(relativePath != nil, @"[FRepo rerunTransactionsQueue:] "
 1150|      0|                                      @"relativePath should not be null.");
 1151|      0|
 1152|      0|        if (transaction.status == FTransactionNeedsAbort) {
 1153|      0|            abortTransaction = YES;
 1154|      0|            if (![transaction.abortStatus
 1155|      0|                    isEqualToString:kFErrorWriteCanceled]) {
 1156|      0|                NSArray *ackEvents = [self.serverSyncTree
 1157|      0|                    ackUserWriteWithWriteId:[transaction.currentWriteId
 1158|      0|                                                    integerValue]
 1159|      0|                                     revert:YES
 1160|      0|                                    persist:NO
 1161|      0|                                      clock:self.serverClock];
 1162|      0|                [events addObjectsFromArray:ackEvents];
 1163|      0|            }
 1164|      0|        } else if (transaction.status == FTransactionRun) {
 1165|      0|            if (transaction.retryCount >= kFTransactionMaxRetries) {
 1166|      0|                abortTransaction = YES;
 1167|      0|                [transaction setAbortStatus:kFTransactionTooManyRetries
 1168|      0|                                     reason:nil];
 1169|      0|                [events
 1170|      0|                    addObjectsFromArray:
 1171|      0|                        [self.serverSyncTree
 1172|      0|                            ackUserWriteWithWriteId:[transaction.currentWriteId
 1173|      0|                                                            integerValue]
 1174|      0|                                             revert:YES
 1175|      0|                                            persist:NO
 1176|      0|                                              clock:self.serverClock]];
 1177|      0|            } else {
 1178|      0|                // This code reruns a transaction
 1179|      0|                id<FNode> currentNode =
 1180|      0|                    [self latestStateAtPath:transaction.path
 1181|      0|                            excludeWriteIds:writeIdsToExclude];
 1182|      0|                transaction.currentInputSnapshot = currentNode;
 1183|      0|                FIRMutableData *mutableCurrent =
 1184|      0|                    [[FIRMutableData alloc] initWithNode:currentNode];
 1185|      0|                FIRTransactionResult *result =
 1186|      0|                    transaction.update(mutableCurrent);
 1187|      0|                if (result.isSuccess) {
 1188|      0|                    NSNumber *oldWriteId = transaction.currentWriteId;
 1189|      0|                    NSDictionary *serverValues =
 1190|      0|                        [FServerValues generateServerValues:self.serverClock];
 1191|      0|
 1192|      0|                    id<FNode> newVal = [result.update nodeValue];
 1193|      0|                    id<FNode> newValResolved = [FServerValues
 1194|      0|                        resolveDeferredValueSnapshot:newVal
 1195|      0|                                    withServerValues:serverValues];
 1196|      0|
 1197|      0|                    transaction.currentOutputSnapshotRaw = newVal;
 1198|      0|                    transaction.currentOutputSnapshotResolved = newValResolved;
 1199|      0|
 1200|      0|                    transaction.currentWriteId =
 1201|      0|                        [NSNumber numberWithInteger:[self nextWriteId]];
 1202|      0|                    // Mutates writeIdsToExclude in place
 1203|      0|                    [writeIdsToExclude removeObject:oldWriteId];
 1204|      0|                    [events
 1205|      0|                        addObjectsFromArray:
 1206|      0|                            [self.serverSyncTree
 1207|      0|                                applyUserOverwriteAtPath:transaction.path
 1208|      0|                                                 newData:
 1209|      0|                                                     transaction
 1210|      0|                                                         .currentOutputSnapshotResolved
 1211|      0|                                                 writeId:
 1212|      0|                                                     [transaction.currentWriteId
 1213|      0|                                                             integerValue]
 1214|      0|                                               isVisible:transaction
 1215|      0|                                                             .applyLocally]];
 1216|      0|                    [events addObjectsFromArray:
 1217|      0|                                [self.serverSyncTree
 1218|      0|                                    ackUserWriteWithWriteId:[oldWriteId
 1219|      0|                                                                integerValue]
 1220|      0|                                                     revert:YES
 1221|      0|                                                    persist:NO
 1222|      0|                                                      clock:self.serverClock]];
 1223|      0|                } else {
 1224|      0|                    abortTransaction = YES;
 1225|      0|                    // The user aborted the transaction. JS treats ths as a
 1226|      0|                    // "nodata" abort, but it's not an error, so we don't send
 1227|      0|                    // them an error.
 1228|      0|                    [transaction setAbortStatus:nil reason:nil];
 1229|      0|                    [events
 1230|      0|                        addObjectsFromArray:
 1231|      0|                            [self.serverSyncTree
 1232|      0|                                ackUserWriteWithWriteId:
 1233|      0|                                    [transaction.currentWriteId integerValue]
 1234|      0|                                                 revert:YES
 1235|      0|                                                persist:NO
 1236|      0|                                                  clock:self.serverClock]];
 1237|      0|                }
 1238|      0|            }
 1239|      0|        }
 1240|      0|
 1241|      0|        [self.eventRaiser raiseEvents:events];
 1242|      0|        events = nil;
 1243|      0|
 1244|      0|        if (abortTransaction) {
 1245|      0|            // Abort
 1246|      0|            transaction.status = FTransactionCompleted;
 1247|      0|            transaction.unwatcher();
 1248|      0|            if (transaction.onComplete) {
 1249|      0|                FIRDatabaseReference *ref = [[FIRDatabaseReference alloc]
 1250|      0|                    initWithRepo:self
 1251|      0|                            path:transaction.path];
 1252|      0|                FIndexedNode *lastInput = [FIndexedNode
 1253|      0|                    indexedNodeWithNode:transaction.currentInputSnapshot];
 1254|      0|                FIRDataSnapshot *snap =
 1255|      0|                    [[FIRDataSnapshot alloc] initWithRef:ref
 1256|      0|                                             indexedNode:lastInput];
 1257|      0|                fbt_void_void cb = ^{
 1258|      0|                  // Unlike JS, no need to check for "nodata" because ObjC has
 1259|      0|                  // abortError = nil
 1260|      0|                  transaction.onComplete(transaction.abortError, NO, snap);
 1261|      0|                };
 1262|      0|                [callbacks addObject:[cb copy]];
 1263|      0|            }
 1264|      0|        }
 1265|      0|    }
 1266|      0|
 1267|      0|    // Note: unlike current js client, we don't need to preserve priority. Users
 1268|      0|    // can set priority via FIRMutableData
 1269|      0|
 1270|      0|    // Clean up completed transactions.
 1271|      0|    [self pruneCompletedTransactionsBelowNode:self.transactionQueueTree];
 1272|      0|
 1273|      0|    // Now fire callbacks, now that we're in a good, known state.
 1274|      0|    [self.eventRaiser raiseCallbacks:callbacks];
 1275|      0|
 1276|      0|    // Try to send the transaction result to the server
 1277|      0|    [self sendAllReadyTransactions];
 1278|      0|}
 1279|       |
 1280|      0|- (FTree *)getAncestorTransactionNodeForPath:(FPath *)path {
 1281|      0|    FTree *transactionNode = self.transactionQueueTree;
 1282|      0|
 1283|      0|    while (![path isEmpty] && [transactionNode getValue] == nil) {
 1284|      0|        NSString *front = [path getFront];
 1285|      0|        transactionNode =
 1286|      0|            [transactionNode subTree:[[FPath alloc] initWith:front]];
 1287|      0|        path = [path popFront];
 1288|      0|    }
 1289|      0|
 1290|      0|    return transactionNode;
 1291|      0|}
 1292|       |
 1293|      0|- (NSMutableArray *)buildTransactionQueueAtNode:(FTree *)node {
 1294|      0|    NSMutableArray *queue = [[NSMutableArray alloc] init];
 1295|      0|    [self aggregateTransactionQueuesForNode:node andQueue:queue];
 1296|      0|
 1297|      0|    [queue sortUsingComparator:^NSComparisonResult(FTupleTransaction *obj1,
 1298|      0|                                                   FTupleTransaction *obj2) {
 1299|      0|      return [obj1.order compare:obj2.order];
 1300|      0|    }];
 1301|      0|
 1302|      0|    return queue;
 1303|      0|}
 1304|       |
 1305|       |- (void)aggregateTransactionQueuesForNode:(FTree *)node
 1306|      0|                                 andQueue:(NSMutableArray *)queue {
 1307|      0|    NSArray *nodeQueue = [node getValue];
 1308|      0|    [queue addObjectsFromArray:nodeQueue];
 1309|      0|
 1310|      0|    [node forEachChild:^(FTree *child) {
 1311|      0|      [self aggregateTransactionQueuesForNode:child andQueue:queue];
 1312|      0|    }];
 1313|      0|}
 1314|       |
 1315|       |/**
 1316|       | * Remove COMPLETED transactions at or below this node in the
 1317|       | * transactionQueueTree
 1318|       | */
 1319|      0|- (void)pruneCompletedTransactionsBelowNode:(FTree *)node {
 1320|      0|    NSMutableArray *queue = [node getValue];
 1321|      0|    if (queue != nil) {
 1322|      0|        int i = 0;
 1323|      0|        // remove all of the completed transactions from the queue
 1324|      0|        while (i < queue.count) {
 1325|      0|            FTupleTransaction *transaction = [queue objectAtIndex:i];
 1326|      0|            if (transaction.status == FTransactionCompleted) {
 1327|      0|                [queue removeObjectAtIndex:i];
 1328|      0|            } else {
 1329|      0|                i++;
 1330|      0|            }
 1331|      0|        }
 1332|      0|        if (queue.count > 0) {
 1333|      0|            [node setValue:queue];
 1334|      0|        } else {
 1335|      0|            [node setValue:nil];
 1336|      0|        }
 1337|      0|    }
 1338|      0|
 1339|      0|    [node forEachChildMutationSafe:^(FTree *child) {
 1340|      0|      [self pruneCompletedTransactionsBelowNode:child];
 1341|      0|    }];
 1342|      0|}
 1343|       |
 1344|       |/**
 1345|       | *  Aborts all transactions on ancestors or descendants of the specified path.
 1346|       | * Called when doing a setValue: or updateChildValues: since we consider them
 1347|       | * incompatible with transactions
 1348|       | *
 1349|       | *  @param path path for which we want to abort related transactions.
 1350|       | */
 1351|      0|- (FPath *)abortTransactionsAtPath:(FPath *)path error:(NSString *)error {
 1352|      0|    // For the common case that there are no transactions going on, skip all
 1353|      0|    // this!
 1354|      0|    if ([self.transactionQueueTree isEmpty]) {
 1355|      0|        return path;
 1356|      0|    } else {
 1357|      0|        FPath *affectedPath =
 1358|      0|            [self getAncestorTransactionNodeForPath:path].path;
 1359|      0|
 1360|      0|        FTree *transactionNode = [self.transactionQueueTree subTree:path];
 1361|      0|        [transactionNode forEachAncestor:^BOOL(FTree *ancestor) {
 1362|      0|          [self abortTransactionsAtNode:ancestor error:error];
 1363|      0|          return NO;
 1364|      0|        }];
 1365|      0|
 1366|      0|        [self abortTransactionsAtNode:transactionNode error:error];
 1367|      0|
 1368|      0|        [transactionNode forEachDescendant:^(FTree *child) {
 1369|      0|          [self abortTransactionsAtNode:child error:error];
 1370|      0|        }];
 1371|      0|
 1372|      0|        return affectedPath;
 1373|      0|    }
 1374|      0|}
 1375|       |
 1376|       |/**
 1377|       | * Abort transactions stored in this transactions queue node.
 1378|       | *
 1379|       | * @param node Node to abort transactions for.
 1380|       | */
 1381|      0|- (void)abortTransactionsAtNode:(FTree *)node error:(NSString *)error {
 1382|      0|    NSMutableArray *queue = [node getValue];
 1383|      0|    if (queue != nil) {
 1384|      0|
 1385|      0|        // Queue up the callbacks and fire them after cleaning up all of our
 1386|      0|        // transaction state, since can be immediately aborted and removed.
 1387|      0|        NSMutableArray *callbacks = [[NSMutableArray alloc] init];
 1388|      0|
 1389|      0|        // Go through queue. Any already-sent transactions must be marked for
 1390|      0|        // abort, while the unsent ones can be immediately aborted and removed
 1391|      0|        NSMutableArray *events = [[NSMutableArray alloc] init];
 1392|      0|        int lastSent = -1;
 1393|      0|        // Note: all of the sent transactions will be at the front of the queue,
 1394|      0|        // so safe to increment lastSent
 1395|      0|        for (FTupleTransaction *transaction in queue) {
 1396|      0|            if (transaction.status == FTransactionSentNeedsAbort) {
 1397|      0|                // No-op. already marked.
 1398|      0|            } else if (transaction.status == FTransactionSent) {
 1399|      0|                // Mark this transaction for abort when it returns
 1400|      0|                lastSent++;
 1401|      0|                transaction.status = FTransactionSentNeedsAbort;
 1402|      0|                [transaction setAbortStatus:error reason:nil];
 1403|      0|            } else {
 1404|      0|                // we can abort this immediately
 1405|      0|                transaction.unwatcher();
 1406|      0|                if ([error isEqualToString:kFTransactionSet]) {
 1407|      0|                    [events
 1408|      0|                        addObjectsFromArray:
 1409|      0|                            [self.serverSyncTree
 1410|      0|                                ackUserWriteWithWriteId:
 1411|      0|                                    [transaction.currentWriteId integerValue]
 1412|      0|                                                 revert:YES
 1413|      0|                                                persist:NO
 1414|      0|                                                  clock:self.serverClock]];
 1415|      0|                } else {
 1416|      0|                    // If it was cancelled it was already removed from the sync
 1417|      0|                    // tree, no need to ack
 1418|      0|                    NSAssert([error isEqualToString:kFErrorWriteCanceled], nil);
 1419|      0|                }
 1420|      0|
 1421|      0|                if (transaction.onComplete) {
 1422|      0|                    NSError *abortReason = [FUtilities errorForStatus:error
 1423|      0|                                                            andReason:nil];
 1424|      0|                    FIRDataSnapshot *snapshot = nil;
 1425|      0|                    fbt_void_void cb = ^{
 1426|      0|                      transaction.onComplete(abortReason, NO, snapshot);
 1427|      0|                    };
 1428|      0|                    [callbacks addObject:[cb copy]];
 1429|      0|                }
 1430|      0|            }
 1431|      0|        }
 1432|      0|        if (lastSent == -1) {
 1433|      0|            // We're not waiting for any sent transactions. We can clear the
 1434|      0|            // queue.
 1435|      0|            [node setValue:nil];
 1436|      0|        } else {
 1437|      0|            // Remove the transactions we aborted
 1438|      0|            NSRange theRange;
 1439|      0|            theRange.location = lastSent + 1;
 1440|      0|            theRange.length = queue.count - theRange.location;
 1441|      0|            [queue removeObjectsInRange:theRange];
 1442|      0|        }
 1443|      0|
 1444|      0|        // Now fire the callbacks
 1445|      0|        [self.eventRaiser raiseEvents:events];
 1446|      0|        [self.eventRaiser raiseCallbacks:callbacks];
 1447|      0|    }
 1448|      0|}
 1449|       |
 1450|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FRepoInfo.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FRepoInfo.h"
   18|       |#import "FConstants.h"
   19|       |
   20|       |@interface FRepoInfo ()
   21|       |
   22|       |@property(nonatomic, strong) NSString *domain;
   23|       |
   24|       |@end
   25|       |
   26|       |@implementation FRepoInfo
   27|       |
   28|       |@synthesize namespace;
   29|       |@synthesize host;
   30|       |@synthesize internalHost;
   31|       |@synthesize secure;
   32|       |@synthesize domain;
   33|       |
   34|       |- (id)initWithHost:(NSString *)aHost
   35|       |          isSecure:(bool)isSecure
   36|      0|     withNamespace:(NSString *)aNamespace {
   37|      0|    self = [super init];
   38|      0|    if (self) {
   39|      0|        host = aHost;
   40|      0|        domain =
   41|      0|            [host containsString:@"."]
   42|      0|                ? [host
   43|      0|                      substringFromIndex:[host rangeOfString:@"."].location + 1]
   44|      0|                : host;
   45|      0|        secure = isSecure;
   46|      0|        namespace = aNamespace;
   47|      0|
   48|      0|        // Get cached internal host if it exists
   49|      0|        NSString *internalHostKey =
   50|      0|            [NSString stringWithFormat:@"firebase:host:%@", self.host];
   51|      0|        NSString *cachedInternalHost = [[NSUserDefaults standardUserDefaults]
   52|      0|            stringForKey:internalHostKey];
   53|      0|        if (cachedInternalHost != nil) {
   54|      0|            internalHost = cachedInternalHost;
   55|      0|        } else {
   56|      0|            internalHost = self.host;
   57|      0|        }
   58|      0|    }
   59|      0|    return self;
   60|      0|}
   61|       |
   62|      0|- (NSString *)description {
   63|      0|    // The namespace is encoded in the hostname, so we can just return this.
   64|      0|    return [NSString
   65|      0|        stringWithFormat:@"http%@://%@", (self.secure ? @"s" : @""), self.host];
   66|      0|}
   67|       |
   68|      0|- (void)setInternalHost:(NSString *)newHost {
   69|      0|    if (![internalHost isEqualToString:newHost]) {
   70|      0|        internalHost = newHost;
   71|      0|
   72|      0|        // Cache the internal host so we don't need to redirect later on
   73|      0|        NSString *internalHostKey =
   74|      0|            [NSString stringWithFormat:@"firebase:host:%@", self.host];
   75|      0|        NSUserDefaults *cache = [NSUserDefaults standardUserDefaults];
   76|      0|        [cache setObject:internalHost forKey:internalHostKey];
   77|      0|        [cache synchronize];
   78|      0|    }
   79|      0|}
   80|       |
   81|      0|- (void)clearInternalHostCache {
   82|      0|    internalHost = self.host;
   83|      0|
   84|      0|    // Remove the cached entry
   85|      0|    NSString *internalHostKey =
   86|      0|        [NSString stringWithFormat:@"firebase:host:%@", self.host];
   87|      0|    NSUserDefaults *cache = [NSUserDefaults standardUserDefaults];
   88|      0|    [cache removeObjectForKey:internalHostKey];
   89|      0|    [cache synchronize];
   90|      0|}
   91|       |
   92|      0|- (BOOL)isDemoHost {
   93|      0|    return [self.domain isEqualToString:@"firebaseio-demo.com"];
   94|      0|}
   95|       |
   96|      0|- (BOOL)isCustomHost {
   97|      0|    return ![self.domain isEqualToString:@"firebaseio-demo.com"] &&
   98|      0|           ![self.domain isEqualToString:@"firebaseio.com"];
   99|      0|}
  100|       |
  101|      0|- (NSString *)connectionURL {
  102|      0|    return [self connectionURLWithLastSessionID:nil];
  103|      0|}
  104|       |
  105|      0|- (NSString *)connectionURLWithLastSessionID:(NSString *)lastSessionID {
  106|      0|    NSString *scheme;
  107|      0|    if (self.secure) {
  108|      0|        scheme = @"wss";
  109|      0|    } else {
  110|      0|        scheme = @"ws";
  111|      0|    }
  112|      0|    NSString *url =
  113|      0|        [NSString stringWithFormat:@"%@://%@/.ws?%@=%@&ns=%@", scheme,
  114|      0|                                   self.internalHost, kWireProtocolVersionParam,
  115|      0|                                   kWebsocketProtocolVersion, self.namespace];
  116|      0|
  117|      0|    if (lastSessionID != nil) {
  118|      0|        url = [NSString stringWithFormat:@"%@&ls=%@", url, lastSessionID];
  119|      0|    }
  120|      0|    return url;
  121|      0|}
  122|       |
  123|       |- (id)copyWithZone:(NSZone *)zone;
  124|      0|{
  125|      0|    return self; // Immutable
  126|      0|}
  127|       |
  128|      0|- (NSUInteger)hash {
  129|      0|    NSUInteger result = host.hash;
  130|      0|    result = 31 * result + (secure ? 1 : 0);
  131|      0|    result = 31 * result + namespace.hash;
  132|      0|    result = 31 * result + host.hash;
  133|      0|    return result;
  134|      0|}
  135|       |
  136|      0|- (BOOL)isEqual:(id)anObject {
  137|      0|    if (![anObject isKindOfClass:[FRepoInfo class]])
  138|      0|        return NO;
  139|      0|    FRepoInfo *other = (FRepoInfo *)anObject;
  140|      0|    return secure == other.secure && [host isEqualToString:other.host] &&
  141|      0|           [namespace isEqualToString:other.namespace];
  142|      0|}
  143|       |
  144|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FRepoManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FRepoManager.h"
   18|       |#import "FAtomicNumber.h"
   19|       |#import "FIRDatabaseConfig_Private.h"
   20|       |#import "FIRDatabaseQuery_Private.h"
   21|       |#import "FIRDatabase_Private.h"
   22|       |#import "FRepo.h"
   23|       |#import <FirebaseCore/FIRLogger.h>
   24|       |
   25|       |@implementation FRepoManager
   26|       |
   27|       |typedef NSMutableDictionary<NSString *,
   28|       |                            NSMutableDictionary<FRepoInfo *, FRepo *> *>
   29|       |    FRepoDictionary;
   30|       |
   31|      0|+ (FRepoDictionary *)configs {
   32|      0|    static dispatch_once_t pred = 0;
   33|      0|    static FRepoDictionary *configs;
   34|      0|    dispatch_once(&pred, ^{
   35|      0|      configs = [NSMutableDictionary dictionary];
   36|      0|    });
   37|      0|    return configs;
   38|      0|}
   39|       |
   40|       |/**
   41|       | * Used for legacy unit tests.  The public API should go through
   42|       | * FirebaseDatabase which calls createRepo.
   43|       | */
   44|      0|+ (FRepo *)getRepo:(FRepoInfo *)repoInfo config:(FIRDatabaseConfig *)config {
   45|      0|    [config freeze];
   46|      0|    FRepoDictionary *configs = [FRepoManager configs];
   47|      0|    @synchronized(configs) {
   48|      0|        NSMutableDictionary<FRepoInfo *, FRepo *> *repos =
   49|      0|            configs[config.sessionIdentifier];
   50|      0|        if (!repos || repos[repoInfo] == nil) {
   51|      0|            // Calling this should create the repo.
   52|      0|            [FIRDatabase createDatabaseForTests:repoInfo config:config];
   53|      0|        }
   54|      0|
   55|      0|        return configs[config.sessionIdentifier][repoInfo];
   56|      0|    }
   57|      0|}
   58|       |
   59|       |+ (FRepo *)createRepo:(FRepoInfo *)repoInfo
   60|       |               config:(FIRDatabaseConfig *)config
   61|      0|             database:(FIRDatabase *)database {
   62|      0|    [config freeze];
   63|      0|    FRepoDictionary *configs = [FRepoManager configs];
   64|      0|    @synchronized(configs) {
   65|      0|        NSMutableDictionary<FRepoInfo *, FRepo *> *repos =
   66|      0|            configs[config.sessionIdentifier];
   67|      0|        if (!repos) {
   68|      0|            repos = [NSMutableDictionary dictionary];
   69|      0|            configs[config.sessionIdentifier] = repos;
   70|      0|        }
   71|      0|        FRepo *repo = repos[repoInfo];
   72|      0|        if (repo == nil) {
   73|      0|            repo = [[FRepo alloc] initWithRepoInfo:repoInfo
   74|      0|                                            config:config
   75|      0|                                          database:database];
   76|      0|            repos[repoInfo] = repo;
   77|      0|            return repo;
   78|      0|        } else {
   79|      0|            [NSException
   80|      0|                 raise:@"RepoExists"
   81|      0|                format:@"createRepo called for Repo that already exists."];
   82|      0|            return nil;
   83|      0|        }
   84|      0|    }
   85|      0|}
   86|       |
   87|      0|+ (void)interrupt:(FIRDatabaseConfig *)config {
   88|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
   89|      0|      FRepoDictionary *configs = [FRepoManager configs];
   90|      0|      NSMutableDictionary<FRepoInfo *, FRepo *> *repos =
   91|      0|          configs[config.sessionIdentifier];
   92|      0|      for (FRepo *repo in [repos allValues]) {
   93|      0|          [repo interrupt];
   94|      0|      }
   95|      0|    });
   96|      0|}
   97|       |
   98|      0|+ (void)interruptAll {
   99|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  100|      0|      FRepoDictionary *configs = [FRepoManager configs];
  101|      0|      for (NSMutableDictionary<FRepoInfo *, FRepo *> *repos in
  102|      0|           [configs allValues]) {
  103|      0|          for (FRepo *repo in [repos allValues]) {
  104|      0|              [repo interrupt];
  105|      0|          }
  106|      0|      }
  107|      0|    });
  108|      0|}
  109|       |
  110|      0|+ (void)resume:(FIRDatabaseConfig *)config {
  111|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  112|      0|      FRepoDictionary *configs = [FRepoManager configs];
  113|      0|      NSMutableDictionary<FRepoInfo *, FRepo *> *repos =
  114|      0|          configs[config.sessionIdentifier];
  115|      0|      for (FRepo *repo in [repos allValues]) {
  116|      0|          [repo resume];
  117|      0|      }
  118|      0|    });
  119|      0|}
  120|       |
  121|      0|+ (void)resumeAll {
  122|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  123|      0|      FRepoDictionary *configs = [FRepoManager configs];
  124|      0|      for (NSMutableDictionary<FRepoInfo *, FRepo *> *repos in
  125|      0|           [configs allValues]) {
  126|      0|          for (FRepo *repo in [repos allValues]) {
  127|      0|              [repo resume];
  128|      0|          }
  129|      0|      }
  130|      0|    });
  131|      0|}
  132|       |
  133|      0|+ (void)disposeRepos:(FIRDatabaseConfig *)config {
  134|      0|    // Do this synchronously to make sure we release our references to LevelDB
  135|      0|    // before returning, allowing LevelDB to close and release its exclusive
  136|      0|    // locks.
  137|      0|    dispatch_sync([FIRDatabaseQuery sharedQueue], ^{
  138|      0|      FFLog(@"I-RDB040001", @"Disposing all repos for Config with name %@",
  139|      0|            config.sessionIdentifier);
  140|      0|      NSMutableDictionary *configs = [FRepoManager configs];
  141|      0|      for (FRepo *repo in [configs[config.sessionIdentifier] allValues]) {
  142|      0|          [repo dispose];
  143|      0|      }
  144|      0|      [configs removeObjectForKey:config.sessionIdentifier];
  145|      0|    });
  146|      0|}
  147|       |
  148|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FServerValues.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FServerValues.h"
   18|       |#import "FChildrenNode.h"
   19|       |#import "FConstants.h"
   20|       |#import "FLeafNode.h"
   21|       |#import "FSnapshotUtilities.h"
   22|       |
   23|       |@implementation FServerValues
   24|       |
   25|      0|+ (NSDictionary *)generateServerValues:(id<FClock>)clock {
   26|      0|    long long millis = (long long)([clock currentTime] * 1000);
   27|      0|    return @{@"timestamp" : [NSNumber numberWithLongLong:millis]};
   28|      0|}
   29|       |
   30|       |+ (id)resolveDeferredValue:(id)val
   31|      0|          withServerValues:(NSDictionary *)serverValues {
   32|      0|    if ([val isKindOfClass:[NSDictionary class]]) {
   33|      0|        NSDictionary *dict = val;
   34|      0|        if (dict[kServerValueSubKey] != nil) {
   35|      0|            NSString *serverValueType = [dict objectForKey:kServerValueSubKey];
   36|      0|            if (serverValues[serverValueType] != nil) {
   37|      0|                return [serverValues objectForKey:serverValueType];
   38|      0|            } else {
   39|      0|                // TODO: Throw unrecognizedServerValue error here
   40|      0|            }
   41|      0|        }
   42|      0|    }
   43|      0|    return val;
   44|      0|}
   45|       |
   46|       |+ (FCompoundWrite *)resolveDeferredValueCompoundWrite:(FCompoundWrite *)write
   47|       |                                     withServerValues:
   48|      0|                                         (NSDictionary *)serverValues {
   49|      0|    __block FCompoundWrite *resolved = write;
   50|      0|    [write enumerateWrites:^(FPath *path, id<FNode> node, BOOL *stop) {
   51|      0|      id<FNode> resolvedNode =
   52|      0|          [FServerValues resolveDeferredValueSnapshot:node
   53|      0|                                     withServerValues:serverValues];
   54|      0|      // Node actually changed, use pointer inequality here
   55|      0|      if (resolvedNode != node) {
   56|      0|          resolved = [resolved addWrite:resolvedNode atPath:path];
   57|      0|      }
   58|      0|    }];
   59|      0|    return resolved;
   60|      0|}
   61|       |
   62|       |+ (id)resolveDeferredValueTree:(FSparseSnapshotTree *)tree
   63|      0|              withServerValues:(NSDictionary *)serverValues {
   64|      0|    FSparseSnapshotTree *resolvedTree = [[FSparseSnapshotTree alloc] init];
   65|      0|    [tree
   66|      0|        forEachTreeAtPath:[FPath empty]
   67|      0|                       do:^(FPath *path, id<FNode> node) {
   68|      0|                         [resolvedTree
   69|      0|                             rememberData:
   70|      0|                                 [FServerValues
   71|      0|                                     resolveDeferredValueSnapshot:node
   72|      0|                                                 withServerValues:serverValues]
   73|      0|                                   onPath:path];
   74|      0|                       }];
   75|      0|    return resolvedTree;
   76|      0|}
   77|       |
   78|       |+ (id<FNode>)resolveDeferredValueSnapshot:(id<FNode>)node
   79|      0|                         withServerValues:(NSDictionary *)serverValues {
   80|      0|    id priorityVal =
   81|      0|        [FServerValues resolveDeferredValue:[[node getPriority] val]
   82|      0|                           withServerValues:serverValues];
   83|      0|    id<FNode> priority = [FSnapshotUtilities nodeFrom:priorityVal];
   84|      0|
   85|      0|    if ([node isLeafNode]) {
   86|      0|        id value = [self resolveDeferredValue:[node val]
   87|      0|                             withServerValues:serverValues];
   88|      0|        if (![value isEqual:[node val]] ||
   89|      0|            ![priority isEqual:[node getPriority]]) {
   90|      0|            return [[FLeafNode alloc] initWithValue:value
   91|      0|                                       withPriority:priority];
   92|      0|        } else {
   93|      0|            return node;
   94|      0|        }
   95|      0|    } else {
   96|      0|        __block FChildrenNode *newNode = node;
   97|      0|        if (![priority isEqual:[node getPriority]]) {
   98|      0|            newNode = [newNode updatePriority:priority];
   99|      0|        }
  100|      0|
  101|      0|        [node enumerateChildrenUsingBlock:^(NSString *childKey,
  102|      0|                                            id<FNode> childNode, BOOL *stop) {
  103|      0|          id newChildNode =
  104|      0|              [FServerValues resolveDeferredValueSnapshot:childNode
  105|      0|                                         withServerValues:serverValues];
  106|      0|          if (![newChildNode isEqual:childNode]) {
  107|      0|              newNode = [newNode updateImmediateChild:childKey
  108|      0|                                         withNewChild:newChildNode];
  109|      0|          }
  110|      0|        }];
  111|      0|        return newNode;
  112|      0|    }
  113|      0|}
  114|       |
  115|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FSnapshotHolder.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FSnapshotHolder.h"
   18|       |#import "FEmptyNode.h"
   19|       |
   20|       |@interface FSnapshotHolder ()
   21|       |
   22|       |@end
   23|       |
   24|       |@implementation FSnapshotHolder
   25|       |
   26|       |@synthesize rootNode;
   27|       |
   28|      0|- (id)init {
   29|      0|    self = [super init];
   30|      0|    if (self) {
   31|      0|        self.rootNode = [FEmptyNode emptyNode];
   32|      0|    }
   33|      0|    return self;
   34|      0|}
   35|       |
   36|      0|- (id<FNode>)getNode:(FPath *)path {
   37|      0|    return [self.rootNode getChild:path];
   38|      0|}
   39|       |
   40|       |- (void)updateSnapshot:(FPath *)path
   41|      0|       withNewSnapshot:(id<FNode>)newSnapshotNode {
   42|      0|    self.rootNode = [self.rootNode updateChild:path
   43|      0|                                  withNewChild:newSnapshotNode];
   44|      0|}
   45|       |
   46|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FSparseSnapshotTree.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FSparseSnapshotTree.h"
   18|       |#import "FChildrenNode.h"
   19|       |
   20|       |@interface FSparseSnapshotTree () {
   21|       |    id<FNode> value;
   22|       |    NSMutableDictionary *children;
   23|       |}
   24|       |
   25|       |@end
   26|       |
   27|       |@implementation FSparseSnapshotTree
   28|       |
   29|      0|- (id)init {
   30|      0|    self = [super init];
   31|      0|    if (self) {
   32|      0|        value = nil;
   33|      0|        children = nil;
   34|      0|    }
   35|      0|    return self;
   36|      0|}
   37|       |
   38|      0|- (id<FNode>)findPath:(FPath *)path {
   39|      0|    if (value != nil) {
   40|      0|        return [value getChild:path];
   41|      0|    } else if (![path isEmpty] && children != nil) {
   42|      0|        NSString *childKey = [path getFront];
   43|      0|        path = [path popFront];
   44|      0|        FSparseSnapshotTree *childTree = children[childKey];
   45|      0|        if (childTree != nil) {
   46|      0|            return [childTree findPath:path];
   47|      0|        } else {
   48|      0|            return nil;
   49|      0|        }
   50|      0|    } else {
   51|      0|        return nil;
   52|      0|    }
   53|      0|}
   54|       |
   55|      0|- (void)rememberData:(id<FNode>)data onPath:(FPath *)path {
   56|      0|    if ([path isEmpty]) {
   57|      0|        value = data;
   58|      0|        children = nil;
   59|      0|    } else if (value != nil) {
   60|      0|        value = [value updateChild:path withNewChild:data];
   61|      0|    } else {
   62|      0|        if (children == nil) {
   63|      0|            children = [[NSMutableDictionary alloc] init];
   64|      0|        }
   65|      0|
   66|      0|        NSString *childKey = [path getFront];
   67|      0|        if (children[childKey] == nil) {
   68|      0|            children[childKey] = [[FSparseSnapshotTree alloc] init];
   69|      0|        }
   70|      0|
   71|      0|        FSparseSnapshotTree *child = children[childKey];
   72|      0|        path = [path popFront];
   73|      0|        [child rememberData:data onPath:path];
   74|      0|    }
   75|      0|}
   76|       |
   77|      0|- (BOOL)forgetPath:(FPath *)path {
   78|      0|    if ([path isEmpty]) {
   79|      0|        value = nil;
   80|      0|        children = nil;
   81|      0|        return YES;
   82|      0|    } else {
   83|      0|        if (value != nil) {
   84|      0|            if ([value isLeafNode]) {
   85|      0|                // non-empty path at leaf. the path leads to nowhere
   86|      0|                return NO;
   87|      0|            } else {
   88|      0|                id<FNode> tmp = value;
   89|      0|                value = nil;
   90|      0|
   91|      0|                [tmp enumerateChildrenUsingBlock:^(NSString *key,
   92|      0|                                                   id<FNode> node, BOOL *stop) {
   93|      0|                  [self rememberData:node onPath:[[FPath alloc] initWith:key]];
   94|      0|                }];
   95|      0|
   96|      0|                // we've cleared out the value and set children. Call ourself
   97|      0|                // again to hit the next case
   98|      0|                return [self forgetPath:path];
   99|      0|            }
  100|      0|        } else if (children != nil) {
  101|      0|            NSString *childKey = [path getFront];
  102|      0|            path = [path popFront];
  103|      0|
  104|      0|            if (children[childKey] != nil) {
  105|      0|                FSparseSnapshotTree *child = children[childKey];
  106|      0|                BOOL safeToRemove = [child forgetPath:path];
  107|      0|                if (safeToRemove) {
  108|      0|                    [children removeObjectForKey:childKey];
  109|      0|                }
  110|      0|            }
  111|      0|
  112|      0|            if ([children count] == 0) {
  113|      0|                children = nil;
  114|      0|                return YES;
  115|      0|            } else {
  116|      0|                return NO;
  117|      0|            }
  118|      0|        } else {
  119|      0|            return YES;
  120|      0|        }
  121|      0|    }
  122|      0|}
  123|       |
  124|      0|- (void)forEachTreeAtPath:(FPath *)prefixPath do:(fbt_void_path_node)func {
  125|      0|    if (value != nil) {
  126|      0|        func(prefixPath, value);
  127|      0|    } else {
  128|      0|        [self forEachChild:^(NSString *key, FSparseSnapshotTree *tree) {
  129|      0|          FPath *path = [prefixPath childFromString:key];
  130|      0|          [tree forEachTreeAtPath:path do:func];
  131|      0|        }];
  132|      0|    }
  133|      0|}
  134|       |
  135|      0|- (void)forEachChild:(fbt_void_nsstring_sstree)func {
  136|      0|    if (children != nil) {
  137|      0|        for (NSString *key in children) {
  138|      0|            FSparseSnapshotTree *tree = [children objectForKey:key];
  139|      0|            func(key, tree);
  140|      0|        }
  141|      0|    }
  142|      0|}
  143|       |
  144|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FSyncPoint.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FSyncPoint.h"
   18|       |#import "FCacheNode.h"
   19|       |#import "FChildrenNode.h"
   20|       |#import "FDataEvent.h"
   21|       |#import "FEmptyNode.h"
   22|       |#import "FEventRegistration.h"
   23|       |#import "FIRDatabaseQuery.h"
   24|       |#import "FNode.h"
   25|       |#import "FOperation.h"
   26|       |#import "FOperationSource.h"
   27|       |#import "FPath.h"
   28|       |#import "FPersistenceManager.h"
   29|       |#import "FQueryParams.h"
   30|       |#import "FQuerySpec.h"
   31|       |#import "FTupleRemovedQueriesEvents.h"
   32|       |#import "FView.h"
   33|       |#import "FViewCache.h"
   34|       |#import "FWriteTreeRef.h"
   35|       |
   36|       |/**
   37|       | * SyncPoint represents a single location in a SyncTree with 1 or more event
   38|       | * registrations, meaning we need to maintain 1 or more Views at this location
   39|       | * to cache server data and raise appropriate events for server changes and user
   40|       | * writes (set, transaction, update).
   41|       | *
   42|       | * It's responsible for:
   43|       | *  - Maintaining the set of 1 or more views necessary at this location (a
   44|       | * SyncPoint with 0 views should be removed).
   45|       | *  - Proxying user / server operations to the views as appropriate (i.e.
   46|       | * applyServerOverwrite, applyUserOverwrite, etc.)
   47|       | */
   48|       |@interface FSyncPoint ()
   49|       |/**
   50|       | * The Views being tracked at this location in the tree, stored as a map where
   51|       | * the key is a queryParams and the value is the View for that query.
   52|       | *
   53|       | * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more
   54|       | * is an odd use case).
   55|       | *
   56|       | * Maps NSString -> FView
   57|       | */
   58|       |@property(nonatomic, strong) NSMutableDictionary *views;
   59|       |
   60|       |@property(nonatomic, strong) FPersistenceManager *persistenceManager;
   61|       |@end
   62|       |
   63|       |@implementation FSyncPoint
   64|       |
   65|      0|- (id)initWithPersistenceManager:(FPersistenceManager *)persistence {
   66|      0|    self = [super init];
   67|      0|    if (self) {
   68|      0|        self.persistenceManager = persistence;
   69|      0|        self.views = [[NSMutableDictionary alloc] init];
   70|      0|    }
   71|      0|    return self;
   72|      0|}
   73|       |
   74|      0|- (BOOL)isEmpty {
   75|      0|    return [self.views count] == 0;
   76|      0|}
   77|       |
   78|       |- (NSArray *)applyOperation:(id<FOperation>)operation
   79|       |                     toView:(FView *)view
   80|       |                writesCache:(FWriteTreeRef *)writesCache
   81|      0|                serverCache:(id<FNode>)optCompleteServerCache {
   82|      0|    FViewOperationResult *result = [view applyOperation:operation
   83|      0|                                            writesCache:writesCache
   84|      0|                                            serverCache:optCompleteServerCache];
   85|      0|    if (!view.query.loadsAllData) {
   86|      0|        NSMutableSet *removed = [NSMutableSet set];
   87|      0|        NSMutableSet *added = [NSMutableSet set];
   88|      0|        [result.changes enumerateObjectsUsingBlock:^(
   89|      0|                            FChange *change, NSUInteger idx, BOOL *stop) {
   90|      0|          if (change.type == FIRDataEventTypeChildAdded) {
   91|      0|              [added addObject:change.childKey];
   92|      0|          } else if (change.type == FIRDataEventTypeChildRemoved) {
   93|      0|              [removed addObject:change.childKey];
   94|      0|          }
   95|      0|        }];
   96|      0|        if ([removed count] > 0 || [added count] > 0) {
   97|      0|            [self.persistenceManager
   98|      0|                updateTrackedQueryKeysWithAddedKeys:added
   99|      0|                                        removedKeys:removed
  100|      0|                                           forQuery:view.query];
  101|      0|        }
  102|      0|    }
  103|      0|    return result.events;
  104|      0|}
  105|       |
  106|       |- (NSArray *)applyOperation:(id<FOperation>)operation
  107|       |                writesCache:(FWriteTreeRef *)writesCache
  108|      0|                serverCache:(id<FNode>)optCompleteServerCache {
  109|      0|    FQueryParams *queryParams = operation.source.queryParams;
  110|      0|    if (queryParams != nil) {
  111|      0|        FView *view = [self.views objectForKey:queryParams];
  112|      0|        NSAssert(view != nil, @"SyncTree gave us an op for an invalid query.");
  113|      0|        return [self applyOperation:operation
  114|      0|                             toView:view
  115|      0|                        writesCache:writesCache
  116|      0|                        serverCache:optCompleteServerCache];
  117|      0|    } else {
  118|      0|        NSMutableArray *events = [[NSMutableArray alloc] init];
  119|      0|        [self.views enumerateKeysAndObjectsUsingBlock:^(
  120|      0|                        FQueryParams *key, FView *view, BOOL *stop) {
  121|      0|          NSArray *eventsForView = [self applyOperation:operation
  122|      0|                                                 toView:view
  123|      0|                                            writesCache:writesCache
  124|      0|                                            serverCache:optCompleteServerCache];
  125|      0|          [events addObjectsFromArray:eventsForView];
  126|      0|        }];
  127|      0|        return events;
  128|      0|    }
  129|      0|}
  130|       |
  131|       |/**
  132|       | * Add an event callback for the specified query
  133|       | * Returns Array of FEvent events to raise.
  134|       | */
  135|       |- (NSArray *)addEventRegistration:(id<FEventRegistration>)eventRegistration
  136|       |       forNonExistingViewForQuery:(FQuerySpec *)query
  137|       |                      writesCache:(FWriteTreeRef *)writesCache
  138|      0|                      serverCache:(FCacheNode *)serverCache {
  139|      0|    NSAssert(self.views[query.params] == nil, @"Found view for query: %@",
  140|      0|             query.params);
  141|      0|    // TODO: make writesCache take flag for complete server node
  142|      0|    id<FNode> eventCache = [writesCache
  143|      0|        calculateCompleteEventCacheWithCompleteServerCache:
  144|      0|            serverCache.isFullyInitialized ? serverCache.node : nil];
  145|      0|    BOOL eventCacheComplete;
  146|      0|    if (eventCache != nil) {
  147|      0|        eventCacheComplete = YES;
  148|      0|    } else {
  149|      0|        eventCache = [writesCache
  150|      0|            calculateCompleteEventChildrenWithCompleteServerChildren:serverCache
  151|      0|                                                                         .node];
  152|      0|        eventCacheComplete = NO;
  153|      0|    }
  154|      0|
  155|      0|    FIndexedNode *indexed = [FIndexedNode indexedNodeWithNode:eventCache
  156|      0|                                                        index:query.index];
  157|      0|    FCacheNode *eventCacheNode =
  158|      0|        [[FCacheNode alloc] initWithIndexedNode:indexed
  159|      0|                             isFullyInitialized:eventCacheComplete
  160|      0|                                     isFiltered:NO];
  161|      0|    FViewCache *viewCache =
  162|      0|        [[FViewCache alloc] initWithEventCache:eventCacheNode
  163|      0|                                   serverCache:serverCache];
  164|      0|    FView *view = [[FView alloc] initWithQuery:query
  165|      0|                              initialViewCache:viewCache];
  166|      0|    // If this is a non-default query we need to tell persistence our current
  167|      0|    // view of the data
  168|      0|    if (!query.loadsAllData) {
  169|      0|        NSMutableSet *allKeys = [NSMutableSet set];
  170|      0|        [view.eventCache enumerateChildrenUsingBlock:^(
  171|      0|                             NSString *key, id<FNode> node, BOOL *stop) {
  172|      0|          [allKeys addObject:key];
  173|      0|        }];
  174|      0|        [self.persistenceManager setTrackedQueryKeys:allKeys forQuery:query];
  175|      0|    }
  176|      0|    self.views[query.params] = view;
  177|      0|    return [self addEventRegistration:eventRegistration
  178|      0|              forExistingViewForQuery:query];
  179|      0|}
  180|       |
  181|       |- (NSArray *)addEventRegistration:(id<FEventRegistration>)eventRegistration
  182|      0|          forExistingViewForQuery:(FQuerySpec *)query {
  183|      0|    FView *view = self.views[query.params];
  184|      0|    NSAssert(view != nil, @"No view for query: %@", query);
  185|      0|    [view addEventRegistration:eventRegistration];
  186|      0|    return [view initialEvents:eventRegistration];
  187|      0|}
  188|       |
  189|       |/**
  190|       | * Remove event callback(s). Return cancelEvents if a cancelError is specified.
  191|       | *
  192|       | * If query is the default query, we'll check all views for the specified
  193|       | * eventRegistration. If eventRegistration is nil, we'll remove all callbacks
  194|       | * for the specified view(s).
  195|       | *
  196|       | * @return FTupleRemovedQueriesEvents removed queries and any cancel events
  197|       | */
  198|       |- (FTupleRemovedQueriesEvents *)removeEventRegistration:
  199|       |                                    (id<FEventRegistration>)eventRegistration
  200|       |                                               forQuery:(FQuerySpec *)query
  201|      0|                                            cancelError:(NSError *)cancelError {
  202|      0|    NSMutableArray *removedQueries = [[NSMutableArray alloc] init];
  203|      0|    __block NSMutableArray *cancelEvents = [[NSMutableArray alloc] init];
  204|      0|    BOOL hadCompleteView = [self hasCompleteView];
  205|      0|    if ([query isDefault]) {
  206|      0|        // When you do [ref removeObserverWithHandle:], we search all views for
  207|      0|        // the registration to remove.
  208|      0|        [self.views enumerateKeysAndObjectsUsingBlock:^(
  209|      0|                        FQueryParams *viewQueryParams, FView *view,
  210|      0|                        BOOL *stop) {
  211|      0|          [cancelEvents
  212|      0|              addObjectsFromArray:[view
  213|      0|                                      removeEventRegistration:eventRegistration
  214|      0|                                                  cancelError:cancelError]];
  215|      0|          if ([view isEmpty]) {
  216|      0|              [self.views removeObjectForKey:viewQueryParams];
  217|      0|
  218|      0|              // We'll deal with complete views later
  219|      0|              if (![view.query loadsAllData]) {
  220|      0|                  [removedQueries addObject:view.query];
  221|      0|              }
  222|      0|          }
  223|      0|        }];
  224|      0|    } else {
  225|      0|        // remove the callback from the specific view
  226|      0|        FView *view = [self.views objectForKey:query.params];
  227|      0|        if (view != nil) {
  228|      0|            [cancelEvents addObjectsFromArray:
  229|      0|                              [view removeEventRegistration:eventRegistration
  230|      0|                                                cancelError:cancelError]];
  231|      0|
  232|      0|            if ([view isEmpty]) {
  233|      0|                [self.views removeObjectForKey:query.params];
  234|      0|
  235|      0|                // We'll deal with complete views later
  236|      0|                if (![view.query loadsAllData]) {
  237|      0|                    [removedQueries addObject:view.query];
  238|      0|                }
  239|      0|            }
  240|      0|        }
  241|      0|    }
  242|      0|
  243|      0|    if (hadCompleteView && ![self hasCompleteView]) {
  244|      0|        // We removed our last complete view
  245|      0|        [removedQueries addObject:[FQuerySpec defaultQueryAtPath:query.path]];
  246|      0|    }
  247|      0|
  248|      0|    return [[FTupleRemovedQueriesEvents alloc]
  249|      0|        initWithRemovedQueries:removedQueries
  250|      0|                  cancelEvents:cancelEvents];
  251|      0|}
  252|       |
  253|      0|- (NSArray *)queryViews {
  254|      0|    __block NSMutableArray *filteredViews = [[NSMutableArray alloc] init];
  255|      0|
  256|      0|    [self.views enumerateKeysAndObjectsUsingBlock:^(FQueryParams *key,
  257|      0|                                                    FView *view, BOOL *stop) {
  258|      0|      if (![view.query loadsAllData]) {
  259|      0|          [filteredViews addObject:view];
  260|      0|      }
  261|      0|    }];
  262|      0|
  263|      0|    return filteredViews;
  264|      0|}
  265|       |
  266|      0|- (id<FNode>)completeServerCacheAtPath:(FPath *)path {
  267|      0|    __block id<FNode> serverCache = nil;
  268|      0|    [self.views enumerateKeysAndObjectsUsingBlock:^(FQueryParams *key,
  269|      0|                                                    FView *view, BOOL *stop) {
  270|      0|      serverCache = [view completeServerCacheFor:path];
  271|      0|      *stop = (serverCache != nil);
  272|      0|    }];
  273|      0|    return serverCache;
  274|      0|}
  275|       |
  276|      0|- (FView *)viewForQuery:(FQuerySpec *)query {
  277|      0|    return [self.views objectForKey:query.params];
  278|      0|}
  279|       |
  280|      0|- (BOOL)viewExistsForQuery:(FQuerySpec *)query {
  281|      0|    return [self viewForQuery:query] != nil;
  282|      0|}
  283|       |
  284|      0|- (BOOL)hasCompleteView {
  285|      0|    return [self completeView] != nil;
  286|      0|}
  287|       |
  288|      0|- (FView *)completeView {
  289|      0|    __block FView *completeView = nil;
  290|      0|
  291|      0|    [self.views enumerateKeysAndObjectsUsingBlock:^(FQueryParams *key,
  292|      0|                                                    FView *view, BOOL *stop) {
  293|      0|      if ([view.query loadsAllData]) {
  294|      0|          completeView = view;
  295|      0|          *stop = YES;
  296|      0|      }
  297|      0|    }];
  298|      0|
  299|      0|    return completeView;
  300|      0|}
  301|       |
  302|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FSyncTree.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FSyncTree.h"
   18|       |#import "FAckUserWrite.h"
   19|       |#import "FAtomicNumber.h"
   20|       |#import "FCacheNode.h"
   21|       |#import "FChildrenNode.h"
   22|       |#import "FCompoundHash.h"
   23|       |#import "FCompoundWrite.h"
   24|       |#import "FEmptyNode.h"
   25|       |#import "FEventRaiser.h"
   26|       |#import "FEventRegistration.h"
   27|       |#import "FImmutableTree.h"
   28|       |#import "FKeepSyncedEventRegistration.h"
   29|       |#import "FListenComplete.h"
   30|       |#import "FListenProvider.h"
   31|       |#import "FMerge.h"
   32|       |#import "FNode.h"
   33|       |#import "FOperation.h"
   34|       |#import "FOperationSource.h"
   35|       |#import "FOverwrite.h"
   36|       |#import "FPath.h"
   37|       |#import "FPersistenceManager.h"
   38|       |#import "FQueryParams.h"
   39|       |#import "FQuerySpec.h"
   40|       |#import "FRangeMerge.h"
   41|       |#import "FServerValues.h"
   42|       |#import "FSnapshotHolder.h"
   43|       |#import "FSnapshotUtilities.h"
   44|       |#import "FSyncPoint.h"
   45|       |#import "FTupleRemovedQueriesEvents.h"
   46|       |#import "FUtilities.h"
   47|       |#import "FView.h"
   48|       |#import "FWriteRecord.h"
   49|       |#import "FWriteTree.h"
   50|       |#import "FWriteTreeRef.h"
   51|       |#import <FirebaseCore/FIRLogger.h>
   52|       |
   53|       |// Size after which we start including the compound hash
   54|       |static const NSUInteger kFSizeThresholdForCompoundHash = 1024;
   55|       |
   56|       |@interface FListenContainer : NSObject <FSyncTreeHash>
   57|       |
   58|       |@property(nonatomic, strong) FView *view;
   59|       |@property(nonatomic, copy) fbt_nsarray_nsstring onComplete;
   60|       |
   61|       |@end
   62|       |
   63|       |@implementation FListenContainer
   64|       |
   65|       |- (instancetype)initWithView:(FView *)view
   66|      0|                  onComplete:(fbt_nsarray_nsstring)onComplete {
   67|      0|    self = [super init];
   68|      0|    if (self != nil) {
   69|      0|        self->_view = view;
   70|      0|        self->_onComplete = onComplete;
   71|      0|    }
   72|      0|    return self;
   73|      0|}
   74|       |
   75|      0|- (id<FNode>)serverCache {
   76|      0|    return self.view.serverCache;
   77|      0|}
   78|       |
   79|      0|- (FCompoundHash *)compoundHash {
   80|      0|    return [FCompoundHash fromNode:[self serverCache]];
   81|      0|}
   82|       |
   83|      0|- (NSString *)simpleHash {
   84|      0|    return [[self serverCache] dataHash];
   85|      0|}
   86|       |
   87|      0|- (BOOL)includeCompoundHash {
   88|      0|    return [FSnapshotUtilities estimateSerializedNodeSize:[self serverCache]] >
   89|      0|           kFSizeThresholdForCompoundHash;
   90|      0|}
   91|       |
   92|       |@end
   93|       |
   94|       |@interface FSyncTree ()
   95|       |
   96|       |/**
   97|       | * Tree of SyncPoints. There's a SyncPoint at any location that has 1 or more
   98|       | * views.
   99|       | */
  100|       |@property(nonatomic, strong) FImmutableTree *syncPointTree;
  101|       |
  102|       |/**
  103|       | * A tree of all pending user writes (user-initiated set, transactions, updates,
  104|       | * etc)
  105|       | */
  106|       |@property(nonatomic, strong) FWriteTree *pendingWriteTree;
  107|       |
  108|       |/**
  109|       | * Maps tagId -> FTuplePathQueryParams
  110|       | */
  111|       |@property(nonatomic, strong) NSMutableDictionary *tagToQueryMap;
  112|       |@property(nonatomic, strong) NSMutableDictionary *queryToTagMap;
  113|       |@property(nonatomic, strong) FListenProvider *listenProvider;
  114|       |@property(nonatomic, strong) FPersistenceManager *persistenceManager;
  115|       |@property(nonatomic, strong) FAtomicNumber *queryTagCounter;
  116|       |@property(nonatomic, strong) NSMutableSet *keepSyncedQueries;
  117|       |
  118|       |@end
  119|       |
  120|       |/**
  121|       | * SyncTree is the central class for managing event callback registration, data
  122|       | * caching, views (query processing), and event generation.  There are typically
  123|       | * two SyncTree instances for each Repo, one for the normal Firebase data, and
  124|       | * one for the .info data.
  125|       | *
  126|       | * It has a number of responsibilities, including:
  127|       | *  - Tracking all user event callbacks (registered via addEventRegistration:
  128|       | * and removeEventRegistration:).
  129|       | *  - Applying and caching data changes for user setValue:,
  130|       | * runTransactionBlock:, and updateChildValues: calls
  131|       | *    (applyUserOverwriteAtPath:, applyUserMergeAtPath:).
  132|       | *  - Applying and caching data changes for server data changes
  133|       | * (applyServerOverwriteAtPath:, applyServerMergeAtPath:).
  134|       | *  - Generating user-facing events for server and user changes (all of the
  135|       | * apply* methods return the set of events that need to be raised as a result).
  136|       | *  - Maintaining the appropriate set of server listens to ensure we are always
  137|       | * subscribed to the correct set of paths and queries to satisfy the current set
  138|       | * of user event callbacks (listens are started/stopped using the provided
  139|       | * listenProvider).
  140|       | *
  141|       | * NOTE: Although SyncTree tracks event callbacks and calculates events to
  142|       | * raise, the actual events are returned to the caller rather than raised
  143|       | * synchronously.
  144|       | */
  145|       |@implementation FSyncTree
  146|       |
  147|      0|- (id)initWithListenProvider:(FListenProvider *)provider {
  148|      0|    return [self initWithPersistenceManager:nil listenProvider:provider];
  149|      0|}
  150|       |
  151|       |- (id)initWithPersistenceManager:(FPersistenceManager *)persistenceManager
  152|      0|                  listenProvider:(FListenProvider *)provider {
  153|      0|    self = [super init];
  154|      0|    if (self) {
  155|      0|        self.syncPointTree = [FImmutableTree empty];
  156|      0|        self.pendingWriteTree = [[FWriteTree alloc] init];
  157|      0|        self.tagToQueryMap = [[NSMutableDictionary alloc] init];
  158|      0|        self.queryToTagMap = [[NSMutableDictionary alloc] init];
  159|      0|        self.listenProvider = provider;
  160|      0|        self.persistenceManager = persistenceManager;
  161|      0|        self.queryTagCounter = [[FAtomicNumber alloc] init];
  162|      0|        self.keepSyncedQueries = [NSMutableSet set];
  163|      0|    }
  164|      0|    return self;
  165|      0|}
  166|       |
  167|       |#pragma mark -
  168|       |#pragma mark Apply Operations
  169|       |
  170|       |/**
  171|       | * Apply data changes for a user-generated setValue: runTransactionBlock:
  172|       | * updateChildValues:, etc.
  173|       | * @return NSArray of FEvent to raise.
  174|       | */
  175|       |- (NSArray *)applyUserOverwriteAtPath:(FPath *)path
  176|       |                              newData:(id<FNode>)newData
  177|       |                              writeId:(NSInteger)writeId
  178|      0|                            isVisible:(BOOL)visible {
  179|      0|    // Record pending write
  180|      0|    [self.pendingWriteTree addOverwriteAtPath:path
  181|      0|                                      newData:newData
  182|      0|                                      writeId:writeId
  183|      0|                                    isVisible:visible];
  184|      0|    if (!visible) {
  185|      0|        return @[];
  186|      0|    } else {
  187|      0|        FOverwrite *operation =
  188|      0|            [[FOverwrite alloc] initWithSource:[FOperationSource userInstance]
  189|      0|                                          path:path
  190|      0|                                          snap:newData];
  191|      0|        return [self applyOperationToSyncPoints:operation];
  192|      0|    }
  193|      0|}
  194|       |
  195|       |/**
  196|       | * Apply the data from a user-generated updateChildValues: call
  197|       | * @return NSArray of FEvent to raise.
  198|       | */
  199|       |- (NSArray *)applyUserMergeAtPath:(FPath *)path
  200|       |                  changedChildren:(FCompoundWrite *)changedChildren
  201|      0|                          writeId:(NSInteger)writeId {
  202|      0|    // Record pending merge
  203|      0|    [self.pendingWriteTree addMergeAtPath:path
  204|      0|                          changedChildren:changedChildren
  205|      0|                                  writeId:writeId];
  206|      0|
  207|      0|    FMerge *operation =
  208|      0|        [[FMerge alloc] initWithSource:[FOperationSource userInstance]
  209|      0|                                  path:path
  210|      0|                              children:changedChildren];
  211|      0|    return [self applyOperationToSyncPoints:operation];
  212|      0|}
  213|       |
  214|       |/**
  215|       | * Acknowledge a pending user write that was previously registered with
  216|       | * applyUserOverwriteAtPath: or applyUserMergeAtPath:
  217|       | * TODO[offline]: Taking a serverClock here is awkward, but server values are
  218|       | * awkward. :-(
  219|       | * @return NSArray of FEvent to raise.
  220|       | */
  221|       |- (NSArray *)ackUserWriteWithWriteId:(NSInteger)writeId
  222|       |                              revert:(BOOL)revert
  223|       |                             persist:(BOOL)persist
  224|      0|                               clock:(id<FClock>)clock {
  225|      0|    FWriteRecord *write = [self.pendingWriteTree writeForId:writeId];
  226|      0|    BOOL needToReevaluate = [self.pendingWriteTree removeWriteId:writeId];
  227|      0|    if (write.visible) {
  228|      0|        if (persist) {
  229|      0|            [self.persistenceManager removeUserWrite:writeId];
  230|      0|        }
  231|      0|        if (!revert) {
  232|      0|            NSDictionary *serverValues =
  233|      0|                [FServerValues generateServerValues:clock];
  234|      0|            if ([write isOverwrite]) {
  235|      0|                id<FNode> resolvedNode =
  236|      0|                    [FServerValues resolveDeferredValueSnapshot:write.overwrite
  237|      0|                                               withServerValues:serverValues];
  238|      0|                [self.persistenceManager applyUserWrite:resolvedNode
  239|      0|                                    toServerCacheAtPath:write.path];
  240|      0|            } else {
  241|      0|                FCompoundWrite *resolvedMerge = [FServerValues
  242|      0|                    resolveDeferredValueCompoundWrite:write.merge
  243|      0|                                     withServerValues:serverValues];
  244|      0|                [self.persistenceManager applyUserMerge:resolvedMerge
  245|      0|                                    toServerCacheAtPath:write.path];
  246|      0|            }
  247|      0|        }
  248|      0|    }
  249|      0|    if (!needToReevaluate) {
  250|      0|        return @[];
  251|      0|    } else {
  252|      0|        __block FImmutableTree *affectedTree = [FImmutableTree empty];
  253|      0|        if (write.isOverwrite) {
  254|      0|            affectedTree = [affectedTree setValue:@YES atPath:[FPath empty]];
  255|      0|        } else {
  256|      0|            [write.merge
  257|      0|                enumerateWrites:^(FPath *path, id<FNode> node, BOOL *stop) {
  258|      0|                  affectedTree = [affectedTree setValue:@YES atPath:path];
  259|      0|                }];
  260|      0|        }
  261|      0|        FAckUserWrite *operation =
  262|      0|            [[FAckUserWrite alloc] initWithPath:write.path
  263|      0|                                   affectedTree:affectedTree
  264|      0|                                         revert:revert];
  265|      0|        return [self applyOperationToSyncPoints:operation];
  266|      0|    }
  267|      0|}
  268|       |
  269|       |/**
  270|       | * Apply new server data for the specified path
  271|       | * @return NSArray of FEvent to raise.
  272|       | */
  273|       |- (NSArray *)applyServerOverwriteAtPath:(FPath *)path
  274|      0|                                newData:(id<FNode>)newData {
  275|      0|    [self.persistenceManager
  276|      0|        updateServerCacheWithNode:newData
  277|      0|                         forQuery:[FQuerySpec defaultQueryAtPath:path]];
  278|      0|    FOverwrite *operation =
  279|      0|        [[FOverwrite alloc] initWithSource:[FOperationSource serverInstance]
  280|      0|                                      path:path
  281|      0|                                      snap:newData];
  282|      0|    return [self applyOperationToSyncPoints:operation];
  283|      0|}
  284|       |
  285|       |/**
  286|       | * Applied new server data to be merged in at the specified path
  287|       | * @return NSArray of FEvent to raise.
  288|       | */
  289|       |- (NSArray *)applyServerMergeAtPath:(FPath *)path
  290|      0|                    changedChildren:(FCompoundWrite *)changedChildren {
  291|      0|    [self.persistenceManager updateServerCacheWithMerge:changedChildren
  292|      0|                                                 atPath:path];
  293|      0|    FMerge *operation =
  294|      0|        [[FMerge alloc] initWithSource:[FOperationSource serverInstance]
  295|      0|                                  path:path
  296|      0|                              children:changedChildren];
  297|      0|    return [self applyOperationToSyncPoints:operation];
  298|      0|}
  299|       |
  300|       |- (NSArray *)applyServerRangeMergeAtPath:(FPath *)path
  301|      0|                                 updates:(NSArray *)ranges {
  302|      0|    FSyncPoint *syncPoint = [self.syncPointTree valueAtPath:path];
  303|      0|    if (syncPoint == nil) {
  304|      0|        // Removed view, so it's safe to just ignore this update
  305|      0|        return @[];
  306|      0|    } else {
  307|      0|        // This could be for any "complete" (unfiltered) view, and if there is
  308|      0|        // more than one complete view, they should each have the same cache so
  309|      0|        // it doesn't matter which one we use.
  310|      0|        FView *view = [syncPoint completeView];
  311|      0|        if (view != nil) {
  312|      0|            id<FNode> serverNode = [view serverCache];
  313|      0|            for (FRangeMerge *merge in ranges) {
  314|      0|                serverNode = [merge applyToNode:serverNode];
  315|      0|            }
  316|      0|            return [self applyServerOverwriteAtPath:path newData:serverNode];
  317|      0|        } else {
  318|      0|            // There doesn't exist a view for this update, so it was removed and
  319|      0|            // it's safe to just ignore this range merge
  320|      0|            return @[];
  321|      0|        }
  322|      0|    }
  323|      0|}
  324|       |
  325|       |/**
  326|       | * Apply a listen complete to a path
  327|       | * @return NSArray of FEvent to raise.
  328|       | */
  329|      0|- (NSArray *)applyListenCompleteAtPath:(FPath *)path {
  330|      0|    [self.persistenceManager
  331|      0|        setQueryComplete:[FQuerySpec defaultQueryAtPath:path]];
  332|      0|    id<FOperation> operation = [[FListenComplete alloc]
  333|      0|        initWithSource:[FOperationSource serverInstance]
  334|      0|                  path:path];
  335|      0|    return [self applyOperationToSyncPoints:operation];
  336|      0|}
  337|       |
  338|       |/**
  339|       | * Apply a listen complete to a path
  340|       | * @return NSArray of FEvent to raise.
  341|       | */
  342|       |- (NSArray *)applyTaggedListenCompleteAtPath:(FPath *)path
  343|      0|                                       tagId:(NSNumber *)tagId {
  344|      0|    FQuerySpec *query = [self queryForTag:tagId];
  345|      0|    if (query != nil) {
  346|      0|        [self.persistenceManager setQueryComplete:query];
  347|      0|        FPath *relativePath = [FPath relativePathFrom:query.path to:path];
  348|      0|        id<FOperation> op = [[FListenComplete alloc]
  349|      0|            initWithSource:[FOperationSource forServerTaggedQuery:query.params]
  350|      0|                      path:relativePath];
  351|      0|        return [self applyTaggedOperation:op atPath:query.path];
  352|      0|    } else {
  353|      0|        // We've already removed the query. No big deal, ignore the update.
  354|      0|        return @[];
  355|      0|    }
  356|      0|}
  357|       |
  358|       |/**
  359|       | * Internal helper method to apply tagged operation
  360|       | */
  361|       |- (NSArray *)applyTaggedOperation:(id<FOperation>)operation
  362|      0|                           atPath:(FPath *)path {
  363|      0|    FSyncPoint *syncPoint = [self.syncPointTree valueAtPath:path];
  364|      0|    NSAssert(syncPoint != nil,
  365|      0|             @"Missing sync point for query tag that we're tracking.");
  366|      0|    FWriteTreeRef *writesCache =
  367|      0|        [self.pendingWriteTree childWritesForPath:path];
  368|      0|    return [syncPoint applyOperation:operation
  369|      0|                         writesCache:writesCache
  370|      0|                         serverCache:nil];
  371|      0|}
  372|       |
  373|       |/**
  374|       | * Apply new server data for the specified tagged query
  375|       | * @return NSArray of FEvent to raise.
  376|       | */
  377|       |- (NSArray *)applyTaggedQueryOverwriteAtPath:(FPath *)path
  378|       |                                     newData:(id<FNode>)newData
  379|      0|                                       tagId:(NSNumber *)tagId {
  380|      0|    FQuerySpec *query = [self queryForTag:tagId];
  381|      0|    if (query != nil) {
  382|      0|        FPath *relativePath = [FPath relativePathFrom:query.path to:path];
  383|      0|        FQuerySpec *queryToOverwrite =
  384|      0|            relativePath.isEmpty ? query : [FQuerySpec defaultQueryAtPath:path];
  385|      0|        [self.persistenceManager updateServerCacheWithNode:newData
  386|      0|                                                  forQuery:queryToOverwrite];
  387|      0|        FOverwrite *operation = [[FOverwrite alloc]
  388|      0|            initWithSource:[FOperationSource forServerTaggedQuery:query.params]
  389|      0|                      path:relativePath
  390|      0|                      snap:newData];
  391|      0|        return [self applyTaggedOperation:operation atPath:query.path];
  392|      0|    } else {
  393|      0|        // Query must have been removed already
  394|      0|        return @[];
  395|      0|    }
  396|      0|}
  397|       |
  398|       |/**
  399|       | * Apply server data to be merged in for the specified tagged query
  400|       | * @return NSArray of FEvent to raise.
  401|       | */
  402|       |- (NSArray *)applyTaggedQueryMergeAtPath:(FPath *)path
  403|       |                         changedChildren:(FCompoundWrite *)changedChildren
  404|      0|                                   tagId:(NSNumber *)tagId {
  405|      0|    FQuerySpec *query = [self queryForTag:tagId];
  406|      0|    if (query != nil) {
  407|      0|        FPath *relativePath = [FPath relativePathFrom:query.path to:path];
  408|      0|        [self.persistenceManager updateServerCacheWithMerge:changedChildren
  409|      0|                                                     atPath:path];
  410|      0|        FMerge *operation = [[FMerge alloc]
  411|      0|            initWithSource:[FOperationSource forServerTaggedQuery:query.params]
  412|      0|                      path:relativePath
  413|      0|                  children:changedChildren];
  414|      0|        return [self applyTaggedOperation:operation atPath:query.path];
  415|      0|    } else {
  416|      0|        // We've already removed the query. No big deal, ignore the update.
  417|      0|        return @[];
  418|      0|    }
  419|      0|}
  420|       |
  421|       |- (NSArray *)applyTaggedServerRangeMergeAtPath:(FPath *)path
  422|       |                                       updates:(NSArray *)ranges
  423|      0|                                         tagId:(NSNumber *)tagId {
  424|      0|    FQuerySpec *query = [self queryForTag:tagId];
  425|      0|    if (query != nil) {
  426|      0|        NSAssert([path isEqual:query.path],
  427|      0|                 @"Tagged update path and query path must match");
  428|      0|        FSyncPoint *syncPoint = [self.syncPointTree valueAtPath:path];
  429|      0|        NSAssert(syncPoint != nil,
  430|      0|                 @"Missing sync point for query tag that we're tracking.");
  431|      0|        FView *view = [syncPoint viewForQuery:query];
  432|      0|        NSAssert(view != nil,
  433|      0|                 @"Missing view for query tag that we're tracking");
  434|      0|        id<FNode> serverNode = [view serverCache];
  435|      0|        for (FRangeMerge *merge in ranges) {
  436|      0|            serverNode = [merge applyToNode:serverNode];
  437|      0|        }
  438|      0|        return [self applyTaggedQueryOverwriteAtPath:path
  439|      0|                                             newData:serverNode
  440|      0|                                               tagId:tagId];
  441|      0|    } else {
  442|      0|        // We've already removed the query. No big deal, ignore the update.
  443|      0|        return @[];
  444|      0|    }
  445|      0|}
  446|       |
  447|       |/**
  448|       | * Add an event callback for the specified query
  449|       | * @return NSArray of FEvent to raise.
  450|       | */
  451|       |- (NSArray *)addEventRegistration:(id<FEventRegistration>)eventRegistration
  452|      0|                         forQuery:(FQuerySpec *)query {
  453|      0|    FPath *path = query.path;
  454|      0|
  455|      0|    __block BOOL foundAncestorDefaultView = NO;
  456|      0|    [self.syncPointTree
  457|      0|        forEachOnPath:query.path
  458|      0|           whileBlock:^BOOL(FPath *pathToSyncPoint, FSyncPoint *syncPoint) {
  459|      0|             foundAncestorDefaultView =
  460|      0|                 foundAncestorDefaultView || [syncPoint hasCompleteView];
  461|      0|             return !foundAncestorDefaultView;
  462|      0|           }];
  463|      0|
  464|      0|    [self.persistenceManager setQueryActive:query];
  465|      0|
  466|      0|    FSyncPoint *syncPoint = [self.syncPointTree valueAtPath:path];
  467|      0|    if (syncPoint == nil) {
  468|      0|        syncPoint = [[FSyncPoint alloc]
  469|      0|            initWithPersistenceManager:self.persistenceManager];
  470|      0|        self.syncPointTree = [self.syncPointTree setValue:syncPoint
  471|      0|                                                   atPath:path];
  472|      0|    }
  473|      0|
  474|      0|    BOOL viewAlreadyExists = [syncPoint viewExistsForQuery:query];
  475|      0|    NSArray *events;
  476|      0|    if (viewAlreadyExists) {
  477|      0|        events = [syncPoint addEventRegistration:eventRegistration
  478|      0|                         forExistingViewForQuery:query];
  479|      0|    } else {
  480|      0|        if (![query loadsAllData]) {
  481|      0|            // We need to track a tag for this query
  482|      0|            NSAssert(self.queryToTagMap[query] == nil,
  483|      0|                     @"View does not exist, but we have a tag");
  484|      0|            NSNumber *tagId = [self.queryTagCounter getAndIncrement];
  485|      0|            self.queryToTagMap[query] = tagId;
  486|      0|            self.tagToQueryMap[tagId] = query;
  487|      0|        }
  488|      0|
  489|      0|        FWriteTreeRef *writesCache =
  490|      0|            [self.pendingWriteTree childWritesForPath:path];
  491|      0|        FCacheNode *serverCache = [self serverCacheForQuery:query];
  492|      0|        events = [syncPoint addEventRegistration:eventRegistration
  493|      0|                      forNonExistingViewForQuery:query
  494|      0|                                     writesCache:writesCache
  495|      0|                                     serverCache:serverCache];
  496|      0|
  497|      0|        // There was no view and no default listen
  498|      0|        if (!foundAncestorDefaultView) {
  499|      0|            FView *view = [syncPoint viewForQuery:query];
  500|      0|            NSMutableArray *mutableEvents = [events mutableCopy];
  501|      0|            [mutableEvents
  502|      0|                addObjectsFromArray:[self setupListenerOnQuery:query
  503|      0|                                                          view:view]];
  504|      0|            events = mutableEvents;
  505|      0|        }
  506|      0|    }
  507|      0|
  508|      0|    return events;
  509|      0|}
  510|       |
  511|      0|- (FCacheNode *)serverCacheForQuery:(FQuerySpec *)query {
  512|      0|    __block id<FNode> serverCacheNode = nil;
  513|      0|
  514|      0|    [self.syncPointTree
  515|      0|        forEachOnPath:query.path
  516|      0|           whileBlock:^BOOL(FPath *pathToSyncPoint, FSyncPoint *syncPoint) {
  517|      0|             FPath *relativePath = [FPath relativePathFrom:pathToSyncPoint
  518|      0|                                                        to:query.path];
  519|      0|             serverCacheNode =
  520|      0|                 [syncPoint completeServerCacheAtPath:relativePath];
  521|      0|             return serverCacheNode == nil;
  522|      0|           }];
  523|      0|
  524|      0|    FCacheNode *serverCache;
  525|      0|    if (serverCacheNode != nil) {
  526|      0|        FIndexedNode *indexed =
  527|      0|            [FIndexedNode indexedNodeWithNode:serverCacheNode
  528|      0|                                        index:query.index];
  529|      0|        serverCache = [[FCacheNode alloc] initWithIndexedNode:indexed
  530|      0|                                           isFullyInitialized:YES
  531|      0|                                                   isFiltered:NO];
  532|      0|    } else {
  533|      0|        FCacheNode *persistenceServerCache =
  534|      0|            [self.persistenceManager serverCacheForQuery:query];
  535|      0|        if (persistenceServerCache.isFullyInitialized) {
  536|      0|            serverCache = persistenceServerCache;
  537|      0|        } else {
  538|      0|            serverCacheNode = [FEmptyNode emptyNode];
  539|      0|
  540|      0|            FImmutableTree *subtree =
  541|      0|                [self.syncPointTree subtreeAtPath:query.path];
  542|      0|            [subtree
  543|      0|                forEachChild:^(NSString *childKey, FSyncPoint *childSyncPoint) {
  544|      0|                  id<FNode> completeCache =
  545|      0|                      [childSyncPoint completeServerCacheAtPath:[FPath empty]];
  546|      0|                  if (completeCache) {
  547|      0|                      serverCacheNode =
  548|      0|                          [serverCacheNode updateImmediateChild:childKey
  549|      0|                                                   withNewChild:completeCache];
  550|      0|                  }
  551|      0|                }];
  552|      0|            // Fill the node with any available children we have
  553|      0|            [persistenceServerCache.node
  554|      0|                enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  555|      0|                                              BOOL *stop) {
  556|      0|                  if (![serverCacheNode hasChild:key]) {
  557|      0|                      serverCacheNode =
  558|      0|                          [serverCacheNode updateImmediateChild:key
  559|      0|                                                   withNewChild:node];
  560|      0|                  }
  561|      0|                }];
  562|      0|            FIndexedNode *indexed =
  563|      0|                [FIndexedNode indexedNodeWithNode:serverCacheNode
  564|      0|                                            index:query.index];
  565|      0|            serverCache = [[FCacheNode alloc] initWithIndexedNode:indexed
  566|      0|                                               isFullyInitialized:NO
  567|      0|                                                       isFiltered:NO];
  568|      0|        }
  569|      0|    }
  570|      0|
  571|      0|    return serverCache;
  572|      0|}
  573|       |
  574|       |/**
  575|       | * Remove event callback(s).
  576|       | *
  577|       | * If query is the default query, we'll check all queries for the specified
  578|       | * eventRegistration. If eventRegistration is null, we'll remove all callbacks
  579|       | * for the specified query/queries.
  580|       | *
  581|       | * @param eventRegistration if nil, all callbacks are removed
  582|       | * @param cancelError If provided, appropriate cancel events will be returned
  583|       | * @return NSArray of FEvent to raise.
  584|       | */
  585|       |- (NSArray *)removeEventRegistration:(id<FEventRegistration>)eventRegistration
  586|       |                            forQuery:(FQuerySpec *)query
  587|      0|                         cancelError:(NSError *)cancelError {
  588|      0|    // Find the syncPoint first. Then deal with whether or not it has matching
  589|      0|    // listeners
  590|      0|    FPath *path = query.path;
  591|      0|    FSyncPoint *maybeSyncPoint = [self.syncPointTree valueAtPath:path];
  592|      0|    NSArray *cancelEvents = @[];
  593|      0|
  594|      0|    // A removal on a default query affects all queries at that location. A
  595|      0|    // removal on an indexed query, even one without other query constraints,
  596|      0|    // does *not* affect all queries at that location. So this check must be for
  597|      0|    // 'default', and not loadsAllData:
  598|      0|    if (maybeSyncPoint &&
  599|      0|        ([query isDefault] || [maybeSyncPoint viewExistsForQuery:query])) {
  600|      0|        FTupleRemovedQueriesEvents *removedAndEvents =
  601|      0|            [maybeSyncPoint removeEventRegistration:eventRegistration
  602|      0|                                           forQuery:query
  603|      0|                                        cancelError:cancelError];
  604|      0|        if ([maybeSyncPoint isEmpty]) {
  605|      0|            self.syncPointTree = [self.syncPointTree removeValueAtPath:path];
  606|      0|        }
  607|      0|        NSArray *removed = removedAndEvents.removedQueries;
  608|      0|        cancelEvents = removedAndEvents.cancelEvents;
  609|      0|
  610|      0|        // We may have just removed one of many listeners and can short-circuit
  611|      0|        // this whole process We may also not have removed a default listener,
  612|      0|        // in which case all of the descendant listeners should already be
  613|      0|        // properly set up.
  614|      0|        //
  615|      0|        // Since indexed queries can shadow if they don't have other query
  616|      0|        // constraints, check for loadsAllData: instead of isDefault:
  617|      0|        NSUInteger defaultQueryIndex = [removed
  618|      0|            indexOfObjectPassingTest:^BOOL(FQuerySpec *q, NSUInteger idx,
  619|      0|                                           BOOL *stop) {
  620|      0|              return [q loadsAllData];
  621|      0|            }];
  622|      0|        BOOL removingDefault = defaultQueryIndex != NSNotFound;
  623|      0|        [removed enumerateObjectsUsingBlock:^(FQuerySpec *query, NSUInteger idx,
  624|      0|                                              BOOL *stop) {
  625|      0|          [self.persistenceManager setQueryInactive:query];
  626|      0|        }];
  627|      0|        NSNumber *covered = [self.syncPointTree
  628|      0|               findOnPath:path
  629|      0|            andApplyBlock:^id(FPath *relativePath,
  630|      0|                              FSyncPoint *parentSyncPoint) {
  631|      0|              return
  632|      0|                  [NSNumber numberWithBool:[parentSyncPoint hasCompleteView]];
  633|      0|            }];
  634|      0|
  635|      0|        if (removingDefault && ![covered boolValue]) {
  636|      0|            FImmutableTree *subtree = [self.syncPointTree subtreeAtPath:path];
  637|      0|            // There are potentially child listeners. Determine what if any
  638|      0|            // listens we need to send before executing the removal
  639|      0|            if (![subtree isEmpty]) {
  640|      0|                // We need to fold over our subtree and collect the listeners to
  641|      0|                // send
  642|      0|                NSArray *newViews =
  643|      0|                    [self collectDistinctViewsForSubTree:subtree];
  644|      0|
  645|      0|                // Ok, we've collected all the listens we need. Set them up.
  646|      0|                [newViews enumerateObjectsUsingBlock:^(
  647|      0|                              FView *view, NSUInteger idx, BOOL *stop) {
  648|      0|                  FQuerySpec *newQuery = view.query;
  649|      0|                  FListenContainer *listenContainer =
  650|      0|                      [self createListenerForView:view];
  651|      0|                  self.listenProvider.startListening(
  652|      0|                      [self queryForListening:newQuery],
  653|      0|                      [self tagForQuery:newQuery], listenContainer,
  654|      0|                      listenContainer.onComplete);
  655|      0|                }];
  656|      0|            } else {
  657|      0|                // There's nothing below us, so nothing we need to start
  658|      0|                // listening on
  659|      0|            }
  660|      0|        }
  661|      0|
  662|      0|        // If we removed anything and we're not covered by a higher up listen,
  663|      0|        // we need to stop listening on this query. The above block has us
  664|      0|        // covered in terms of making sure we're set up on listens lower in the
  665|      0|        // tree. Also, note that if we have a cancelError, it's already been
  666|      0|        // removed at the provider level.
  667|      0|        if (![covered boolValue] && [removed count] > 0 && cancelError == nil) {
  668|      0|            // If we removed a default, then we weren't listening on any of the
  669|      0|            // other queries here. Just cancel the one default. Otherwise, we
  670|      0|            // need to iterate through and cancel each individual query
  671|      0|            if (removingDefault) {
  672|      0|                // We don't tag default listeners
  673|      0|                self.listenProvider.stopListening(
  674|      0|                    [self queryForListening:query], nil);
  675|      0|            } else {
  676|      0|                [removed
  677|      0|                    enumerateObjectsUsingBlock:^(FQuerySpec *queryToRemove,
  678|      0|                                                 NSUInteger idx, BOOL *stop) {
  679|      0|                      NSNumber *tagToRemove =
  680|      0|                          [self.queryToTagMap objectForKey:queryToRemove];
  681|      0|                      self.listenProvider.stopListening(
  682|      0|                          [self queryForListening:queryToRemove], tagToRemove);
  683|      0|                    }];
  684|      0|            }
  685|      0|        }
  686|      0|        // Now, clear all the tags we're tracking for the removed listens.
  687|      0|        [self removeTags:removed];
  688|      0|    } else {
  689|      0|        // No-op, this listener must've been already removed
  690|      0|    }
  691|      0|    return cancelEvents;
  692|      0|}
  693|       |
  694|      0|- (void)keepQuery:(FQuerySpec *)query synced:(BOOL)keepSynced {
  695|      0|    // Only do something if we actually need to add/remove an event registration
  696|      0|    if (keepSynced && ![self.keepSyncedQueries containsObject:query]) {
  697|      0|        [self addEventRegistration:[FKeepSyncedEventRegistration instance]
  698|      0|                          forQuery:query];
  699|      0|        [self.keepSyncedQueries addObject:query];
  700|      0|    } else if (!keepSynced && [self.keepSyncedQueries containsObject:query]) {
  701|      0|        [self removeEventRegistration:[FKeepSyncedEventRegistration instance]
  702|      0|                             forQuery:query
  703|      0|                          cancelError:nil];
  704|      0|        [self.keepSyncedQueries removeObject:query];
  705|      0|    }
  706|      0|}
  707|       |
  708|      0|- (NSArray *)removeAllWrites {
  709|      0|    [self.persistenceManager removeAllUserWrites];
  710|      0|    NSArray *removedWrites = [self.pendingWriteTree removeAllWrites];
  711|      0|    if (removedWrites.count > 0) {
  712|      0|        FImmutableTree *affectedTree =
  713|      0|            [[FImmutableTree empty] setValue:@YES atPath:[FPath empty]];
  714|      0|        return [self applyOperationToSyncPoints:[[FAckUserWrite alloc]
  715|      0|                                                    initWithPath:[FPath empty]
  716|      0|                                                    affectedTree:affectedTree
  717|      0|                                                          revert:YES]];
  718|      0|    } else {
  719|      0|        return @[];
  720|      0|    }
  721|      0|}
  722|       |
  723|       |/**
  724|       | * Returns a complete cache, if we have one, of the data at a particular path.
  725|       | * The location must have a listener above it, but as this is only used by
  726|       | * transaction code, that should always be the case anyways.
  727|       | *
  728|       | * Note: this method will *include* hidden writes from transaction with
  729|       | * applyLocally set to false.
  730|       | * @param path The path to the data we want
  731|       | * @param writeIdsToExclude A specific set to be excluded
  732|       | */
  733|       |- (id<FNode>)calcCompleteEventCacheAtPath:(FPath *)path
  734|      0|                          excludeWriteIds:(NSArray *)writeIdsToExclude {
  735|      0|    BOOL includeHiddenSets = YES;
  736|      0|    FWriteTree *writeTree = self.pendingWriteTree;
  737|      0|    id<FNode> serverCache = [self.syncPointTree
  738|      0|           findOnPath:path
  739|      0|        andApplyBlock:^id<FNode>(FPath *pathSoFar, FSyncPoint *syncPoint) {
  740|      0|          FPath *relativePath = [FPath relativePathFrom:pathSoFar to:path];
  741|      0|          id<FNode> serverCache =
  742|      0|              [syncPoint completeServerCacheAtPath:relativePath];
  743|      0|          if (serverCache) {
  744|      0|              return serverCache;
  745|      0|          } else {
  746|      0|              return nil;
  747|      0|          }
  748|      0|        }];
  749|      0|    return [writeTree calculateCompleteEventCacheAtPath:path
  750|      0|                                    completeServerCache:serverCache
  751|      0|                                        excludeWriteIds:writeIdsToExclude
  752|      0|                                    includeHiddenWrites:includeHiddenSets];
  753|      0|}
  754|       |
  755|       |#pragma mark -
  756|       |#pragma mark Private Methods
  757|       |/**
  758|       | * This collapses multiple unfiltered views into a single view, since we only
  759|       | * need a single listener for them.
  760|       | * @return NSArray of FView
  761|       | */
  762|      0|- (NSArray *)collectDistinctViewsForSubTree:(FImmutableTree *)subtree {
  763|      0|    return [subtree foldWithBlock:^NSArray *(FPath *relativePath,
  764|      0|                                             FSyncPoint *maybeChildSyncPoint,
  765|      0|                                             NSDictionary *childMap) {
  766|      0|      if (maybeChildSyncPoint && [maybeChildSyncPoint hasCompleteView]) {
  767|      0|          FView *completeView = [maybeChildSyncPoint completeView];
  768|      0|          return @[ completeView ];
  769|      0|      } else {
  770|      0|          // No complete view here, flatten any deeper listens into an array
  771|      0|          NSMutableArray *views = [[NSMutableArray alloc] init];
  772|      0|          if (maybeChildSyncPoint) {
  773|      0|              views = [[maybeChildSyncPoint queryViews] mutableCopy];
  774|      0|          }
  775|      0|          [childMap enumerateKeysAndObjectsUsingBlock:^(
  776|      0|                        NSString *childKey, NSArray *childViews, BOOL *stop) {
  777|      0|            [views addObjectsFromArray:childViews];
  778|      0|          }];
  779|      0|          return views;
  780|      0|      }
  781|      0|    }];
  782|      0|}
  783|       |
  784|       |/**
  785|       | * @param queries NSArray of FQuerySpec
  786|       | */
  787|      0|- (void)removeTags:(NSArray *)queries {
  788|      0|    [queries enumerateObjectsUsingBlock:^(FQuerySpec *removedQuery,
  789|      0|                                          NSUInteger idx, BOOL *stop) {
  790|      0|      if (![removedQuery loadsAllData]) {
  791|      0|          // We should have a tag for this
  792|      0|          NSNumber *removedQueryTag = self.queryToTagMap[removedQuery];
  793|      0|          [self.queryToTagMap removeObjectForKey:removedQuery];
  794|      0|          [self.tagToQueryMap removeObjectForKey:removedQueryTag];
  795|      0|      }
  796|      0|    }];
  797|      0|}
  798|       |
  799|      0|- (FQuerySpec *)queryForListening:(FQuerySpec *)query {
  800|      0|    if (query.loadsAllData && !query.isDefault) {
  801|      0|        // We treat queries that load all data as default queries
  802|      0|        return [FQuerySpec defaultQueryAtPath:query.path];
  803|      0|    } else {
  804|      0|        return query;
  805|      0|    }
  806|      0|}
  807|       |
  808|       |/**
  809|       | * For a given new listen, manage the de-duplication of outstanding
  810|       | * subscriptions.
  811|       | * @return NSArray of FEvent events to support synchronous data sources
  812|       | */
  813|      0|- (NSArray *)setupListenerOnQuery:(FQuerySpec *)query view:(FView *)view {
  814|      0|    FPath *path = query.path;
  815|      0|    NSNumber *tagId = [self tagForQuery:query];
  816|      0|    FListenContainer *listenContainer = [self createListenerForView:view];
  817|      0|
  818|      0|    NSArray *events = self.listenProvider.startListening(
  819|      0|        [self queryForListening:query], tagId, listenContainer,
  820|      0|        listenContainer.onComplete);
  821|      0|
  822|      0|    FImmutableTree *subtree = [self.syncPointTree subtreeAtPath:path];
  823|      0|    // The root of this subtree has our query. We're here because we definitely
  824|      0|    // need to send a listen for that, but we may need to shadow other listens
  825|      0|    // as well.
  826|      0|    if (tagId != nil) {
  827|      0|        NSAssert(![subtree.value hasCompleteView],
  828|      0|                 @"If we're adding a query, it shouldn't be shadowed");
  829|      0|    } else {
  830|      0|        // Shadow everything at or below this location, this is a default
  831|      0|        // listener.
  832|      0|        NSArray *queriesToStop =
  833|      0|            [subtree foldWithBlock:^id(FPath *relativePath,
  834|      0|                                       FSyncPoint *maybeChildSyncPoint,
  835|      0|                                       NSDictionary *childMap) {
  836|      0|              if (![relativePath isEmpty] && maybeChildSyncPoint != nil &&
  837|      0|                  [maybeChildSyncPoint hasCompleteView]) {
  838|      0|                  return @[ [maybeChildSyncPoint completeView].query ];
  839|      0|              } else {
  840|      0|                  // No default listener here, flatten any deeper queries into
  841|      0|                  // an array
  842|      0|                  NSMutableArray *queries = [[NSMutableArray alloc] init];
  843|      0|                  if (maybeChildSyncPoint != nil) {
  844|      0|                      for (FView *view in [maybeChildSyncPoint queryViews]) {
  845|      0|                          [queries addObject:view.query];
  846|      0|                      }
  847|      0|                  }
  848|      0|                  [childMap
  849|      0|                      enumerateKeysAndObjectsUsingBlock:^(
  850|      0|                          NSString *key, NSArray *childQueries, BOOL *stop) {
  851|      0|                        [queries addObjectsFromArray:childQueries];
  852|      0|                      }];
  853|      0|                  return queries;
  854|      0|              }
  855|      0|            }];
  856|      0|        for (FQuerySpec *queryToStop in queriesToStop) {
  857|      0|            self.listenProvider.stopListening(
  858|      0|                [self queryForListening:queryToStop],
  859|      0|                [self tagForQuery:queryToStop]);
  860|      0|        }
  861|      0|    }
  862|      0|    return events;
  863|      0|}
  864|       |
  865|      0|- (FListenContainer *)createListenerForView:(FView *)view {
  866|      0|    FQuerySpec *query = view.query;
  867|      0|    NSNumber *tagId = [self tagForQuery:query];
  868|      0|
  869|      0|    FListenContainer *listenContainer = [[FListenContainer alloc]
  870|      0|        initWithView:view
  871|      0|          onComplete:^(NSString *status) {
  872|      0|            if ([status isEqualToString:@"ok"]) {
  873|      0|                if (tagId != nil) {
  874|      0|                    return [self applyTaggedListenCompleteAtPath:query.path
  875|      0|                                                           tagId:tagId];
  876|      0|                } else {
  877|      0|                    return [self applyListenCompleteAtPath:query.path];
  878|      0|                }
  879|      0|            } else {
  880|      0|                // If a listen failed, kill all of the listeners here, not just
  881|      0|                // the one that triggered the error. Note that this may need to
  882|      0|                // be scoped to just this listener if we change permissions on
  883|      0|                // filtered children
  884|      0|                NSError *error = [FUtilities errorForStatus:status
  885|      0|                                                  andReason:nil];
  886|      0|                FFWarn(@"I-RDB038012", @"Listener at %@ failed: %@", query.path,
  887|      0|                       status);
  888|      0|                return [self removeEventRegistration:nil
  889|      0|                                            forQuery:query
  890|      0|                                         cancelError:error];
  891|      0|            }
  892|      0|          }];
  893|      0|
  894|      0|    return listenContainer;
  895|      0|}
  896|       |
  897|       |/**
  898|       | * @return The query associated with the given tag, if we have one
  899|       | */
  900|      0|- (FQuerySpec *)queryForTag:(NSNumber *)tagId {
  901|      0|    return self.tagToQueryMap[tagId];
  902|      0|}
  903|       |
  904|       |/**
  905|       | * @return The tag associated with the given query
  906|       | */
  907|      0|- (NSNumber *)tagForQuery:(FQuerySpec *)query {
  908|      0|    return self.queryToTagMap[query];
  909|      0|}
  910|       |
  911|       |#pragma mark -
  912|       |#pragma mark applyOperation Helpers
  913|       |
  914|       |/**
  915|       |* A helper method that visits all descendant and ancestor SyncPoints, applying
  916|       |the operation.
  917|       |*
  918|       |* NOTES:
  919|       |* - Descendant SyncPoints will be visited first (since we raise events
  920|       |depth-first).
  921|       |
  922|       |* - We call applyOperation: on each SyncPoint passing three things:
  923|       |*   1. A version of the Operation that has been made relative to the SyncPoint
  924|       |location.
  925|       |*   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
  926|       |*   3. A snapshot Node with cached server data, if we have it.
  927|       |
  928|       |* - We concatenate all of the events returned by each SyncPoint and return the
  929|       |result.
  930|       |*
  931|       |* @return Array of FEvent
  932|       |*/
  933|      0|- (NSArray *)applyOperationToSyncPoints:(id<FOperation>)operation {
  934|      0|    return [self applyOperationHelper:operation
  935|      0|                        syncPointTree:self.syncPointTree
  936|      0|                          serverCache:nil
  937|      0|                          writesCache:[self.pendingWriteTree
  938|      0|                                          childWritesForPath:[FPath empty]]];
  939|      0|}
  940|       |
  941|       |/**
  942|       | * Recursive helper for applyOperationToSyncPoints_
  943|       | */
  944|       |- (NSArray *)applyOperationHelper:(id<FOperation>)operation
  945|       |                    syncPointTree:(FImmutableTree *)syncPointTree
  946|       |                      serverCache:(id<FNode>)serverCache
  947|      0|                      writesCache:(FWriteTreeRef *)writesCache {
  948|      0|    if ([operation.path isEmpty]) {
  949|      0|        return [self applyOperationDescendantsHelper:operation
  950|      0|                                       syncPointTree:syncPointTree
  951|      0|                                         serverCache:serverCache
  952|      0|                                         writesCache:writesCache];
  953|      0|    } else {
  954|      0|        FSyncPoint *syncPoint = syncPointTree.value;
  955|      0|
  956|      0|        // If we don't have cached server data, see if we can get it from this
  957|      0|        // SyncPoint
  958|      0|        if (serverCache == nil && syncPoint != nil) {
  959|      0|            serverCache = [syncPoint completeServerCacheAtPath:[FPath empty]];
  960|      0|        }
  961|      0|
  962|      0|        NSMutableArray *events = [[NSMutableArray alloc] init];
  963|      0|        NSString *childKey = [operation.path getFront];
  964|      0|        id<FOperation> childOperation = [operation operationForChild:childKey];
  965|      0|        FImmutableTree *childTree = [syncPointTree.children get:childKey];
  966|      0|        if (childTree != nil && childOperation != nil) {
  967|      0|            id<FNode> childServerCache =
  968|      0|                serverCache ? [serverCache getImmediateChild:childKey] : nil;
  969|      0|            FWriteTreeRef *childWritesCache =
  970|      0|                [writesCache childWriteTreeRef:childKey];
  971|      0|            [events
  972|      0|                addObjectsFromArray:[self
  973|      0|                                        applyOperationHelper:childOperation
  974|      0|                                               syncPointTree:childTree
  975|      0|                                                 serverCache:childServerCache
  976|      0|                                                 writesCache:childWritesCache]];
  977|      0|        }
  978|      0|
  979|      0|        if (syncPoint) {
  980|      0|            [events addObjectsFromArray:[syncPoint applyOperation:operation
  981|      0|                                                      writesCache:writesCache
  982|      0|                                                      serverCache:serverCache]];
  983|      0|        }
  984|      0|
  985|      0|        return events;
  986|      0|    }
  987|      0|}
  988|       |
  989|       |/**
  990|       | *  Recursive helper for applyOperationToSyncPoints:
  991|       | */
  992|       |- (NSArray *)applyOperationDescendantsHelper:(id<FOperation>)operation
  993|       |                               syncPointTree:(FImmutableTree *)syncPointTree
  994|       |                                 serverCache:(id<FNode>)serverCache
  995|      0|                                 writesCache:(FWriteTreeRef *)writesCache {
  996|      0|    FSyncPoint *syncPoint = syncPointTree.value;
  997|      0|
  998|      0|    // If we don't have cached server data, see if we can get it from this
  999|      0|    // SyncPoint
 1000|      0|    id<FNode> resolvedServerCache;
 1001|      0|    if (serverCache == nil & syncPoint != nil) {
 1002|      0|        resolvedServerCache =
 1003|      0|            [syncPoint completeServerCacheAtPath:[FPath empty]];
 1004|      0|    } else {
 1005|      0|        resolvedServerCache = serverCache;
 1006|      0|    }
 1007|      0|
 1008|      0|    NSMutableArray *events = [[NSMutableArray alloc] init];
 1009|      0|    [syncPointTree.children enumerateKeysAndObjectsUsingBlock:^(
 1010|      0|                                NSString *childKey, FImmutableTree *childTree,
 1011|      0|                                BOOL *stop) {
 1012|      0|      id<FNode> childServerCache = nil;
 1013|      0|      if (resolvedServerCache != nil) {
 1014|      0|          childServerCache = [resolvedServerCache getImmediateChild:childKey];
 1015|      0|      }
 1016|      0|      FWriteTreeRef *childWritesCache =
 1017|      0|          [writesCache childWriteTreeRef:childKey];
 1018|      0|      id<FOperation> childOperation = [operation operationForChild:childKey];
 1019|      0|      if (childOperation != nil) {
 1020|      0|          [events addObjectsFromArray:
 1021|      0|                      [self applyOperationDescendantsHelper:childOperation
 1022|      0|                                              syncPointTree:childTree
 1023|      0|                                                serverCache:childServerCache
 1024|      0|                                                writesCache:childWritesCache]];
 1025|      0|      }
 1026|      0|    }];
 1027|      0|
 1028|      0|    if (syncPoint) {
 1029|      0|        [events
 1030|      0|            addObjectsFromArray:[syncPoint applyOperation:operation
 1031|      0|                                              writesCache:writesCache
 1032|      0|                                              serverCache:resolvedServerCache]];
 1033|      0|    }
 1034|      0|
 1035|      0|    return events;
 1036|      0|}
 1037|       |
 1038|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FWriteRecord.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FWriteRecord.h"
   18|       |#import "FCompoundWrite.h"
   19|       |#import "FNode.h"
   20|       |#import "FPath.h"
   21|       |
   22|       |@interface FWriteRecord ()
   23|       |@property(nonatomic, readwrite) NSInteger writeId;
   24|       |@property(nonatomic, strong, readwrite) FPath *path;
   25|       |@property(nonatomic, strong, readwrite) id<FNode> overwrite;
   26|       |@property(nonatomic, strong, readwrite) FCompoundWrite *merge;
   27|       |@property(nonatomic, readwrite) BOOL visible;
   28|       |@end
   29|       |
   30|       |@implementation FWriteRecord
   31|       |
   32|       |- (id)initWithPath:(FPath *)path
   33|       |         overwrite:(id<FNode>)overwrite
   34|       |           writeId:(NSInteger)writeId
   35|      0|           visible:(BOOL)isVisible {
   36|      0|    self = [super init];
   37|      0|    if (self) {
   38|      0|        self.path = path;
   39|      0|        if (overwrite == nil) {
   40|      0|            [NSException raise:NSInvalidArgumentException
   41|      0|                        format:@"Can't pass nil as overwrite parameter to an "
   42|      0|                               @"overwrite write record"];
   43|      0|        }
   44|      0|        self.overwrite = overwrite;
   45|      0|        self.merge = nil;
   46|      0|        self.writeId = writeId;
   47|      0|        self.visible = isVisible;
   48|      0|    }
   49|      0|    return self;
   50|      0|}
   51|       |
   52|       |- (id)initWithPath:(FPath *)path
   53|       |             merge:(FCompoundWrite *)merge
   54|      0|           writeId:(NSInteger)writeId {
   55|      0|    self = [super init];
   56|      0|    if (self) {
   57|      0|        self.path = path;
   58|      0|        if (merge == nil) {
   59|      0|            [NSException raise:NSInvalidArgumentException
   60|      0|                        format:@"Can't pass nil as merge parameter to an merge "
   61|      0|                               @"write record"];
   62|      0|        }
   63|      0|        self.overwrite = nil;
   64|      0|        self.merge = merge;
   65|      0|        self.writeId = writeId;
   66|      0|        self.visible = YES;
   67|      0|    }
   68|      0|    return self;
   69|      0|}
   70|       |
   71|      0|- (id<FNode>)overwrite {
   72|      0|    if (self->_overwrite == nil) {
   73|      0|        [NSException raise:NSInvalidArgumentException
   74|      0|                    format:@"Can't get overwrite for merge write record!"];
   75|      0|    }
   76|      0|    return self->_overwrite;
   77|      0|}
   78|       |
   79|      0|- (FCompoundWrite *)compoundWrite {
   80|      0|    if (self->_merge == nil) {
   81|      0|        [NSException raise:NSInvalidArgumentException
   82|      0|                    format:@"Can't get merge for overwrite write record!"];
   83|      0|    }
   84|      0|    return self->_merge;
   85|      0|}
   86|       |
   87|      0|- (BOOL)isMerge {
   88|      0|    return self->_merge != nil;
   89|      0|}
   90|       |
   91|      0|- (BOOL)isOverwrite {
   92|      0|    return self->_overwrite != nil;
   93|      0|}
   94|       |
   95|      0|- (NSString *)description {
   96|      0|    if (self.isOverwrite) {
   97|      0|        return
   98|      0|            [NSString stringWithFormat:@"FWriteRecord { writeId = %lu, path = "
   99|      0|                                       @"%@, overwrite = %@, visible = %d }",
  100|      0|                                       (unsigned long)self.writeId, self.path,
  101|      0|                                       self.overwrite, self.visible];
  102|      0|    } else {
  103|      0|        return [NSString
  104|      0|            stringWithFormat:
  105|      0|                @"FWriteRecord { writeId = %lu, path = %@, merge = %@ }",
  106|      0|                (unsigned long)self.writeId, self.path, self.merge];
  107|      0|    }
  108|      0|}
  109|       |
  110|      0|- (BOOL)isEqual:(id)object {
  111|      0|    if (![object isKindOfClass:[self class]]) {
  112|      0|        return NO;
  113|      0|    }
  114|      0|    FWriteRecord *other = (FWriteRecord *)object;
  115|      0|    if (self->_writeId != other->_writeId)
  116|      0|        return NO;
  117|      0|    if (self->_path != other->_path && ![self->_path isEqual:other->_path])
  118|      0|        return NO;
  119|      0|    if (self->_overwrite != other->_overwrite &&
  120|      0|        ![self->_overwrite isEqual:other->_overwrite])
  121|      0|        return NO;
  122|      0|    if (self->_merge != other->_merge && ![self->_merge isEqual:other->_merge])
  123|      0|        return NO;
  124|      0|    if (self->_visible != other->_visible)
  125|      0|        return NO;
  126|      0|
  127|      0|    return YES;
  128|      0|}
  129|       |
  130|      0|- (NSUInteger)hash {
  131|      0|    NSUInteger hash = self->_writeId * 17;
  132|      0|    hash = hash * 31 + self->_path.hash;
  133|      0|    hash = hash * 31 + self->_overwrite.hash;
  134|      0|    hash = hash * 31 + self->_merge.hash;
  135|      0|    hash = hash * 31 + ((self->_visible) ? 1 : 0);
  136|      0|    return hash;
  137|      0|}
  138|       |
  139|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FWriteTree.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FWriteTree.h"
   18|       |#import "FCacheNode.h"
   19|       |#import "FChildrenNode.h"
   20|       |#import "FCompoundWrite.h"
   21|       |#import "FEmptyNode.h"
   22|       |#import "FImmutableTree.h"
   23|       |#import "FIndex.h"
   24|       |#import "FNamedNode.h"
   25|       |#import "FNode.h"
   26|       |#import "FPath.h"
   27|       |#import "FWriteRecord.h"
   28|       |#import "FWriteTreeRef.h"
   29|       |
   30|       |@interface FWriteTree ()
   31|       |/**
   32|       | * A tree tracking the results of applying all visible writes. This does not
   33|       | * include transactions with applyLocally=false or writes that are completely
   34|       | * shadowed by other writes. Contains id<FNode> as values.
   35|       | */
   36|       |@property(nonatomic, strong) FCompoundWrite *visibleWrites;
   37|       |/**
   38|       | * A list of pending writes, regardless of visibility and shadowed-ness. Used to
   39|       | * calcuate arbitrary sets of the changed data, such as hidden writes (from
   40|       | * transactions) or changes with certain writes excluded (also used by
   41|       | * transactions). Contains FWriteRecords.
   42|       | */
   43|       |@property(nonatomic, strong) NSMutableArray *allWrites;
   44|       |@property(nonatomic) NSInteger lastWriteId;
   45|       |@end
   46|       |
   47|       |/**
   48|       | * FWriteTree tracks all pending user-initiated writes and has methods to
   49|       | * calcuate the result of merging them with underlying server data (to create
   50|       | * "event cache" data). Pending writes are added with addOverwriteAtPath: and
   51|       | * addMergeAtPath: and removed with removeWriteId:.
   52|       | */
   53|       |@implementation FWriteTree
   54|       |
   55|       |@synthesize allWrites;
   56|       |@synthesize lastWriteId;
   57|       |
   58|      0|- (id)init {
   59|      0|    self = [super init];
   60|      0|    if (self) {
   61|      0|        self.visibleWrites = [FCompoundWrite emptyWrite];
   62|      0|        self.allWrites = [[NSMutableArray alloc] init];
   63|      0|        self.lastWriteId = -1;
   64|      0|    }
   65|      0|    return self;
   66|      0|}
   67|       |
   68|       |/**
   69|       | * Create a new WriteTreeRef for the given path. For use with a new sync point
   70|       | * at the given path.
   71|       | */
   72|      0|- (FWriteTreeRef *)childWritesForPath:(FPath *)path {
   73|      0|    return [[FWriteTreeRef alloc] initWithPath:path writeTree:self];
   74|      0|}
   75|       |
   76|       |/**
   77|       | * Record a new overwrite from user code.
   78|       | * @param visible Is set to false by some transactions. It should be excluded
   79|       | * from event caches.
   80|       | */
   81|       |- (void)addOverwriteAtPath:(FPath *)path
   82|       |                   newData:(id<FNode>)newData
   83|       |                   writeId:(NSInteger)writeId
   84|      0|                 isVisible:(BOOL)visible {
   85|      0|    NSAssert(writeId > self.lastWriteId,
   86|      0|             @"Stacking an older write on top of a newer one");
   87|      0|    FWriteRecord *record = [[FWriteRecord alloc] initWithPath:path
   88|      0|                                                    overwrite:newData
   89|      0|                                                      writeId:writeId
   90|      0|                                                      visible:visible];
   91|      0|    [self.allWrites addObject:record];
   92|      0|
   93|      0|    if (visible) {
   94|      0|        self.visibleWrites = [self.visibleWrites addWrite:newData atPath:path];
   95|      0|    }
   96|      0|
   97|      0|    self.lastWriteId = writeId;
   98|      0|}
   99|       |
  100|       |/**
  101|       | * Record a new merge from user code.
  102|       | * @param changedChildren maps NSString -> id<FNode>
  103|       | */
  104|       |- (void)addMergeAtPath:(FPath *)path
  105|       |       changedChildren:(FCompoundWrite *)changedChildren
  106|      0|               writeId:(NSInteger)writeId {
  107|      0|    NSAssert(writeId > self.lastWriteId,
  108|      0|             @"Stacking an older merge on top of newer one");
  109|      0|    FWriteRecord *record = [[FWriteRecord alloc] initWithPath:path
  110|      0|                                                        merge:changedChildren
  111|      0|                                                      writeId:writeId];
  112|      0|    [self.allWrites addObject:record];
  113|      0|
  114|      0|    self.visibleWrites = [self.visibleWrites addCompoundWrite:changedChildren
  115|      0|                                                       atPath:path];
  116|      0|    self.lastWriteId = writeId;
  117|      0|}
  118|       |
  119|      0|- (FWriteRecord *)writeForId:(NSInteger)writeId {
  120|      0|    NSUInteger index = [self.allWrites
  121|      0|        indexOfObjectPassingTest:^BOOL(FWriteRecord *write, NSUInteger idx,
  122|      0|                                       BOOL *stop) {
  123|      0|          return write.writeId == writeId;
  124|      0|        }];
  125|      0|    return (index == NSNotFound) ? nil : self.allWrites[index];
  126|      0|}
  127|       |
  128|       |/**
  129|       | * Remove a write (either an overwrite or merge) that has been successfully
  130|       | * acknowledged by the server. Recalculates the tree if necessary. We return the
  131|       | * path of the write and whether it may have been visible, meaning views need to
  132|       | * reevaluate.
  133|       | *
  134|       | * @return YES if the write may have been visible (meaning we'll need to
  135|       | * reevaluate / raise events as a result).
  136|       | */
  137|      0|- (BOOL)removeWriteId:(NSInteger)writeId {
  138|      0|    NSUInteger index = [self.allWrites
  139|      0|        indexOfObjectPassingTest:^BOOL(FWriteRecord *record, NSUInteger idx,
  140|      0|                                       BOOL *stop) {
  141|      0|          if (record.writeId == writeId) {
  142|      0|              return YES;
  143|      0|          } else {
  144|      0|              return NO;
  145|      0|          }
  146|      0|        }];
  147|      0|    NSAssert(index != NSNotFound,
  148|      0|             @"[FWriteTree removeWriteId:] called with nonexistent writeId.");
  149|      0|    FWriteRecord *writeToRemove = self.allWrites[index];
  150|      0|    [self.allWrites removeObjectAtIndex:index];
  151|      0|
  152|      0|    BOOL removedWriteWasVisible = writeToRemove.visible;
  153|      0|    BOOL removedWriteOverlapsWithOtherWrites = NO;
  154|      0|    NSInteger i = [self.allWrites count] - 1;
  155|      0|
  156|      0|    while (removedWriteWasVisible && i >= 0) {
  157|      0|        FWriteRecord *currentWrite = [self.allWrites objectAtIndex:i];
  158|      0|        if (currentWrite.visible) {
  159|      0|            if (i >= index && [self record:currentWrite
  160|      0|                                  containsPath:writeToRemove.path]) {
  161|      0|                // The removed write was completely shadowed by a subsequent
  162|      0|                // write.
  163|      0|                removedWriteWasVisible = NO;
  164|      0|            } else if ([writeToRemove.path contains:currentWrite.path]) {
  165|      0|                // Either we're covering some writes or they're covering part of
  166|      0|                // us (depending on which came first).
  167|      0|                removedWriteOverlapsWithOtherWrites = YES;
  168|      0|            }
  169|      0|        }
  170|      0|        i--;
  171|      0|    }
  172|      0|
  173|      0|    if (!removedWriteWasVisible) {
  174|      0|        return NO;
  175|      0|    } else if (removedWriteOverlapsWithOtherWrites) {
  176|      0|        // There's some shadowing going on. Just rebuild the visible writes from
  177|      0|        // scratch.
  178|      0|        [self resetTree];
  179|      0|        return YES;
  180|      0|    } else {
  181|      0|        // There's no shadowing.  We can safely just remove the write(s) from
  182|      0|        // visibleWrites.
  183|      0|        if ([writeToRemove isOverwrite]) {
  184|      0|            self.visibleWrites =
  185|      0|                [self.visibleWrites removeWriteAtPath:writeToRemove.path];
  186|      0|        } else {
  187|      0|            FCompoundWrite *merge = writeToRemove.merge;
  188|      0|            [merge enumerateWrites:^(FPath *path, id<FNode> node, BOOL *stop) {
  189|      0|              self.visibleWrites = [self.visibleWrites
  190|      0|                  removeWriteAtPath:[writeToRemove.path child:path]];
  191|      0|            }];
  192|      0|        }
  193|      0|        return YES;
  194|      0|    }
  195|      0|}
  196|       |
  197|      0|- (NSArray *)removeAllWrites {
  198|      0|    NSArray *writes = self.allWrites;
  199|      0|    self.visibleWrites = [FCompoundWrite emptyWrite];
  200|      0|    self.allWrites = [NSMutableArray array];
  201|      0|    return writes;
  202|      0|}
  203|       |
  204|       |/**
  205|       | * @return A complete snapshot for the given path if there's visible write data
  206|       | * at that path, else nil. No server data is considered.
  207|       | */
  208|      0|- (id<FNode>)completeWriteDataAtPath:(FPath *)path {
  209|      0|    return [self.visibleWrites completeNodeAtPath:path];
  210|      0|}
  211|       |
  212|       |/**
  213|       | * Given optional, underlying server data, and an optional set of constraints
  214|       | * (exclude some sets, include hidden writes), attempt to calculate a complete
  215|       | * snapshot for the given path
  216|       | * @param includeHiddenWrites Defaults to false, whether or not to layer on
  217|       | * writes with visible set to false
  218|       | */
  219|       |- (id<FNode>)calculateCompleteEventCacheAtPath:(FPath *)treePath
  220|       |                           completeServerCache:(id<FNode>)completeServerCache
  221|       |                               excludeWriteIds:(NSArray *)writeIdsToExclude
  222|      0|                           includeHiddenWrites:(BOOL)includeHiddenWrites {
  223|      0|    if (writeIdsToExclude == nil && !includeHiddenWrites) {
  224|      0|        id<FNode> shadowingNode =
  225|      0|            [self.visibleWrites completeNodeAtPath:treePath];
  226|      0|        if (shadowingNode != nil) {
  227|      0|            return shadowingNode;
  228|      0|        } else {
  229|      0|            // No cache here. Can't claim complete knowledge.
  230|      0|            FCompoundWrite *subMerge =
  231|      0|                [self.visibleWrites childCompoundWriteAtPath:treePath];
  232|      0|            if (subMerge.isEmpty) {
  233|      0|                return completeServerCache;
  234|      0|            } else if (completeServerCache == nil &&
  235|      0|                       ![subMerge hasCompleteWriteAtPath:[FPath empty]]) {
  236|      0|                // We wouldn't have a complete snapshot since there's no
  237|      0|                // underlying data and no complete shadow
  238|      0|                return nil;
  239|      0|            } else {
  240|      0|                id<FNode> layeredCache = completeServerCache != nil
  241|      0|                                             ? completeServerCache
  242|      0|                                             : [FEmptyNode emptyNode];
  243|      0|                return [subMerge applyToNode:layeredCache];
  244|      0|            }
  245|      0|        }
  246|      0|    } else {
  247|      0|        FCompoundWrite *merge =
  248|      0|            [self.visibleWrites childCompoundWriteAtPath:treePath];
  249|      0|        if (!includeHiddenWrites && merge.isEmpty) {
  250|      0|            return completeServerCache;
  251|      0|        } else {
  252|      0|            // If the server cache is null and we don't have a complete cache,
  253|      0|            // we need to return nil
  254|      0|            if (!includeHiddenWrites && completeServerCache == nil &&
  255|      0|                ![merge hasCompleteWriteAtPath:[FPath empty]]) {
  256|      0|                return nil;
  257|      0|            } else {
  258|      0|                BOOL (^filter)(FWriteRecord *) = ^(FWriteRecord *record) {
  259|      0|                  return (BOOL)(
  260|      0|                      (record.visible || includeHiddenWrites) &&
  261|      0|                      (writeIdsToExclude == nil ||
  262|      0|                       ![writeIdsToExclude
  263|      0|                           containsObject:
  264|      0|                               [NSNumber numberWithInteger:record.writeId]]) &&
  265|      0|                      ([record.path contains:treePath] ||
  266|      0|                       [treePath contains:record.path]));
  267|      0|                };
  268|      0|                FCompoundWrite *mergeAtPath =
  269|      0|                    [FWriteTree layerTreeFromWrites:self.allWrites
  270|      0|                                             filter:filter
  271|      0|                                           treeRoot:treePath];
  272|      0|                id<FNode> layeredCache = completeServerCache
  273|      0|                                             ? completeServerCache
  274|      0|                                             : [FEmptyNode emptyNode];
  275|      0|                return [mergeAtPath applyToNode:layeredCache];
  276|      0|            }
  277|      0|        }
  278|      0|    }
  279|      0|}
  280|       |
  281|       |/**
  282|       | * With optional, underlying server data, attempt to return a children node of
  283|       | * children that we have complete data for. Used when creating new views, to
  284|       | * pre-fill their complete event children snapshot.
  285|       | */
  286|       |- (FChildrenNode *)calculateCompleteEventChildrenAtPath:(FPath *)treePath
  287|       |                                 completeServerChildren:
  288|      0|                                     (id<FNode>)completeServerChildren {
  289|      0|    __block id<FNode> completeChildren = [FEmptyNode emptyNode];
  290|      0|    id<FNode> topLevelSet = [self.visibleWrites completeNodeAtPath:treePath];
  291|      0|    if (topLevelSet != nil) {
  292|      0|        if (![topLevelSet isLeafNode]) {
  293|      0|            // We're shadowing everything. Return the children.
  294|      0|            FChildrenNode *topChildrenNode = topLevelSet;
  295|      0|            [topChildrenNode enumerateChildrenUsingBlock:^(
  296|      0|                                 NSString *key, id<FNode> node, BOOL *stop) {
  297|      0|              completeChildren = [completeChildren updateImmediateChild:key
  298|      0|                                                           withNewChild:node];
  299|      0|            }];
  300|      0|        }
  301|      0|        return completeChildren;
  302|      0|    } else {
  303|      0|        // Layer any children we have on top of this
  304|      0|        // We know we don't have a top-level set, so just enumerate existing
  305|      0|        // children, and apply any updates
  306|      0|        FCompoundWrite *merge =
  307|      0|            [self.visibleWrites childCompoundWriteAtPath:treePath];
  308|      0|        [completeServerChildren enumerateChildrenUsingBlock:^(
  309|      0|                                    NSString *key, id<FNode> node, BOOL *stop) {
  310|      0|          FCompoundWrite *childMerge =
  311|      0|              [merge childCompoundWriteAtPath:[[FPath alloc] initWith:key]];
  312|      0|          id<FNode> newChildNode = [childMerge applyToNode:node];
  313|      0|          completeChildren =
  314|      0|              [completeChildren updateImmediateChild:key
  315|      0|                                        withNewChild:newChildNode];
  316|      0|        }];
  317|      0|        // Add any complete children we have from the set.
  318|      0|        for (FNamedNode *node in merge.completeChildren) {
  319|      0|            completeChildren =
  320|      0|                [completeChildren updateImmediateChild:node.name
  321|      0|                                          withNewChild:node.node];
  322|      0|        }
  323|      0|        return completeChildren;
  324|      0|    }
  325|      0|}
  326|       |
  327|       |/**
  328|       | * Given that the underlying server data has updated, determine what, if
  329|       | * anything, needs to be applied to the event cache.
  330|       | *
  331|       | * Possibilities
  332|       | *
  333|       | * 1. No write are shadowing. Events should be raised, the snap to be applied
  334|       | * comes from the server data.
  335|       | *
  336|       | * 2. Some write is completely shadowing. No events to be raised.
  337|       | *
  338|       | * 3. Is partially shadowed. Events ..
  339|       | *
  340|       | * Either existingEventSnap or existingServerSnap must exist.
  341|       | */
  342|       |- (id<FNode>)calculateEventCacheAfterServerOverwriteAtPath:(FPath *)treePath
  343|       |                                                 childPath:(FPath *)childPath
  344|       |                                         existingEventSnap:
  345|       |                                             (id<FNode>)existingEventSnap
  346|       |                                        existingServerSnap:
  347|      0|                                            (id<FNode>)existingServerSnap {
  348|      0|    NSAssert(existingEventSnap != nil || existingServerSnap != nil,
  349|      0|             @"Either existingEventSnap or existingServerSanp must exist.");
  350|      0|
  351|      0|    FPath *path = [treePath child:childPath];
  352|      0|    if ([self.visibleWrites hasCompleteWriteAtPath:path]) {
  353|      0|        // At this point we can probably guarantee that we're in case 2, meaning
  354|      0|        // no events May need to check visibility while doing the
  355|      0|        // findRootMostValueAndPath call
  356|      0|        return nil;
  357|      0|    } else {
  358|      0|        // This could be more efficient if the serverNode + updates doesn't
  359|      0|        // change the eventSnap However this is tricky to find out, since user
  360|      0|        // updates don't necessary change the server snap, e.g. priority updates
  361|      0|        // on empty nodes, or deep deletes. Another special case is if the
  362|      0|        // server adds nodes, but doesn't change any existing writes. It is
  363|      0|        // therefore not enough to only check if the updates change the
  364|      0|        // serverNode. Maybe check if the merge tree contains these special
  365|      0|        // cases and only do a full overwrite in that case?
  366|      0|        FCompoundWrite *childMerge =
  367|      0|            [self.visibleWrites childCompoundWriteAtPath:path];
  368|      0|        if (childMerge.isEmpty) {
  369|      0|            // We're not shadowing at all. Case 1
  370|      0|            return [existingServerSnap getChild:childPath];
  371|      0|        } else {
  372|      0|            return [childMerge
  373|      0|                applyToNode:[existingServerSnap getChild:childPath]];
  374|      0|        }
  375|      0|    }
  376|      0|}
  377|       |
  378|       |/**
  379|       | * Returns a complete child for a given server snap after applying all user
  380|       | * writes or nil if there is no complete child for this child key.
  381|       | */
  382|       |- (id<FNode>)calculateCompleteChildAtPath:(FPath *)treePath
  383|       |                                 childKey:(NSString *)childKey
  384|      0|                                    cache:(FCacheNode *)existingServerCache {
  385|      0|    FPath *path = [treePath childFromString:childKey];
  386|      0|    id<FNode> shadowingNode = [self.visibleWrites completeNodeAtPath:path];
  387|      0|    if (shadowingNode != nil) {
  388|      0|        return shadowingNode;
  389|      0|    } else {
  390|      0|        if ([existingServerCache isCompleteForChild:childKey]) {
  391|      0|            FCompoundWrite *childMerge =
  392|      0|                [self.visibleWrites childCompoundWriteAtPath:path];
  393|      0|            return [childMerge applyToNode:[existingServerCache.node
  394|      0|                                               getImmediateChild:childKey]];
  395|      0|        } else {
  396|      0|            return nil;
  397|      0|        }
  398|      0|    }
  399|      0|}
  400|       |
  401|       |/**
  402|       | * Returns a node if there is a complete overwrite for this path. More
  403|       | * specifically, if there is a write at a higher path, this will return the
  404|       | * child of that write relative to the write and this path. Returns null if
  405|       | * there is no write at this path.
  406|       | */
  407|      0|- (id<FNode>)shadowingWriteAtPath:(FPath *)path {
  408|      0|    return [self.visibleWrites completeNodeAtPath:path];
  409|      0|}
  410|       |
  411|       |/**
  412|       | * This method is used when processing child remove events on a query. If we
  413|       | * can, we pull in children that were outside the window, but may now be in the
  414|       | * window.
  415|       | */
  416|       |- (FNamedNode *)calculateNextNodeAfterPost:(FNamedNode *)post
  417|       |                                    atPath:(FPath *)treePath
  418|       |                        completeServerData:(id<FNode>)completeServerData
  419|       |                                   reverse:(BOOL)reverse
  420|      0|                                     index:(id<FIndex>)index {
  421|      0|    __block id<FNode> toIterate;
  422|      0|    FCompoundWrite *merge =
  423|      0|        [self.visibleWrites childCompoundWriteAtPath:treePath];
  424|      0|    id<FNode> shadowingNode = [merge completeNodeAtPath:[FPath empty]];
  425|      0|    if (shadowingNode != nil) {
  426|      0|        toIterate = shadowingNode;
  427|      0|    } else if (completeServerData != nil) {
  428|      0|        toIterate = [merge applyToNode:completeServerData];
  429|      0|    } else {
  430|      0|        return nil;
  431|      0|    }
  432|      0|
  433|      0|    __block NSString *currentNextKey = nil;
  434|      0|    __block id<FNode> currentNextNode = nil;
  435|      0|    [toIterate enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  436|      0|                                             BOOL *stop) {
  437|      0|      if ([index compareKey:key
  438|      0|                    andNode:node
  439|      0|                 toOtherKey:post.name
  440|      0|                    andNode:post.node
  441|      0|                    reverse:reverse] > NSOrderedSame &&
  442|      0|          (!currentNextKey || [index compareKey:key
  443|      0|                                        andNode:node
  444|      0|                                     toOtherKey:currentNextKey
  445|      0|                                        andNode:currentNextNode
  446|      0|                                        reverse:reverse] < NSOrderedSame)) {
  447|      0|          currentNextKey = key;
  448|      0|          currentNextNode = node;
  449|      0|      }
  450|      0|    }];
  451|      0|
  452|      0|    if (currentNextKey != nil) {
  453|      0|        return [FNamedNode nodeWithName:currentNextKey node:currentNextNode];
  454|      0|    } else {
  455|      0|        return nil;
  456|      0|    }
  457|      0|}
  458|       |
  459|       |#pragma mark -
  460|       |#pragma mark Private Methods
  461|       |
  462|      0|- (BOOL)record:(FWriteRecord *)record containsPath:(FPath *)path {
  463|      0|    if ([record isOverwrite]) {
  464|      0|        return [record.path contains:path];
  465|      0|    } else {
  466|      0|        __block BOOL contains = NO;
  467|      0|        [record.merge
  468|      0|            enumerateWrites:^(FPath *childPath, id<FNode> node, BOOL *stop) {
  469|      0|              contains = [[record.path child:childPath] contains:path];
  470|      0|              *stop = contains;
  471|      0|            }];
  472|      0|        return contains;
  473|      0|    }
  474|      0|}
  475|       |
  476|       |/**
  477|       | * Re-layer the writes and merges into a tree so we can efficiently calculate
  478|       | * event snapshots
  479|       | */
  480|      0|- (void)resetTree {
  481|      0|    self.visibleWrites =
  482|      0|        [FWriteTree layerTreeFromWrites:self.allWrites
  483|      0|                                 filter:[FWriteTree defaultFilter]
  484|      0|                               treeRoot:[FPath empty]];
  485|      0|    if ([self.allWrites count] > 0) {
  486|      0|        FWriteRecord *lastRecord = self.allWrites[[self.allWrites count] - 1];
  487|      0|        self.lastWriteId = lastRecord.writeId;
  488|      0|    } else {
  489|      0|        self.lastWriteId = -1;
  490|      0|    }
  491|      0|}
  492|       |
  493|       |/**
  494|       | * The default filter used when constructing the tree. Keep everything that's
  495|       | * visible.
  496|       | */
  497|      0|+ (BOOL (^)(FWriteRecord *record))defaultFilter {
  498|      0|    static BOOL (^filter)(FWriteRecord *);
  499|      0|    static dispatch_once_t filterToken;
  500|      0|    dispatch_once(&filterToken, ^{
  501|      0|      filter = ^(FWriteRecord *record) {
  502|      0|        return YES;
  503|      0|      };
  504|      0|    });
  505|      0|    return filter;
  506|      0|}
  507|       |
  508|       |/**
  509|       | * Static method. Given an array of WriteRecords, a filter for which ones to
  510|       | * include, and a path, construct a merge at that path
  511|       | * @return An FImmutableTree of id<FNode>s.
  512|       | */
  513|       |+ (FCompoundWrite *)layerTreeFromWrites:(NSArray *)writes
  514|       |                                 filter:(BOOL (^)(FWriteRecord *record))filter
  515|      0|                               treeRoot:(FPath *)treeRoot {
  516|      0|    __block FCompoundWrite *compoundWrite = [FCompoundWrite emptyWrite];
  517|      0|    [writes enumerateObjectsUsingBlock:^(FWriteRecord *record, NSUInteger idx,
  518|      0|                                         BOOL *stop) {
  519|      0|      // Theory, a later set will either:
  520|      0|      // a) abort a relevant transaction, so no need to worry about excluding it
  521|      0|      // from calculating that transaction b) not be relevant to a transaction
  522|      0|      // (separate branch), so again will not affect the data for that
  523|      0|      // transaction
  524|      0|      if (filter(record)) {
  525|      0|          FPath *writePath = record.path;
  526|      0|          if ([record isOverwrite]) {
  527|      0|              if ([treeRoot contains:writePath]) {
  528|      0|                  FPath *relativePath = [FPath relativePathFrom:treeRoot
  529|      0|                                                             to:writePath];
  530|      0|                  compoundWrite = [compoundWrite addWrite:record.overwrite
  531|      0|                                                   atPath:relativePath];
  532|      0|              } else if ([writePath contains:treeRoot]) {
  533|      0|                  id<FNode> child = [record.overwrite
  534|      0|                      getChild:[FPath relativePathFrom:writePath to:treeRoot]];
  535|      0|                  compoundWrite = [compoundWrite addWrite:child
  536|      0|                                                   atPath:[FPath empty]];
  537|      0|              } else {
  538|      0|                  // There is no overlap between root path and write path,
  539|      0|                  // ignore write
  540|      0|              }
  541|      0|          } else {
  542|      0|              if ([treeRoot contains:writePath]) {
  543|      0|                  FPath *relativePath = [FPath relativePathFrom:treeRoot
  544|      0|                                                             to:writePath];
  545|      0|                  compoundWrite = [compoundWrite addCompoundWrite:record.merge
  546|      0|                                                           atPath:relativePath];
  547|      0|              } else if ([writePath contains:treeRoot]) {
  548|      0|                  FPath *relativePath = [FPath relativePathFrom:writePath
  549|      0|                                                             to:treeRoot];
  550|      0|                  if (relativePath.isEmpty) {
  551|      0|                      compoundWrite =
  552|      0|                          [compoundWrite addCompoundWrite:record.merge
  553|      0|                                                   atPath:[FPath empty]];
  554|      0|                  } else {
  555|      0|                      id<FNode> child =
  556|      0|                          [record.merge completeNodeAtPath:relativePath];
  557|      0|                      if (child != nil) {
  558|      0|                          // There exists a child in this node that matches the
  559|      0|                          // root path
  560|      0|                          id<FNode> deepNode =
  561|      0|                              [child getChild:[relativePath popFront]];
  562|      0|                          compoundWrite =
  563|      0|                              [compoundWrite addWrite:deepNode
  564|      0|                                               atPath:[FPath empty]];
  565|      0|                      }
  566|      0|                  }
  567|      0|              } else {
  568|      0|                  // There is no overlap between root path and write path,
  569|      0|                  // ignore write
  570|      0|              }
  571|      0|          }
  572|      0|      }
  573|      0|    }];
  574|      0|    return compoundWrite;
  575|      0|}
  576|       |
  577|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/FWriteTreeRef.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FWriteTreeRef.h"
   18|       |#import "FCacheNode.h"
   19|       |#import "FChildrenNode.h"
   20|       |#import "FIndex.h"
   21|       |#import "FNamedNode.h"
   22|       |#import "FNode.h"
   23|       |#import "FPath.h"
   24|       |#import "FWriteRecord.h"
   25|       |#import "FWriteTree.h"
   26|       |
   27|       |@interface FWriteTreeRef ()
   28|       |/**
   29|       | * The path to this particular FWriteTreeRef. Used for calling methods on
   30|       | * writeTree while exposing a simpler interface to callers.
   31|       | */
   32|       |@property(nonatomic, strong) FPath *path;
   33|       |/**
   34|       | * A reference to the actual tree of the write data. All methods are
   35|       | * pass-through to the tree, but with the appropriate path prefixed.
   36|       | *
   37|       | * This lets us make cheap references to points in the tree for sync points
   38|       | * without having to copy and maintain all of the data.
   39|       | */
   40|       |@property(nonatomic, strong) FWriteTree *writeTree;
   41|       |@end
   42|       |
   43|       |/**
   44|       | * A FWriteTreeRef wraps a FWriteTree and a FPath, for convenient access to a
   45|       | * particular subtree. All the methods just proxy to the underlying FWriteTree.
   46|       | */
   47|       |@implementation FWriteTreeRef
   48|      0|- (id)initWithPath:(FPath *)aPath writeTree:(FWriteTree *)tree {
   49|      0|    self = [super init];
   50|      0|    if (self) {
   51|      0|        self.path = aPath;
   52|      0|        self.writeTree = tree;
   53|      0|    }
   54|      0|    return self;
   55|      0|}
   56|       |
   57|       |/**
   58|       | * @return If possible, returns a complete event cache, using the underlying
   59|       | * server data if possible. In addition, can be used to get a cache that
   60|       | * includes hidden writes, and excludes arbitrary writes. Note that customizing
   61|       | * the returned node can lead to a more expensive calculation.
   62|       | */
   63|       |- (id<FNode>)calculateCompleteEventCacheWithCompleteServerCache:
   64|      0|    (id<FNode>)completeServerCache {
   65|      0|    return [self.writeTree calculateCompleteEventCacheAtPath:self.path
   66|      0|                                         completeServerCache:completeServerCache
   67|      0|                                             excludeWriteIds:nil
   68|      0|                                         includeHiddenWrites:NO];
   69|      0|}
   70|       |
   71|       |/**
   72|       | * @return If possible, returns a children node containing all of the complete
   73|       | * children we have data for. The returned data is a mix of the given server
   74|       | * data and write data.
   75|       | */
   76|       |- (FChildrenNode *)calculateCompleteEventChildrenWithCompleteServerChildren:
   77|      0|    (id<FNode>)completeServerChildren {
   78|      0|    return [self.writeTree
   79|      0|        calculateCompleteEventChildrenAtPath:self.path
   80|      0|                      completeServerChildren:completeServerChildren];
   81|      0|}
   82|       |
   83|       |/**
   84|       | * Given that either the underlying server data has updated or the outstanding
   85|       | * writes have been updating, determine what, if anything, needs to be applied
   86|       | * to the event cache.
   87|       | *
   88|       | * Possibilities:
   89|       | *
   90|       | * 1. No writes are shadowing. Events should be raised, the snap to be applied
   91|       | * comes from the server data.
   92|       | *
   93|       | * 2. Some writes are completly shadowing. No events to be raised.
   94|       | *
   95|       | * 3. Is partially shadowed. Events should be raised.
   96|       | *
   97|       | * Either existingEventSnap or existingServerSnap must exist, this is validated
   98|       | * via an assert.
   99|       | */
  100|       |- (id<FNode>)
  101|       |    calculateEventCacheAfterServerOverwriteWithChildPath:(FPath *)childPath
  102|       |                                       existingEventSnap:
  103|       |                                           (id<FNode>)existingEventSnap
  104|       |                                      existingServerSnap:
  105|      0|                                          (id<FNode>)existingServerSnap {
  106|      0|    return [self.writeTree
  107|      0|        calculateEventCacheAfterServerOverwriteAtPath:self.path
  108|      0|                                            childPath:childPath
  109|      0|                                    existingEventSnap:existingEventSnap
  110|      0|                                   existingServerSnap:existingServerSnap];
  111|      0|}
  112|       |
  113|       |/**
  114|       | * Returns a node if there is a complete overwrite for this path. More
  115|       | * specifically, if there is a write at a higher path, this will return the
  116|       | * child of that write relative to the write and this path. Returns nil if there
  117|       | * is no write at this path.
  118|       | */
  119|      0|- (id<FNode>)shadowingWriteAtPath:(FPath *)path {
  120|      0|    return [self.writeTree shadowingWriteAtPath:[self.path child:path]];
  121|      0|}
  122|       |
  123|       |/**
  124|       | * This method is used when processing child remove events on a query. If we
  125|       | * can, we pull in children that are outside the window, but may now be in the
  126|       | * window.
  127|       | */
  128|       |- (FNamedNode *)calculateNextNodeAfterPost:(FNamedNode *)post
  129|       |                        completeServerData:(id<FNode>)completeServerData
  130|       |                                   reverse:(BOOL)reverse
  131|      0|                                     index:(id<FIndex>)index {
  132|      0|    return [self.writeTree calculateNextNodeAfterPost:post
  133|      0|                                               atPath:self.path
  134|      0|                                   completeServerData:completeServerData
  135|      0|                                              reverse:reverse
  136|      0|                                                index:index];
  137|      0|}
  138|       |
  139|       |/**
  140|       | * Returns a complete child for a given server snap after applying all user
  141|       | * writes or nil if there is no complete child for this child key.
  142|       | */
  143|       |- (id<FNode>)calculateCompleteChild:(NSString *)childKey
  144|      0|                              cache:(FCacheNode *)existingServerCache {
  145|      0|    return [self.writeTree calculateCompleteChildAtPath:self.path
  146|      0|                                               childKey:childKey
  147|      0|                                                  cache:existingServerCache];
  148|      0|}
  149|       |
  150|       |/**
  151|       | * @return a WriteTreeref for a child.
  152|       | */
  153|      0|- (FWriteTreeRef *)childWriteTreeRef:(NSString *)childKey {
  154|      0|    return
  155|      0|        [[FWriteTreeRef alloc] initWithPath:[self.path childFromString:childKey]
  156|      0|                                  writeTree:self.writeTree];
  157|      0|}
  158|       |
  159|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Operation/FAckUserWrite.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FAckUserWrite.h"
   18|       |#import "FImmutableTree.h"
   19|       |#import "FOperationSource.h"
   20|       |#import "FPath.h"
   21|       |
   22|       |@implementation FAckUserWrite
   23|       |
   24|       |- (id)initWithPath:(FPath *)operationPath
   25|       |      affectedTree:(FImmutableTree *)tree
   26|      0|            revert:(BOOL)shouldRevert {
   27|      0|    self = [super init];
   28|      0|    if (self) {
   29|      0|        self->_source = [FOperationSource userInstance];
   30|      0|        self->_type = FOperationTypeAckUserWrite;
   31|      0|        self->_path = operationPath;
   32|      0|        self->_affectedTree = tree;
   33|      0|        self->_revert = shouldRevert;
   34|      0|    }
   35|      0|    return self;
   36|      0|}
   37|       |
   38|      0|- (FAckUserWrite *)operationForChild:(NSString *)childKey {
   39|      0|    if (![self.path isEmpty]) {
   40|      0|        NSAssert([self.path.getFront isEqualToString:childKey],
   41|      0|                 @"operationForChild called for unrelated child.");
   42|      0|        return [[FAckUserWrite alloc] initWithPath:[self.path popFront]
   43|      0|                                      affectedTree:self.affectedTree
   44|      0|                                            revert:self.revert];
   45|      0|    } else if (self.affectedTree.value != nil) {
   46|      0|        NSAssert(self.affectedTree.children.isEmpty,
   47|      0|                 @"affectedTree should not have overlapping affected paths.");
   48|      0|        // All child locations are affected as well; just return same operation.
   49|      0|        return self;
   50|      0|    } else {
   51|      0|        FImmutableTree *childTree =
   52|      0|            [self.affectedTree subtreeAtPath:[[FPath alloc] initWith:childKey]];
   53|      0|        return [[FAckUserWrite alloc] initWithPath:[FPath empty]
   54|      0|                                      affectedTree:childTree
   55|      0|                                            revert:self.revert];
   56|      0|    }
   57|      0|}
   58|       |
   59|      0|- (NSString *)description {
   60|      0|    return
   61|      0|        [NSString stringWithFormat:
   62|      0|                      @"FAckUserWrite { path=%@, revert=%d, affectedTree=%@ }",
   63|      0|                      self.path, self.revert, self.affectedTree];
   64|      0|}
   65|       |
   66|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Operation/FMerge.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FMerge.h"
   18|       |#import "FCompoundWrite.h"
   19|       |#import "FNode.h"
   20|       |#import "FOperationSource.h"
   21|       |#import "FOverwrite.h"
   22|       |#import "FPath.h"
   23|       |
   24|       |@interface FMerge ()
   25|       |@property(nonatomic, strong, readwrite) FOperationSource *source;
   26|       |@property(nonatomic, readwrite) FOperationType type;
   27|       |@property(nonatomic, strong, readwrite) FPath *path;
   28|       |@property(nonatomic, strong) FCompoundWrite *children;
   29|       |@end
   30|       |
   31|       |@implementation FMerge
   32|       |
   33|       |@synthesize source;
   34|       |@synthesize type;
   35|       |@synthesize path;
   36|       |@synthesize children;
   37|       |
   38|       |- (id)initWithSource:(FOperationSource *)aSource
   39|       |                path:(FPath *)aPath
   40|      0|            children:(FCompoundWrite *)someChildren {
   41|      0|    self = [super init];
   42|      0|    if (self) {
   43|      0|        self.source = aSource;
   44|      0|        self.type = FOperationTypeMerge;
   45|      0|        self.path = aPath;
   46|      0|        self.children = someChildren;
   47|      0|    }
   48|      0|    return self;
   49|      0|}
   50|       |
   51|      0|- (id<FOperation>)operationForChild:(NSString *)childKey {
   52|      0|    if ([self.path isEmpty]) {
   53|      0|        FCompoundWrite *childTree = [self.children
   54|      0|            childCompoundWriteAtPath:[[FPath alloc] initWith:childKey]];
   55|      0|        if (childTree.isEmpty) {
   56|      0|            return nil;
   57|      0|        } else if (childTree.rootWrite != nil) {
   58|      0|            // We have a snapshot for the child in question. This becomes an
   59|      0|            // overwrite of the child.
   60|      0|            return [[FOverwrite alloc] initWithSource:self.source
   61|      0|                                                 path:[FPath empty]
   62|      0|                                                 snap:childTree.rootWrite];
   63|      0|        } else {
   64|      0|            // This is a merge at a deeper level
   65|      0|            return [[FMerge alloc] initWithSource:self.source
   66|      0|                                             path:[FPath empty]
   67|      0|                                         children:childTree];
   68|      0|        }
   69|      0|    } else {
   70|      0|        NSAssert(
   71|      0|            [self.path.getFront isEqualToString:childKey],
   72|      0|            @"Can't get a merge for a child not on the path of the operation");
   73|      0|        return [[FMerge alloc] initWithSource:self.source
   74|      0|                                         path:[self.path popFront]
   75|      0|                                     children:self.children];
   76|      0|    }
   77|      0|}
   78|       |
   79|      0|- (NSString *)description {
   80|      0|    return
   81|      0|        [NSString stringWithFormat:@"FMerge { path=%@, soruce=%@ children=%@}",
   82|      0|                                   self.path, self.source, self.children];
   83|      0|}
   84|       |
   85|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Operation/FOperationSource.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FOperationSource.h"
   18|       |#import "FPath.h"
   19|       |#import "FQueryParams.h"
   20|       |
   21|       |@interface FOperationSource ()
   22|       |@property(nonatomic, readwrite) BOOL fromUser;
   23|       |@property(nonatomic, readwrite) BOOL fromServer;
   24|       |@property(nonatomic, readwrite) BOOL isTagged;
   25|       |@property(nonatomic, strong, readwrite) FQueryParams *queryParams;
   26|       |@end
   27|       |
   28|       |@implementation FOperationSource
   29|       |
   30|       |@synthesize fromUser;
   31|       |@synthesize fromServer;
   32|       |@synthesize queryParams;
   33|       |
   34|       |- (id)initWithFromUser:(BOOL)isFromUser
   35|       |            fromServer:(BOOL)isFromServer
   36|       |           queryParams:(FQueryParams *)params
   37|      0|                tagged:(BOOL)tagged {
   38|      0|    self = [super init];
   39|      0|    if (self) {
   40|      0|        self.fromUser = isFromUser;
   41|      0|        self.fromServer = isFromServer;
   42|      0|        self.queryParams = params;
   43|      0|        self.isTagged = tagged;
   44|      0|    }
   45|      0|    return self;
   46|      0|}
   47|       |
   48|      0|+ (FOperationSource *)userInstance {
   49|      0|    static FOperationSource *user = nil;
   50|      0|    static dispatch_once_t userToken;
   51|      0|    dispatch_once(&userToken, ^{
   52|      0|      user = [[FOperationSource alloc] initWithFromUser:YES
   53|      0|                                             fromServer:NO
   54|      0|                                            queryParams:nil
   55|      0|                                                 tagged:NO];
   56|      0|    });
   57|      0|    return user;
   58|      0|}
   59|       |
   60|      0|+ (FOperationSource *)serverInstance {
   61|      0|    static FOperationSource *server = nil;
   62|      0|    static dispatch_once_t serverToken;
   63|      0|    dispatch_once(&serverToken, ^{
   64|      0|      server = [[FOperationSource alloc] initWithFromUser:NO
   65|      0|                                               fromServer:YES
   66|      0|                                              queryParams:nil
   67|      0|                                                   tagged:NO];
   68|      0|    });
   69|      0|    return server;
   70|      0|}
   71|       |
   72|      0|+ (FOperationSource *)forServerTaggedQuery:(FQueryParams *)params {
   73|      0|    return [[FOperationSource alloc] initWithFromUser:NO
   74|      0|                                           fromServer:YES
   75|      0|                                          queryParams:params
   76|      0|                                               tagged:YES];
   77|      0|}
   78|       |
   79|      0|- (NSString *)description {
   80|      0|    return [NSString stringWithFormat:@"FOperationSource { fromUser=%d, "
   81|      0|                                      @"fromServer=%d, queryId=%@, tagged=%d }",
   82|      0|                                      self.fromUser, self.fromServer,
   83|      0|                                      self.queryParams, self.isTagged];
   84|      0|}
   85|       |
   86|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Operation/FOverwrite.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FOverwrite.h"
   18|       |#import "FNode.h"
   19|       |#import "FOperationSource.h"
   20|       |
   21|       |@interface FOverwrite ()
   22|       |@property(nonatomic, strong, readwrite) FOperationSource *source;
   23|       |@property(nonatomic, readwrite) FOperationType type;
   24|       |@property(nonatomic, strong, readwrite) FPath *path;
   25|       |@property(nonatomic, strong) id<FNode> snap;
   26|       |@end
   27|       |
   28|       |@implementation FOverwrite
   29|       |
   30|       |@synthesize source;
   31|       |@synthesize type;
   32|       |@synthesize path;
   33|       |@synthesize snap;
   34|       |
   35|       |- (id)initWithSource:(FOperationSource *)aSource
   36|       |                path:(FPath *)aPath
   37|      0|                snap:(id<FNode>)aSnap {
   38|      0|    self = [super init];
   39|      0|    if (self) {
   40|      0|        self.source = aSource;
   41|      0|        self.type = FOperationTypeOverwrite;
   42|      0|        self.path = aPath;
   43|      0|        self.snap = aSnap;
   44|      0|    }
   45|      0|    return self;
   46|      0|}
   47|       |
   48|      0|- (FOverwrite *)operationForChild:(NSString *)childKey {
   49|      0|    if ([self.path isEmpty]) {
   50|      0|        return [[FOverwrite alloc]
   51|      0|            initWithSource:self.source
   52|      0|                      path:[FPath empty]
   53|      0|                      snap:[self.snap getImmediateChild:childKey]];
   54|      0|    } else {
   55|      0|        return [[FOverwrite alloc] initWithSource:self.source
   56|      0|                                             path:[self.path popFront]
   57|      0|                                             snap:self.snap];
   58|      0|    }
   59|      0|}
   60|       |
   61|      0|- (NSString *)description {
   62|      0|    return [NSString
   63|      0|        stringWithFormat:@"FOverwrite { path=%@, source=%@, snapshot=%@ }",
   64|      0|                         self.path, self.source, self.snap];
   65|      0|}
   66|       |
   67|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Utilities/FIRRetryHelper.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRRetryHelper.h"
   18|       |#import "FUtilities.h"
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |
   21|       |@interface FIRRetryHelperTask : NSObject
   22|       |
   23|       |@property(nonatomic, strong) void (^block)(void);
   24|       |
   25|       |@end
   26|       |
   27|       |@implementation FIRRetryHelperTask
   28|       |
   29|      0|- (instancetype)initWithBlock:(void (^)(void))block {
   30|      0|    self = [super init];
   31|      0|    if (self != nil) {
   32|      0|        self->_block = [block copy];
   33|      0|    }
   34|      0|    return self;
   35|      0|}
   36|       |
   37|      0|- (BOOL)isCanceled {
   38|      0|    return self.block == nil;
   39|      0|}
   40|       |
   41|      0|- (void)cancel {
   42|      0|    self.block = nil;
   43|      0|}
   44|       |
   45|      0|- (void)execute {
   46|      0|    if (self.block) {
   47|      0|        self.block();
   48|      0|    }
   49|      0|}
   50|       |
   51|       |@end
   52|       |
   53|       |@interface FIRRetryHelper ()
   54|       |
   55|       |@property(nonatomic, strong) dispatch_queue_t dispatchQueue;
   56|       |@property(nonatomic) NSTimeInterval minRetryDelayAfterFailure;
   57|       |@property(nonatomic) NSTimeInterval maxRetryDelay;
   58|       |@property(nonatomic) double retryExponent;
   59|       |@property(nonatomic) double jitterFactor;
   60|       |
   61|       |@property(nonatomic) BOOL lastWasSuccess;
   62|       |@property(nonatomic) NSTimeInterval currentRetryDelay;
   63|       |
   64|       |@property(nonatomic, strong) FIRRetryHelperTask *scheduledRetry;
   65|       |
   66|       |@end
   67|       |
   68|       |@implementation FIRRetryHelper
   69|       |
   70|       |- (instancetype)initWithDispatchQueue:(dispatch_queue_t)dispatchQueue
   71|       |            minRetryDelayAfterFailure:(NSTimeInterval)minRetryDelayAfterFailure
   72|       |                        maxRetryDelay:(NSTimeInterval)maxRetryDelay
   73|       |                        retryExponent:(double)retryExponent
   74|      0|                         jitterFactor:(double)jitterFactor {
   75|      0|    self = [super init];
   76|      0|    if (self != nil) {
   77|      0|        self->_dispatchQueue = dispatchQueue;
   78|      0|        self->_minRetryDelayAfterFailure = minRetryDelayAfterFailure;
   79|      0|        self->_maxRetryDelay = maxRetryDelay;
   80|      0|        self->_retryExponent = retryExponent;
   81|      0|        self->_jitterFactor = jitterFactor;
   82|      0|        self->_lastWasSuccess = YES;
   83|      0|    }
   84|      0|    return self;
   85|      0|}
   86|       |
   87|      0|- (void)retry:(void (^)(void))block {
   88|      0|    if (self.scheduledRetry != nil) {
   89|      0|        FFLog(@"I-RDB054001", @"Canceling existing retry attempt");
   90|      0|        [self.scheduledRetry cancel];
   91|      0|        self.scheduledRetry = nil;
   92|      0|    }
   93|      0|
   94|      0|    NSTimeInterval delay;
   95|      0|    if (self.lastWasSuccess) {
   96|      0|        delay = 0;
   97|      0|    } else {
   98|      0|        if (self.currentRetryDelay == 0) {
   99|      0|            self.currentRetryDelay = self.minRetryDelayAfterFailure;
  100|      0|        } else {
  101|      0|            NSTimeInterval newDelay =
  102|      0|                (self.currentRetryDelay * self.retryExponent);
  103|      0|            self.currentRetryDelay = MIN(newDelay, self.maxRetryDelay);
  104|      0|        }
  105|      0|
  106|      0|        delay = ((1 - self.jitterFactor) * self.currentRetryDelay) +
  107|      0|                (self.jitterFactor * self.currentRetryDelay *
  108|      0|                 [FUtilities randomDouble]);
  109|      0|        FFLog(@"I-RDB054002", @"Scheduling retry in %fs", delay);
  110|      0|    }
  111|      0|    self.lastWasSuccess = NO;
  112|      0|    FIRRetryHelperTask *task = [[FIRRetryHelperTask alloc] initWithBlock:block];
  113|      0|    self.scheduledRetry = task;
  114|      0|    dispatch_time_t popTime =
  115|      0|        dispatch_time(DISPATCH_TIME_NOW, (long long)(delay * NSEC_PER_SEC));
  116|      0|    dispatch_after(popTime, self.dispatchQueue, ^{
  117|      0|      if (![task isCanceled]) {
  118|      0|          self.scheduledRetry = nil;
  119|      0|          [task execute];
  120|      0|      }
  121|      0|    });
  122|      0|}
  123|       |
  124|      0|- (void)signalSuccess {
  125|      0|    self.lastWasSuccess = YES;
  126|      0|    self.currentRetryDelay = 0;
  127|      0|}
  128|       |
  129|      0|- (void)cancel {
  130|      0|    if (self.scheduledRetry != nil) {
  131|      0|        FFLog(@"I-RDB054003", @"Canceling existing retry attempt");
  132|      0|        [self.scheduledRetry cancel];
  133|      0|        self.scheduledRetry = nil;
  134|      0|    } else {
  135|      0|        FFLog(@"I-RDB054004", @"No existing retry attempt to cancel");
  136|      0|    }
  137|      0|    self.currentRetryDelay = 0;
  138|      0|}
  139|       |
  140|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Utilities/FImmutableTree.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FImmutableTree.h"
   18|       |#import "FImmutableSortedDictionary.h"
   19|       |#import "FPath.h"
   20|       |#import "FUtilities.h"
   21|       |
   22|       |@interface FImmutableTree ()
   23|       |@property(nonatomic, strong, readwrite) id value;
   24|       |/**
   25|       | * Maps NSString -> FImmutableTree<T>, where <T> is type of value.
   26|       | */
   27|       |@property(nonatomic, strong, readwrite) FImmutableSortedDictionary *children;
   28|       |@end
   29|       |
   30|       |@implementation FImmutableTree
   31|       |@synthesize value;
   32|       |@synthesize children;
   33|       |
   34|      0|- (id)initWithValue:(id)aValue {
   35|      0|    self = [super init];
   36|      0|    if (self) {
   37|      0|        self.value = aValue;
   38|      0|        self.children = [FImmutableTree emptyChildren];
   39|      0|    }
   40|      0|    return self;
   41|      0|}
   42|       |
   43|       |- (id)initWithValue:(id)aValue
   44|      0|           children:(FImmutableSortedDictionary *)childrenMap {
   45|      0|    self = [super init];
   46|      0|    if (self) {
   47|      0|        self.value = aValue;
   48|      0|        self.children = childrenMap;
   49|      0|    }
   50|      0|    return self;
   51|      0|}
   52|       |
   53|      0|+ (FImmutableSortedDictionary *)emptyChildren {
   54|      0|    static dispatch_once_t emptyChildrenToken;
   55|      0|    static FImmutableSortedDictionary *emptyChildren;
   56|      0|    dispatch_once(&emptyChildrenToken, ^{
   57|      0|      emptyChildren = [FImmutableSortedDictionary
   58|      0|          dictionaryWithComparator:[FUtilities stringComparator]];
   59|      0|    });
   60|      0|    return emptyChildren;
   61|      0|}
   62|       |
   63|      0|+ (FImmutableTree *)empty {
   64|      0|    static dispatch_once_t emptyImmutableTreeToken;
   65|      0|    static FImmutableTree *emptyTree = nil;
   66|      0|    dispatch_once(&emptyImmutableTreeToken, ^{
   67|      0|      emptyTree = [[FImmutableTree alloc] initWithValue:nil];
   68|      0|    });
   69|      0|    return emptyTree;
   70|      0|}
   71|       |
   72|      0|- (BOOL)isEmpty {
   73|      0|    return self.value == nil && [self.children isEmpty];
   74|      0|}
   75|       |
   76|       |/**
   77|       | * Given a path and a predicate, return the first node and the path to that node
   78|       | * where the predicate returns true
   79|       | * // TODO Do a perf test. If we're creating a bunch of FTuplePathValue objects
   80|       | * on the way back out, it may be better to pass down a pathSoFar FPath
   81|       | */
   82|       |- (FTuplePathValue *)findRootMostMatchingPath:(FPath *)relativePath
   83|      0|                                    predicate:(BOOL (^)(id value))predicate {
   84|      0|    if (self.value != nil && predicate(self.value)) {
   85|      0|        return [[FTuplePathValue alloc] initWithPath:[FPath empty]
   86|      0|                                               value:self.value];
   87|      0|    } else {
   88|      0|        if ([relativePath isEmpty]) {
   89|      0|            return nil;
   90|      0|        } else {
   91|      0|            NSString *front = [relativePath getFront];
   92|      0|            FImmutableTree *child = [self.children get:front];
   93|      0|            if (child != nil) {
   94|      0|                FTuplePathValue *childExistingPathAndValue =
   95|      0|                    [child findRootMostMatchingPath:[relativePath popFront]
   96|      0|                                          predicate:predicate];
   97|      0|                if (childExistingPathAndValue != nil) {
   98|      0|                    FPath *fullPath = [[[FPath alloc] initWith:front]
   99|      0|                        child:childExistingPathAndValue.path];
  100|      0|                    return [[FTuplePathValue alloc]
  101|      0|                        initWithPath:fullPath
  102|      0|                               value:childExistingPathAndValue.value];
  103|      0|                } else {
  104|      0|                    return nil;
  105|      0|                }
  106|      0|            } else {
  107|      0|                // No child matching path
  108|      0|                return nil;
  109|      0|            }
  110|      0|        }
  111|      0|    }
  112|      0|}
  113|       |
  114|       |/**
  115|       | * Find, if it exists, the shortest subpath of the given path that points a
  116|       | * defined value in the tree
  117|       | */
  118|      0|- (FTuplePathValue *)findRootMostValueAndPath:(FPath *)relativePath {
  119|      0|    return [self findRootMostMatchingPath:relativePath
  120|      0|                                predicate:^BOOL(__unsafe_unretained id value) {
  121|      0|                                  return YES;
  122|      0|                                }];
  123|      0|}
  124|       |
  125|      0|- (id)rootMostValueOnPath:(FPath *)path {
  126|      0|    return [self rootMostValueOnPath:path
  127|      0|                            matching:^BOOL(id value) {
  128|      0|                              return YES;
  129|      0|                            }];
  130|      0|}
  131|       |
  132|      0|- (id)rootMostValueOnPath:(FPath *)path matching:(BOOL (^)(id))predicate {
  133|      0|    if (self.value != nil && predicate(self.value)) {
  134|      0|        return self.value;
  135|      0|    } else if (path.isEmpty) {
  136|      0|        return nil;
  137|      0|    } else {
  138|      0|        return [[self.children get:path.getFront]
  139|      0|            rootMostValueOnPath:[path popFront]
  140|      0|                       matching:predicate];
  141|      0|    }
  142|      0|}
  143|       |
  144|      0|- (id)leafMostValueOnPath:(FPath *)path {
  145|      0|    return [self leafMostValueOnPath:path
  146|      0|                            matching:^BOOL(id value) {
  147|      0|                              return YES;
  148|      0|                            }];
  149|      0|}
  150|       |
  151|       |- (id)leafMostValueOnPath:(FPath *)relativePath
  152|      0|                 matching:(BOOL (^)(id))predicate {
  153|      0|    __block id currentValue = self.value;
  154|      0|    __block FImmutableTree *currentTree = self;
  155|      0|    [relativePath enumerateComponentsUsingBlock:^(NSString *key, BOOL *stop) {
  156|      0|      currentTree = [currentTree.children get:key];
  157|      0|      if (currentTree == nil) {
  158|      0|          *stop = YES;
  159|      0|      } else {
  160|      0|          id treeValue = currentTree.value;
  161|      0|          if (treeValue != nil && predicate(treeValue)) {
  162|      0|              currentValue = treeValue;
  163|      0|          }
  164|      0|      }
  165|      0|    }];
  166|      0|    return currentValue;
  167|      0|}
  168|       |
  169|      0|- (BOOL)containsValueMatching:(BOOL (^)(id))predicate {
  170|      0|    if (self.value != nil && predicate(self.value)) {
  171|      0|        return YES;
  172|      0|    } else {
  173|      0|        __block BOOL found = NO;
  174|      0|        [self.children enumerateKeysAndObjectsUsingBlock:^(
  175|      0|                           NSString *key, FImmutableTree *subtree, BOOL *stop) {
  176|      0|          found = [subtree containsValueMatching:predicate];
  177|      0|          if (found)
  178|      0|              *stop = YES;
  179|      0|        }];
  180|      0|        return found;
  181|      0|    }
  182|      0|}
  183|       |
  184|      0|- (FImmutableTree *)subtreeAtPath:(FPath *)relativePath {
  185|      0|    if ([relativePath isEmpty]) {
  186|      0|        return self;
  187|      0|    } else {
  188|      0|        NSString *front = [relativePath getFront];
  189|      0|        FImmutableTree *childTree = [self.children get:front];
  190|      0|        if (childTree != nil) {
  191|      0|            return [childTree subtreeAtPath:[relativePath popFront]];
  192|      0|        } else {
  193|      0|            return [FImmutableTree empty];
  194|      0|        }
  195|      0|    }
  196|      0|}
  197|       |
  198|       |/**
  199|       | * Sets a value at the specified path
  200|       | */
  201|      0|- (FImmutableTree *)setValue:(id)newValue atPath:(FPath *)relativePath {
  202|      0|    if ([relativePath isEmpty]) {
  203|      0|        return [[FImmutableTree alloc] initWithValue:newValue
  204|      0|                                            children:self.children];
  205|      0|    } else {
  206|      0|        NSString *front = [relativePath getFront];
  207|      0|        FImmutableTree *child = [self.children get:front];
  208|      0|        if (child == nil) {
  209|      0|            child = [FImmutableTree empty];
  210|      0|        }
  211|      0|        FImmutableTree *newChild = [child setValue:newValue
  212|      0|                                            atPath:[relativePath popFront]];
  213|      0|        FImmutableSortedDictionary *newChildren =
  214|      0|            [self.children insertKey:front withValue:newChild];
  215|      0|        return [[FImmutableTree alloc] initWithValue:self.value
  216|      0|                                            children:newChildren];
  217|      0|    }
  218|      0|}
  219|       |
  220|       |/**
  221|       | * Remove the value at the specified path
  222|       | */
  223|      0|- (FImmutableTree *)removeValueAtPath:(FPath *)relativePath {
  224|      0|    if ([relativePath isEmpty]) {
  225|      0|        if ([self.children isEmpty]) {
  226|      0|            return [FImmutableTree empty];
  227|      0|        } else {
  228|      0|            return [[FImmutableTree alloc] initWithValue:nil
  229|      0|                                                children:self.children];
  230|      0|        }
  231|      0|    } else {
  232|      0|        NSString *front = [relativePath getFront];
  233|      0|        FImmutableTree *child = [self.children get:front];
  234|      0|        if (child) {
  235|      0|            FImmutableTree *newChild =
  236|      0|                [child removeValueAtPath:[relativePath popFront]];
  237|      0|            FImmutableSortedDictionary *newChildren;
  238|      0|            if ([newChild isEmpty]) {
  239|      0|                newChildren = [self.children removeKey:front];
  240|      0|            } else {
  241|      0|                newChildren = [self.children insertKey:front
  242|      0|                                             withValue:newChild];
  243|      0|            }
  244|      0|            if (self.value == nil && [newChildren isEmpty]) {
  245|      0|                return [FImmutableTree empty];
  246|      0|            } else {
  247|      0|                return [[FImmutableTree alloc] initWithValue:self.value
  248|      0|                                                    children:newChildren];
  249|      0|            }
  250|      0|        } else {
  251|      0|            return self;
  252|      0|        }
  253|      0|    }
  254|      0|}
  255|       |
  256|       |/**
  257|       | * Gets a value from the tree
  258|       | */
  259|      0|- (id)valueAtPath:(FPath *)relativePath {
  260|      0|    if ([relativePath isEmpty]) {
  261|      0|        return self.value;
  262|      0|    } else {
  263|      0|        NSString *front = [relativePath getFront];
  264|      0|        FImmutableTree *child = [self.children get:front];
  265|      0|        if (child) {
  266|      0|            return [child valueAtPath:[relativePath popFront]];
  267|      0|        } else {
  268|      0|            return nil;
  269|      0|        }
  270|      0|    }
  271|      0|}
  272|       |
  273|       |/**
  274|       | * Replaces the subtree at the specified path with the given new tree
  275|       | */
  276|       |- (FImmutableTree *)setTree:(FImmutableTree *)newTree
  277|      0|                     atPath:(FPath *)relativePath {
  278|      0|    if ([relativePath isEmpty]) {
  279|      0|        return newTree;
  280|      0|    } else {
  281|      0|        NSString *front = [relativePath getFront];
  282|      0|        FImmutableTree *child = [self.children get:front];
  283|      0|        if (child == nil) {
  284|      0|            child = [FImmutableTree empty];
  285|      0|        }
  286|      0|        FImmutableTree *newChild = [child setTree:newTree
  287|      0|                                           atPath:[relativePath popFront]];
  288|      0|        FImmutableSortedDictionary *newChildren;
  289|      0|        if ([newChild isEmpty]) {
  290|      0|            newChildren = [self.children removeKey:front];
  291|      0|        } else {
  292|      0|            newChildren = [self.children insertKey:front withValue:newChild];
  293|      0|        }
  294|      0|        return [[FImmutableTree alloc] initWithValue:self.value
  295|      0|                                            children:newChildren];
  296|      0|    }
  297|      0|}
  298|       |
  299|       |/**
  300|       | * Performs a depth first fold on this tree. Transforms a tree into a single
  301|       | * value, given a function that operates on the path to a node, an optional
  302|       | * current value, and a map of the child names to folded subtrees
  303|       | */
  304|       |- (id)foldWithBlock:(id (^)(FPath *path, id value,
  305|      0|                            NSDictionary *foldedChildren))block {
  306|      0|    return [self foldWithPathSoFar:[FPath empty] withBlock:block];
  307|      0|}
  308|       |
  309|       |/**
  310|       | * Recursive helper for public facing foldWithBlock: method
  311|       | */
  312|       |- (id)foldWithPathSoFar:(FPath *)pathSoFar
  313|       |              withBlock:(id (^)(FPath *path, id value,
  314|      0|                                NSDictionary *foldedChildren))block {
  315|      0|    __block NSMutableDictionary *accum = [[NSMutableDictionary alloc] init];
  316|      0|    [self.children
  317|      0|        enumerateKeysAndObjectsUsingBlock:^(
  318|      0|            NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  319|      0|          accum[childKey] =
  320|      0|              [childTree foldWithPathSoFar:[pathSoFar childFromString:childKey]
  321|      0|                                 withBlock:block];
  322|      0|        }];
  323|      0|    return block(pathSoFar, self.value, accum);
  324|      0|}
  325|       |
  326|       |/**
  327|       | * Find the first matching value on the given path. Return the result of
  328|       | * applying block to it.
  329|       | */
  330|       |- (id)findOnPath:(FPath *)path
  331|      0|    andApplyBlock:(id (^)(FPath *path, id value))block {
  332|      0|    return [self findOnPath:path pathSoFar:[FPath empty] andApplyBlock:block];
  333|      0|}
  334|       |
  335|       |- (id)findOnPath:(FPath *)pathToFollow
  336|       |        pathSoFar:(FPath *)pathSoFar
  337|      0|    andApplyBlock:(id (^)(FPath *path, id value))block {
  338|      0|    id result = self.value ? block(pathSoFar, self.value) : nil;
  339|      0|    if (result != nil) {
  340|      0|        return result;
  341|      0|    } else {
  342|      0|        if ([pathToFollow isEmpty]) {
  343|      0|            return nil;
  344|      0|        } else {
  345|      0|            NSString *front = [pathToFollow getFront];
  346|      0|            FImmutableTree *nextChild = [self.children get:front];
  347|      0|            if (nextChild != nil) {
  348|      0|                return [nextChild findOnPath:[pathToFollow popFront]
  349|      0|                                   pathSoFar:[pathSoFar childFromString:front]
  350|      0|                               andApplyBlock:block];
  351|      0|            } else {
  352|      0|                return nil;
  353|      0|            }
  354|      0|        }
  355|      0|    }
  356|      0|}
  357|       |/**
  358|       | * Call the block on each value along the path for as long as that function
  359|       | * returns true
  360|       | * @return The path to the deepest location inspected
  361|       | */
  362|      0|- (FPath *)forEachOnPath:(FPath *)path whileBlock:(BOOL (^)(FPath *, id))block {
  363|      0|    return [self forEachOnPath:path pathSoFar:[FPath empty] whileBlock:block];
  364|      0|}
  365|       |
  366|       |- (FPath *)forEachOnPath:(FPath *)pathToFollow
  367|       |               pathSoFar:(FPath *)pathSoFar
  368|      0|              whileBlock:(BOOL (^)(FPath *, id))block {
  369|      0|    if ([pathToFollow isEmpty]) {
  370|      0|        if (self.value) {
  371|      0|            block(pathSoFar, self.value);
  372|      0|        }
  373|      0|        return pathSoFar;
  374|      0|    } else {
  375|      0|        BOOL shouldContinue = YES;
  376|      0|        if (self.value) {
  377|      0|            shouldContinue = block(pathSoFar, self.value);
  378|      0|        }
  379|      0|        if (shouldContinue) {
  380|      0|            NSString *front = [pathToFollow getFront];
  381|      0|            FImmutableTree *nextChild = [self.children get:front];
  382|      0|            if (nextChild) {
  383|      0|                return
  384|      0|                    [nextChild forEachOnPath:[pathToFollow popFront]
  385|      0|                                   pathSoFar:[pathSoFar childFromString:front]
  386|      0|                                  whileBlock:block];
  387|      0|            } else {
  388|      0|                return pathSoFar;
  389|      0|            }
  390|      0|        } else {
  391|      0|            return pathSoFar;
  392|      0|        }
  393|      0|    }
  394|      0|}
  395|       |
  396|       |- (FImmutableTree *)forEachOnPath:(FPath *)path
  397|      0|                     performBlock:(void (^)(FPath *path, id value))block {
  398|      0|    return [self forEachOnPath:path pathSoFar:[FPath empty] performBlock:block];
  399|      0|}
  400|       |
  401|       |- (FImmutableTree *)forEachOnPath:(FPath *)pathToFollow
  402|       |                        pathSoFar:(FPath *)pathSoFar
  403|      0|                     performBlock:(void (^)(FPath *path, id value))block {
  404|      0|    if ([pathToFollow isEmpty]) {
  405|      0|        return self;
  406|      0|    } else {
  407|      0|        if (self.value) {
  408|      0|            block(pathSoFar, self.value);
  409|      0|        }
  410|      0|        NSString *front = [pathToFollow getFront];
  411|      0|        FImmutableTree *nextChild = [self.children get:front];
  412|      0|        if (nextChild) {
  413|      0|            return [nextChild forEachOnPath:[pathToFollow popFront]
  414|      0|                                  pathSoFar:[pathSoFar childFromString:front]
  415|      0|                               performBlock:block];
  416|      0|        } else {
  417|      0|            return [FImmutableTree empty];
  418|      0|        }
  419|      0|    }
  420|      0|}
  421|       |/**
  422|       | * Calls the given block for each node in the tree that has a value. Called in
  423|       | * depth-first order
  424|       | */
  425|      0|- (void)forEach:(void (^)(FPath *path, id value))block {
  426|      0|    [self forEachPathSoFar:[FPath empty] withBlock:block];
  427|      0|}
  428|       |
  429|       |- (void)forEachPathSoFar:(FPath *)pathSoFar
  430|      0|               withBlock:(void (^)(FPath *path, id value))block {
  431|      0|    [self.children
  432|      0|        enumerateKeysAndObjectsUsingBlock:^(
  433|      0|            NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  434|      0|          [childTree forEachPathSoFar:[pathSoFar childFromString:childKey]
  435|      0|                            withBlock:block];
  436|      0|        }];
  437|      0|    if (self.value) {
  438|      0|        block(pathSoFar, self.value);
  439|      0|    }
  440|      0|}
  441|       |
  442|      0|- (void)forEachChild:(void (^)(NSString *childKey, id childValue))block {
  443|      0|    [self.children
  444|      0|        enumerateKeysAndObjectsUsingBlock:^(
  445|      0|            NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  446|      0|          if (childTree.value) {
  447|      0|              block(childKey, childTree.value);
  448|      0|          }
  449|      0|        }];
  450|      0|}
  451|       |
  452|      0|- (BOOL)isEqual:(id)object {
  453|      0|    if (![object isKindOfClass:[FImmutableTree class]]) {
  454|      0|        return NO;
  455|      0|    }
  456|      0|    FImmutableTree *other = (FImmutableTree *)object;
  457|      0|    return (self.value == other.value || [self.value isEqual:other.value]) &&
  458|      0|           [self.children isEqual:other.children];
  459|      0|}
  460|       |
  461|      0|- (NSUInteger)hash {
  462|      0|    return self.children.hash * 31 + [self.value hash];
  463|      0|}
  464|       |
  465|      0|- (NSString *)description {
  466|      0|    NSMutableString *string = [[NSMutableString alloc] init];
  467|      0|    [string appendString:@"FImmutableTree { value="];
  468|      0|    [string appendString:(self.value ? [self.value description] : @"<nil>")];
  469|      0|    [string appendString:@", children={"];
  470|      0|    [self.children
  471|      0|        enumerateKeysAndObjectsUsingBlock:^(
  472|      0|            NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  473|      0|          [string appendString:@" "];
  474|      0|          [string appendString:childKey];
  475|      0|          [string appendString:@"="];
  476|      0|          [string appendString:[childTree.value description]];
  477|      0|        }];
  478|      0|    [string appendString:@" } }"];
  479|      0|    return [NSString stringWithString:string];
  480|      0|}
  481|       |
  482|      0|- (NSString *)debugDescription {
  483|      0|    return [self description];
  484|      0|}
  485|       |
  486|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Utilities/FPath.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FPath.h"
   18|       |
   19|       |#import "FUtilities.h"
   20|       |
   21|       |@interface FPath ()
   22|       |
   23|       |@property(nonatomic, readwrite, assign) NSInteger pieceNum;
   24|       |@property(nonatomic, strong) NSArray *pieces;
   25|       |
   26|       |@end
   27|       |
   28|       |@implementation FPath
   29|       |
   30|       |#pragma mark -
   31|       |#pragma mark Initializers
   32|       |
   33|      0|+ (FPath *)relativePathFrom:(FPath *)outer to:(FPath *)inner {
   34|      0|    NSString *outerFront = [outer getFront];
   35|      0|    NSString *innerFront = [inner getFront];
   36|      0|    if (outerFront == nil) {
   37|      0|        return inner;
   38|      0|    } else if ([outerFront isEqualToString:innerFront]) {
   39|      0|        return [self relativePathFrom:[outer popFront] to:[inner popFront]];
   40|      0|    } else {
   41|      0|        @throw [[NSException alloc]
   42|      0|            initWithName:@"FirebaseDatabaseInternalError"
   43|      0|                  reason:[NSString
   44|      0|                             stringWithFormat:
   45|      0|                                 @"innerPath (%@) is not within outerPath (%@)",
   46|      0|                                 inner, outer]
   47|      0|                userInfo:nil];
   48|      0|    }
   49|      0|}
   50|       |
   51|      0|+ (FPath *)pathWithString:(NSString *)string {
   52|      0|    return [[FPath alloc] initWith:string];
   53|      0|}
   54|       |
   55|      0|- (id)initWith:(NSString *)path {
   56|      0|    self = [super init];
   57|      0|    if (self) {
   58|      0|        NSArray *pathPieces = [path componentsSeparatedByString:@"/"];
   59|      0|        NSMutableArray *newPieces = [[NSMutableArray alloc] init];
   60|      0|        for (NSInteger i = 0; i < pathPieces.count; i++) {
   61|      0|            NSString *piece = [pathPieces objectAtIndex:i];
   62|      0|            if (piece.length > 0) {
   63|      0|                [newPieces addObject:piece];
   64|      0|            }
   65|      0|        }
   66|      0|
   67|      0|        self.pieces = newPieces;
   68|      0|        self.pieceNum = 0;
   69|      0|    }
   70|      0|    return self;
   71|      0|}
   72|       |
   73|      0|- (id)initWithPieces:(NSArray *)somePieces andPieceNum:(NSInteger)aPieceNum {
   74|      0|    self = [super init];
   75|      0|    if (self) {
   76|      0|        self.pieceNum = aPieceNum;
   77|      0|        self.pieces = somePieces;
   78|      0|    }
   79|      0|    return self;
   80|      0|}
   81|       |
   82|      0|- (id)copyWithZone:(NSZone *)zone {
   83|      0|    // Immutable, so it's safe to return self
   84|      0|    return self;
   85|      0|}
   86|       |
   87|      0|- (NSString *)description {
   88|      0|    return [self toString];
   89|      0|}
   90|       |
   91|       |#pragma mark -
   92|       |#pragma mark Public methods
   93|       |
   94|      0|- (NSString *)getFront {
   95|      0|    if (self.pieceNum >= self.pieces.count) {
   96|      0|        return nil;
   97|      0|    }
   98|      0|    return [self.pieces objectAtIndex:self.pieceNum];
   99|      0|}
  100|       |
  101|       |/**
  102|       | * @return The number of segments in this path
  103|       | */
  104|      0|- (NSUInteger)length {
  105|      0|    return self.pieces.count - self.pieceNum;
  106|      0|}
  107|       |
  108|      0|- (FPath *)popFront {
  109|      0|    NSInteger newPieceNum = self.pieceNum;
  110|      0|    if (newPieceNum < self.pieces.count) {
  111|      0|        newPieceNum++;
  112|      0|    }
  113|      0|    return [[FPath alloc] initWithPieces:self.pieces andPieceNum:newPieceNum];
  114|      0|}
  115|       |
  116|      0|- (NSString *)getBack {
  117|      0|    if (self.pieceNum < self.pieces.count) {
  118|      0|        return [self.pieces lastObject];
  119|      0|    } else {
  120|      0|        return nil;
  121|      0|    }
  122|      0|}
  123|       |
  124|      0|- (NSString *)toString {
  125|      0|    return [self toStringWithTrailingSlash:NO];
  126|      0|}
  127|       |
  128|      0|- (NSString *)toStringWithTrailingSlash {
  129|      0|    return [self toStringWithTrailingSlash:YES];
  130|      0|}
  131|       |
  132|      0|- (NSString *)toStringWithTrailingSlash:(BOOL)trailingSlash {
  133|      0|    NSMutableString *pathString = [[NSMutableString alloc] init];
  134|      0|    for (NSInteger i = self.pieceNum; i < self.pieces.count; i++) {
  135|      0|        [pathString appendString:@"/"];
  136|      0|        [pathString appendString:[self.pieces objectAtIndex:i]];
  137|      0|    }
  138|      0|    if ([pathString length] == 0) {
  139|      0|        return @"/";
  140|      0|    } else {
  141|      0|        if (trailingSlash) {
  142|      0|            [pathString appendString:@"/"];
  143|      0|        }
  144|      0|        return pathString;
  145|      0|    }
  146|      0|}
  147|       |
  148|      0|- (NSString *)wireFormat {
  149|      0|    if ([self isEmpty]) {
  150|      0|        return @"/";
  151|      0|    } else {
  152|      0|        NSMutableString *pathString = [[NSMutableString alloc] init];
  153|      0|        for (NSInteger i = self.pieceNum; i < self.pieces.count; i++) {
  154|      0|            if (i > self.pieceNum) {
  155|      0|                [pathString appendString:@"/"];
  156|      0|            }
  157|      0|            [pathString appendString:[self.pieces objectAtIndex:i]];
  158|      0|        }
  159|      0|        return pathString;
  160|      0|    }
  161|      0|}
  162|       |
  163|      0|- (FPath *)parent {
  164|      0|    if (self.pieceNum >= self.pieces.count) {
  165|      0|        return nil;
  166|      0|    } else {
  167|      0|        NSMutableArray *newPieces = [[NSMutableArray alloc] init];
  168|      0|        for (NSInteger i = self.pieceNum; i < self.pieces.count - 1; i++) {
  169|      0|            [newPieces addObject:[self.pieces objectAtIndex:i]];
  170|      0|        }
  171|      0|        return [[FPath alloc] initWithPieces:newPieces andPieceNum:0];
  172|      0|    }
  173|      0|}
  174|       |
  175|      0|- (FPath *)child:(FPath *)childPathObj {
  176|      0|    NSMutableArray *newPieces = [[NSMutableArray alloc] init];
  177|      0|    for (NSInteger i = self.pieceNum; i < self.pieces.count; i++) {
  178|      0|        [newPieces addObject:[self.pieces objectAtIndex:i]];
  179|      0|    }
  180|      0|
  181|      0|    for (NSInteger i = childPathObj.pieceNum; i < childPathObj.pieces.count;
  182|      0|         i++) {
  183|      0|        [newPieces addObject:[childPathObj.pieces objectAtIndex:i]];
  184|      0|    }
  185|      0|
  186|      0|    return [[FPath alloc] initWithPieces:newPieces andPieceNum:0];
  187|      0|}
  188|       |
  189|      0|- (FPath *)childFromString:(NSString *)childPath {
  190|      0|    NSMutableArray *newPieces = [[NSMutableArray alloc] init];
  191|      0|    for (NSInteger i = self.pieceNum; i < self.pieces.count; i++) {
  192|      0|        [newPieces addObject:[self.pieces objectAtIndex:i]];
  193|      0|    }
  194|      0|
  195|      0|    NSArray *pathPieces = [childPath componentsSeparatedByString:@"/"];
  196|      0|    for (unsigned int i = 0; i < pathPieces.count; i++) {
  197|      0|        NSString *piece = [pathPieces objectAtIndex:i];
  198|      0|        if (piece.length > 0) {
  199|      0|            [newPieces addObject:piece];
  200|      0|        }
  201|      0|    }
  202|      0|
  203|      0|    return [[FPath alloc] initWithPieces:newPieces andPieceNum:0];
  204|      0|}
  205|       |
  206|       |/**
  207|       | * @return True if there are no segments in this path
  208|       | */
  209|      0|- (BOOL)isEmpty {
  210|      0|    return self.pieceNum >= self.pieces.count;
  211|      0|}
  212|       |
  213|       |/**
  214|       | * @return Singleton to represent an empty path
  215|       | */
  216|      0|+ (FPath *)empty {
  217|      0|    static dispatch_once_t oneEmptyPath;
  218|      0|    static FPath *emptyPath;
  219|      0|    dispatch_once(&oneEmptyPath, ^{
  220|      0|      emptyPath = [[FPath alloc] initWith:@""];
  221|      0|    });
  222|      0|    return emptyPath;
  223|      0|}
  224|       |
  225|      0|- (BOOL)contains:(FPath *)other {
  226|      0|    if (self.length > other.length) {
  227|      0|        return NO;
  228|      0|    }
  229|      0|
  230|      0|    NSInteger i = self.pieceNum;
  231|      0|    NSInteger j = other.pieceNum;
  232|      0|    while (i < self.pieces.count) {
  233|      0|        NSString *thisSeg = [self.pieces objectAtIndex:i];
  234|      0|        NSString *otherSeg = [other.pieces objectAtIndex:j];
  235|      0|        if (![thisSeg isEqualToString:otherSeg]) {
  236|      0|            return NO;
  237|      0|        }
  238|      0|        ++i;
  239|      0|        ++j;
  240|      0|    }
  241|      0|    return YES;
  242|      0|}
  243|       |
  244|      0|- (void)enumerateComponentsUsingBlock:(void (^)(NSString *, BOOL *))block {
  245|      0|    BOOL stop = NO;
  246|      0|    for (NSInteger i = self.pieceNum; !stop && i < self.pieces.count; i++) {
  247|      0|        block(self.pieces[i], &stop);
  248|      0|    }
  249|      0|}
  250|       |
  251|      0|- (NSComparisonResult)compare:(FPath *)other {
  252|      0|    NSInteger myCount = self.pieces.count;
  253|      0|    NSInteger otherCount = other.pieces.count;
  254|      0|    for (NSInteger i = self.pieceNum, j = other.pieceNum;
  255|      0|         i < myCount && j < otherCount; i++, j++) {
  256|      0|        NSComparisonResult comparison = [FUtilities compareKey:self.pieces[i]
  257|      0|                                                         toKey:other.pieces[j]];
  258|      0|        if (comparison != NSOrderedSame) {
  259|      0|            return comparison;
  260|      0|        }
  261|      0|    }
  262|      0|    if (self.length < other.length) {
  263|      0|        return NSOrderedAscending;
  264|      0|    } else if (other.length < self.length) {
  265|      0|        return NSOrderedDescending;
  266|      0|    } else {
  267|      0|        NSAssert(self.length == other.length,
  268|      0|                 @"Paths must be the same lengths");
  269|      0|        return NSOrderedSame;
  270|      0|    }
  271|      0|}
  272|       |
  273|       |/**
  274|       | * @return YES if paths are the same
  275|       | */
  276|      0|- (BOOL)isEqual:(id)other {
  277|      0|    if (other == self) {
  278|      0|        return YES;
  279|      0|    }
  280|      0|    if (!other || ![other isKindOfClass:[self class]]) {
  281|      0|        return NO;
  282|      0|    }
  283|      0|    FPath *otherPath = (FPath *)other;
  284|      0|    if (self.length != otherPath.length) {
  285|      0|        return NO;
  286|      0|    }
  287|      0|    for (NSUInteger i = self.pieceNum, j = otherPath.pieceNum;
  288|      0|         i < self.pieces.count; i++, j++) {
  289|      0|        if (![self.pieces[i] isEqualToString:otherPath.pieces[j]]) {
  290|      0|            return NO;
  291|      0|        }
  292|      0|    }
  293|      0|    return YES;
  294|      0|}
  295|       |
  296|      0|- (NSUInteger)hash {
  297|      0|    NSUInteger hashCode = 0;
  298|      0|    for (NSInteger i = self.pieceNum; i < self.pieces.count; i++) {
  299|      0|        hashCode = hashCode * 37 + [self.pieces[i] hash];
  300|      0|    }
  301|      0|    return hashCode;
  302|      0|}
  303|       |
  304|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Utilities/FTree.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTree.h"
   18|       |#import "FPath.h"
   19|       |#import "FTreeNode.h"
   20|       |#import "FUtilities.h"
   21|       |
   22|       |@implementation FTree
   23|       |
   24|       |@synthesize name;
   25|       |@synthesize parent;
   26|       |@synthesize node;
   27|       |
   28|      0|- (id)init {
   29|      0|    self = [super init];
   30|      0|    if (self) {
   31|      0|        self.name = @"";
   32|      0|        self.parent = nil;
   33|      0|        self.node = [[FTreeNode alloc] init];
   34|      0|    }
   35|      0|    return self;
   36|      0|}
   37|       |
   38|       |- (id)initWithName:(NSString *)aName
   39|       |        withParent:(FTree *)aParent
   40|      0|          withNode:(FTreeNode *)aNode {
   41|      0|    self = [super init];
   42|      0|    if (self) {
   43|      0|        self.name = aName != nil ? aName : @"";
   44|      0|        self.parent = aParent != nil ? aParent : nil;
   45|      0|        self.node = aNode != nil ? aNode : [[FTreeNode alloc] init];
   46|      0|    }
   47|      0|    return self;
   48|      0|}
   49|       |
   50|      0|- (FTree *)subTree:(FPath *)path {
   51|      0|    FTree *child = self;
   52|      0|    NSString *next = [path getFront];
   53|      0|    while (next != nil) {
   54|      0|        FTreeNode *childNode = child.node.children[next];
   55|      0|        if (childNode == nil) {
   56|      0|            childNode = [[FTreeNode alloc] init];
   57|      0|        }
   58|      0|        child = [[FTree alloc] initWithName:next
   59|      0|                                 withParent:child
   60|      0|                                   withNode:childNode];
   61|      0|        path = [path popFront];
   62|      0|        next = [path getFront];
   63|      0|    }
   64|      0|    return child;
   65|      0|}
   66|       |
   67|      0|- (id)getValue {
   68|      0|    return self.node.value;
   69|      0|}
   70|       |
   71|      0|- (void)setValue:(id)value {
   72|      0|    self.node.value = value;
   73|      0|    [self updateParents];
   74|      0|}
   75|       |
   76|      0|- (void)clear {
   77|      0|    self.node.value = nil;
   78|      0|    [self.node.children removeAllObjects];
   79|      0|    self.node.childCount = 0;
   80|      0|    [self updateParents];
   81|      0|}
   82|       |
   83|      0|- (BOOL)hasChildren {
   84|      0|    return self.node.childCount > 0;
   85|      0|}
   86|       |
   87|      0|- (BOOL)isEmpty {
   88|      0|    return [self getValue] == nil && ![self hasChildren];
   89|      0|}
   90|       |
   91|      0|- (void)forEachChild:(void (^)(FTree *))action {
   92|      0|    for (NSString *key in self.node.children) {
   93|      0|        action([[FTree alloc]
   94|      0|            initWithName:key
   95|      0|              withParent:self
   96|      0|                withNode:[self.node.children objectForKey:key]]);
   97|      0|    }
   98|      0|}
   99|       |
  100|      0|- (void)forEachChildMutationSafe:(void (^)(FTree *))action {
  101|      0|    for (NSString *key in [self.node.children copy]) {
  102|      0|        action([[FTree alloc]
  103|      0|            initWithName:key
  104|      0|              withParent:self
  105|      0|                withNode:[self.node.children objectForKey:key]]);
  106|      0|    }
  107|      0|}
  108|       |
  109|      0|- (void)forEachDescendant:(void (^)(FTree *))action {
  110|      0|    [self forEachDescendant:action includeSelf:NO childrenFirst:NO];
  111|      0|}
  112|       |
  113|       |- (void)forEachDescendant:(void (^)(FTree *))action
  114|       |              includeSelf:(BOOL)incSelf
  115|      0|            childrenFirst:(BOOL)childFirst {
  116|      0|    if (incSelf && !childFirst) {
  117|      0|        action(self);
  118|      0|    }
  119|      0|
  120|      0|    [self forEachChild:^(FTree *child) {
  121|      0|      [child forEachDescendant:action includeSelf:YES childrenFirst:childFirst];
  122|      0|    }];
  123|      0|
  124|      0|    if (incSelf && childFirst) {
  125|      0|        action(self);
  126|      0|    }
  127|      0|}
  128|       |
  129|      0|- (BOOL)forEachAncestor:(BOOL (^)(FTree *))action {
  130|      0|    return [self forEachAncestor:action includeSelf:NO];
  131|      0|}
  132|       |
  133|      0|- (BOOL)forEachAncestor:(BOOL (^)(FTree *))action includeSelf:(BOOL)incSelf {
  134|      0|    FTree *aNode = (incSelf) ? self : self.parent;
  135|      0|    while (aNode != nil) {
  136|      0|        if (action(aNode)) {
  137|      0|            return YES;
  138|      0|        }
  139|      0|        aNode = aNode.parent;
  140|      0|    }
  141|      0|    return NO;
  142|      0|}
  143|       |
  144|      0|- (void)forEachImmediateDescendantWithValue:(void (^)(FTree *))action {
  145|      0|    [self forEachChild:^(FTree *child) {
  146|      0|      if ([child getValue] != nil) {
  147|      0|          action(child);
  148|      0|      } else {
  149|      0|          [child forEachImmediateDescendantWithValue:action];
  150|      0|      }
  151|      0|    }];
  152|      0|}
  153|       |
  154|      0|- (BOOL)valueExistsAtOrAbove:(FPath *)path {
  155|      0|    FTreeNode *aNode = self.node;
  156|      0|    while (aNode != nil) {
  157|      0|        if (aNode.value != nil) {
  158|      0|            return YES;
  159|      0|        }
  160|      0|        aNode = [aNode.children objectForKey:path.getFront];
  161|      0|        path = [path popFront];
  162|      0|    }
  163|      0|    // XXX Check with Michael if this is correct; deviates from JS.
  164|      0|    return NO;
  165|      0|}
  166|       |
  167|      0|- (FPath *)path {
  168|      0|    return [[FPath alloc]
  169|      0|        initWith:(self.parent == nil)
  170|      0|                     ? self.name
  171|      0|                     : [NSString stringWithFormat:@"%@/%@", [self.parent path],
  172|      0|                                                  self.name]];
  173|      0|}
  174|       |
  175|      0|- (void)updateParents {
  176|      0|    [self.parent updateChild:self.name withNode:self];
  177|      0|}
  178|       |
  179|      0|- (void)updateChild:(NSString *)childName withNode:(FTree *)child {
  180|      0|    BOOL childEmpty = [child isEmpty];
  181|      0|    BOOL childExists = self.node.children[childName] != nil;
  182|      0|    if (childEmpty && childExists) {
  183|      0|        [self.node.children removeObjectForKey:childName];
  184|      0|        self.node.childCount = self.node.childCount - 1;
  185|      0|        [self updateParents];
  186|      0|    } else if (!childEmpty && !childExists) {
  187|      0|        [self.node.children setObject:child.node forKey:childName];
  188|      0|        self.node.childCount = self.node.childCount + 1;
  189|      0|        [self updateParents];
  190|      0|    }
  191|      0|}
  192|       |
  193|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/Utilities/FTreeNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTreeNode.h"
   18|       |
   19|       |@implementation FTreeNode
   20|       |
   21|       |@synthesize children;
   22|       |@synthesize childCount;
   23|       |@synthesize value;
   24|       |
   25|      0|- (id)init {
   26|      0|    self = [super init];
   27|      0|    if (self) {
   28|      0|        self.children = [[NSMutableDictionary alloc] init];
   29|      0|        self.childCount = 0;
   30|      0|        self.value = nil;
   31|      0|    }
   32|      0|    return self;
   33|      0|}
   34|       |
   35|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FCacheNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FCacheNode.h"
   18|       |#import "FEmptyNode.h"
   19|       |#import "FIndexedNode.h"
   20|       |#import "FNode.h"
   21|       |#import "FPath.h"
   22|       |
   23|       |@interface FCacheNode ()
   24|       |@property(nonatomic, readwrite) BOOL isFullyInitialized;
   25|       |@property(nonatomic, readwrite) BOOL isFiltered;
   26|       |@property(nonatomic, strong, readwrite) FIndexedNode *indexedNode;
   27|       |@end
   28|       |
   29|       |@implementation FCacheNode
   30|       |- (id)initWithIndexedNode:(FIndexedNode *)indexedNode
   31|       |       isFullyInitialized:(BOOL)fullyInitialized
   32|      0|               isFiltered:(BOOL)filtered {
   33|      0|    self = [super init];
   34|      0|    if (self) {
   35|      0|        self.indexedNode = indexedNode;
   36|      0|        self.isFullyInitialized = fullyInitialized;
   37|      0|        self.isFiltered = filtered;
   38|      0|    }
   39|      0|    return self;
   40|      0|}
   41|       |
   42|      0|- (BOOL)isCompleteForPath:(FPath *)path {
   43|      0|    if (path.isEmpty) {
   44|      0|        return self.isFullyInitialized && !self.isFiltered;
   45|      0|    } else {
   46|      0|        NSString *childKey = [path getFront];
   47|      0|        return [self isCompleteForChild:childKey];
   48|      0|    }
   49|      0|}
   50|       |
   51|      0|- (BOOL)isCompleteForChild:(NSString *)childKey {
   52|      0|    return (self.isFullyInitialized && !self.isFiltered) ||
   53|      0|           [self.node hasChild:childKey];
   54|      0|}
   55|       |
   56|      0|- (id<FNode>)node {
   57|      0|    return self.indexedNode.node;
   58|      0|}
   59|       |
   60|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FCancelEvent.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FCancelEvent.h"
   18|       |#import "FEventRegistration.h"
   19|       |#import "FPath.h"
   20|       |
   21|       |@interface FCancelEvent ()
   22|       |@property(nonatomic, strong) id<FEventRegistration> eventRegistration;
   23|       |@property(nonatomic, strong, readwrite) NSError *error;
   24|       |@property(nonatomic, strong, readwrite) FPath *path;
   25|       |@end
   26|       |
   27|       |@implementation FCancelEvent
   28|       |
   29|       |@synthesize eventRegistration;
   30|       |@synthesize error;
   31|       |@synthesize path;
   32|       |
   33|       |- (id)initWithEventRegistration:(id<FEventRegistration>)registration
   34|       |                          error:(NSError *)anError
   35|      0|                           path:(FPath *)aPath {
   36|      0|    self = [super init];
   37|      0|    if (self) {
   38|      0|        self.eventRegistration = registration;
   39|      0|        self.error = anError;
   40|      0|        self.path = aPath;
   41|      0|    }
   42|      0|    return self;
   43|      0|}
   44|       |
   45|      0|- (void)fireEventOnQueue:(dispatch_queue_t)queue {
   46|      0|    [self.eventRegistration fireEvent:self queue:queue];
   47|      0|}
   48|       |
   49|      0|- (BOOL)isCancelEvent {
   50|      0|    return YES;
   51|      0|}
   52|       |
   53|      0|- (NSString *)description {
   54|      0|    return [NSString stringWithFormat:@"%@: cancel", self.path];
   55|      0|}
   56|       |
   57|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FChange.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FChange.h"
   18|       |
   19|       |@interface FChange ()
   20|       |
   21|       |@property(nonatomic, strong, readwrite) NSString *prevKey;
   22|       |
   23|       |@end
   24|       |
   25|       |@implementation FChange
   26|       |
   27|       |- (id)initWithType:(FIRDataEventType)type
   28|      0|       indexedNode:(FIndexedNode *)indexedNode {
   29|      0|    return [self initWithType:type
   30|      0|                  indexedNode:indexedNode
   31|      0|                     childKey:nil
   32|      0|               oldIndexedNode:nil];
   33|      0|}
   34|       |
   35|       |- (id)initWithType:(FIRDataEventType)type
   36|       |       indexedNode:(FIndexedNode *)indexedNode
   37|      0|          childKey:(NSString *)childKey {
   38|      0|    return [self initWithType:type
   39|      0|                  indexedNode:indexedNode
   40|      0|                     childKey:childKey
   41|      0|               oldIndexedNode:nil];
   42|      0|}
   43|       |
   44|       |- (id)initWithType:(FIRDataEventType)type
   45|       |       indexedNode:(FIndexedNode *)indexedNode
   46|       |          childKey:(NSString *)childKey
   47|      0|    oldIndexedNode:(FIndexedNode *)oldIndexedNode {
   48|      0|    self = [super init];
   49|      0|    if (self != nil) {
   50|      0|        self->_type = type;
   51|      0|        self->_indexedNode = indexedNode;
   52|      0|        self->_childKey = childKey;
   53|      0|        self->_oldIndexedNode = oldIndexedNode;
   54|      0|    }
   55|      0|    return self;
   56|      0|}
   57|       |
   58|      0|- (FChange *)changeWithPrevKey:(NSString *)prevKey {
   59|      0|    FChange *newChange = [[FChange alloc] initWithType:self.type
   60|      0|                                           indexedNode:self.indexedNode
   61|      0|                                              childKey:self.childKey
   62|      0|                                        oldIndexedNode:self.oldIndexedNode];
   63|      0|    newChange.prevKey = prevKey;
   64|      0|    return newChange;
   65|      0|}
   66|       |
   67|      0|- (NSString *)description {
   68|      0|    return [NSString stringWithFormat:@"event: %d, data: %@", (int)self.type,
   69|      0|                                      [self.indexedNode.node val]];
   70|      0|}
   71|       |
   72|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FChildEventRegistration.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FChildEventRegistration.h"
   18|       |#import "FCancelEvent.h"
   19|       |#import "FDataEvent.h"
   20|       |#import "FIRDataSnapshot_Private.h"
   21|       |#import "FIRDatabaseQuery_Private.h"
   22|       |#import "FQueryParams.h"
   23|       |#import "FQuerySpec.h"
   24|       |#import <FirebaseCore/FIRLogger.h>
   25|       |
   26|       |@interface FChildEventRegistration ()
   27|       |@property(nonatomic, strong) FRepo *repo;
   28|       |@property(nonatomic, copy, readwrite) NSDictionary *callbacks;
   29|       |@property(nonatomic, copy, readwrite) fbt_void_nserror cancelCallback;
   30|       |@property(nonatomic, readwrite) FIRDatabaseHandle handle;
   31|       |@end
   32|       |
   33|       |@implementation FChildEventRegistration
   34|       |
   35|       |- (id)initWithRepo:(id)repo
   36|       |            handle:(FIRDatabaseHandle)fHandle
   37|       |         callbacks:(NSDictionary *)callbackBlocks
   38|      0|    cancelCallback:(fbt_void_nserror)cancelCallbackBlock {
   39|      0|    self = [super init];
   40|      0|    if (self) {
   41|      0|        self.repo = repo;
   42|      0|        self.handle = fHandle;
   43|      0|        self.callbacks = callbackBlocks;
   44|      0|        self.cancelCallback = cancelCallbackBlock;
   45|      0|    }
   46|      0|    return self;
   47|      0|}
   48|       |
   49|      0|- (BOOL)responseTo:(FIRDataEventType)eventType {
   50|      0|    return self.callbacks != nil &&
   51|      0|           [self.callbacks
   52|      0|               objectForKey:[NSNumber numberWithInteger:eventType]] != nil;
   53|      0|}
   54|       |
   55|      0|- (FDataEvent *)createEventFrom:(FChange *)change query:(FQuerySpec *)query {
   56|      0|    FIRDatabaseReference *ref = [[FIRDatabaseReference alloc]
   57|      0|        initWithRepo:self.repo
   58|      0|                path:[query.path childFromString:change.childKey]];
   59|      0|    FIRDataSnapshot *snapshot =
   60|      0|        [[FIRDataSnapshot alloc] initWithRef:ref
   61|      0|                                 indexedNode:change.indexedNode];
   62|      0|
   63|      0|    FDataEvent *eventData =
   64|      0|        [[FDataEvent alloc] initWithEventType:change.type
   65|      0|                            eventRegistration:self
   66|      0|                                 dataSnapshot:snapshot
   67|      0|                                     prevName:change.prevKey];
   68|      0|    return eventData;
   69|      0|}
   70|       |
   71|      0|- (void)fireEvent:(id<FEvent>)event queue:(dispatch_queue_t)queue {
   72|      0|    if ([event isCancelEvent]) {
   73|      0|        FCancelEvent *cancelEvent = event;
   74|      0|        FFLog(@"I-RDB061001", @"Raising cancel value event on %@", event.path);
   75|      0|        NSAssert(
   76|      0|            self.cancelCallback != nil,
   77|      0|            @"Raising a cancel event on a listener with no cancel callback");
   78|      0|        dispatch_async(queue, ^{
   79|      0|          self.cancelCallback(cancelEvent.error);
   80|      0|        });
   81|      0|    } else if (self.callbacks != nil) {
   82|      0|        FDataEvent *dataEvent = event;
   83|      0|        FFLog(@"I-RDB061002", @"Raising event callback (%ld) on %@",
   84|      0|              (long)dataEvent.eventType, dataEvent.path);
   85|      0|        fbt_void_datasnapshot_nsstring callback = [self.callbacks
   86|      0|            objectForKey:[NSNumber numberWithInteger:dataEvent.eventType]];
   87|      0|
   88|      0|        if (callback != nil) {
   89|      0|            dispatch_async(queue, ^{
   90|      0|              callback(dataEvent.snapshot, dataEvent.prevName);
   91|      0|            });
   92|      0|        }
   93|      0|    }
   94|      0|}
   95|       |
   96|       |- (FCancelEvent *)createCancelEventFromError:(NSError *)error
   97|      0|                                        path:(FPath *)path {
   98|      0|    if (self.cancelCallback != nil) {
   99|      0|        return [[FCancelEvent alloc] initWithEventRegistration:self
  100|      0|                                                         error:error
  101|      0|                                                          path:path];
  102|      0|    } else {
  103|      0|        return nil;
  104|      0|    }
  105|      0|}
  106|       |
  107|      0|- (BOOL)matches:(id<FEventRegistration>)other {
  108|      0|    return self.handle == NSNotFound || other.handle == NSNotFound ||
  109|      0|           self.handle == other.handle;
  110|      0|}
  111|       |
  112|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FDataEvent.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FDataEvent.h"
   18|       |#import "FEventRegistration.h"
   19|       |#import "FIRDatabaseQuery_Private.h"
   20|       |#import "FIndex.h"
   21|       |
   22|       |@interface FDataEvent ()
   23|       |@property(nonatomic, strong, readwrite) id<FEventRegistration>
   24|       |    eventRegistration;
   25|       |@property(nonatomic, strong, readwrite) FIRDataSnapshot *snapshot;
   26|       |@property(nonatomic, strong, readwrite) NSString *prevName;
   27|       |@property(nonatomic, readwrite) FIRDataEventType eventType;
   28|       |@end
   29|       |
   30|       |@implementation FDataEvent
   31|       |
   32|       |@synthesize eventRegistration;
   33|       |@synthesize snapshot;
   34|       |@synthesize prevName;
   35|       |@synthesize eventType;
   36|       |
   37|       |- (id)initWithEventType:(FIRDataEventType)type
   38|       |      eventRegistration:(id<FEventRegistration>)registration
   39|      0|           dataSnapshot:(FIRDataSnapshot *)dataSnapshot {
   40|      0|    return [self initWithEventType:type
   41|      0|                 eventRegistration:registration
   42|      0|                      dataSnapshot:dataSnapshot
   43|      0|                          prevName:nil];
   44|      0|}
   45|       |
   46|       |- (id)initWithEventType:(FIRDataEventType)type
   47|       |      eventRegistration:(id<FEventRegistration>)registration
   48|       |           dataSnapshot:(FIRDataSnapshot *)dataSnapshot
   49|      0|               prevName:(NSString *)previousName {
   50|      0|    self = [super init];
   51|      0|    if (self) {
   52|      0|        self.eventRegistration = registration;
   53|      0|        self.snapshot = dataSnapshot;
   54|      0|        self.prevName = previousName;
   55|      0|        self.eventType = type;
   56|      0|    }
   57|      0|    return self;
   58|      0|}
   59|       |
   60|      0|- (FPath *)path {
   61|      0|    // Used for logging, so delay calculation
   62|      0|    FIRDatabaseReference *ref = self.snapshot.ref;
   63|      0|    if (self.eventType == FIRDataEventTypeValue) {
   64|      0|        return ref.path;
   65|      0|    } else {
   66|      0|        return ref.parent.path;
   67|      0|    }
   68|      0|}
   69|       |
   70|      0|- (void)fireEventOnQueue:(dispatch_queue_t)queue {
   71|      0|    [self.eventRegistration fireEvent:self queue:queue];
   72|      0|}
   73|       |
   74|      0|- (BOOL)isCancelEvent {
   75|      0|    return NO;
   76|      0|}
   77|       |
   78|      0|- (NSString *)description {
   79|      0|    return [NSString stringWithFormat:@"event %d, data: %@", (int)eventType,
   80|      0|                                      [snapshot value]];
   81|      0|}
   82|       |
   83|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FEventRaiser.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FEventRaiser.h"
   18|       |#import "FDataEvent.h"
   19|       |#import "FRepo.h"
   20|       |#import "FRepoManager.h"
   21|       |#import "FTupleUserCallback.h"
   22|       |#import "FTypedefs.h"
   23|       |#import "FUtilities.h"
   24|       |
   25|       |@interface FEventRaiser ()
   26|       |
   27|       |@property(nonatomic, strong) dispatch_queue_t queue;
   28|       |
   29|       |@end
   30|       |
   31|       |/**
   32|       | * This class exists for symmetry with other clients, but since events are
   33|       | * async, we don't need to do the complicated stuff the JS client does to
   34|       | * preserve event order.
   35|       | */
   36|       |@implementation FEventRaiser
   37|       |
   38|      0|- (id)init {
   39|      0|    [NSException raise:NSInternalInconsistencyException
   40|      0|                format:@"Can't use default constructor"];
   41|      0|    return nil;
   42|      0|}
   43|       |
   44|      0|- (id)initWithQueue:(dispatch_queue_t)queue {
   45|      0|    self = [super init];
   46|      0|    if (self != nil) {
   47|      0|        self->_queue = queue;
   48|      0|    }
   49|      0|    return self;
   50|      0|}
   51|       |
   52|      0|- (void)raiseEvents:(NSArray *)eventDataList {
   53|      0|    for (id<FEvent> event in eventDataList) {
   54|      0|        [event fireEventOnQueue:self.queue];
   55|      0|    }
   56|      0|}
   57|       |
   58|      0|- (void)raiseCallback:(fbt_void_void)callback {
   59|      0|    dispatch_async(self.queue, callback);
   60|      0|}
   61|       |
   62|      0|- (void)raiseCallbacks:(NSArray *)callbackList {
   63|      0|    for (fbt_void_void callback in callbackList) {
   64|      0|        dispatch_async(self.queue, callback);
   65|      0|    }
   66|      0|}
   67|       |
   68|      0|+ (void)raiseCallbacks:(NSArray *)callbackList queue:(dispatch_queue_t)queue {
   69|      0|    for (fbt_void_void callback in callbackList) {
   70|      0|        dispatch_async(queue, callback);
   71|      0|    }
   72|      0|}
   73|       |
   74|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FKeepSyncedEventRegistration.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FKeepSyncedEventRegistration.h"
   18|       |
   19|       |@interface FKeepSyncedEventRegistration ()
   20|       |
   21|       |@end
   22|       |
   23|       |@implementation FKeepSyncedEventRegistration
   24|       |
   25|      0|+ (FKeepSyncedEventRegistration *)instance {
   26|      0|    static dispatch_once_t onceToken;
   27|      0|    static FKeepSyncedEventRegistration *keepSynced;
   28|      0|    dispatch_once(&onceToken, ^{
   29|      0|      keepSynced = [[FKeepSyncedEventRegistration alloc] init];
   30|      0|    });
   31|      0|    return keepSynced;
   32|      0|}
   33|       |
   34|      0|- (BOOL)responseTo:(FIRDataEventType)eventType {
   35|      0|    return NO;
   36|      0|}
   37|       |
   38|      0|- (FDataEvent *)createEventFrom:(FChange *)change query:(FQuerySpec *)query {
   39|      0|    [NSException
   40|      0|         raise:NSInternalInconsistencyException
   41|      0|        format:@"Should never create event for FKeepSyncedEventRegistration"];
   42|      0|    return nil;
   43|      0|}
   44|       |
   45|      0|- (void)fireEvent:(id<FEvent>)event queue:(dispatch_queue_t)queue {
   46|      0|    [NSException
   47|      0|         raise:NSInternalInconsistencyException
   48|      0|        format:@"Should never raise event for FKeepSyncedEventRegistration"];
   49|      0|}
   50|       |
   51|       |- (FCancelEvent *)createCancelEventFromError:(NSError *)error
   52|      0|                                        path:(FPath *)path {
   53|      0|    // Don't create cancel events....
   54|      0|    return nil;
   55|      0|}
   56|       |
   57|      0|- (FIRDatabaseHandle)handle {
   58|      0|    // TODO[offline]: returning arbitray, can't return NSNotFound since that is
   59|      0|    // used to match other event registrations We should really redo this to
   60|      0|    // match on different kind of events (single observer, all observers,
   61|      0|    // cancelled) rather than on a NSNotFound handle...
   62|      0|    return NSNotFound - 1;
   63|      0|}
   64|       |
   65|      0|- (BOOL)matches:(id<FEventRegistration>)other {
   66|      0|    // Only matches singleton instance
   67|      0|    return self == other;
   68|      0|}
   69|       |
   70|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FValueEventRegistration.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FValueEventRegistration.h"
   18|       |#import "FCancelEvent.h"
   19|       |#import "FDataEvent.h"
   20|       |#import "FIRDataSnapshot_Private.h"
   21|       |#import "FIRDatabaseQuery_Private.h"
   22|       |#import "FQueryParams.h"
   23|       |#import "FQuerySpec.h"
   24|       |#import <FirebaseCore/FIRLogger.h>
   25|       |
   26|       |@interface FValueEventRegistration ()
   27|       |@property(nonatomic, strong) FRepo *repo;
   28|       |@property(nonatomic, copy, readwrite) fbt_void_datasnapshot callback;
   29|       |@property(nonatomic, copy, readwrite) fbt_void_nserror cancelCallback;
   30|       |@property(nonatomic, readwrite) FIRDatabaseHandle handle;
   31|       |@end
   32|       |
   33|       |@implementation FValueEventRegistration
   34|       |
   35|       |- (id)initWithRepo:(FRepo *)repo
   36|       |            handle:(FIRDatabaseHandle)fHandle
   37|       |          callback:(fbt_void_datasnapshot)callbackBlock
   38|      0|    cancelCallback:(fbt_void_nserror)cancelCallbackBlock {
   39|      0|    self = [super init];
   40|      0|    if (self) {
   41|      0|        self.repo = repo;
   42|      0|        self.handle = fHandle;
   43|      0|        self.callback = callbackBlock;
   44|      0|        self.cancelCallback = cancelCallbackBlock;
   45|      0|    }
   46|      0|    return self;
   47|      0|}
   48|       |
   49|      0|- (BOOL)responseTo:(FIRDataEventType)eventType {
   50|      0|    return eventType == FIRDataEventTypeValue;
   51|      0|}
   52|       |
   53|      0|- (FDataEvent *)createEventFrom:(FChange *)change query:(FQuerySpec *)query {
   54|      0|    FIRDatabaseReference *ref =
   55|      0|        [[FIRDatabaseReference alloc] initWithRepo:self.repo path:query.path];
   56|      0|    FIRDataSnapshot *snapshot =
   57|      0|        [[FIRDataSnapshot alloc] initWithRef:ref
   58|      0|                                 indexedNode:change.indexedNode];
   59|      0|    FDataEvent *eventData =
   60|      0|        [[FDataEvent alloc] initWithEventType:FIRDataEventTypeValue
   61|      0|                            eventRegistration:self
   62|      0|                                 dataSnapshot:snapshot];
   63|      0|    return eventData;
   64|      0|}
   65|       |
   66|      0|- (void)fireEvent:(id<FEvent>)event queue:(dispatch_queue_t)queue {
   67|      0|    if ([event isCancelEvent]) {
   68|      0|        FCancelEvent *cancelEvent = event;
   69|      0|        FFLog(@"I-RDB065001", @"Raising cancel value event on %@", event.path);
   70|      0|        NSAssert(
   71|      0|            self.cancelCallback != nil,
   72|      0|            @"Raising a cancel event on a listener with no cancel callback");
   73|      0|        dispatch_async(queue, ^{
   74|      0|          self.cancelCallback(cancelEvent.error);
   75|      0|        });
   76|      0|    } else if (self.callback != nil) {
   77|      0|        FDataEvent *dataEvent = event;
   78|      0|        FFLog(@"I-RDB065002", @"Raising value event on %@",
   79|      0|              dataEvent.snapshot.key);
   80|      0|        dispatch_async(queue, ^{
   81|      0|          self.callback(dataEvent.snapshot);
   82|      0|        });
   83|      0|    }
   84|      0|}
   85|       |
   86|       |- (FCancelEvent *)createCancelEventFromError:(NSError *)error
   87|      0|                                        path:(FPath *)path {
   88|      0|    if (self.cancelCallback != nil) {
   89|      0|        return [[FCancelEvent alloc] initWithEventRegistration:self
   90|      0|                                                         error:error
   91|      0|                                                          path:path];
   92|      0|    } else {
   93|      0|        return nil;
   94|      0|    }
   95|      0|}
   96|       |
   97|      0|- (BOOL)matches:(id<FEventRegistration>)other {
   98|      0|    return self.handle == NSNotFound || other.handle == NSNotFound ||
   99|      0|           self.handle == other.handle;
  100|      0|}
  101|       |
  102|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FView.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FView.h"
   18|       |#import "FCacheNode.h"
   19|       |#import "FCancelEvent.h"
   20|       |#import "FEmptyNode.h"
   21|       |#import "FEventGenerator.h"
   22|       |#import "FEventRegistration.h"
   23|       |#import "FIRDatabaseQuery.h"
   24|       |#import "FIRDatabaseQuery_Private.h"
   25|       |#import "FIndexedFilter.h"
   26|       |#import "FIndexedNode.h"
   27|       |#import "FNode.h"
   28|       |#import "FOperation.h"
   29|       |#import "FOperationSource.h"
   30|       |#import "FPath.h"
   31|       |#import "FQueryParams.h"
   32|       |#import "FQuerySpec.h"
   33|       |#import "FViewCache.h"
   34|       |#import "FViewProcessor.h"
   35|       |#import "FViewProcessorResult.h"
   36|       |#import "FWriteTreeRef.h"
   37|       |
   38|       |@interface FViewOperationResult ()
   39|       |
   40|       |@property(nonatomic, strong, readwrite) NSArray *changes;
   41|       |@property(nonatomic, strong, readwrite) NSArray *events;
   42|       |
   43|       |@end
   44|       |
   45|       |@implementation FViewOperationResult
   46|       |
   47|      0|- (id)initWithChanges:(NSArray *)changes events:(NSArray *)events {
   48|      0|    self = [super init];
   49|      0|    if (self != nil) {
   50|      0|        self->_changes = changes;
   51|      0|        self->_events = events;
   52|      0|    }
   53|      0|    return self;
   54|      0|}
   55|       |
   56|       |@end
   57|       |
   58|       |/**
   59|       | * A view represents a specific location and query that has 1 or more event
   60|       | * registrations.
   61|       | *
   62|       | * It does several things:
   63|       | * - Maintains the list of event registration for this location/query.
   64|       | * - Maintains a cache of the data visible for this location/query.
   65|       | * - Applies new operations (via applyOperation), updates the cache, and based
   66|       | * on the event registrations returns the set of events to be raised.
   67|       | */
   68|       |@interface FView ()
   69|       |
   70|       |@property(nonatomic, strong, readwrite) FQuerySpec *query;
   71|       |@property(nonatomic, strong) FViewProcessor *processor;
   72|       |@property(nonatomic, strong) FViewCache *viewCache;
   73|       |@property(nonatomic, strong) NSMutableArray *eventRegistrations;
   74|       |@property(nonatomic, strong) FEventGenerator *eventGenerator;
   75|       |
   76|       |@end
   77|       |
   78|       |@implementation FView
   79|       |- (id)initWithQuery:(FQuerySpec *)query
   80|      0|    initialViewCache:(FViewCache *)initialViewCache {
   81|      0|    self = [super init];
   82|      0|    if (self) {
   83|      0|        self.query = query;
   84|      0|
   85|      0|        FIndexedFilter *indexFilter =
   86|      0|            [[FIndexedFilter alloc] initWithIndex:query.index];
   87|      0|        id<FNodeFilter> filter = query.params.nodeFilter;
   88|      0|        self.processor = [[FViewProcessor alloc] initWithFilter:filter];
   89|      0|        FCacheNode *initialServerCache = initialViewCache.cachedServerSnap;
   90|      0|        FCacheNode *initialEventCache = initialViewCache.cachedEventSnap;
   91|      0|
   92|      0|        // Don't filter server node with other filter than index, wait for
   93|      0|        // tagged listen
   94|      0|        FIndexedNode *emptyIndexedNode =
   95|      0|            [FIndexedNode indexedNodeWithNode:[FEmptyNode emptyNode]
   96|      0|                                        index:query.index];
   97|      0|        FIndexedNode *serverSnap =
   98|      0|            [indexFilter updateFullNode:emptyIndexedNode
   99|      0|                            withNewNode:initialServerCache.indexedNode
  100|      0|                            accumulator:nil];
  101|      0|        FIndexedNode *eventSnap =
  102|      0|            [filter updateFullNode:emptyIndexedNode
  103|      0|                       withNewNode:initialEventCache.indexedNode
  104|      0|                       accumulator:nil];
  105|      0|        FCacheNode *newServerCache = [[FCacheNode alloc]
  106|      0|            initWithIndexedNode:serverSnap
  107|      0|             isFullyInitialized:initialServerCache.isFullyInitialized
  108|      0|                     isFiltered:indexFilter.filtersNodes];
  109|      0|        FCacheNode *newEventCache = [[FCacheNode alloc]
  110|      0|            initWithIndexedNode:eventSnap
  111|      0|             isFullyInitialized:initialEventCache.isFullyInitialized
  112|      0|                     isFiltered:filter.filtersNodes];
  113|      0|
  114|      0|        self.viewCache = [[FViewCache alloc] initWithEventCache:newEventCache
  115|      0|                                                    serverCache:newServerCache];
  116|      0|
  117|      0|        self.eventRegistrations = [[NSMutableArray alloc] init];
  118|      0|
  119|      0|        self.eventGenerator = [[FEventGenerator alloc] initWithQuery:query];
  120|      0|    }
  121|      0|
  122|      0|    return self;
  123|      0|}
  124|       |
  125|      0|- (id<FNode>)serverCache {
  126|      0|    return self.viewCache.cachedServerSnap.node;
  127|      0|}
  128|       |
  129|      0|- (id<FNode>)eventCache {
  130|      0|    return self.viewCache.cachedEventSnap.node;
  131|      0|}
  132|       |
  133|      0|- (id<FNode>)completeServerCacheFor:(FPath *)path {
  134|      0|    id<FNode> cache = self.viewCache.completeServerSnap;
  135|      0|    if (cache) {
  136|      0|        // If this isn't a "loadsAllData" view, then cache isn't actually a
  137|      0|        // complete cache and we need to see if it contains the child we're
  138|      0|        // interested in.
  139|      0|        if ([self.query loadsAllData] ||
  140|      0|            (!path.isEmpty &&
  141|      0|             ![cache getImmediateChild:path.getFront].isEmpty)) {
  142|      0|            return [cache getChild:path];
  143|      0|        }
  144|      0|    }
  145|      0|    return nil;
  146|      0|}
  147|       |
  148|      0|- (BOOL)isEmpty {
  149|      0|    return self.eventRegistrations.count == 0;
  150|      0|}
  151|       |
  152|      0|- (void)addEventRegistration:(id<FEventRegistration>)eventRegistration {
  153|      0|    [self.eventRegistrations addObject:eventRegistration];
  154|      0|}
  155|       |
  156|       |/**
  157|       | * @param eventRegistration If null, remove all callbacks.
  158|       | * @param cancelError If a cancelError is provided, appropriate cancel events
  159|       | * will be returned.
  160|       | * @return Cancel events, if cancelError was provided.
  161|       | */
  162|       |- (NSArray *)removeEventRegistration:(id<FEventRegistration>)eventRegistration
  163|      0|                         cancelError:(NSError *)cancelError {
  164|      0|    NSMutableArray *cancelEvents = [[NSMutableArray alloc] init];
  165|      0|    if (cancelError != nil) {
  166|      0|        NSAssert(eventRegistration == nil,
  167|      0|                 @"A cancel should cancel all event registrations.");
  168|      0|        FPath *path = self.query.path;
  169|      0|        for (id<FEventRegistration> registration in self.eventRegistrations) {
  170|      0|            FCancelEvent *maybeEvent =
  171|      0|                [registration createCancelEventFromError:cancelError path:path];
  172|      0|            if (maybeEvent) {
  173|      0|                [cancelEvents addObject:maybeEvent];
  174|      0|            }
  175|      0|        }
  176|      0|    }
  177|      0|
  178|      0|    if (eventRegistration) {
  179|      0|        NSUInteger i = 0;
  180|      0|        while (i < self.eventRegistrations.count) {
  181|      0|            id<FEventRegistration> existing = self.eventRegistrations[i];
  182|      0|            if ([existing matches:eventRegistration]) {
  183|      0|                [self.eventRegistrations removeObjectAtIndex:i];
  184|      0|            } else {
  185|      0|                i++;
  186|      0|            }
  187|      0|        }
  188|      0|    } else {
  189|      0|        [self.eventRegistrations removeAllObjects];
  190|      0|    }
  191|      0|    return cancelEvents;
  192|      0|}
  193|       |
  194|       |/**
  195|       | * Applies the given Operation, updates our cache, and returns the appropriate
  196|       | * events and changes
  197|       | */
  198|       |- (FViewOperationResult *)applyOperation:(id<FOperation>)operation
  199|       |                             writesCache:(FWriteTreeRef *)writesCache
  200|      0|                             serverCache:(id<FNode>)optCompleteServerCache {
  201|      0|    if (operation.type == FOperationTypeMerge &&
  202|      0|        operation.source.queryParams != nil) {
  203|      0|        NSAssert(self.viewCache.completeServerSnap != nil,
  204|      0|                 @"We should always have a full cache before handling merges");
  205|      0|        NSAssert(self.viewCache.completeEventSnap != nil,
  206|      0|                 @"Missing event cache, even though we have a server cache");
  207|      0|    }
  208|      0|    FViewCache *oldViewCache = self.viewCache;
  209|      0|    FViewProcessorResult *result =
  210|      0|        [self.processor applyOperationOn:oldViewCache
  211|      0|                               operation:operation
  212|      0|                             writesCache:writesCache
  213|      0|                           completeCache:optCompleteServerCache];
  214|      0|
  215|      0|    NSAssert(result.viewCache.cachedServerSnap.isFullyInitialized ||
  216|      0|                 !oldViewCache.cachedServerSnap.isFullyInitialized,
  217|      0|             @"Once a server snap is complete, it should never go back.");
  218|      0|
  219|      0|    self.viewCache = result.viewCache;
  220|      0|    NSArray *events = [self
  221|      0|        generateEventsForChanges:result.changes
  222|      0|                      eventCache:result.viewCache.cachedEventSnap.indexedNode
  223|      0|                    registration:nil];
  224|      0|    return [[FViewOperationResult alloc] initWithChanges:result.changes
  225|      0|                                                  events:events];
  226|      0|}
  227|       |
  228|      0|- (NSArray *)initialEvents:(id<FEventRegistration>)registration {
  229|      0|    FCacheNode *eventSnap = self.viewCache.cachedEventSnap;
  230|      0|    NSMutableArray *initialChanges = [[NSMutableArray alloc] init];
  231|      0|    [eventSnap.indexedNode.node enumerateChildrenUsingBlock:^(
  232|      0|                                    NSString *key, id<FNode> node, BOOL *stop) {
  233|      0|      FIndexedNode *indexed = [FIndexedNode indexedNodeWithNode:node];
  234|      0|      FChange *change = [[FChange alloc] initWithType:FIRDataEventTypeChildAdded
  235|      0|                                          indexedNode:indexed
  236|      0|                                             childKey:key];
  237|      0|      [initialChanges addObject:change];
  238|      0|    }];
  239|      0|    if (eventSnap.isFullyInitialized) {
  240|      0|        FChange *change = [[FChange alloc] initWithType:FIRDataEventTypeValue
  241|      0|                                            indexedNode:eventSnap.indexedNode];
  242|      0|        [initialChanges addObject:change];
  243|      0|    }
  244|      0|    return [self generateEventsForChanges:initialChanges
  245|      0|                               eventCache:eventSnap.indexedNode
  246|      0|                             registration:registration];
  247|      0|}
  248|       |
  249|       |- (NSArray *)generateEventsForChanges:(NSArray *)changes
  250|       |                           eventCache:(FIndexedNode *)eventCache
  251|      0|                         registration:(id<FEventRegistration>)registration {
  252|      0|    NSArray *registrations;
  253|      0|    if (registration == nil) {
  254|      0|        registrations = [[NSArray alloc] initWithArray:self.eventRegistrations];
  255|      0|    } else {
  256|      0|        registrations = [[NSArray alloc] initWithObjects:registration, nil];
  257|      0|    }
  258|      0|    return [self.eventGenerator generateEventsForChanges:changes
  259|      0|                                              eventCache:eventCache
  260|      0|                                      eventRegistrations:registrations];
  261|      0|}
  262|       |
  263|      0|- (NSString *)description {
  264|      0|    return [NSString stringWithFormat:@"FView (%@)", self.query];
  265|      0|}
  266|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/FViewCache.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FViewCache.h"
   18|       |#import "FCacheNode.h"
   19|       |#import "FEmptyNode.h"
   20|       |#import "FNode.h"
   21|       |
   22|       |@interface FViewCache ()
   23|       |@property(nonatomic, strong, readwrite) FCacheNode *cachedEventSnap;
   24|       |@property(nonatomic, strong, readwrite) FCacheNode *cachedServerSnap;
   25|       |@end
   26|       |
   27|       |@implementation FViewCache
   28|       |
   29|       |- (id)initWithEventCache:(FCacheNode *)eventCache
   30|      0|             serverCache:(FCacheNode *)serverCache {
   31|      0|    self = [super init];
   32|      0|    if (self) {
   33|      0|        self.cachedEventSnap = eventCache;
   34|      0|        self.cachedServerSnap = serverCache;
   35|      0|    }
   36|      0|    return self;
   37|      0|}
   38|       |
   39|       |- (FViewCache *)updateEventSnap:(FIndexedNode *)eventSnap
   40|       |                     isComplete:(BOOL)complete
   41|      0|                     isFiltered:(BOOL)filtered {
   42|      0|    FCacheNode *updatedEventCache =
   43|      0|        [[FCacheNode alloc] initWithIndexedNode:eventSnap
   44|      0|                             isFullyInitialized:complete
   45|      0|                                     isFiltered:filtered];
   46|      0|    return [[FViewCache alloc] initWithEventCache:updatedEventCache
   47|      0|                                      serverCache:self.cachedServerSnap];
   48|      0|}
   49|       |
   50|       |- (FViewCache *)updateServerSnap:(FIndexedNode *)serverSnap
   51|       |                      isComplete:(BOOL)complete
   52|      0|                      isFiltered:(BOOL)filtered {
   53|      0|    FCacheNode *updatedServerCache =
   54|      0|        [[FCacheNode alloc] initWithIndexedNode:serverSnap
   55|      0|                             isFullyInitialized:complete
   56|      0|                                     isFiltered:filtered];
   57|      0|    return [[FViewCache alloc] initWithEventCache:self.cachedEventSnap
   58|      0|                                      serverCache:updatedServerCache];
   59|      0|}
   60|       |
   61|      0|- (id<FNode>)completeEventSnap {
   62|      0|    return (self.cachedEventSnap.isFullyInitialized) ? self.cachedEventSnap.node
   63|      0|                                                     : nil;
   64|      0|}
   65|       |
   66|      0|- (id<FNode>)completeServerSnap {
   67|      0|    return (self.cachedServerSnap.isFullyInitialized)
   68|      0|               ? self.cachedServerSnap.node
   69|      0|               : nil;
   70|      0|}
   71|       |
   72|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/Filter/FChildChangeAccumulator.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FChildChangeAccumulator.h"
   18|       |#import "FChange.h"
   19|       |#import "FIndex.h"
   20|       |
   21|       |@interface FChildChangeAccumulator ()
   22|       |@property(nonatomic, strong) NSMutableDictionary *changeMap;
   23|       |@end
   24|       |
   25|       |@implementation FChildChangeAccumulator
   26|       |
   27|      0|- (id)init {
   28|      0|    self = [super init];
   29|      0|    if (self) {
   30|      0|        self.changeMap = [[NSMutableDictionary alloc] init];
   31|      0|    }
   32|      0|    return self;
   33|      0|}
   34|       |
   35|      0|- (void)trackChildChange:(FChange *)change {
   36|      0|    FIRDataEventType type = change.type;
   37|      0|    NSString *childKey = change.childKey;
   38|      0|    NSAssert(type == FIRDataEventTypeChildAdded ||
   39|      0|                 type == FIRDataEventTypeChildChanged ||
   40|      0|                 type == FIRDataEventTypeChildRemoved,
   41|      0|             @"Only child changes supported for tracking.");
   42|      0|    NSAssert(![change.childKey isEqualToString:@".priority"],
   43|      0|             @"Changes not tracked on priority");
   44|      0|    if (self.changeMap[childKey] != nil) {
   45|      0|        FChange *oldChange = [self.changeMap objectForKey:childKey];
   46|      0|        FIRDataEventType oldType = oldChange.type;
   47|      0|        if (type == FIRDataEventTypeChildAdded &&
   48|      0|            oldType == FIRDataEventTypeChildRemoved) {
   49|      0|            FChange *newChange =
   50|      0|                [[FChange alloc] initWithType:FIRDataEventTypeChildChanged
   51|      0|                                  indexedNode:change.indexedNode
   52|      0|                                     childKey:childKey
   53|      0|                               oldIndexedNode:oldChange.indexedNode];
   54|      0|            [self.changeMap setObject:newChange forKey:childKey];
   55|      0|        } else if (type == FIRDataEventTypeChildRemoved &&
   56|      0|                   oldType == FIRDataEventTypeChildAdded) {
   57|      0|            [self.changeMap removeObjectForKey:childKey];
   58|      0|        } else if (type == FIRDataEventTypeChildRemoved &&
   59|      0|                   oldType == FIRDataEventTypeChildChanged) {
   60|      0|            FChange *newChange =
   61|      0|                [[FChange alloc] initWithType:FIRDataEventTypeChildRemoved
   62|      0|                                  indexedNode:oldChange.oldIndexedNode
   63|      0|                                     childKey:childKey];
   64|      0|            [self.changeMap setObject:newChange forKey:childKey];
   65|      0|        } else if (type == FIRDataEventTypeChildChanged &&
   66|      0|                   oldType == FIRDataEventTypeChildAdded) {
   67|      0|            FChange *newChange =
   68|      0|                [[FChange alloc] initWithType:FIRDataEventTypeChildAdded
   69|      0|                                  indexedNode:change.indexedNode
   70|      0|                                     childKey:childKey];
   71|      0|            [self.changeMap setObject:newChange forKey:childKey];
   72|      0|        } else if (type == FIRDataEventTypeChildChanged &&
   73|      0|                   oldType == FIRDataEventTypeChildChanged) {
   74|      0|            FChange *newChange =
   75|      0|                [[FChange alloc] initWithType:FIRDataEventTypeChildChanged
   76|      0|                                  indexedNode:change.indexedNode
   77|      0|                                     childKey:childKey
   78|      0|                               oldIndexedNode:oldChange.oldIndexedNode];
   79|      0|            [self.changeMap setObject:newChange forKey:childKey];
   80|      0|        } else {
   81|      0|            NSString *reason = [NSString
   82|      0|                stringWithFormat:
   83|      0|                    @"Illegal combination of changes: %@ occurred after %@",
   84|      0|                    change, oldChange];
   85|      0|            @throw [[NSException alloc]
   86|      0|                initWithName:@"FirebaseDatabaseInternalError"
   87|      0|                      reason:reason
   88|      0|                    userInfo:nil];
   89|      0|        }
   90|      0|    } else {
   91|      0|        [self.changeMap setObject:change forKey:childKey];
   92|      0|    }
   93|      0|}
   94|       |
   95|      0|- (NSArray *)changes {
   96|      0|    return [self.changeMap allValues];
   97|      0|}
   98|       |
   99|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/Filter/FIndexedFilter.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIndexedFilter.h"
   18|       |#import "FChange.h"
   19|       |#import "FChildChangeAccumulator.h"
   20|       |#import "FChildrenNode.h"
   21|       |#import "FEmptyNode.h"
   22|       |#import "FIndex.h"
   23|       |#import "FIndexedNode.h"
   24|       |#import "FKeyIndex.h"
   25|       |#import "FNode.h"
   26|       |
   27|       |@interface FIndexedFilter ()
   28|       |@property(nonatomic, strong, readwrite) id<FIndex> index;
   29|       |@end
   30|       |
   31|       |@implementation FIndexedFilter
   32|      0|- (id)initWithIndex:(id<FIndex>)theIndex {
   33|      0|    self = [super init];
   34|      0|    if (self) {
   35|      0|        self.index = theIndex;
   36|      0|    }
   37|      0|    return self;
   38|      0|}
   39|       |
   40|       |- (FIndexedNode *)updateChildIn:(FIndexedNode *)indexedNode
   41|       |                    forChildKey:(NSString *)childKey
   42|       |                       newChild:(id<FNode>)newChildSnap
   43|       |                   affectedPath:(FPath *)affectedPath
   44|       |                     fromSource:(id<FCompleteChildSource>)source
   45|       |                    accumulator:
   46|      0|                        (FChildChangeAccumulator *)optChangeAccumulator {
   47|      0|    NSAssert([indexedNode hasIndex:self.index],
   48|      0|             @"The index in FIndexedNode must match the index of the filter");
   49|      0|    id<FNode> node = indexedNode.node;
   50|      0|    id<FNode> oldChildSnap = [node getImmediateChild:childKey];
   51|      0|
   52|      0|    // Check if anything actually changed.
   53|      0|    if ([[oldChildSnap getChild:affectedPath]
   54|      0|            isEqual:[newChildSnap getChild:affectedPath]]) {
   55|      0|        // There's an edge case where a child can enter or leave the view
   56|      0|        // because affectedPath was set to null. In this case, affectedPath will
   57|      0|        // appear null in both the old and new snapshots.  So we need to avoid
   58|      0|        // treating these cases as "nothing changed."
   59|      0|        if (oldChildSnap.isEmpty == newChildSnap.isEmpty) {
   60|      0|// Nothing changed.
   61|      0|#ifdef DEBUG
   62|      0|            NSAssert([oldChildSnap isEqual:newChildSnap],
   63|      0|                     @"Old and new snapshots should be equal.");
   64|      0|#endif
   65|      0|
   66|      0|            return indexedNode;
   67|      0|        }
   68|      0|    }
   69|      0|    if (optChangeAccumulator) {
   70|      0|        if (newChildSnap.isEmpty) {
   71|      0|            if ([node hasChild:childKey]) {
   72|      0|                FChange *change = [[FChange alloc]
   73|      0|                    initWithType:FIRDataEventTypeChildRemoved
   74|      0|                     indexedNode:[FIndexedNode indexedNodeWithNode:oldChildSnap]
   75|      0|                        childKey:childKey];
   76|      0|                [optChangeAccumulator trackChildChange:change];
   77|      0|            } else {
   78|      0|                NSAssert(node.isLeafNode,
   79|      0|                         @"A child remove without an old child only makes "
   80|      0|                         @"sense on a leaf node.");
   81|      0|            }
   82|      0|        } else if (oldChildSnap.isEmpty) {
   83|      0|            FChange *change = [[FChange alloc]
   84|      0|                initWithType:FIRDataEventTypeChildAdded
   85|      0|                 indexedNode:[FIndexedNode indexedNodeWithNode:newChildSnap]
   86|      0|                    childKey:childKey];
   87|      0|            [optChangeAccumulator trackChildChange:change];
   88|      0|        } else {
   89|      0|            FChange *change = [[FChange alloc]
   90|      0|                  initWithType:FIRDataEventTypeChildChanged
   91|      0|                   indexedNode:[FIndexedNode indexedNodeWithNode:newChildSnap]
   92|      0|                      childKey:childKey
   93|      0|                oldIndexedNode:[FIndexedNode indexedNodeWithNode:oldChildSnap]];
   94|      0|            [optChangeAccumulator trackChildChange:change];
   95|      0|        }
   96|      0|    }
   97|      0|    if (node.isLeafNode && newChildSnap.isEmpty) {
   98|      0|        return indexedNode;
   99|      0|    } else {
  100|      0|        return [indexedNode updateChild:childKey withNewChild:newChildSnap];
  101|      0|    }
  102|      0|}
  103|       |
  104|       |- (FIndexedNode *)updateFullNode:(FIndexedNode *)oldSnap
  105|       |                     withNewNode:(FIndexedNode *)newSnap
  106|       |                     accumulator:
  107|      0|                         (FChildChangeAccumulator *)optChangeAccumulator {
  108|      0|    if (optChangeAccumulator) {
  109|      0|        [oldSnap.node enumerateChildrenUsingBlock:^(
  110|      0|                          NSString *childKey, id<FNode> childNode, BOOL *stop) {
  111|      0|          if (![newSnap.node hasChild:childKey]) {
  112|      0|              FChange *change = [[FChange alloc]
  113|      0|                  initWithType:FIRDataEventTypeChildRemoved
  114|      0|                   indexedNode:[FIndexedNode indexedNodeWithNode:childNode]
  115|      0|                      childKey:childKey];
  116|      0|              [optChangeAccumulator trackChildChange:change];
  117|      0|          }
  118|      0|        }];
  119|      0|
  120|      0|        [newSnap.node enumerateChildrenUsingBlock:^(
  121|      0|                          NSString *childKey, id<FNode> childNode, BOOL *stop) {
  122|      0|          if ([oldSnap.node hasChild:childKey]) {
  123|      0|              id<FNode> oldChildSnap =
  124|      0|                  [oldSnap.node getImmediateChild:childKey];
  125|      0|              if (![oldChildSnap isEqual:childNode]) {
  126|      0|                  FChange *change = [[FChange alloc]
  127|      0|                        initWithType:FIRDataEventTypeChildChanged
  128|      0|                         indexedNode:[FIndexedNode
  129|      0|                                         indexedNodeWithNode:childNode]
  130|      0|                            childKey:childKey
  131|      0|                      oldIndexedNode:[FIndexedNode
  132|      0|                                         indexedNodeWithNode:oldChildSnap]];
  133|      0|                  [optChangeAccumulator trackChildChange:change];
  134|      0|              }
  135|      0|          } else {
  136|      0|              FChange *change = [[FChange alloc]
  137|      0|                  initWithType:FIRDataEventTypeChildAdded
  138|      0|                   indexedNode:[FIndexedNode indexedNodeWithNode:childNode]
  139|      0|                      childKey:childKey];
  140|      0|              [optChangeAccumulator trackChildChange:change];
  141|      0|          }
  142|      0|        }];
  143|      0|    }
  144|      0|    return newSnap;
  145|      0|}
  146|       |
  147|       |- (FIndexedNode *)updatePriority:(id<FNode>)priority
  148|      0|                         forNode:(FIndexedNode *)oldSnap {
  149|      0|    if ([oldSnap.node isEmpty]) {
  150|      0|        return oldSnap;
  151|      0|    } else {
  152|      0|        return [oldSnap updatePriority:priority];
  153|      0|    }
  154|      0|}
  155|       |
  156|      0|- (BOOL)filtersNodes {
  157|      0|    return NO;
  158|      0|}
  159|       |
  160|      0|- (id<FNodeFilter>)indexedFilter {
  161|      0|    return self;
  162|      0|}
  163|       |
  164|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Core/View/Filter/FLimitedFilter.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FLimitedFilter.h"
   18|       |#import "FChange.h"
   19|       |#import "FChildChangeAccumulator.h"
   20|       |#import "FChildrenNode.h"
   21|       |#import "FCompleteChildSource.h"
   22|       |#import "FEmptyNode.h"
   23|       |#import "FIndex.h"
   24|       |#import "FNamedNode.h"
   25|       |#import "FQueryParams.h"
   26|       |#import "FRangedFilter.h"
   27|       |#import "FTreeSortedDictionary.h"
   28|       |
   29|       |@interface FLimitedFilter ()
   30|       |@property(nonatomic, strong) FRangedFilter *rangedFilter;
   31|       |@property(nonatomic, strong, readwrite) id<FIndex> index;
   32|       |@property(nonatomic) NSInteger limit;
   33|       |@property(nonatomic) BOOL reverse;
   34|       |
   35|       |@end
   36|       |
   37|       |@implementation FLimitedFilter
   38|      0|- (id)initWithQueryParams:(FQueryParams *)params {
   39|      0|    self = [super init];
   40|      0|    if (self) {
   41|      0|        self.rangedFilter = [[FRangedFilter alloc] initWithQueryParams:params];
   42|      0|        self.index = params.index;
   43|      0|        self.limit = params.limit;
   44|      0|        self.reverse = !params.isViewFromLeft;
   45|      0|    }
   46|      0|    return self;
   47|      0|}
   48|       |
   49|       |- (FIndexedNode *)updateChildIn:(FIndexedNode *)oldSnap
   50|       |                    forChildKey:(NSString *)childKey
   51|       |                       newChild:(id<FNode>)newChildSnap
   52|       |                   affectedPath:(FPath *)affectedPath
   53|       |                     fromSource:(id<FCompleteChildSource>)source
   54|       |                    accumulator:
   55|      0|                        (FChildChangeAccumulator *)optChangeAccumulator {
   56|      0|    if (![self.rangedFilter matchesKey:childKey andNode:newChildSnap]) {
   57|      0|        newChildSnap = [FEmptyNode emptyNode];
   58|      0|    }
   59|      0|    if ([[oldSnap.node getImmediateChild:childKey] isEqual:newChildSnap]) {
   60|      0|        // No change
   61|      0|        return oldSnap;
   62|      0|    } else if (oldSnap.node.numChildren < self.limit) {
   63|      0|        return [[self.rangedFilter indexedFilter]
   64|      0|            updateChildIn:oldSnap
   65|      0|              forChildKey:childKey
   66|      0|                 newChild:newChildSnap
   67|      0|             affectedPath:affectedPath
   68|      0|               fromSource:source
   69|      0|              accumulator:optChangeAccumulator];
   70|      0|    } else {
   71|      0|        return [self fullLimitUpdateNode:oldSnap
   72|      0|                             forChildKey:childKey
   73|      0|                                newChild:newChildSnap
   74|      0|                              fromSource:source
   75|      0|                             accumulator:optChangeAccumulator];
   76|      0|    }
   77|      0|}
   78|       |
   79|       |- (FIndexedNode *)fullLimitUpdateNode:(FIndexedNode *)oldIndexed
   80|       |                          forChildKey:(NSString *)childKey
   81|       |                             newChild:(id<FNode>)newChildSnap
   82|       |                           fromSource:(id<FCompleteChildSource>)source
   83|       |                          accumulator:
   84|      0|                              (FChildChangeAccumulator *)optChangeAccumulator {
   85|      0|    NSAssert(oldIndexed.node.numChildren == self.limit,
   86|      0|             @"Should have number of children equal to limit.");
   87|      0|
   88|      0|    FNamedNode *windowBoundary =
   89|      0|        self.reverse ? oldIndexed.firstChild : oldIndexed.lastChild;
   90|      0|
   91|      0|    BOOL inRange = [self.rangedFilter matchesKey:childKey andNode:newChildSnap];
   92|      0|    if ([oldIndexed.node hasChild:childKey]) {
   93|      0|        // `childKey` was already in `oldSnap`. Figure out if it remains in the
   94|      0|        // window or needs to be replaced.
   95|      0|        id<FNode> oldChildSnap = [oldIndexed.node getImmediateChild:childKey];
   96|      0|
   97|      0|        // In case the `newChildSnap` falls outside the window, get the
   98|      0|        // `nextChild` that might replace it.
   99|      0|        FNamedNode *nextChild = [source childByIndex:self.index
  100|      0|                                          afterChild:windowBoundary
  101|      0|                                           isReverse:(BOOL)self.reverse];
  102|      0|        if (nextChild != nil && ([nextChild.name isEqualToString:childKey] ||
  103|      0|                                 [oldIndexed.node hasChild:nextChild.name])) {
  104|      0|            // There is a weird edge case where a node is updated as part of a
  105|      0|            // merge in the write tree, but hasn't been applied to the limited
  106|      0|            // filter yet. Ignore this next child which will be updated later in
  107|      0|            // the limited filter...
  108|      0|            nextChild = [source childByIndex:self.index
  109|      0|                                  afterChild:nextChild
  110|      0|                                   isReverse:self.reverse];
  111|      0|        }
  112|      0|
  113|      0|        // Figure out if `newChildSnap` is in range and ordered before
  114|      0|        // `nextChild`
  115|      0|        BOOL remainsInWindow = inRange && !newChildSnap.isEmpty;
  116|      0|        remainsInWindow = remainsInWindow &&
  117|      0|                          (!nextChild || [self.index compareKey:nextChild.name
  118|      0|                                                        andNode:nextChild.node
  119|      0|                                                     toOtherKey:childKey
  120|      0|                                                        andNode:newChildSnap
  121|      0|                                                        reverse:self.reverse] >=
  122|      0|                                             NSOrderedSame);
  123|      0|        if (remainsInWindow) {
  124|      0|            // `newChildSnap` is ordered before `nextChild`, so it's a child
  125|      0|            // changed event
  126|      0|            if (optChangeAccumulator != nil) {
  127|      0|                FChange *change = [[FChange alloc]
  128|      0|                      initWithType:FIRDataEventTypeChildChanged
  129|      0|                       indexedNode:[FIndexedNode
  130|      0|                                       indexedNodeWithNode:newChildSnap]
  131|      0|                          childKey:childKey
  132|      0|                    oldIndexedNode:[FIndexedNode
  133|      0|                                       indexedNodeWithNode:oldChildSnap]];
  134|      0|                [optChangeAccumulator trackChildChange:change];
  135|      0|            }
  136|      0|            return [oldIndexed updateChild:childKey withNewChild:newChildSnap];
  137|      0|        } else {
  138|      0|            // `newChildSnap` is ordered after `nextChild`, so it's a child
  139|      0|            // removed event
  140|      0|            if (optChangeAccumulator != nil) {
  141|      0|                FChange *change = [[FChange alloc]
  142|      0|                    initWithType:FIRDataEventTypeChildRemoved
  143|      0|                     indexedNode:[FIndexedNode indexedNodeWithNode:oldChildSnap]
  144|      0|                        childKey:childKey];
  145|      0|                [optChangeAccumulator trackChildChange:change];
  146|      0|            }
  147|      0|            FIndexedNode *newIndexed =
  148|      0|                [oldIndexed updateChild:childKey
  149|      0|                           withNewChild:[FEmptyNode emptyNode]];
  150|      0|
  151|      0|            // We need to check if the `nextChild` is actually in range before
  152|      0|            // adding it
  153|      0|            BOOL nextChildInRange =
  154|      0|                (nextChild != nil) &&
  155|      0|                [self.rangedFilter matchesKey:nextChild.name
  156|      0|                                      andNode:nextChild.node];
  157|      0|            if (nextChildInRange) {
  158|      0|                if (optChangeAccumulator != nil) {
  159|      0|                    FChange *change = [[FChange alloc]
  160|      0|                        initWithType:FIRDataEventTypeChildAdded
  161|      0|                         indexedNode:[FIndexedNode
  162|      0|                                         indexedNodeWithNode:nextChild.node]
  163|      0|                            childKey:nextChild.name];
  164|      0|                    [optChangeAccumulator trackChildChange:change];
  165|      0|                }
  166|      0|                return [newIndexed updateChild:nextChild.name
  167|      0|                                  withNewChild:nextChild.node];
  168|      0|            } else {
  169|      0|                return newIndexed;
  170|      0|            }
  171|      0|        }
  172|      0|    } else if (newChildSnap.isEmpty) {
  173|      0|        // We're deleting a node, but it was not in the window, so ignore it.
  174|      0|        return oldIndexed;
  175|      0|    } else if (inRange) {
  176|      0|        // `newChildSnap` is in range, but was ordered after `windowBoundary`.
  177|      0|        // If this has changed, we bump out the `windowBoundary` and add the
  178|      0|        // `newChildSnap`
  179|      0|        if ([self.index compareKey:windowBoundary.name
  180|      0|                           andNode:windowBoundary.node
  181|      0|                        toOtherKey:childKey
  182|      0|                           andNode:newChildSnap
  183|      0|                           reverse:self.reverse] >= NSOrderedSame) {
  184|      0|            if (optChangeAccumulator != nil) {
  185|      0|                FChange *removedChange = [[FChange alloc]
  186|      0|                    initWithType:FIRDataEventTypeChildRemoved
  187|      0|                     indexedNode:[FIndexedNode
  188|      0|                                     indexedNodeWithNode:windowBoundary.node]
  189|      0|                        childKey:windowBoundary.name];
  190|      0|                FChange *addedChange = [[FChange alloc]
  191|      0|                    initWithType:FIRDataEventTypeChildAdded
  192|      0|                     indexedNode:[FIndexedNode indexedNodeWithNode:newChildSnap]
  193|      0|                        childKey:childKey];
  194|      0|                [optChangeAccumulator trackChildChange:removedChange];
  195|      0|                [optChangeAccumulator trackChildChange:addedChange];
  196|      0|            }
  197|      0|            return [[oldIndexed updateChild:childKey withNewChild:newChildSnap]
  198|      0|                 updateChild:windowBoundary.name
  199|      0|                withNewChild:[FEmptyNode emptyNode]];
  200|      0|        } else {
  201|      0|            return oldIndexed;
  202|      0|        }
  203|      0|    } else {
  204|      0|        // `newChildSnap` was not in range and remains not in range, so ignore
  205|      0|        // it.
  206|      0|        return oldIndexed;
  207|      0|    }
  208|      0|}
  209|       |
  210|       |- (FIndexedNode *)updateFullNode:(FIndexedNode *)oldSnap
  211|       |                     withNewNode:(FIndexedNode *)newSnap
  212|       |                     accumulator:
  213|      0|                         (FChildChangeAccumulator *)optChangeAccumulator {
  214|      0|    __block FIndexedNode *filtered;
  215|      0|    if (newSnap.node.isLeafNode || newSnap.node.isEmpty) {
  216|      0|        // Make sure we have a children node with the correct index, not a leaf
  217|      0|        // node
  218|      0|        filtered = [FIndexedNode indexedNodeWithNode:[FEmptyNode emptyNode]
  219|      0|                                               index:self.index];
  220|      0|    } else {
  221|      0|        filtered = newSnap;
  222|      0|        // Don't support priorities on queries.
  223|      0|        filtered = [filtered updatePriority:[FEmptyNode emptyNode]];
  224|      0|        FNamedNode *startPost = nil;
  225|      0|        FNamedNode *endPost = nil;
  226|      0|        if (self.reverse) {
  227|      0|            startPost = self.rangedFilter.endPost;
  228|      0|            endPost = self.rangedFilter.startPost;
  229|      0|        } else {
  230|      0|            startPost = self.rangedFilter.startPost;
  231|      0|            endPost = self.rangedFilter.endPost;
  232|      0|        }
  233|      0|        __block BOOL foundStartPost = NO;
  234|      0|        __block NSUInteger count = 0;
  235|      0|        [newSnap
  236|      0|            enumerateChildrenReverse:self.reverse
  237|      0|                          usingBlock:^(NSString *childKey, id<FNode> childNode,
  238|      0|                                       BOOL *stop) {
  239|      0|                            if (!foundStartPost &&
  240|      0|                                [self.index
  241|      0|                                    compareKey:startPost.name
  242|      0|                                       andNode:startPost.node
  243|      0|                                    toOtherKey:childKey
  244|      0|                                       andNode:childNode
  245|      0|                                       reverse:self.reverse] <= NSOrderedSame) {
  246|      0|                                // Start adding
  247|      0|                                foundStartPost = YES;
  248|      0|                            }
  249|      0|                            BOOL inRange = foundStartPost && count < self.limit;
  250|      0|                            inRange = inRange &&
  251|      0|                                      [self.index compareKey:childKey
  252|      0|                                                     andNode:childNode
  253|      0|                                                  toOtherKey:endPost.name
  254|      0|                                                     andNode:endPost.node
  255|      0|                                                     reverse:self.reverse] <=
  256|      0|                                          NSOrderedSame;
  257|      0|                            if (inRange) {
  258|      0|                                count++;
  259|      0|                            } else {
  260|      0|                                filtered = [filtered
  261|      0|                                     updateChild:childKey
  262|      0|                                    withNewChild:[FEmptyNode emptyNode]];
  263|      0|                            }
  264|      0|                          }];
  265|      0|    }
  266|      0|    return [self.indexedFilter updateFullNode:oldSnap
  267|      0|                                  withNewNode:filtered
  268|      0|                                  accumulator:optChangeAccumulator];
  269|      0|}
  270|       |
  271|       |- (FIndexedNode *)updatePriority:(id<FNode>)priority
  272|      0|                         forNode:(FIndexedNode *)oldSnap {
  273|      0|    // Don't support priorities on queries.
  274|      0|    return oldSnap;
  275|      0|}
  276|       |
  277|      0|- (BOOL)filtersNodes {
  278|      0|    return YES;
  279|      0|}
  280|       |
  281|      0|- (id<FNodeFilter>)indexedFilter {
  282|      0|    return self.rangedFilter.indexedFilter;
  283|      0|}
  284|       |
  285|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FClock.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FClock.h"
   18|       |
   19|       |@implementation FSystemClock
   20|       |
   21|      0|- (NSTimeInterval)currentTime {
   22|      0|    return [[NSDate date] timeIntervalSince1970];
   23|      0|}
   24|       |
   25|      0|+ (FSystemClock *)clock {
   26|      0|    static dispatch_once_t onceToken;
   27|      0|    static FSystemClock *clock;
   28|      0|    dispatch_once(&onceToken, ^{
   29|      0|      clock = [[FSystemClock alloc] init];
   30|      0|    });
   31|      0|    return clock;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |@interface FOffsetClock ()
   37|       |
   38|       |@property(nonatomic, strong) id<FClock> clock;
   39|       |@property(nonatomic) NSTimeInterval offset;
   40|       |
   41|       |@end
   42|       |
   43|       |@implementation FOffsetClock
   44|       |
   45|      0|- (NSTimeInterval)currentTime {
   46|      0|    return [self.clock currentTime] + self.offset;
   47|      0|}
   48|       |
   49|      0|- (id)initWithClock:(id<FClock>)clock offset:(NSTimeInterval)offset {
   50|      0|    self = [super init];
   51|      0|    if (self != nil) {
   52|      0|        self->_clock = clock;
   53|      0|        self->_offset = offset;
   54|      0|    }
   55|      0|    return self;
   56|      0|}
   57|       |
   58|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FEventGenerator.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FEventGenerator.h"
   18|       |#import "FChange.h"
   19|       |#import "FDataEvent.h"
   20|       |#import "FEvent.h"
   21|       |#import "FEventRegistration.h"
   22|       |#import "FIRDatabaseQuery_Private.h"
   23|       |#import "FNamedNode.h"
   24|       |#import "FNode.h"
   25|       |#import "FQueryParams.h"
   26|       |#import "FQuerySpec.h"
   27|       |
   28|       |@interface FEventGenerator ()
   29|       |@property(nonatomic, strong) FQuerySpec *query;
   30|       |@end
   31|       |
   32|       |/**
   33|       | * An EventGenerator is used to convert "raw" changes (fb.core.view.Change) as
   34|       | * computed by the CacheDiffer into actual events (fb.core.view.Event) that can
   35|       | * be raised.  See generateEventsForChanges() for details.
   36|       | */
   37|       |@implementation FEventGenerator
   38|       |
   39|      0|- (id)initWithQuery:(FQuerySpec *)query {
   40|      0|    self = [super init];
   41|      0|    if (self) {
   42|      0|        self.query = query;
   43|      0|    }
   44|      0|    return self;
   45|      0|}
   46|       |
   47|       |/**
   48|       | * Given a set of raw changes (no moved events, and prevName not specified yet),
   49|       | * and a set of EventRegistrations that should be notified of these changes,
   50|       | * generate the actual events to be raised.
   51|       | *
   52|       | * Notes:
   53|       | * - child_moved events will be synthesized at this time for any child_changed
   54|       | * events that affect our index
   55|       | * - prevName will be calculated based on the index ordering
   56|       | *
   57|       | * @param changes NSArray of FChange, not necessarily in order.
   58|       | * @param registrations is NSArray of FEventRegistration.
   59|       | * @return NSArray of FEvent.
   60|       | */
   61|       |- (NSArray *)generateEventsForChanges:(NSArray *)changes
   62|       |                           eventCache:(FIndexedNode *)eventCache
   63|      0|                   eventRegistrations:(NSArray *)registrations {
   64|      0|    NSMutableArray *events = [[NSMutableArray alloc] init];
   65|      0|
   66|      0|    // child_moved is index-specific, so check all our child_changed events to
   67|      0|    // see if we need to materialize child_moved events with this view's index
   68|      0|    NSMutableArray *moves = [[NSMutableArray alloc] init];
   69|      0|    for (FChange *change in changes) {
   70|      0|        if (change.type == FIRDataEventTypeChildChanged &&
   71|      0|            [self.query.index
   72|      0|                indexedValueChangedBetween:change.oldIndexedNode.node
   73|      0|                                       and:change.indexedNode.node]) {
   74|      0|            FChange *moveChange =
   75|      0|                [[FChange alloc] initWithType:FIRDataEventTypeChildMoved
   76|      0|                                  indexedNode:change.indexedNode
   77|      0|                                     childKey:change.childKey
   78|      0|                               oldIndexedNode:nil];
   79|      0|            [moves addObject:moveChange];
   80|      0|        }
   81|      0|    }
   82|      0|
   83|      0|    [self generateEvents:events
   84|      0|                   forType:FIRDataEventTypeChildRemoved
   85|      0|                   changes:changes
   86|      0|                eventCache:eventCache
   87|      0|        eventRegistrations:registrations];
   88|      0|    [self generateEvents:events
   89|      0|                   forType:FIRDataEventTypeChildAdded
   90|      0|                   changes:changes
   91|      0|                eventCache:eventCache
   92|      0|        eventRegistrations:registrations];
   93|      0|    [self generateEvents:events
   94|      0|                   forType:FIRDataEventTypeChildMoved
   95|      0|                   changes:moves
   96|      0|                eventCache:eventCache
   97|      0|        eventRegistrations:registrations];
   98|      0|    [self generateEvents:events
   99|      0|                   forType:FIRDataEventTypeChildChanged
  100|      0|                   changes:changes
  101|      0|                eventCache:eventCache
  102|      0|        eventRegistrations:registrations];
  103|      0|    [self generateEvents:events
  104|      0|                   forType:FIRDataEventTypeValue
  105|      0|                   changes:changes
  106|      0|                eventCache:eventCache
  107|      0|        eventRegistrations:registrations];
  108|      0|
  109|      0|    return events;
  110|      0|}
  111|       |
  112|       |- (void)generateEvents:(NSMutableArray *)events
  113|       |               forType:(FIRDataEventType)eventType
  114|       |               changes:(NSArray *)changes
  115|       |            eventCache:(FIndexedNode *)eventCache
  116|      0|    eventRegistrations:(NSArray *)registrations {
  117|      0|    NSMutableArray *filteredChanges = [[NSMutableArray alloc] init];
  118|      0|    for (FChange *change in changes) {
  119|      0|        if (change.type == eventType) {
  120|      0|            [filteredChanges addObject:change];
  121|      0|        }
  122|      0|    }
  123|      0|
  124|      0|    id<FIndex> index = self.query.index;
  125|      0|
  126|      0|    [filteredChanges
  127|      0|        sortUsingComparator:^NSComparisonResult(FChange *one, FChange *two) {
  128|      0|          if (one.childKey == nil || two.childKey == nil) {
  129|      0|              @throw [[NSException alloc]
  130|      0|                  initWithName:@"InternalInconsistencyError"
  131|      0|                        reason:@"Should only compare child_ events"
  132|      0|                      userInfo:nil];
  133|      0|          }
  134|      0|          return [index compareKey:one.childKey
  135|      0|                           andNode:one.indexedNode.node
  136|      0|                        toOtherKey:two.childKey
  137|      0|                           andNode:two.indexedNode.node];
  138|      0|        }];
  139|      0|
  140|      0|    for (FChange *change in filteredChanges) {
  141|      0|        for (id<FEventRegistration> registration in registrations) {
  142|      0|            if ([registration responseTo:eventType]) {
  143|      0|                id<FEvent> event = [self generateEventForChange:change
  144|      0|                                                   registration:registration
  145|      0|                                                     eventCache:eventCache];
  146|      0|                [events addObject:event];
  147|      0|            }
  148|      0|        }
  149|      0|    }
  150|      0|}
  151|       |
  152|       |- (id<FEvent>)generateEventForChange:(FChange *)change
  153|       |                        registration:(id<FEventRegistration>)registration
  154|      0|                          eventCache:(FIndexedNode *)eventCache {
  155|      0|    FChange *materializedChange;
  156|      0|    if (change.type == FIRDataEventTypeValue ||
  157|      0|        change.type == FIRDataEventTypeChildRemoved) {
  158|      0|        materializedChange = change;
  159|      0|    } else {
  160|      0|        NSString *prevChildKey =
  161|      0|            [eventCache predecessorForChildKey:change.childKey
  162|      0|                                     childNode:change.indexedNode.node
  163|      0|                                         index:self.query.index];
  164|      0|        materializedChange = [change changeWithPrevKey:prevChildKey];
  165|      0|    }
  166|      0|    return [registration createEventFrom:materializedChange query:self.query];
  167|      0|}
  168|       |
  169|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FIRDatabaseReference.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDatabaseReference.h"
   18|       |#import "FIRDatabase.h"
   19|       |#import "FIRDatabaseConfig.h"
   20|       |#import "FIRDatabaseConfig_Private.h"
   21|       |#import "FIRDatabaseQuery_Private.h"
   22|       |#import "FIRDatabaseReference_Private.h"
   23|       |#import "FNextPushId.h"
   24|       |#import "FQueryParams.h"
   25|       |#import "FSnapshotUtilities.h"
   26|       |#import "FStringUtilities.h"
   27|       |#import "FUtilities.h"
   28|       |#import "FValidation.h"
   29|       |#import <FirebaseCore/FIRApp.h>
   30|       |#import <FirebaseCore/FIROptions.h>
   31|       |
   32|       |@implementation FIRDatabaseReference
   33|       |
   34|       |#pragma mark -
   35|       |#pragma mark Constructors
   36|       |
   37|      0|- (id)initWithConfig:(FIRDatabaseConfig *)config {
   38|      0|    FParsedUrl *parsedUrl =
   39|      0|        [FUtilities parseUrl:[[FIRApp defaultApp] options].databaseURL];
   40|      0|    [FValidation validateFrom:@"initWithUrl:" validURL:parsedUrl];
   41|      0|    return [self initWithRepo:[FRepoManager getRepo:parsedUrl.repoInfo
   42|      0|                                             config:config]
   43|      0|                         path:parsedUrl.path];
   44|      0|}
   45|       |
   46|      0|- (id)initWithRepo:(FRepo *)repo path:(FPath *)path {
   47|      0|    return [super initWithRepo:repo
   48|      0|                          path:path
   49|      0|                        params:[FQueryParams defaultInstance]
   50|      0|                 orderByCalled:NO
   51|      0|          priorityMethodCalled:NO];
   52|      0|}
   53|       |
   54|       |#pragma mark -
   55|       |#pragma mark Ancillary methods
   56|       |
   57|      0|- (nullable NSString *)key {
   58|      0|    if ([self.path isEmpty]) {
   59|      0|        return nil;
   60|      0|    } else {
   61|      0|        return [self.path getBack];
   62|      0|    }
   63|      0|}
   64|       |
   65|      0|- (FIRDatabase *)database {
   66|      0|    return self.repo.database;
   67|      0|}
   68|       |
   69|      0|- (FIRDatabaseReference *)parent {
   70|      0|    FPath *parentPath = [self.path parent];
   71|      0|    FIRDatabaseReference *parent = nil;
   72|      0|    if (parentPath != nil) {
   73|      0|        parent = [[FIRDatabaseReference alloc] initWithRepo:self.repo
   74|      0|                                                       path:parentPath];
   75|      0|    }
   76|      0|    return parent;
   77|      0|}
   78|       |
   79|      0|- (NSString *)URL {
   80|      0|    FIRDatabaseReference *parent = [self parent];
   81|      0|    return parent == nil
   82|      0|               ? [self.repo description]
   83|      0|               : [NSString
   84|      0|                     stringWithFormat:@"%@/%@", [parent description],
   85|      0|                                      [FStringUtilities urlEncoded:self.key]];
   86|      0|}
   87|       |
   88|      0|- (NSString *)description {
   89|      0|    return [self URL];
   90|      0|}
   91|       |
   92|      0|- (FIRDatabaseReference *)root {
   93|      0|    return [[FIRDatabaseReference alloc]
   94|      0|        initWithRepo:self.repo
   95|      0|                path:[[FPath alloc] initWith:@""]];
   96|      0|}
   97|       |
   98|       |#pragma mark -
   99|       |#pragma mark Child methods
  100|       |
  101|      0|- (FIRDatabaseReference *)child:(NSString *)pathString {
  102|      0|    if ([self.path getFront] == nil) {
  103|      0|        // we're at the root
  104|      0|        [FValidation validateFrom:@"child:" validRootPathString:pathString];
  105|      0|    } else {
  106|      0|        [FValidation validateFrom:@"child:" validPathString:pathString];
  107|      0|    }
  108|      0|    FPath *path = [self.path childFromString:pathString];
  109|      0|    FIRDatabaseReference *firebaseRef =
  110|      0|        [[FIRDatabaseReference alloc] initWithRepo:self.repo path:path];
  111|      0|    return firebaseRef;
  112|      0|}
  113|       |
  114|      0|- (FIRDatabaseReference *)childByAutoId {
  115|      0|    [FValidation validateFrom:@"childByAutoId:" writablePath:self.path];
  116|      0|
  117|      0|    NSString *name = [FNextPushId get:self.repo.serverTime];
  118|      0|    return [self child:name];
  119|      0|}
  120|       |
  121|       |#pragma mark -
  122|       |#pragma mark Basic write methods
  123|       |
  124|      0|- (void)setValue:(id)value {
  125|      0|    [self setValueInternal:value
  126|      0|                andPriority:nil
  127|      0|        withCompletionBlock:nil
  128|      0|                       from:@"setValue:"];
  129|      0|}
  130|       |
  131|      0|- (void)setValue:(id)value withCompletionBlock:(fbt_void_nserror_ref)block {
  132|      0|    [self setValueInternal:value
  133|      0|                andPriority:nil
  134|      0|        withCompletionBlock:block
  135|      0|                       from:@"setValue:withCompletionBlock:"];
  136|      0|}
  137|       |
  138|      0|- (void)setValue:(id)value andPriority:(id)priority {
  139|      0|    [self setValueInternal:value
  140|      0|                andPriority:priority
  141|      0|        withCompletionBlock:nil
  142|      0|                       from:@"setValue:andPriority:"];
  143|      0|}
  144|       |
  145|       |- (void)setValue:(id)value
  146|       |            andPriority:(id)priority
  147|      0|    withCompletionBlock:(fbt_void_nserror_ref)block {
  148|      0|    [self setValueInternal:value
  149|      0|                andPriority:priority
  150|      0|        withCompletionBlock:block
  151|      0|                       from:@"setValue:andPriority:withCompletionBlock:"];
  152|      0|}
  153|       |
  154|       |- (void)setValueInternal:(id)value
  155|       |             andPriority:(id)priority
  156|       |     withCompletionBlock:(fbt_void_nserror_ref)block
  157|      0|                    from:(NSString *)fn {
  158|      0|    [FValidation validateFrom:fn writablePath:self.path];
  159|      0|
  160|      0|    fbt_void_nserror_ref userCallback = [block copy];
  161|      0|    id<FNode> newNode = [FSnapshotUtilities nodeFrom:value
  162|      0|                                            priority:priority
  163|      0|                                  withValidationFrom:fn];
  164|      0|
  165|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  166|      0|      [self.repo set:self.path withNode:newNode withCallback:userCallback];
  167|      0|    });
  168|      0|}
  169|       |
  170|      0|- (void)removeValue {
  171|      0|    [self setValueInternal:nil
  172|      0|                andPriority:nil
  173|      0|        withCompletionBlock:nil
  174|      0|                       from:@"removeValue:"];
  175|      0|}
  176|       |
  177|      0|- (void)removeValueWithCompletionBlock:(fbt_void_nserror_ref)block {
  178|      0|    [self setValueInternal:nil
  179|      0|                andPriority:nil
  180|      0|        withCompletionBlock:block
  181|      0|                       from:@"removeValueWithCompletionBlock:"];
  182|      0|}
  183|       |
  184|      0|- (void)setPriority:(id)priority {
  185|      0|    [self setPriorityInternal:priority
  186|      0|          withCompletionBlock:nil
  187|      0|                         from:@"setPriority:"];
  188|      0|}
  189|       |
  190|       |- (void)setPriority:(id)priority
  191|      0|    withCompletionBlock:(fbt_void_nserror_ref)block {
  192|      0|
  193|      0|    [self setPriorityInternal:priority
  194|      0|          withCompletionBlock:block
  195|      0|                         from:@"setPriority:withCompletionBlock:"];
  196|      0|}
  197|       |
  198|       |- (void)setPriorityInternal:(id)priority
  199|       |        withCompletionBlock:(fbt_void_nserror_ref)block
  200|      0|                       from:(NSString *)fn {
  201|      0|    [FValidation validateFrom:fn writablePath:self.path];
  202|      0|
  203|      0|    fbt_void_nserror_ref userCallback = [block copy];
  204|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  205|      0|      [self.repo set:[self.path childFromString:@".priority"]
  206|      0|              withNode:[FSnapshotUtilities nodeFrom:priority]
  207|      0|          withCallback:userCallback];
  208|      0|    });
  209|      0|}
  210|       |
  211|      0|- (void)updateChildValues:(NSDictionary *)values {
  212|      0|    [self updateChildValuesInternal:values
  213|      0|                withCompletionBlock:nil
  214|      0|                               from:@"updateChildValues:"];
  215|      0|}
  216|       |
  217|       |- (void)updateChildValues:(NSDictionary *)values
  218|      0|      withCompletionBlock:(fbt_void_nserror_ref)block {
  219|      0|    [self updateChildValuesInternal:values
  220|      0|                withCompletionBlock:block
  221|      0|                               from:@"updateChildValues:withCompletionBlock:"];
  222|      0|}
  223|       |
  224|       |- (void)updateChildValuesInternal:(NSDictionary *)values
  225|       |              withCompletionBlock:(fbt_void_nserror_ref)block
  226|      0|                             from:(NSString *)fn {
  227|      0|    [FValidation validateFrom:fn writablePath:self.path];
  228|      0|
  229|      0|    FCompoundWrite *merge =
  230|      0|        [FSnapshotUtilities compoundWriteFromDictionary:values
  231|      0|                                     withValidationFrom:fn];
  232|      0|
  233|      0|    fbt_void_nserror_ref userCallback = [block copy];
  234|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  235|      0|      [self.repo update:self.path withNodes:merge withCallback:userCallback];
  236|      0|    });
  237|      0|}
  238|       |
  239|       |#pragma mark -
  240|       |#pragma mark Disconnect Operations
  241|       |
  242|      0|- (void)onDisconnectSetValue:(id)value {
  243|      0|    [self onDisconnectSetValueInternal:value
  244|      0|                           andPriority:nil
  245|      0|                   withCompletionBlock:nil
  246|      0|                                  from:@"onDisconnectSetValue:"];
  247|      0|}
  248|       |
  249|       |- (void)onDisconnectSetValue:(id)value
  250|      0|         withCompletionBlock:(fbt_void_nserror_ref)block {
  251|      0|    [self onDisconnectSetValueInternal:value
  252|      0|                           andPriority:nil
  253|      0|                   withCompletionBlock:block
  254|      0|                                  from:@"onDisconnectSetValue:"
  255|      0|                                       @"withCompletionBlock:"];
  256|      0|}
  257|       |
  258|      0|- (void)onDisconnectSetValue:(id)value andPriority:(id)priority {
  259|      0|    [self onDisconnectSetValueInternal:value
  260|      0|                           andPriority:priority
  261|      0|                   withCompletionBlock:nil
  262|      0|                                  from:@"onDisconnectSetValue:andPriority:"];
  263|      0|}
  264|       |
  265|       |- (void)onDisconnectSetValue:(id)value
  266|       |                 andPriority:(id)priority
  267|      0|         withCompletionBlock:(fbt_void_nserror_ref)block {
  268|      0|    [self onDisconnectSetValueInternal:value
  269|      0|                           andPriority:priority
  270|      0|                   withCompletionBlock:block
  271|      0|                                  from:@"onDisconnectSetValue:andPriority:"
  272|      0|                                       @"withCompletionBlock:"];
  273|      0|}
  274|       |
  275|       |- (void)onDisconnectSetValueInternal:(id)value
  276|       |                         andPriority:(id)priority
  277|       |                 withCompletionBlock:(fbt_void_nserror_ref)block
  278|      0|                                from:(NSString *)fn {
  279|      0|    [FValidation validateFrom:fn writablePath:self.path];
  280|      0|
  281|      0|    id<FNode> newNodeUnresolved = [FSnapshotUtilities nodeFrom:value
  282|      0|                                                      priority:priority
  283|      0|                                            withValidationFrom:fn];
  284|      0|
  285|      0|    fbt_void_nserror_ref userCallback = [block copy];
  286|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  287|      0|      [self.repo onDisconnectSet:self.path
  288|      0|                        withNode:newNodeUnresolved
  289|      0|                    withCallback:userCallback];
  290|      0|    });
  291|      0|}
  292|       |
  293|      0|- (void)onDisconnectRemoveValue {
  294|      0|    [self onDisconnectSetValueInternal:nil
  295|      0|                           andPriority:nil
  296|      0|                   withCompletionBlock:nil
  297|      0|                                  from:@"onDisconnectRemoveValue:"];
  298|      0|}
  299|       |
  300|      0|- (void)onDisconnectRemoveValueWithCompletionBlock:(fbt_void_nserror_ref)block {
  301|      0|    [self onDisconnectSetValueInternal:nil
  302|      0|                           andPriority:nil
  303|      0|                   withCompletionBlock:block
  304|      0|                                  from:@"onDisconnectRemoveValueWithCompletionB"
  305|      0|                                       @"lock:"];
  306|      0|}
  307|       |
  308|      0|- (void)onDisconnectUpdateChildValues:(NSDictionary *)values {
  309|      0|    [self
  310|      0|        onDisconnectUpdateChildValuesInternal:values
  311|      0|                          withCompletionBlock:nil
  312|      0|                                         from:
  313|      0|                                             @"onDisconnectUpdateChildValues:"];
  314|      0|}
  315|       |
  316|       |- (void)onDisconnectUpdateChildValues:(NSDictionary *)values
  317|      0|                  withCompletionBlock:(fbt_void_nserror_ref)block {
  318|      0|    [self onDisconnectUpdateChildValuesInternal:values
  319|      0|                            withCompletionBlock:block
  320|      0|                                           from:@"onDisconnectUpdateChildValues"
  321|      0|                                                @":withCompletionBlock:"];
  322|      0|}
  323|       |
  324|       |- (void)onDisconnectUpdateChildValuesInternal:(NSDictionary *)values
  325|       |                          withCompletionBlock:(fbt_void_nserror_ref)block
  326|      0|                                         from:(NSString *)fn {
  327|      0|    [FValidation validateFrom:fn writablePath:self.path];
  328|      0|
  329|      0|    FCompoundWrite *merge =
  330|      0|        [FSnapshotUtilities compoundWriteFromDictionary:values
  331|      0|                                     withValidationFrom:fn];
  332|      0|
  333|      0|    fbt_void_nserror_ref userCallback = [block copy];
  334|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  335|      0|      [self.repo onDisconnectUpdate:self.path
  336|      0|                          withNodes:merge
  337|      0|                       withCallback:userCallback];
  338|      0|    });
  339|      0|}
  340|       |
  341|      0|- (void)cancelDisconnectOperations {
  342|      0|    [self cancelDisconnectOperationsWithCompletionBlock:nil];
  343|      0|}
  344|       |
  345|       |- (void)cancelDisconnectOperationsWithCompletionBlock:
  346|      0|    (fbt_void_nserror_ref)block {
  347|      0|    fbt_void_nserror_ref callback = nil;
  348|      0|    if (block != nil) {
  349|      0|        callback = [block copy];
  350|      0|    }
  351|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  352|      0|      [self.repo onDisconnectCancel:self.path withCallback:callback];
  353|      0|    });
  354|      0|}
  355|       |
  356|       |#pragma mark -
  357|       |#pragma mark Connection management methods
  358|       |
  359|      0|+ (void)goOffline {
  360|      0|    [FRepoManager interruptAll];
  361|      0|}
  362|       |
  363|      0|+ (void)goOnline {
  364|      0|    [FRepoManager resumeAll];
  365|      0|}
  366|       |
  367|       |#pragma mark -
  368|       |#pragma mark Data reading methods deferred to FQuery
  369|       |
  370|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  371|      0|                            withBlock:(fbt_void_datasnapshot)block {
  372|      0|    return [self observeEventType:eventType
  373|      0|                        withBlock:block
  374|      0|                  withCancelBlock:nil];
  375|      0|}
  376|       |
  377|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  378|      0|       andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block {
  379|      0|    return [self observeEventType:eventType
  380|      0|        andPreviousSiblingKeyWithBlock:block
  381|      0|                       withCancelBlock:nil];
  382|      0|}
  383|       |
  384|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  385|       |                            withBlock:(fbt_void_datasnapshot)block
  386|      0|                      withCancelBlock:(fbt_void_nserror)cancelBlock {
  387|      0|    return [super observeEventType:eventType
  388|      0|                         withBlock:block
  389|      0|                   withCancelBlock:cancelBlock];
  390|      0|}
  391|       |
  392|       |- (FIRDatabaseHandle)observeEventType:(FIRDataEventType)eventType
  393|       |       andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block
  394|      0|                      withCancelBlock:(fbt_void_nserror)cancelBlock {
  395|      0|    return [super observeEventType:eventType
  396|      0|        andPreviousSiblingKeyWithBlock:block
  397|      0|                       withCancelBlock:cancelBlock];
  398|      0|}
  399|       |
  400|      0|- (void)removeObserverWithHandle:(FIRDatabaseHandle)handle {
  401|      0|    [super removeObserverWithHandle:handle];
  402|      0|}
  403|       |
  404|      0|- (void)removeAllObservers {
  405|      0|    [super removeAllObservers];
  406|      0|}
  407|       |
  408|      0|- (void)keepSynced:(BOOL)keepSynced {
  409|      0|    [super keepSynced:keepSynced];
  410|      0|}
  411|       |
  412|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  413|      0|                       withBlock:(fbt_void_datasnapshot)block {
  414|      0|    [self observeSingleEventOfType:eventType
  415|      0|                         withBlock:block
  416|      0|                   withCancelBlock:nil];
  417|      0|}
  418|       |
  419|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  420|      0|    andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block {
  421|      0|    [self observeSingleEventOfType:eventType
  422|      0|        andPreviousSiblingKeyWithBlock:block
  423|      0|                       withCancelBlock:nil];
  424|      0|}
  425|       |
  426|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  427|       |                       withBlock:(fbt_void_datasnapshot)block
  428|      0|                 withCancelBlock:(fbt_void_nserror)cancelBlock {
  429|      0|    [super observeSingleEventOfType:eventType
  430|      0|                          withBlock:block
  431|      0|                    withCancelBlock:cancelBlock];
  432|      0|}
  433|       |
  434|       |- (void)observeSingleEventOfType:(FIRDataEventType)eventType
  435|       |    andPreviousSiblingKeyWithBlock:(fbt_void_datasnapshot_nsstring)block
  436|      0|                   withCancelBlock:(fbt_void_nserror)cancelBlock {
  437|      0|    [super observeSingleEventOfType:eventType
  438|      0|        andPreviousSiblingKeyWithBlock:block
  439|      0|                       withCancelBlock:cancelBlock];
  440|      0|}
  441|       |
  442|       |#pragma mark -
  443|       |#pragma mark Query methods
  444|       |// These methods suppress warnings from having method definitions in
  445|       |// FIRDatabaseReference.h for docs generation.
  446|       |
  447|      0|- (FIRDatabaseQuery *)queryLimitedToFirst:(NSUInteger)limit {
  448|      0|    return [super queryLimitedToFirst:limit];
  449|      0|}
  450|       |
  451|      0|- (FIRDatabaseQuery *)queryLimitedToLast:(NSUInteger)limit {
  452|      0|    return [super queryLimitedToLast:limit];
  453|      0|}
  454|       |
  455|      0|- (FIRDatabaseQuery *)queryOrderedByChild:(NSString *)key {
  456|      0|    return [super queryOrderedByChild:key];
  457|      0|}
  458|       |
  459|      0|- (FIRDatabaseQuery *)queryOrderedByKey {
  460|      0|    return [super queryOrderedByKey];
  461|      0|}
  462|       |
  463|      0|- (FIRDatabaseQuery *)queryOrderedByPriority {
  464|      0|    return [super queryOrderedByPriority];
  465|      0|}
  466|       |
  467|      0|- (FIRDatabaseQuery *)queryStartingAtValue:(id)startValue {
  468|      0|    return [super queryStartingAtValue:startValue];
  469|      0|}
  470|       |
  471|       |- (FIRDatabaseQuery *)queryStartingAtValue:(id)startValue
  472|      0|                                  childKey:(NSString *)childKey {
  473|      0|    return [super queryStartingAtValue:startValue childKey:childKey];
  474|      0|}
  475|       |
  476|      0|- (FIRDatabaseQuery *)queryEndingAtValue:(id)endValue {
  477|      0|    return [super queryEndingAtValue:endValue];
  478|      0|}
  479|       |
  480|       |- (FIRDatabaseQuery *)queryEndingAtValue:(id)endValue
  481|      0|                                childKey:(NSString *)childKey {
  482|      0|    return [super queryEndingAtValue:endValue childKey:childKey];
  483|      0|}
  484|       |
  485|      0|- (FIRDatabaseQuery *)queryEqualToValue:(id)value {
  486|      0|    return [super queryEqualToValue:value];
  487|      0|}
  488|       |
  489|       |- (FIRDatabaseQuery *)queryEqualToValue:(id)value
  490|      0|                               childKey:(NSString *)childKey {
  491|      0|    return [super queryEqualToValue:value childKey:childKey];
  492|      0|}
  493|       |
  494|       |#pragma mark -
  495|       |#pragma mark Transaction methods
  496|       |
  497|      0|- (void)runTransactionBlock:(fbt_transactionresult_mutabledata)block {
  498|      0|    [FValidation validateFrom:@"runTransactionBlock:" writablePath:self.path];
  499|      0|    [self runTransactionBlock:block andCompletionBlock:nil withLocalEvents:YES];
  500|      0|}
  501|       |
  502|       |- (void)runTransactionBlock:(fbt_transactionresult_mutabledata)update
  503|       |         andCompletionBlock:
  504|      0|             (fbt_void_nserror_bool_datasnapshot)completionBlock {
  505|      0|    [FValidation validateFrom:@"runTransactionBlock:andCompletionBlock:"
  506|      0|                 writablePath:self.path];
  507|      0|    [self runTransactionBlock:update
  508|      0|           andCompletionBlock:completionBlock
  509|      0|              withLocalEvents:YES];
  510|      0|}
  511|       |
  512|       |- (void)runTransactionBlock:(fbt_transactionresult_mutabledata)block
  513|       |         andCompletionBlock:(fbt_void_nserror_bool_datasnapshot)completionBlock
  514|      0|            withLocalEvents:(BOOL)localEvents {
  515|      0|    [FValidation
  516|      0|        validateFrom:@"runTransactionBlock:andCompletionBlock:withLocalEvents:"
  517|      0|        writablePath:self.path];
  518|      0|    fbt_transactionresult_mutabledata updateCopy = [block copy];
  519|      0|    fbt_void_nserror_bool_datasnapshot onCompleteCopy = [completionBlock copy];
  520|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  521|      0|      [self.repo startTransactionOnPath:self.path
  522|      0|                                 update:updateCopy
  523|      0|                             onComplete:onCompleteCopy
  524|      0|                        withLocalEvents:localEvents];
  525|      0|    });
  526|      0|}
  527|       |
  528|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FIndex.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIndex.h"
   18|       |
   19|       |#import "FKeyIndex.h"
   20|       |#import "FPathIndex.h"
   21|       |#import "FPriorityIndex.h"
   22|       |#import "FValueIndex.h"
   23|       |
   24|       |@implementation FIndex
   25|       |
   26|      0|+ (id<FIndex>)indexFromQueryDefinition:(NSString *)string {
   27|      0|    if ([string isEqualToString:@".key"]) {
   28|      0|        return [FKeyIndex keyIndex];
   29|      0|    } else if ([string isEqualToString:@".value"]) {
   30|      0|        return [FValueIndex valueIndex];
   31|      0|    } else if ([string isEqualToString:@".priority"]) {
   32|      0|        return [FPriorityIndex priorityIndex];
   33|      0|    } else {
   34|      0|        return
   35|      0|            [[FPathIndex alloc] initWithPath:[[FPath alloc] initWith:string]];
   36|      0|    }
   37|      0|}
   38|       |
   39|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FKeyIndex.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FKeyIndex.h"
   18|       |#import "FEmptyNode.h"
   19|       |#import "FNamedNode.h"
   20|       |#import "FSnapshotUtilities.h"
   21|       |#import "FUtilities.h"
   22|       |
   23|       |@interface FKeyIndex ()
   24|       |
   25|       |@property(nonatomic, strong) FNamedNode *maxPost;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FKeyIndex
   30|       |
   31|      0|- (id)init {
   32|      0|    self = [super init];
   33|      0|    if (self) {
   34|      0|        self.maxPost = [[FNamedNode alloc] initWithName:[FUtilities maxName]
   35|      0|                                                andNode:[FEmptyNode emptyNode]];
   36|      0|    }
   37|      0|    return self;
   38|      0|}
   39|       |
   40|       |- (NSComparisonResult)compareKey:(NSString *)key1
   41|       |                         andNode:(id<FNode>)node1
   42|       |                      toOtherKey:(NSString *)key2
   43|      0|                         andNode:(id<FNode>)node2 {
   44|      0|    return [FUtilities compareKey:key1 toKey:key2];
   45|      0|}
   46|       |
   47|       |- (NSComparisonResult)compareKey:(NSString *)key1
   48|       |                         andNode:(id<FNode>)node1
   49|       |                      toOtherKey:(NSString *)key2
   50|       |                         andNode:(id<FNode>)node2
   51|      0|                         reverse:(BOOL)reverse {
   52|      0|    if (reverse) {
   53|      0|        return [self compareKey:key2
   54|      0|                        andNode:node2
   55|      0|                     toOtherKey:key1
   56|      0|                        andNode:node1];
   57|      0|    } else {
   58|      0|        return [self compareKey:key1
   59|      0|                        andNode:node1
   60|      0|                     toOtherKey:key2
   61|      0|                        andNode:node2];
   62|      0|    }
   63|      0|}
   64|       |
   65|       |- (NSComparisonResult)compareNamedNode:(FNamedNode *)namedNode1
   66|      0|                           toNamedNode:(FNamedNode *)namedNode2 {
   67|      0|    return [self compareKey:namedNode1.name
   68|      0|                    andNode:namedNode1.node
   69|      0|                 toOtherKey:namedNode2.name
   70|      0|                    andNode:namedNode2.node];
   71|      0|}
   72|       |
   73|      0|- (BOOL)isDefinedOn:(id<FNode>)node {
   74|      0|    return YES;
   75|      0|}
   76|       |
   77|      0|- (BOOL)indexedValueChangedBetween:(id<FNode>)oldNode and:(id<FNode>)newNode {
   78|      0|    return NO; // The key for a node never changes.
   79|      0|}
   80|       |
   81|      0|- (FNamedNode *)minPost {
   82|      0|    return [FNamedNode min];
   83|      0|}
   84|       |
   85|      0|- (FNamedNode *)makePost:(id<FNode>)indexValue name:(NSString *)name {
   86|      0|    NSString *key = indexValue.val;
   87|      0|    NSAssert([key isKindOfClass:[NSString class]],
   88|      0|             @"KeyIndex indexValue must always be a string.");
   89|      0|    // We just use empty node, but it'll never be compared, since our comparator
   90|      0|    // only looks at name.
   91|      0|    return [[FNamedNode alloc] initWithName:key andNode:[FEmptyNode emptyNode]];
   92|      0|}
   93|       |
   94|      0|- (NSString *)queryDefinition {
   95|      0|    return @".key";
   96|      0|}
   97|       |
   98|      0|- (NSString *)description {
   99|      0|    return @"FKeyIndex";
  100|      0|}
  101|       |
  102|      0|- (id)copyWithZone:(NSZone *)zone {
  103|      0|    return self;
  104|      0|}
  105|       |
  106|      0|- (BOOL)isEqual:(id)other {
  107|      0|    // since we're a singleton.
  108|      0|    return (other == self);
  109|      0|}
  110|       |
  111|      0|- (NSUInteger)hash {
  112|      0|    return [@".key" hash];
  113|      0|}
  114|       |
  115|      0|+ (id<FIndex>)keyIndex {
  116|      0|    static id<FIndex> keyIndex;
  117|      0|    static dispatch_once_t once;
  118|      0|    dispatch_once(&once, ^{
  119|      0|      keyIndex = [[FKeyIndex alloc] init];
  120|      0|    });
  121|      0|    return keyIndex;
  122|      0|}
  123|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FListenComplete.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FListenComplete.h"
   18|       |#import "FOperationSource.h"
   19|       |#import "FPath.h"
   20|       |
   21|       |@interface FListenComplete ()
   22|       |@property(nonatomic, strong, readwrite) FOperationSource *source;
   23|       |@property(nonatomic, strong, readwrite) FPath *path;
   24|       |@property(nonatomic, readwrite) FOperationType type;
   25|       |@end
   26|       |
   27|       |@implementation FListenComplete
   28|      0|- (id)initWithSource:(FOperationSource *)aSource path:(FPath *)aPath {
   29|      0|    NSAssert(!aSource.fromUser,
   30|      0|             @"Can't have a listen complete from a user source");
   31|      0|    self = [super init];
   32|      0|    if (self) {
   33|      0|        self.source = aSource;
   34|      0|        self.path = aPath;
   35|      0|        self.type = FOperationTypeListenComplete;
   36|      0|    }
   37|      0|    return self;
   38|      0|}
   39|       |
   40|      0|- (id<FOperation>)operationForChild:(NSString *)childKey {
   41|      0|    if ([self.path isEmpty]) {
   42|      0|        return [[FListenComplete alloc] initWithSource:self.source
   43|      0|                                                  path:[FPath empty]];
   44|      0|    } else {
   45|      0|        return [[FListenComplete alloc] initWithSource:self.source
   46|      0|                                                  path:[self.path popFront]];
   47|      0|    }
   48|      0|}
   49|       |
   50|      0|- (NSString *)description {
   51|      0|    return [NSString stringWithFormat:@"FListenComplete { path=%@, source=%@ }",
   52|      0|                                      self.path, self.source];
   53|      0|}
   54|       |
   55|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FMaxNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FMaxNode.h"
   18|       |#import "FEmptyNode.h"
   19|       |#import "FUtilities.h"
   20|       |
   21|       |@implementation FMaxNode {
   22|       |}
   23|      0|- (id)init {
   24|      0|    self = [super init];
   25|      0|    if (self) {
   26|      0|    }
   27|      0|    return self;
   28|      0|}
   29|       |
   30|      0|+ (id<FNode>)maxNode {
   31|      0|    static FMaxNode *maxNode = nil;
   32|      0|    static dispatch_once_t once;
   33|      0|    dispatch_once(&once, ^{
   34|      0|      maxNode = [[FMaxNode alloc] init];
   35|      0|    });
   36|      0|    return maxNode;
   37|      0|}
   38|       |
   39|      0|- (NSComparisonResult)compare:(id<FNode>)other {
   40|      0|    if (other == self) {
   41|      0|        return NSOrderedSame;
   42|      0|    } else {
   43|      0|        return NSOrderedDescending;
   44|      0|    }
   45|      0|}
   46|       |
   47|      0|- (BOOL)isEqual:(id)other {
   48|      0|    return other == self;
   49|      0|}
   50|       |
   51|      0|- (id<FNode>)getImmediateChild:(NSString *)childName {
   52|      0|    return [FEmptyNode emptyNode];
   53|      0|}
   54|       |
   55|      0|- (BOOL)isEmpty {
   56|      0|    return NO;
   57|      0|}
   58|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FNamedNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FNamedNode.h"
   18|       |#import "FEmptyNode.h"
   19|       |#import "FIndex.h"
   20|       |#import "FMaxNode.h"
   21|       |#import "FUtilities.h"
   22|       |
   23|       |@interface FNamedNode ()
   24|       |@property(nonatomic, strong, readwrite) NSString *name;
   25|       |@property(nonatomic, strong, readwrite) id<FNode> node;
   26|       |@end
   27|       |
   28|       |@implementation FNamedNode
   29|       |
   30|      0|+ (FNamedNode *)nodeWithName:(NSString *)name node:(id<FNode>)node {
   31|      0|    return [[FNamedNode alloc] initWithName:name andNode:node];
   32|      0|}
   33|       |
   34|      0|- (id)initWithName:(NSString *)name andNode:(id<FNode>)node {
   35|      0|    self = [super init];
   36|      0|    if (self) {
   37|      0|        self.name = name;
   38|      0|        self.node = node;
   39|      0|    }
   40|      0|    return self;
   41|      0|}
   42|       |
   43|      0|- (id)copy {
   44|      0|    return self;
   45|      0|}
   46|       |
   47|      0|- (id)copyWithZone:(NSZone *)zone {
   48|      0|    return self;
   49|      0|}
   50|       |
   51|      0|+ (FNamedNode *)min {
   52|      0|    static FNamedNode *min = nil;
   53|      0|    static dispatch_once_t once;
   54|      0|    dispatch_once(&once, ^{
   55|      0|      min = [[FNamedNode alloc] initWithName:[FUtilities minName]
   56|      0|                                     andNode:[FEmptyNode emptyNode]];
   57|      0|    });
   58|      0|    return min;
   59|      0|}
   60|       |
   61|      0|+ (FNamedNode *)max {
   62|      0|    static FNamedNode *max = nil;
   63|      0|    static dispatch_once_t once;
   64|      0|    dispatch_once(&once, ^{
   65|      0|      max = [[FNamedNode alloc] initWithName:[FUtilities maxName]
   66|      0|                                     andNode:[FMaxNode maxNode]];
   67|      0|    });
   68|      0|    return max;
   69|      0|}
   70|       |
   71|      0|- (NSString *)description {
   72|      0|    return
   73|      0|        [NSString stringWithFormat:@"NamedNode[%@] %@", self.name, self.node];
   74|      0|}
   75|       |
   76|      0|- (BOOL)isEqual:(id)object {
   77|      0|    if (self == object) {
   78|      0|        return YES;
   79|      0|    }
   80|      0|    if (object == nil || ![object isKindOfClass:[FNamedNode class]]) {
   81|      0|        return NO;
   82|      0|    }
   83|      0|
   84|      0|    FNamedNode *namedNode = object;
   85|      0|    if (![self.name isEqualToString:namedNode.name]) {
   86|      0|        return NO;
   87|      0|    }
   88|      0|    if (![self.node isEqual:namedNode.node]) {
   89|      0|        return NO;
   90|      0|    }
   91|      0|
   92|      0|    return YES;
   93|      0|}
   94|       |
   95|      0|- (NSUInteger)hash {
   96|      0|    NSUInteger nameHash = [self.name hash];
   97|      0|    NSUInteger nodeHash = [self.node hash];
   98|      0|    NSUInteger result = 31 * nameHash + nodeHash;
   99|      0|    return result;
  100|      0|}
  101|       |
  102|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FPathIndex.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FPathIndex.h"
   18|       |#import "FEmptyNode.h"
   19|       |#import "FMaxNode.h"
   20|       |#import "FNamedNode.h"
   21|       |#import "FPath.h"
   22|       |#import "FSnapshotUtilities.h"
   23|       |#import "FUtilities.h"
   24|       |
   25|       |@interface FPathIndex ()
   26|       |@property(nonatomic, strong) FPath *path;
   27|       |@end
   28|       |
   29|       |@implementation FPathIndex
   30|       |
   31|      0|- (id)initWithPath:(FPath *)path {
   32|      0|    self = [super init];
   33|      0|    if (self) {
   34|      0|        if (path.isEmpty || [path.getFront isEqualToString:@".priority"]) {
   35|      0|            [NSException raise:NSInvalidArgumentException
   36|      0|                        format:@"Invalid path for PathIndex: %@", path];
   37|      0|        }
   38|      0|        _path = path;
   39|      0|    }
   40|      0|    return self;
   41|      0|}
   42|       |
   43|       |- (NSComparisonResult)compareKey:(NSString *)key1
   44|       |                         andNode:(id<FNode>)node1
   45|       |                      toOtherKey:(NSString *)key2
   46|      0|                         andNode:(id<FNode>)node2 {
   47|      0|    id<FNode> child1 = [node1 getChild:self.path];
   48|      0|    id<FNode> child2 = [node2 getChild:self.path];
   49|      0|    NSComparisonResult indexCmp = [child1 compare:child2];
   50|      0|    if (indexCmp == NSOrderedSame) {
   51|      0|        return [FUtilities compareKey:key1 toKey:key2];
   52|      0|    } else {
   53|      0|        return indexCmp;
   54|      0|    }
   55|      0|}
   56|       |
   57|       |- (NSComparisonResult)compareKey:(NSString *)key1
   58|       |                         andNode:(id<FNode>)node1
   59|       |                      toOtherKey:(NSString *)key2
   60|       |                         andNode:(id<FNode>)node2
   61|      0|                         reverse:(BOOL)reverse {
   62|      0|    if (reverse) {
   63|      0|        return [self compareKey:key2
   64|      0|                        andNode:node2
   65|      0|                     toOtherKey:key1
   66|      0|                        andNode:node1];
   67|      0|    } else {
   68|      0|        return [self compareKey:key1
   69|      0|                        andNode:node1
   70|      0|                     toOtherKey:key2
   71|      0|                        andNode:node2];
   72|      0|    }
   73|      0|}
   74|       |
   75|       |- (NSComparisonResult)compareNamedNode:(FNamedNode *)namedNode1
   76|      0|                           toNamedNode:(FNamedNode *)namedNode2 {
   77|      0|    return [self compareKey:namedNode1.name
   78|      0|                    andNode:namedNode1.node
   79|      0|                 toOtherKey:namedNode2.name
   80|      0|                    andNode:namedNode2.node];
   81|      0|}
   82|       |
   83|      0|- (BOOL)isDefinedOn:(id<FNode>)node {
   84|      0|    return ![node getChild:self.path].isEmpty;
   85|      0|}
   86|       |
   87|      0|- (BOOL)indexedValueChangedBetween:(id<FNode>)oldNode and:(id<FNode>)newNode {
   88|      0|    id<FNode> oldValue = [oldNode getChild:self.path];
   89|      0|    id<FNode> newValue = [newNode getChild:self.path];
   90|      0|    return [oldValue compare:newValue] != NSOrderedSame;
   91|      0|}
   92|       |
   93|      0|- (FNamedNode *)minPost {
   94|      0|    return FNamedNode.min;
   95|      0|}
   96|       |
   97|      0|- (FNamedNode *)maxPost {
   98|      0|    id<FNode> maxNode = [[FEmptyNode emptyNode] updateChild:self.path
   99|      0|                                               withNewChild:[FMaxNode maxNode]];
  100|      0|
  101|      0|    return [[FNamedNode alloc] initWithName:[FUtilities maxName]
  102|      0|                                    andNode:maxNode];
  103|      0|}
  104|       |
  105|      0|- (FNamedNode *)makePost:(id<FNode>)indexValue name:(NSString *)name {
  106|      0|    id<FNode> node = [[FEmptyNode emptyNode] updateChild:self.path
  107|      0|                                            withNewChild:indexValue];
  108|      0|    return [[FNamedNode alloc] initWithName:name andNode:node];
  109|      0|}
  110|       |
  111|      0|- (NSString *)queryDefinition {
  112|      0|    return [self.path wireFormat];
  113|      0|}
  114|       |
  115|      0|- (NSString *)description {
  116|      0|    return [NSString stringWithFormat:@"FPathIndex(%@)", self.path];
  117|      0|}
  118|       |
  119|      0|- (id)copyWithZone:(NSZone *)zone {
  120|      0|    // Safe since we're immutable.
  121|      0|    return self;
  122|      0|}
  123|       |
  124|      0|- (BOOL)isEqual:(id)other {
  125|      0|    if (![other isKindOfClass:[FPathIndex class]]) {
  126|      0|        return NO;
  127|      0|    }
  128|      0|    return ([self.path isEqual:((FPathIndex *)other).path]);
  129|      0|}
  130|       |
  131|      0|- (NSUInteger)hash {
  132|      0|    return [self.path hash];
  133|      0|}
  134|       |
  135|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FPriorityIndex.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FPriorityIndex.h"
   18|       |
   19|       |#import "FEmptyNode.h"
   20|       |#import "FLeafNode.h"
   21|       |#import "FMaxNode.h"
   22|       |#import "FNamedNode.h"
   23|       |#import "FNode.h"
   24|       |#import "FUtilities.h"
   25|       |
   26|       |// TODO: Abstract into some common base class?
   27|       |
   28|       |@implementation FPriorityIndex
   29|       |
   30|       |- (NSComparisonResult)compareKey:(NSString *)key1
   31|       |                         andNode:(id<FNode>)node1
   32|       |                      toOtherKey:(NSString *)key2
   33|      0|                         andNode:(id<FNode>)node2 {
   34|      0|    id<FNode> child1 = [node1 getPriority];
   35|      0|    id<FNode> child2 = [node2 getPriority];
   36|      0|    NSComparisonResult indexCmp = [child1 compare:child2];
   37|      0|    if (indexCmp == NSOrderedSame) {
   38|      0|        return [FUtilities compareKey:key1 toKey:key2];
   39|      0|    } else {
   40|      0|        return indexCmp;
   41|      0|    }
   42|      0|}
   43|       |
   44|       |- (NSComparisonResult)compareKey:(NSString *)key1
   45|       |                         andNode:(id<FNode>)node1
   46|       |                      toOtherKey:(NSString *)key2
   47|       |                         andNode:(id<FNode>)node2
   48|      0|                         reverse:(BOOL)reverse {
   49|      0|    if (reverse) {
   50|      0|        return [self compareKey:key2
   51|      0|                        andNode:node2
   52|      0|                     toOtherKey:key1
   53|      0|                        andNode:node1];
   54|      0|    } else {
   55|      0|        return [self compareKey:key1
   56|      0|                        andNode:node1
   57|      0|                     toOtherKey:key2
   58|      0|                        andNode:node2];
   59|      0|    }
   60|      0|}
   61|       |
   62|       |- (NSComparisonResult)compareNamedNode:(FNamedNode *)namedNode1
   63|      0|                           toNamedNode:(FNamedNode *)namedNode2 {
   64|      0|    return [self compareKey:namedNode1.name
   65|      0|                    andNode:namedNode1.node
   66|      0|                 toOtherKey:namedNode2.name
   67|      0|                    andNode:namedNode2.node];
   68|      0|}
   69|       |
   70|      0|- (BOOL)isDefinedOn:(id<FNode>)node {
   71|      0|    return !node.getPriority.isEmpty;
   72|      0|}
   73|       |
   74|      0|- (BOOL)indexedValueChangedBetween:(id<FNode>)oldNode and:(id<FNode>)newNode {
   75|      0|    id<FNode> oldValue = [oldNode getPriority];
   76|      0|    id<FNode> newValue = [newNode getPriority];
   77|      0|    return ![oldValue isEqual:newValue];
   78|      0|}
   79|       |
   80|      0|- (FNamedNode *)minPost {
   81|      0|    return FNamedNode.min;
   82|      0|}
   83|       |
   84|      0|- (FNamedNode *)maxPost {
   85|      0|    return [self makePost:[FMaxNode maxNode] name:[FUtilities maxName]];
   86|      0|}
   87|       |
   88|      0|- (FNamedNode *)makePost:(id<FNode>)indexValue name:(NSString *)name {
   89|      0|    id<FNode> node = [[FLeafNode alloc] initWithValue:@"[PRIORITY-POST]"
   90|      0|                                         withPriority:indexValue];
   91|      0|    return [[FNamedNode alloc] initWithName:name andNode:node];
   92|      0|}
   93|       |
   94|      0|- (NSString *)queryDefinition {
   95|      0|    return @".priority";
   96|      0|}
   97|       |
   98|      0|- (NSString *)description {
   99|      0|    return @"FPriorityIndex";
  100|      0|}
  101|       |
  102|      0|- (id)copyWithZone:(NSZone *)zone {
  103|      0|    // Safe since we're immutable.
  104|      0|    return self;
  105|      0|}
  106|       |
  107|      0|- (BOOL)isEqual:(id)other {
  108|      0|    return [other isKindOfClass:[FPriorityIndex class]];
  109|      0|}
  110|       |
  111|      0|- (NSUInteger)hash {
  112|      0|    // chosen by a fair dice roll. Guaranteed to be random
  113|      0|    return 3155577;
  114|      0|}
  115|       |
  116|      0|+ (id<FIndex>)priorityIndex {
  117|      0|    static id<FIndex> index;
  118|      0|    static dispatch_once_t once;
  119|      0|    dispatch_once(&once, ^{
  120|      0|      index = [[FPriorityIndex alloc] init];
  121|      0|    });
  122|      0|
  123|      0|    return index;
  124|      0|}
  125|       |
  126|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FRangedFilter.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FRangedFilter.h"
   18|       |#import "FChildChangeAccumulator.h"
   19|       |#import "FChildrenNode.h"
   20|       |#import "FEmptyNode.h"
   21|       |#import "FIndexedFilter.h"
   22|       |#import "FIndexedNode.h"
   23|       |#import "FNamedNode.h"
   24|       |#import "FQueryParams.h"
   25|       |
   26|       |@interface FRangedFilter ()
   27|       |@property(nonatomic, strong, readwrite) id<FNodeFilter> indexedFilter;
   28|       |@property(nonatomic, strong, readwrite) id<FIndex> index;
   29|       |@property(nonatomic, strong, readwrite) FNamedNode *startPost;
   30|       |@property(nonatomic, strong, readwrite) FNamedNode *endPost;
   31|       |@end
   32|       |
   33|       |@implementation FRangedFilter
   34|      0|- (id)initWithQueryParams:(FQueryParams *)params {
   35|      0|    self = [super init];
   36|      0|    if (self) {
   37|      0|        self.indexedFilter =
   38|      0|            [[FIndexedFilter alloc] initWithIndex:params.index];
   39|      0|        self.index = params.index;
   40|      0|        self.startPost = [FRangedFilter startPostFromQueryParams:params];
   41|      0|        self.endPost = [FRangedFilter endPostFromQueryParams:params];
   42|      0|    }
   43|      0|    return self;
   44|      0|}
   45|       |
   46|      0|+ (FNamedNode *)startPostFromQueryParams:(FQueryParams *)params {
   47|      0|    if ([params hasStart]) {
   48|      0|        NSString *startKey = params.indexStartKey;
   49|      0|        return [params.index makePost:params.indexStartValue name:startKey];
   50|      0|    } else {
   51|      0|        return params.index.minPost;
   52|      0|    }
   53|      0|}
   54|       |
   55|      0|+ (FNamedNode *)endPostFromQueryParams:(FQueryParams *)params {
   56|      0|    if ([params hasEnd]) {
   57|      0|        NSString *endKey = params.indexEndKey;
   58|      0|        return [params.index makePost:params.indexEndValue name:endKey];
   59|      0|    } else {
   60|      0|        return params.index.maxPost;
   61|      0|    }
   62|      0|}
   63|       |
   64|      0|- (BOOL)matchesKey:(NSString *)key andNode:(id<FNode>)node {
   65|      0|    return ([self.index compareKey:self.startPost.name
   66|      0|                           andNode:self.startPost.node
   67|      0|                        toOtherKey:key
   68|      0|                           andNode:node] <= NSOrderedSame &&
   69|      0|            [self.index compareKey:key
   70|      0|                           andNode:node
   71|      0|                        toOtherKey:self.endPost.name
   72|      0|                           andNode:self.endPost.node] <= NSOrderedSame);
   73|      0|}
   74|       |
   75|       |- (FIndexedNode *)updateChildIn:(FIndexedNode *)oldSnap
   76|       |                    forChildKey:(NSString *)childKey
   77|       |                       newChild:(id<FNode>)newChildSnap
   78|       |                   affectedPath:(FPath *)affectedPath
   79|       |                     fromSource:(id<FCompleteChildSource>)source
   80|       |                    accumulator:
   81|      0|                        (FChildChangeAccumulator *)optChangeAccumulator {
   82|      0|    if (![self matchesKey:childKey andNode:newChildSnap]) {
   83|      0|        newChildSnap = [FEmptyNode emptyNode];
   84|      0|    }
   85|      0|    return [self.indexedFilter updateChildIn:oldSnap
   86|      0|                                 forChildKey:childKey
   87|      0|                                    newChild:newChildSnap
   88|      0|                                affectedPath:affectedPath
   89|      0|                                  fromSource:source
   90|      0|                                 accumulator:optChangeAccumulator];
   91|      0|}
   92|       |
   93|       |- (FIndexedNode *)updateFullNode:(FIndexedNode *)oldSnap
   94|       |                     withNewNode:(FIndexedNode *)newSnap
   95|       |                     accumulator:
   96|      0|                         (FChildChangeAccumulator *)optChangeAccumulator {
   97|      0|    __block FIndexedNode *filtered;
   98|      0|    if (newSnap.node.isLeafNode) {
   99|      0|        // Make sure we have a children node with the correct index, not a leaf
  100|      0|        // node
  101|      0|        filtered = [FIndexedNode indexedNodeWithNode:[FEmptyNode emptyNode]
  102|      0|                                               index:self.index];
  103|      0|    } else {
  104|      0|        // Dont' support priorities on queries
  105|      0|        filtered = [newSnap updatePriority:[FEmptyNode emptyNode]];
  106|      0|        [newSnap.node enumerateChildrenUsingBlock:^(
  107|      0|                          NSString *key, id<FNode> node, BOOL *stop) {
  108|      0|          if (![self matchesKey:key andNode:node]) {
  109|      0|              filtered = [filtered updateChild:key
  110|      0|                                  withNewChild:[FEmptyNode emptyNode]];
  111|      0|          }
  112|      0|        }];
  113|      0|    }
  114|      0|    return [self.indexedFilter updateFullNode:oldSnap
  115|      0|                                  withNewNode:filtered
  116|      0|                                  accumulator:optChangeAccumulator];
  117|      0|}
  118|       |
  119|       |- (FIndexedNode *)updatePriority:(id<FNode>)priority
  120|      0|                         forNode:(FIndexedNode *)oldSnap {
  121|      0|    // Don't support priorities on queries
  122|      0|    return oldSnap;
  123|      0|}
  124|       |
  125|      0|- (BOOL)filtersNodes {
  126|      0|    return YES;
  127|      0|}
  128|       |
  129|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FTransformedEnumerator.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTransformedEnumerator.h"
   18|       |
   19|       |@interface FTransformedEnumerator ()
   20|       |@property(nonatomic, strong) NSEnumerator *enumerator;
   21|       |@property(nonatomic, copy) id (^transform)(id);
   22|       |@end
   23|       |
   24|       |@implementation FTransformedEnumerator
   25|       |- (id)initWithEnumerator:(NSEnumerator *)enumerator
   26|      0|            andTransform:(id (^)(id))transform {
   27|      0|    self = [super init];
   28|      0|    if (self) {
   29|      0|        self.enumerator = enumerator;
   30|      0|        self.transform = transform;
   31|      0|    }
   32|      0|    return self;
   33|      0|}
   34|       |
   35|      0|- (id)nextObject {
   36|      0|    id next = self.enumerator.nextObject;
   37|      0|    if (next != nil) {
   38|      0|        return self.transform(next);
   39|      0|    } else {
   40|      0|        return nil;
   41|      0|    }
   42|      0|}
   43|       |
   44|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FValueIndex.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FValueIndex.h"
   18|       |#import "FMaxNode.h"
   19|       |#import "FNamedNode.h"
   20|       |#import "FSnapshotUtilities.h"
   21|       |#import "FUtilities.h"
   22|       |
   23|       |@implementation FValueIndex
   24|       |
   25|       |- (NSComparisonResult)compareKey:(NSString *)key1
   26|       |                         andNode:(id<FNode>)node1
   27|       |                      toOtherKey:(NSString *)key2
   28|      0|                         andNode:(id<FNode>)node2 {
   29|      0|    NSComparisonResult indexCmp = [node1 compare:node2];
   30|      0|    if (indexCmp == NSOrderedSame) {
   31|      0|        return [FUtilities compareKey:key1 toKey:key2];
   32|      0|    } else {
   33|      0|        return indexCmp;
   34|      0|    }
   35|      0|}
   36|       |
   37|       |- (NSComparisonResult)compareKey:(NSString *)key1
   38|       |                         andNode:(id<FNode>)node1
   39|       |                      toOtherKey:(NSString *)key2
   40|       |                         andNode:(id<FNode>)node2
   41|      0|                         reverse:(BOOL)reverse {
   42|      0|    if (reverse) {
   43|      0|        return [self compareKey:key2
   44|      0|                        andNode:node2
   45|      0|                     toOtherKey:key1
   46|      0|                        andNode:node1];
   47|      0|    } else {
   48|      0|        return [self compareKey:key1
   49|      0|                        andNode:node1
   50|      0|                     toOtherKey:key2
   51|      0|                        andNode:node2];
   52|      0|    }
   53|      0|}
   54|       |
   55|       |- (NSComparisonResult)compareNamedNode:(FNamedNode *)namedNode1
   56|      0|                           toNamedNode:(FNamedNode *)namedNode2 {
   57|      0|    return [self compareKey:namedNode1.name
   58|      0|                    andNode:namedNode1.node
   59|      0|                 toOtherKey:namedNode2.name
   60|      0|                    andNode:namedNode2.node];
   61|      0|}
   62|       |
   63|      0|- (BOOL)isDefinedOn:(id<FNode>)node {
   64|      0|    return YES;
   65|      0|}
   66|       |
   67|      0|- (BOOL)indexedValueChangedBetween:(id<FNode>)oldNode and:(id<FNode>)newNode {
   68|      0|    return ![oldNode isEqual:newNode];
   69|      0|}
   70|       |
   71|      0|- (FNamedNode *)minPost {
   72|      0|    return FNamedNode.min;
   73|      0|}
   74|       |
   75|      0|- (FNamedNode *)maxPost {
   76|      0|    return FNamedNode.max;
   77|      0|}
   78|       |
   79|      0|- (FNamedNode *)makePost:(id<FNode>)indexValue name:(NSString *)name {
   80|      0|    return [[FNamedNode alloc] initWithName:name andNode:indexValue];
   81|      0|}
   82|       |
   83|      0|- (NSString *)queryDefinition {
   84|      0|    return @".value";
   85|      0|}
   86|       |
   87|      0|- (NSString *)description {
   88|      0|    return @"FValueIndex";
   89|      0|}
   90|       |
   91|      0|- (id)copyWithZone:(NSZone *)zone {
   92|      0|    return self;
   93|      0|}
   94|       |
   95|      0|- (BOOL)isEqual:(id)other {
   96|      0|    // since we're a singleton.
   97|      0|    return (other == self);
   98|      0|}
   99|       |
  100|      0|- (NSUInteger)hash {
  101|      0|    return [@".value" hash];
  102|      0|}
  103|       |
  104|      0|+ (id<FIndex>)valueIndex {
  105|      0|    static id<FIndex> valueIndex;
  106|      0|    static dispatch_once_t once;
  107|      0|    dispatch_once(&once, ^{
  108|      0|      valueIndex = [[FValueIndex alloc] init];
  109|      0|    });
  110|      0|    return valueIndex;
  111|      0|}
  112|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FViewProcessor.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FViewProcessor.h"
   18|       |#import "FAckUserWrite.h"
   19|       |#import "FCacheNode.h"
   20|       |#import "FChange.h"
   21|       |#import "FChildChangeAccumulator.h"
   22|       |#import "FChildrenNode.h"
   23|       |#import "FCompleteChildSource.h"
   24|       |#import "FCompoundWrite.h"
   25|       |#import "FEmptyNode.h"
   26|       |#import "FIRDataEventType.h"
   27|       |#import "FImmutableTree.h"
   28|       |#import "FKeyIndex.h"
   29|       |#import "FMerge.h"
   30|       |#import "FNode.h"
   31|       |#import "FNodeFilter.h"
   32|       |#import "FOperation.h"
   33|       |#import "FOperationSource.h"
   34|       |#import "FOverwrite.h"
   35|       |#import "FPath.h"
   36|       |#import "FViewCache.h"
   37|       |#import "FViewProcessorResult.h"
   38|       |#import "FWriteTreeRef.h"
   39|       |
   40|       |/**
   41|       | * An implementation of FCompleteChildSource that never returns any additional
   42|       | * children
   43|       | */
   44|       |@interface FNoCompleteChildSource : NSObject <FCompleteChildSource>
   45|       |@end
   46|       |
   47|       |@implementation FNoCompleteChildSource
   48|      0|+ (FNoCompleteChildSource *)instance {
   49|      0|    static FNoCompleteChildSource *source = nil;
   50|      0|    static dispatch_once_t once;
   51|      0|    dispatch_once(&once, ^{
   52|      0|      source = [[FNoCompleteChildSource alloc] init];
   53|      0|    });
   54|      0|    return source;
   55|      0|}
   56|       |
   57|      0|- (id<FNode>)completeChild:(NSString *)childKey {
   58|      0|    return nil;
   59|      0|}
   60|       |
   61|       |- (FNamedNode *)childByIndex:(id<FIndex>)index
   62|       |                  afterChild:(FNamedNode *)child
   63|      0|                   isReverse:(BOOL)reverse {
   64|      0|    return nil;
   65|      0|}
   66|       |@end
   67|       |
   68|       |/**
   69|       | * An implementation of FCompleteChildSource that uses a FWriteTree in addition
   70|       | * to any other server data or old event caches available to calculate complete
   71|       | * children.
   72|       | */
   73|       |@interface FWriteTreeCompleteChildSource : NSObject <FCompleteChildSource>
   74|       |@property(nonatomic, strong) FWriteTreeRef *writes;
   75|       |@property(nonatomic, strong) FViewCache *viewCache;
   76|       |@property(nonatomic, strong) id<FNode> optCompleteServerCache;
   77|       |@end
   78|       |
   79|       |@implementation FWriteTreeCompleteChildSource
   80|       |- (id)initWithWrites:(FWriteTreeRef *)writes
   81|       |           viewCache:(FViewCache *)viewCache
   82|      0|         serverCache:(id<FNode>)optCompleteServerCache {
   83|      0|    self = [super init];
   84|      0|    if (self) {
   85|      0|        self.writes = writes;
   86|      0|        self.viewCache = viewCache;
   87|      0|        self.optCompleteServerCache = optCompleteServerCache;
   88|      0|    }
   89|      0|    return self;
   90|      0|}
   91|       |
   92|      0|- (id<FNode>)completeChild:(NSString *)childKey {
   93|      0|    FCacheNode *node = self.viewCache.cachedEventSnap;
   94|      0|    if ([node isCompleteForChild:childKey]) {
   95|      0|        return [node.node getImmediateChild:childKey];
   96|      0|    } else {
   97|      0|        FCacheNode *serverNode;
   98|      0|        if (self.optCompleteServerCache) {
   99|      0|            // Since we're only ever getting child nodes, we can use the key
  100|      0|            // index here
  101|      0|            FIndexedNode *indexed =
  102|      0|                [FIndexedNode indexedNodeWithNode:self.optCompleteServerCache
  103|      0|                                            index:[FKeyIndex keyIndex]];
  104|      0|            serverNode = [[FCacheNode alloc] initWithIndexedNode:indexed
  105|      0|                                              isFullyInitialized:YES
  106|      0|                                                      isFiltered:NO];
  107|      0|        } else {
  108|      0|            serverNode = self.viewCache.cachedServerSnap;
  109|      0|        }
  110|      0|        return [self.writes calculateCompleteChild:childKey cache:serverNode];
  111|      0|    }
  112|      0|}
  113|       |
  114|       |- (FNamedNode *)childByIndex:(id<FIndex>)index
  115|       |                  afterChild:(FNamedNode *)child
  116|      0|                   isReverse:(BOOL)reverse {
  117|      0|    id<FNode> completeServerData = self.optCompleteServerCache != nil
  118|      0|                                       ? self.optCompleteServerCache
  119|      0|                                       : self.viewCache.completeServerSnap;
  120|      0|    return [self.writes calculateNextNodeAfterPost:child
  121|      0|                                completeServerData:completeServerData
  122|      0|                                           reverse:reverse
  123|      0|                                             index:index];
  124|      0|}
  125|       |
  126|       |@end
  127|       |
  128|       |@interface FViewProcessor ()
  129|       |@property(nonatomic, strong) id<FNodeFilter> filter;
  130|       |@end
  131|       |
  132|       |@implementation FViewProcessor
  133|       |
  134|      0|- (id)initWithFilter:(id<FNodeFilter>)nodeFilter {
  135|      0|    self = [super init];
  136|      0|    if (self) {
  137|      0|        self.filter = nodeFilter;
  138|      0|    }
  139|      0|    return self;
  140|      0|}
  141|       |
  142|       |- (FViewProcessorResult *)applyOperationOn:(FViewCache *)oldViewCache
  143|       |                                 operation:(id<FOperation>)operation
  144|       |                               writesCache:(FWriteTreeRef *)writesCache
  145|      0|                             completeCache:(id<FNode>)optCompleteCache {
  146|      0|    FChildChangeAccumulator *accumulator =
  147|      0|        [[FChildChangeAccumulator alloc] init];
  148|      0|    FViewCache *newViewCache;
  149|      0|
  150|      0|    if (operation.type == FOperationTypeOverwrite) {
  151|      0|        FOverwrite *overwrite = (FOverwrite *)operation;
  152|      0|        if (operation.source.fromUser) {
  153|      0|            newViewCache = [self applyUserOverwriteTo:oldViewCache
  154|      0|                                           changePath:overwrite.path
  155|      0|                                          changedSnap:overwrite.snap
  156|      0|                                          writesCache:writesCache
  157|      0|                                        completeCache:optCompleteCache
  158|      0|                                          accumulator:accumulator];
  159|      0|        } else {
  160|      0|            NSAssert(operation.source.fromServer,
  161|      0|                     @"Unknown source for overwrite.");
  162|      0|            // We filter the node if it's a tagged update or the node has been
  163|      0|            // previously filtered  and the update is not at the root in which
  164|      0|            // case it is ok (and necessary) to mark the node unfiltered again
  165|      0|            BOOL filterServerNode = overwrite.source.isTagged ||
  166|      0|                                    (oldViewCache.cachedServerSnap.isFiltered &&
  167|      0|                                     !overwrite.path.isEmpty);
  168|      0|            newViewCache = [self applyServerOverwriteTo:oldViewCache
  169|      0|                                             changePath:overwrite.path
  170|      0|                                                   snap:overwrite.snap
  171|      0|                                            writesCache:writesCache
  172|      0|                                          completeCache:optCompleteCache
  173|      0|                                       filterServerNode:filterServerNode
  174|      0|                                            accumulator:accumulator];
  175|      0|        }
  176|      0|    } else if (operation.type == FOperationTypeMerge) {
  177|      0|        FMerge *merge = (FMerge *)operation;
  178|      0|        if (operation.source.fromUser) {
  179|      0|            newViewCache = [self applyUserMergeTo:oldViewCache
  180|      0|                                             path:merge.path
  181|      0|                                  changedChildren:merge.children
  182|      0|                                      writesCache:writesCache
  183|      0|                                    completeCache:optCompleteCache
  184|      0|                                      accumulator:accumulator];
  185|      0|        } else {
  186|      0|            NSAssert(operation.source.fromServer, @"Unknown source for merge.");
  187|      0|            // We filter the node if it's a tagged update or the node has been
  188|      0|            // previously filtered
  189|      0|            BOOL filterServerNode = merge.source.isTagged ||
  190|      0|                                    oldViewCache.cachedServerSnap.isFiltered;
  191|      0|            newViewCache = [self applyServerMergeTo:oldViewCache
  192|      0|                                               path:merge.path
  193|      0|                                    changedChildren:merge.children
  194|      0|                                        writesCache:writesCache
  195|      0|                                      completeCache:optCompleteCache
  196|      0|                                   filterServerNode:filterServerNode
  197|      0|                                        accumulator:accumulator];
  198|      0|        }
  199|      0|    } else if (operation.type == FOperationTypeAckUserWrite) {
  200|      0|        FAckUserWrite *ackWrite = (FAckUserWrite *)operation;
  201|      0|        if (!ackWrite.revert) {
  202|      0|            newViewCache = [self ackUserWriteOn:oldViewCache
  203|      0|                                        ackPath:ackWrite.path
  204|      0|                                   affectedTree:ackWrite.affectedTree
  205|      0|                                    writesCache:writesCache
  206|      0|                                  completeCache:optCompleteCache
  207|      0|                                    accumulator:accumulator];
  208|      0|        } else {
  209|      0|            newViewCache = [self revertUserWriteOn:oldViewCache
  210|      0|                                              path:ackWrite.path
  211|      0|                                       writesCache:writesCache
  212|      0|                                     completeCache:optCompleteCache
  213|      0|                                       accumulator:accumulator];
  214|      0|        }
  215|      0|    } else if (operation.type == FOperationTypeListenComplete) {
  216|      0|        newViewCache = [self listenCompleteOldCache:oldViewCache
  217|      0|                                               path:operation.path
  218|      0|                                        writesCache:writesCache
  219|      0|                                        serverCache:optCompleteCache
  220|      0|                                        accumulator:accumulator];
  221|      0|    } else {
  222|      0|        [NSException
  223|      0|             raise:NSInternalInconsistencyException
  224|      0|            format:@"Unknown operation encountered %ld.", (long)operation.type];
  225|      0|        return nil;
  226|      0|    }
  227|      0|
  228|      0|    NSArray *changes = [self maybeAddValueFromOldViewCache:oldViewCache
  229|      0|                                              newViewCache:newViewCache
  230|      0|                                                   changes:accumulator.changes];
  231|      0|    FViewProcessorResult *results =
  232|      0|        [[FViewProcessorResult alloc] initWithViewCache:newViewCache
  233|      0|                                                changes:changes];
  234|      0|    return results;
  235|      0|}
  236|       |
  237|       |- (NSArray *)maybeAddValueFromOldViewCache:(FViewCache *)oldViewCache
  238|       |                              newViewCache:(FViewCache *)newViewCache
  239|      0|                                   changes:(NSArray *)changes {
  240|      0|    NSArray *newChanges = changes;
  241|      0|    FCacheNode *eventSnap = newViewCache.cachedEventSnap;
  242|      0|    if (eventSnap.isFullyInitialized) {
  243|      0|        BOOL isLeafOrEmpty =
  244|      0|            eventSnap.node.isLeafNode || eventSnap.node.isEmpty;
  245|      0|        if ([changes count] > 0 ||
  246|      0|            !oldViewCache.cachedEventSnap.isFullyInitialized ||
  247|      0|            (isLeafOrEmpty &&
  248|      0|             ![eventSnap.node isEqual:oldViewCache.completeEventSnap]) ||
  249|      0|            ![eventSnap.node.getPriority
  250|      0|                isEqual:oldViewCache.completeEventSnap.getPriority]) {
  251|      0|            FChange *valueChange =
  252|      0|                [[FChange alloc] initWithType:FIRDataEventTypeValue
  253|      0|                                  indexedNode:eventSnap.indexedNode];
  254|      0|            NSMutableArray *mutableChanges = [changes mutableCopy];
  255|      0|            [mutableChanges addObject:valueChange];
  256|      0|            newChanges = mutableChanges;
  257|      0|        }
  258|      0|    }
  259|      0|    return newChanges;
  260|      0|}
  261|       |
  262|       |- (FViewCache *)
  263|       |    generateEventCacheAfterServerEvent:(FViewCache *)viewCache
  264|       |                                  path:(FPath *)changePath
  265|       |                           writesCache:(FWriteTreeRef *)writesCache
  266|       |                                source:(id<FCompleteChildSource>)source
  267|      0|                           accumulator:(FChildChangeAccumulator *)accumulator {
  268|      0|    FCacheNode *oldEventSnap = viewCache.cachedEventSnap;
  269|      0|    if ([writesCache shadowingWriteAtPath:changePath] != nil) {
  270|      0|        // we have a shadowing write, ignore changes.
  271|      0|        return viewCache;
  272|      0|    } else {
  273|      0|        FIndexedNode *newEventCache;
  274|      0|        if (changePath.isEmpty) {
  275|      0|            // TODO: figure out how this plays with "sliding ack windows"
  276|      0|            NSAssert(
  277|      0|                viewCache.cachedServerSnap.isFullyInitialized,
  278|      0|                @"If change path is empty, we must have complete server data");
  279|      0|            id<FNode> nodeWithLocalWrites;
  280|      0|            if (viewCache.cachedServerSnap.isFiltered) {
  281|      0|                // We need to special case this, because we need to only apply
  282|      0|                // writes to complete children, or we might end up raising
  283|      0|                // events for incomplete children. If the server data is
  284|      0|                // filtered deep writes cannot be guaranteed to be complete
  285|      0|                id<FNode> serverCache = viewCache.completeServerSnap;
  286|      0|                FChildrenNode *completeChildren =
  287|      0|                    ([serverCache isKindOfClass:[FChildrenNode class]])
  288|      0|                        ? serverCache
  289|      0|                        : [FEmptyNode emptyNode];
  290|      0|                nodeWithLocalWrites = [writesCache
  291|      0|                    calculateCompleteEventChildrenWithCompleteServerChildren:
  292|      0|                        completeChildren];
  293|      0|            } else {
  294|      0|                nodeWithLocalWrites = [writesCache
  295|      0|                    calculateCompleteEventCacheWithCompleteServerCache:
  296|      0|                        viewCache.completeServerSnap];
  297|      0|            }
  298|      0|            FIndexedNode *indexedNode =
  299|      0|                [FIndexedNode indexedNodeWithNode:nodeWithLocalWrites
  300|      0|                                            index:self.filter.index];
  301|      0|            newEventCache = [self.filter
  302|      0|                updateFullNode:viewCache.cachedEventSnap.indexedNode
  303|      0|                   withNewNode:indexedNode
  304|      0|                   accumulator:accumulator];
  305|      0|        } else {
  306|      0|            NSString *childKey = [changePath getFront];
  307|      0|            if ([childKey isEqualToString:@".priority"]) {
  308|      0|                NSAssert(
  309|      0|                    changePath.length == 1,
  310|      0|                    @"Can't have a priority with additional path components");
  311|      0|                id<FNode> oldEventNode = oldEventSnap.node;
  312|      0|                id<FNode> serverNode = viewCache.cachedServerSnap.node;
  313|      0|                // we might have overwrites for this priority
  314|      0|                id<FNode> updatedPriority = [writesCache
  315|      0|                    calculateEventCacheAfterServerOverwriteWithChildPath:
  316|      0|                        changePath
  317|      0|                                                       existingEventSnap:
  318|      0|                                                           oldEventNode
  319|      0|                                                      existingServerSnap:
  320|      0|                                                          serverNode];
  321|      0|                if (updatedPriority != nil) {
  322|      0|                    newEventCache =
  323|      0|                        [self.filter updatePriority:updatedPriority
  324|      0|                                            forNode:oldEventSnap.indexedNode];
  325|      0|                } else {
  326|      0|                    // priority didn't change, keep old node
  327|      0|                    newEventCache = oldEventSnap.indexedNode;
  328|      0|                }
  329|      0|            } else {
  330|      0|                FPath *childChangePath = [changePath popFront];
  331|      0|                id<FNode> newEventChild;
  332|      0|                if ([oldEventSnap isCompleteForChild:childKey]) {
  333|      0|                    id<FNode> serverNode = viewCache.cachedServerSnap.node;
  334|      0|                    id<FNode> eventChildUpdate = [writesCache
  335|      0|                        calculateEventCacheAfterServerOverwriteWithChildPath:
  336|      0|                            changePath
  337|      0|                                                           existingEventSnap:
  338|      0|                                                               oldEventSnap.node
  339|      0|                                                          existingServerSnap:
  340|      0|                                                              serverNode];
  341|      0|                    if (eventChildUpdate != nil) {
  342|      0|                        newEventChild =
  343|      0|                            [[oldEventSnap.node getImmediateChild:childKey]
  344|      0|                                 updateChild:childChangePath
  345|      0|                                withNewChild:eventChildUpdate];
  346|      0|                    } else {
  347|      0|                        // Nothing changed, just keep the old child
  348|      0|                        newEventChild =
  349|      0|                            [oldEventSnap.node getImmediateChild:childKey];
  350|      0|                    }
  351|      0|                } else {
  352|      0|                    newEventChild = [writesCache
  353|      0|                        calculateCompleteChild:childKey
  354|      0|                                         cache:viewCache.cachedServerSnap];
  355|      0|                }
  356|      0|                if (newEventChild != nil) {
  357|      0|                    newEventCache =
  358|      0|                        [self.filter updateChildIn:oldEventSnap.indexedNode
  359|      0|                                       forChildKey:childKey
  360|      0|                                          newChild:newEventChild
  361|      0|                                      affectedPath:childChangePath
  362|      0|                                        fromSource:source
  363|      0|                                       accumulator:accumulator];
  364|      0|                } else {
  365|      0|                    // No complete children available or no change
  366|      0|                    newEventCache = oldEventSnap.indexedNode;
  367|      0|                }
  368|      0|            }
  369|      0|        }
  370|      0|        return [viewCache updateEventSnap:newEventCache
  371|      0|                               isComplete:(oldEventSnap.isFullyInitialized ||
  372|      0|                                           changePath.isEmpty)
  373|      0|                               isFiltered:self.filter.filtersNodes];
  374|      0|    }
  375|      0|}
  376|       |
  377|       |- (FViewCache *)applyServerOverwriteTo:(FViewCache *)oldViewCache
  378|       |                            changePath:(FPath *)changePath
  379|       |                                  snap:(id<FNode>)changedSnap
  380|       |                           writesCache:(FWriteTreeRef *)writesCache
  381|       |                         completeCache:(id<FNode>)optCompleteCache
  382|       |                      filterServerNode:(BOOL)filterServerNode
  383|      0|                           accumulator:(FChildChangeAccumulator *)accumulator {
  384|      0|    FCacheNode *oldServerSnap = oldViewCache.cachedServerSnap;
  385|      0|    FIndexedNode *newServerCache;
  386|      0|    id<FNodeFilter> serverFilter =
  387|      0|        filterServerNode ? self.filter : self.filter.indexedFilter;
  388|      0|
  389|      0|    if (changePath.isEmpty) {
  390|      0|        FIndexedNode *indexed =
  391|      0|            [FIndexedNode indexedNodeWithNode:changedSnap
  392|      0|                                        index:serverFilter.index];
  393|      0|        newServerCache = [serverFilter updateFullNode:oldServerSnap.indexedNode
  394|      0|                                          withNewNode:indexed
  395|      0|                                          accumulator:nil];
  396|      0|    } else if (serverFilter.filtersNodes && !oldServerSnap.isFiltered) {
  397|      0|        // We want to filter the server node, but we didn't filter the server
  398|      0|        // node yet, so simulate a full update
  399|      0|        NSAssert(![changePath isEmpty],
  400|      0|                 @"An empty path should been caught in the other branch");
  401|      0|        NSString *childKey = [changePath getFront];
  402|      0|        FPath *updatePath = [changePath popFront];
  403|      0|        id<FNode> newChild = [[oldServerSnap.node getImmediateChild:childKey]
  404|      0|             updateChild:updatePath
  405|      0|            withNewChild:changedSnap];
  406|      0|        FIndexedNode *indexed =
  407|      0|            [oldServerSnap.indexedNode updateChild:childKey
  408|      0|                                      withNewChild:newChild];
  409|      0|        newServerCache = [serverFilter updateFullNode:oldServerSnap.indexedNode
  410|      0|                                          withNewNode:indexed
  411|      0|                                          accumulator:nil];
  412|      0|    } else {
  413|      0|        NSString *childKey = [changePath getFront];
  414|      0|        if (![oldServerSnap isCompleteForPath:changePath] &&
  415|      0|            changePath.length > 1) {
  416|      0|            // We don't update incomplete nodes with updates intended for other
  417|      0|            // listeners.
  418|      0|            return oldViewCache;
  419|      0|        }
  420|      0|        FPath *childChangePath = [changePath popFront];
  421|      0|        id<FNode> childNode = [oldServerSnap.node getImmediateChild:childKey];
  422|      0|        id<FNode> newChildNode = [childNode updateChild:childChangePath
  423|      0|                                           withNewChild:changedSnap];
  424|      0|        if ([childKey isEqualToString:@".priority"]) {
  425|      0|            newServerCache =
  426|      0|                [serverFilter updatePriority:newChildNode
  427|      0|                                     forNode:oldServerSnap.indexedNode];
  428|      0|        } else {
  429|      0|            newServerCache =
  430|      0|                [serverFilter updateChildIn:oldServerSnap.indexedNode
  431|      0|                                forChildKey:childKey
  432|      0|                                   newChild:newChildNode
  433|      0|                               affectedPath:childChangePath
  434|      0|                                 fromSource:[FNoCompleteChildSource instance]
  435|      0|                                accumulator:nil];
  436|      0|        }
  437|      0|    }
  438|      0|    FViewCache *newViewCache =
  439|      0|        [oldViewCache updateServerSnap:newServerCache
  440|      0|                            isComplete:(oldServerSnap.isFullyInitialized ||
  441|      0|                                        changePath.isEmpty)
  442|      0|                            isFiltered:serverFilter.filtersNodes];
  443|      0|    id<FCompleteChildSource> source =
  444|      0|        [[FWriteTreeCompleteChildSource alloc] initWithWrites:writesCache
  445|      0|                                                    viewCache:newViewCache
  446|      0|                                                  serverCache:optCompleteCache];
  447|      0|    return [self generateEventCacheAfterServerEvent:newViewCache
  448|      0|                                               path:changePath
  449|      0|                                        writesCache:writesCache
  450|      0|                                             source:source
  451|      0|                                        accumulator:accumulator];
  452|      0|}
  453|       |
  454|       |- (FViewCache *)applyUserOverwriteTo:(FViewCache *)oldViewCache
  455|       |                          changePath:(FPath *)changePath
  456|       |                         changedSnap:(id<FNode>)changedSnap
  457|       |                         writesCache:(FWriteTreeRef *)writesCache
  458|       |                       completeCache:(id<FNode>)optCompleteCache
  459|      0|                         accumulator:(FChildChangeAccumulator *)accumulator {
  460|      0|    FCacheNode *oldEventSnap = oldViewCache.cachedEventSnap;
  461|      0|    FViewCache *newViewCache;
  462|      0|    id<FCompleteChildSource> source =
  463|      0|        [[FWriteTreeCompleteChildSource alloc] initWithWrites:writesCache
  464|      0|                                                    viewCache:oldViewCache
  465|      0|                                                  serverCache:optCompleteCache];
  466|      0|    if (changePath.isEmpty) {
  467|      0|        FIndexedNode *newIndexed =
  468|      0|            [FIndexedNode indexedNodeWithNode:changedSnap
  469|      0|                                        index:self.filter.index];
  470|      0|        FIndexedNode *newEventCache =
  471|      0|            [self.filter updateFullNode:oldEventSnap.indexedNode
  472|      0|                            withNewNode:newIndexed
  473|      0|                            accumulator:accumulator];
  474|      0|        newViewCache = [oldViewCache updateEventSnap:newEventCache
  475|      0|                                          isComplete:YES
  476|      0|                                          isFiltered:self.filter.filtersNodes];
  477|      0|    } else {
  478|      0|        NSString *childKey = [changePath getFront];
  479|      0|        if ([childKey isEqualToString:@".priority"]) {
  480|      0|            FIndexedNode *newEventCache = [self.filter
  481|      0|                updatePriority:changedSnap
  482|      0|                       forNode:oldViewCache.cachedEventSnap.indexedNode];
  483|      0|            newViewCache =
  484|      0|                [oldViewCache updateEventSnap:newEventCache
  485|      0|                                   isComplete:oldEventSnap.isFullyInitialized
  486|      0|                                   isFiltered:oldEventSnap.isFiltered];
  487|      0|        } else {
  488|      0|            FPath *childChangePath = [changePath popFront];
  489|      0|            id<FNode> oldChild = [oldEventSnap.node getImmediateChild:childKey];
  490|      0|            id<FNode> newChild;
  491|      0|            if (childChangePath.isEmpty) {
  492|      0|                // Child overwrite, we can replace the child
  493|      0|                newChild = changedSnap;
  494|      0|            } else {
  495|      0|                id<FNode> childNode = [source completeChild:childKey];
  496|      0|                if (childNode != nil) {
  497|      0|                    if ([[childChangePath getBack]
  498|      0|                            isEqualToString:@".priority"] &&
  499|      0|                        [childNode getChild:[childChangePath parent]].isEmpty) {
  500|      0|                        // This is a priority update on an empty node. If this
  501|      0|                        // node exists on the server, the server will send down
  502|      0|                        // the priority in the update, so ignore for now
  503|      0|                        newChild = childNode;
  504|      0|                    } else {
  505|      0|                        newChild = [childNode updateChild:childChangePath
  506|      0|                                             withNewChild:changedSnap];
  507|      0|                    }
  508|      0|                } else {
  509|      0|                    newChild = [FEmptyNode emptyNode];
  510|      0|                }
  511|      0|            }
  512|      0|            if (![oldChild isEqual:newChild]) {
  513|      0|                FIndexedNode *newEventSnap =
  514|      0|                    [self.filter updateChildIn:oldEventSnap.indexedNode
  515|      0|                                   forChildKey:childKey
  516|      0|                                      newChild:newChild
  517|      0|                                  affectedPath:childChangePath
  518|      0|                                    fromSource:source
  519|      0|                                   accumulator:accumulator];
  520|      0|                newViewCache = [oldViewCache
  521|      0|                    updateEventSnap:newEventSnap
  522|      0|                         isComplete:oldEventSnap.isFullyInitialized
  523|      0|                         isFiltered:self.filter.filtersNodes];
  524|      0|            } else {
  525|      0|                newViewCache = oldViewCache;
  526|      0|            }
  527|      0|        }
  528|      0|    }
  529|      0|    return newViewCache;
  530|      0|}
  531|       |
  532|      0|+ (BOOL)cache:(FViewCache *)viewCache hasChild:(NSString *)childKey {
  533|      0|    return [viewCache.cachedEventSnap isCompleteForChild:childKey];
  534|      0|}
  535|       |
  536|       |/**
  537|       | * @param changedChildren NSDictionary of child name (NSString*) to child value
  538|       | * (id<FNode>)
  539|       | */
  540|       |- (FViewCache *)applyUserMergeTo:(FViewCache *)viewCache
  541|       |                            path:(FPath *)path
  542|       |                 changedChildren:(FCompoundWrite *)changedChildren
  543|       |                     writesCache:(FWriteTreeRef *)writesCache
  544|       |                   completeCache:(id<FNode>)serverCache
  545|      0|                     accumulator:(FChildChangeAccumulator *)accumulator {
  546|      0|    // HACK: In the case of a limit query, there may be some changes that bump
  547|      0|    // things out of the window leaving room for new items.  It's important we
  548|      0|    // process these changes first, so we iterate the changes twice, first
  549|      0|    // processing any that affect items currently in view.
  550|      0|    // TODO: I consider an item "in view" if cacheHasChild is true, which checks
  551|      0|    // both the server and event snap.  I'm not sure if this will result in edge
  552|      0|    // cases when a child is in one but not the other.
  553|      0|    __block FViewCache *curViewCache = viewCache;
  554|      0|
  555|      0|    [changedChildren enumerateWrites:^(FPath *relativePath, id<FNode> childNode,
  556|      0|                                       BOOL *stop) {
  557|      0|      FPath *writePath = [path child:relativePath];
  558|      0|      if ([FViewProcessor cache:viewCache hasChild:[writePath getFront]]) {
  559|      0|          curViewCache = [self applyUserOverwriteTo:curViewCache
  560|      0|                                         changePath:writePath
  561|      0|                                        changedSnap:childNode
  562|      0|                                        writesCache:writesCache
  563|      0|                                      completeCache:serverCache
  564|      0|                                        accumulator:accumulator];
  565|      0|      }
  566|      0|    }];
  567|      0|
  568|      0|    [changedChildren enumerateWrites:^(FPath *relativePath, id<FNode> childNode,
  569|      0|                                       BOOL *stop) {
  570|      0|      FPath *writePath = [path child:relativePath];
  571|      0|      if (![FViewProcessor cache:viewCache hasChild:[writePath getFront]]) {
  572|      0|          curViewCache = [self applyUserOverwriteTo:curViewCache
  573|      0|                                         changePath:writePath
  574|      0|                                        changedSnap:childNode
  575|      0|                                        writesCache:writesCache
  576|      0|                                      completeCache:serverCache
  577|      0|                                        accumulator:accumulator];
  578|      0|      }
  579|      0|    }];
  580|      0|
  581|      0|    return curViewCache;
  582|      0|}
  583|       |
  584|       |- (FViewCache *)applyServerMergeTo:(FViewCache *)viewCache
  585|       |                              path:(FPath *)path
  586|       |                   changedChildren:(FCompoundWrite *)changedChildren
  587|       |                       writesCache:(FWriteTreeRef *)writesCache
  588|       |                     completeCache:(id<FNode>)serverCache
  589|       |                  filterServerNode:(BOOL)filterServerNode
  590|      0|                       accumulator:(FChildChangeAccumulator *)accumulator {
  591|      0|    // If we don't have a cache yet, this merge was intended for a previously
  592|      0|    // listen in the same location. Ignore it and wait for the complete data
  593|      0|    // update coming soon.
  594|      0|    if (viewCache.cachedServerSnap.node.isEmpty &&
  595|      0|        !viewCache.cachedServerSnap.isFullyInitialized) {
  596|      0|        return viewCache;
  597|      0|    }
  598|      0|
  599|      0|    // HACK: In the case of a limit query, there may be some changes that bump
  600|      0|    // things out of the window leaving room for new items.  It's important we
  601|      0|    // process these changes first, so we iterate the changes twice, first
  602|      0|    // processing any that affect items currently in view.
  603|      0|    // TODO: I consider an item "in view" if cacheHasChild is true, which checks
  604|      0|    // both the server and event snap.  I'm not sure if this will result in edge
  605|      0|    // cases when a child is in one but not the other.
  606|      0|    __block FViewCache *curViewCache = viewCache;
  607|      0|    FCompoundWrite *actualMerge;
  608|      0|    if (path.isEmpty) {
  609|      0|        actualMerge = changedChildren;
  610|      0|    } else {
  611|      0|        actualMerge =
  612|      0|            [[FCompoundWrite emptyWrite] addCompoundWrite:changedChildren
  613|      0|                                                   atPath:path];
  614|      0|    }
  615|      0|    id<FNode> serverNode = viewCache.cachedServerSnap.node;
  616|      0|
  617|      0|    NSDictionary *childCompoundWrites = actualMerge.childCompoundWrites;
  618|      0|    [childCompoundWrites
  619|      0|        enumerateKeysAndObjectsUsingBlock:^(
  620|      0|            NSString *childKey, FCompoundWrite *childMerge, BOOL *stop) {
  621|      0|          if ([serverNode hasChild:childKey]) {
  622|      0|              id<FNode> serverChild =
  623|      0|                  [viewCache.cachedServerSnap.node getImmediateChild:childKey];
  624|      0|              id<FNode> newChild = [childMerge applyToNode:serverChild];
  625|      0|              curViewCache =
  626|      0|                  [self applyServerOverwriteTo:curViewCache
  627|      0|                                    changePath:[[FPath alloc] initWith:childKey]
  628|      0|                                          snap:newChild
  629|      0|                                   writesCache:writesCache
  630|      0|                                 completeCache:serverCache
  631|      0|                              filterServerNode:filterServerNode
  632|      0|                                   accumulator:accumulator];
  633|      0|          }
  634|      0|        }];
  635|      0|
  636|      0|    [childCompoundWrites
  637|      0|        enumerateKeysAndObjectsUsingBlock:^(
  638|      0|            NSString *childKey, FCompoundWrite *childMerge, BOOL *stop) {
  639|      0|          bool isUnknownDeepMerge =
  640|      0|              ![viewCache.cachedServerSnap isCompleteForChild:childKey] &&
  641|      0|              childMerge.rootWrite == nil;
  642|      0|          if (![serverNode hasChild:childKey] && !isUnknownDeepMerge) {
  643|      0|              id<FNode> serverChild =
  644|      0|                  [viewCache.cachedServerSnap.node getImmediateChild:childKey];
  645|      0|              id<FNode> newChild = [childMerge applyToNode:serverChild];
  646|      0|              curViewCache =
  647|      0|                  [self applyServerOverwriteTo:curViewCache
  648|      0|                                    changePath:[[FPath alloc] initWith:childKey]
  649|      0|                                          snap:newChild
  650|      0|                                   writesCache:writesCache
  651|      0|                                 completeCache:serverCache
  652|      0|                              filterServerNode:filterServerNode
  653|      0|                                   accumulator:accumulator];
  654|      0|          }
  655|      0|        }];
  656|      0|
  657|      0|    return curViewCache;
  658|      0|}
  659|       |
  660|       |- (FViewCache *)ackUserWriteOn:(FViewCache *)viewCache
  661|       |                       ackPath:(FPath *)ackPath
  662|       |                  affectedTree:(FImmutableTree *)affectedTree
  663|       |                   writesCache:(FWriteTreeRef *)writesCache
  664|       |                 completeCache:(id<FNode>)optCompleteCache
  665|      0|                   accumulator:(FChildChangeAccumulator *)accumulator {
  666|      0|
  667|      0|    if ([writesCache shadowingWriteAtPath:ackPath] != nil) {
  668|      0|        return viewCache;
  669|      0|    }
  670|      0|
  671|      0|    // Only filter server node if it is currently filtered
  672|      0|    BOOL filterServerNode = viewCache.cachedServerSnap.isFiltered;
  673|      0|
  674|      0|    // Essentially we'll just get our existing server cache for the affected
  675|      0|    // paths and re-apply it as a server update now that it won't be shadowed.
  676|      0|    FCacheNode *serverCache = viewCache.cachedServerSnap;
  677|      0|    if (affectedTree.value != nil) {
  678|      0|        // This is an overwrite.
  679|      0|        if ((ackPath.isEmpty && serverCache.isFullyInitialized) ||
  680|      0|            [serverCache isCompleteForPath:ackPath]) {
  681|      0|            return
  682|      0|                [self applyServerOverwriteTo:viewCache
  683|      0|                                  changePath:ackPath
  684|      0|                                        snap:[serverCache.node getChild:ackPath]
  685|      0|                                 writesCache:writesCache
  686|      0|                               completeCache:optCompleteCache
  687|      0|                            filterServerNode:filterServerNode
  688|      0|                                 accumulator:accumulator];
  689|      0|        } else if (ackPath.isEmpty) {
  690|      0|            // This is a goofy edge case where we are acking data at this
  691|      0|            // location but don't have full data.  We should just re-apply
  692|      0|            // whatever we have in our cache as a merge.
  693|      0|            FCompoundWrite *changedChildren = [FCompoundWrite emptyWrite];
  694|      0|            for (FNamedNode *child in serverCache.node.childEnumerator) {
  695|      0|                changedChildren = [changedChildren addWrite:child.node
  696|      0|                                                      atKey:child.name];
  697|      0|            }
  698|      0|            return [self applyServerMergeTo:viewCache
  699|      0|                                       path:ackPath
  700|      0|                            changedChildren:changedChildren
  701|      0|                                writesCache:writesCache
  702|      0|                              completeCache:optCompleteCache
  703|      0|                           filterServerNode:filterServerNode
  704|      0|                                accumulator:accumulator];
  705|      0|        } else {
  706|      0|            return viewCache;
  707|      0|        }
  708|      0|    } else {
  709|      0|        // This is a merge.
  710|      0|        __block FCompoundWrite *changedChildren = [FCompoundWrite emptyWrite];
  711|      0|        [affectedTree forEach:^(FPath *mergePath, id value) {
  712|      0|          FPath *serverCachePath = [ackPath child:mergePath];
  713|      0|          if ([serverCache isCompleteForPath:serverCachePath]) {
  714|      0|              changedChildren = [changedChildren
  715|      0|                  addWrite:[serverCache.node getChild:serverCachePath]
  716|      0|                    atPath:mergePath];
  717|      0|          }
  718|      0|        }];
  719|      0|        return [self applyServerMergeTo:viewCache
  720|      0|                                   path:ackPath
  721|      0|                        changedChildren:changedChildren
  722|      0|                            writesCache:writesCache
  723|      0|                          completeCache:optCompleteCache
  724|      0|                       filterServerNode:filterServerNode
  725|      0|                            accumulator:accumulator];
  726|      0|    }
  727|      0|}
  728|       |
  729|       |- (FViewCache *)revertUserWriteOn:(FViewCache *)viewCache
  730|       |                             path:(FPath *)path
  731|       |                      writesCache:(FWriteTreeRef *)writesCache
  732|       |                    completeCache:(id<FNode>)optCompleteCache
  733|      0|                      accumulator:(FChildChangeAccumulator *)accumulator {
  734|      0|    if ([writesCache shadowingWriteAtPath:path] != nil) {
  735|      0|        return viewCache;
  736|      0|    } else {
  737|      0|        id<FCompleteChildSource> source = [[FWriteTreeCompleteChildSource alloc]
  738|      0|            initWithWrites:writesCache
  739|      0|                 viewCache:viewCache
  740|      0|               serverCache:optCompleteCache];
  741|      0|        FIndexedNode *oldEventCache = viewCache.cachedEventSnap.indexedNode;
  742|      0|        FIndexedNode *newEventCache;
  743|      0|        if (path.isEmpty || [[path getFront] isEqualToString:@".priority"]) {
  744|      0|            id<FNode> newNode;
  745|      0|            if (viewCache.cachedServerSnap.isFullyInitialized) {
  746|      0|                newNode = [writesCache
  747|      0|                    calculateCompleteEventCacheWithCompleteServerCache:
  748|      0|                        viewCache.completeServerSnap];
  749|      0|            } else {
  750|      0|                newNode = [writesCache
  751|      0|                    calculateCompleteEventChildrenWithCompleteServerChildren:
  752|      0|                        viewCache.cachedServerSnap.node];
  753|      0|            }
  754|      0|            FIndexedNode *indexedNode =
  755|      0|                [FIndexedNode indexedNodeWithNode:newNode
  756|      0|                                            index:self.filter.index];
  757|      0|            newEventCache = [self.filter updateFullNode:oldEventCache
  758|      0|                                            withNewNode:indexedNode
  759|      0|                                            accumulator:accumulator];
  760|      0|        } else {
  761|      0|            NSString *childKey = [path getFront];
  762|      0|            id<FNode> newChild =
  763|      0|                [writesCache calculateCompleteChild:childKey
  764|      0|                                              cache:viewCache.cachedServerSnap];
  765|      0|            if (newChild == nil &&
  766|      0|                [viewCache.cachedServerSnap isCompleteForChild:childKey]) {
  767|      0|                newChild = [oldEventCache.node getImmediateChild:childKey];
  768|      0|            }
  769|      0|            if (newChild != nil) {
  770|      0|                newEventCache = [self.filter updateChildIn:oldEventCache
  771|      0|                                               forChildKey:childKey
  772|      0|                                                  newChild:newChild
  773|      0|                                              affectedPath:[path popFront]
  774|      0|                                                fromSource:source
  775|      0|                                               accumulator:accumulator];
  776|      0|            } else if (newChild == nil &&
  777|      0|                       [viewCache.cachedEventSnap.node hasChild:childKey]) {
  778|      0|                // No complete child available, delete the existing one, if any
  779|      0|                newEventCache =
  780|      0|                    [self.filter updateChildIn:oldEventCache
  781|      0|                                   forChildKey:childKey
  782|      0|                                      newChild:[FEmptyNode emptyNode]
  783|      0|                                  affectedPath:[path popFront]
  784|      0|                                    fromSource:source
  785|      0|                                   accumulator:accumulator];
  786|      0|            } else {
  787|      0|                newEventCache = oldEventCache;
  788|      0|            }
  789|      0|            if (newEventCache.node.isEmpty &&
  790|      0|                viewCache.cachedServerSnap.isFullyInitialized) {
  791|      0|                // We might have reverted all child writes. Maybe the old event
  792|      0|                // was a leaf node.
  793|      0|                id<FNode> complete = [writesCache
  794|      0|                    calculateCompleteEventCacheWithCompleteServerCache:
  795|      0|                        viewCache.completeServerSnap];
  796|      0|                if (complete.isLeafNode) {
  797|      0|                    FIndexedNode *indexed =
  798|      0|                        [FIndexedNode indexedNodeWithNode:complete];
  799|      0|                    newEventCache = [self.filter updateFullNode:newEventCache
  800|      0|                                                    withNewNode:indexed
  801|      0|                                                    accumulator:accumulator];
  802|      0|                }
  803|      0|            }
  804|      0|        }
  805|      0|        BOOL complete = viewCache.cachedServerSnap.isFullyInitialized ||
  806|      0|                        [writesCache shadowingWriteAtPath:[FPath empty]] != nil;
  807|      0|        return [viewCache updateEventSnap:newEventCache
  808|      0|                               isComplete:complete
  809|      0|                               isFiltered:self.filter.filtersNodes];
  810|      0|    }
  811|      0|}
  812|       |
  813|       |- (FViewCache *)listenCompleteOldCache:(FViewCache *)viewCache
  814|       |                                  path:(FPath *)path
  815|       |                           writesCache:(FWriteTreeRef *)writesCache
  816|       |                           serverCache:(id<FNode>)servercache
  817|      0|                           accumulator:(FChildChangeAccumulator *)accumulator {
  818|      0|    FCacheNode *oldServerNode = viewCache.cachedServerSnap;
  819|      0|    FViewCache *newViewCache = [viewCache
  820|      0|        updateServerSnap:oldServerNode.indexedNode
  821|      0|              isComplete:(oldServerNode.isFullyInitialized || path.isEmpty)
  822|      0|              isFiltered:oldServerNode.isFiltered];
  823|      0|    return [self
  824|      0|        generateEventCacheAfterServerEvent:newViewCache
  825|      0|                                      path:path
  826|      0|                               writesCache:writesCache
  827|      0|                                    source:[FNoCompleteChildSource instance]
  828|      0|                               accumulator:accumulator];
  829|      0|}
  830|       |
  831|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/FViewProcessorResult.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FViewProcessorResult.h"
   18|       |#import "FViewCache.h"
   19|       |
   20|       |@interface FViewProcessorResult ()
   21|       |@property(nonatomic, strong, readwrite) FViewCache *viewCache;
   22|       |@property(nonatomic, strong, readwrite) NSArray *changes;
   23|       |@end
   24|       |
   25|       |@implementation FViewProcessorResult
   26|      0|- (id)initWithViewCache:(FViewCache *)viewCache changes:(NSArray *)changes {
   27|      0|    self = [super init];
   28|      0|    if (self) {
   29|      0|        self.viewCache = viewCache;
   30|      0|        self.changes = changes;
   31|      0|    }
   32|      0|    return self;
   33|      0|}
   34|       |
   35|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Login/FAuthTokenProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FAuthTokenProvider.h"
   18|       |
   19|       |#import <FirebaseAuthInterop/FIRAuthInterop.h>
   20|       |#import <FirebaseCore/FIRAppInternal.h>
   21|       |#import <FirebaseCore/FIRComponentContainer.h>
   22|       |#import <FirebaseCore/FIRLogger.h>
   23|       |
   24|       |#import "FIRDatabaseQuery_Private.h"
   25|       |#import "FIRNoopAuthTokenProvider.h"
   26|       |#import "FUtilities.h"
   27|       |
   28|       |@interface FAuthStateListenerWrapper : NSObject
   29|       |
   30|       |@property(nonatomic, copy) fbt_void_nsstring listener;
   31|       |@property(nonatomic, weak) id<FIRAuthInterop> auth;
   32|       |
   33|       |@end
   34|       |
   35|       |@implementation FAuthStateListenerWrapper
   36|       |
   37|       |- (instancetype)initWithListener:(fbt_void_nsstring)listener
   38|      0|                            auth:(id<FIRAuthInterop>)auth {
   39|      0|    self = [super init];
   40|      0|    if (self != nil) {
   41|      0|        self->_listener = listener;
   42|      0|        self->_auth = auth;
   43|      0|        [[NSNotificationCenter defaultCenter]
   44|      0|            addObserver:self
   45|      0|               selector:@selector(authStateDidChangeNotification:)
   46|      0|                   name:FIRAuthStateDidChangeInternalNotification
   47|      0|                 object:nil];
   48|      0|    }
   49|      0|    return self;
   50|      0|}
   51|       |
   52|      0|- (void)authStateDidChangeNotification:(NSNotification *)notification {
   53|      0|    NSDictionary *userInfo = notification.userInfo;
   54|      0|    if (notification.object == self.auth) {
   55|      0|        NSString *token =
   56|      0|            userInfo[FIRAuthStateDidChangeInternalNotificationTokenKey];
   57|      0|        dispatch_async([FIRDatabaseQuery sharedQueue], ^{
   58|      0|          self.listener(token);
   59|      0|        });
   60|      0|    }
   61|      0|}
   62|       |
   63|      0|- (void)dealloc {
   64|      0|    [[NSNotificationCenter defaultCenter] removeObserver:self];
   65|      0|}
   66|       |
   67|       |@end
   68|       |
   69|       |@interface FIRFirebaseAuthTokenProvider : NSObject <FAuthTokenProvider>
   70|       |
   71|       |@property(nonatomic, strong) id<FIRAuthInterop> auth;
   72|       |/** Strong references to the auth listeners as they are only weak in
   73|       | * FIRFirebaseApp */
   74|       |@property(nonatomic, strong) NSMutableArray *authListeners;
   75|       |
   76|       |- (instancetype)initWithAuth:(id<FIRAuthInterop>)auth;
   77|       |
   78|       |@end
   79|       |
   80|       |@implementation FIRFirebaseAuthTokenProvider
   81|       |
   82|      0|- (instancetype)initWithAuth:(id<FIRAuthInterop>)auth {
   83|      0|    self = [super init];
   84|      0|    if (self != nil) {
   85|      0|        self->_auth = auth;
   86|      0|        self->_authListeners = [NSMutableArray array];
   87|      0|    }
   88|      0|    return self;
   89|      0|}
   90|       |
   91|       |- (void)fetchTokenForcingRefresh:(BOOL)forceRefresh
   92|      0|                    withCallback:(fbt_void_nsstring_nserror)callback {
   93|      0|    if (self.auth == nil) {
   94|      0|        // Signal that Auth is not available by returning nil.
   95|      0|        callback(nil, nil);
   96|      0|    } else {
   97|      0|        [self.auth getTokenForcingRefresh:forceRefresh
   98|      0|                             withCallback:^(NSString *_Nullable token,
   99|      0|                                            NSError *_Nullable error) {
  100|      0|                               dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  101|      0|                                 callback(token, error);
  102|      0|                               });
  103|      0|                             }];
  104|      0|    }
  105|      0|}
  106|       |
  107|      0|- (void)listenForTokenChanges:(_Nonnull fbt_void_nsstring)listener {
  108|      0|    FAuthStateListenerWrapper *wrapper =
  109|      0|        [[FAuthStateListenerWrapper alloc] initWithListener:listener
  110|      0|                                                       auth:self.auth];
  111|      0|    [self.authListeners addObject:wrapper];
  112|      0|}
  113|       |
  114|       |@end
  115|       |
  116|       |@implementation FAuthTokenProvider
  117|       |
  118|       |+ (id<FAuthTokenProvider>)authTokenProviderWithAuth:
  119|      0|    (id<FIRAuthInterop>)authInterop {
  120|      0|    return [[FIRFirebaseAuthTokenProvider alloc] initWithAuth:authInterop];
  121|      0|}
  122|       |
  123|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Login/FIRNoopAuthTokenProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRNoopAuthTokenProvider.h"
   18|       |#import "FAuthTokenProvider.h"
   19|       |#import "FIRDatabaseQuery_Private.h"
   20|       |
   21|       |@implementation FIRNoopAuthTokenProvider
   22|       |
   23|       |- (void)fetchTokenForcingRefresh:(BOOL)forceRefresh
   24|      0|                    withCallback:(fbt_void_nsstring_nserror)callback {
   25|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
   26|      0|      callback(nil, nil);
   27|      0|    });
   28|      0|}
   29|       |
   30|      0|- (void)listenForTokenChanges:(fbt_void_nsstring)listener {
   31|      0|    // no-op, because token never changes
   32|      0|}
   33|       |
   34|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FCachePolicy.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FCachePolicy.h"
   18|       |
   19|       |@interface FLRUCachePolicy ()
   20|       |
   21|       |@property(nonatomic, readwrite) NSUInteger maxSize;
   22|       |
   23|       |@end
   24|       |
   25|       |static const NSUInteger kFServerUpdatesBetweenCacheSizeChecks = 1000;
   26|       |static const NSUInteger kFMaxNumberOfPrunableQueriesToKeep = 1000;
   27|       |static const float kFPercentOfQueriesToPruneAtOnce = 0.2f;
   28|       |
   29|       |@implementation FLRUCachePolicy
   30|       |
   31|      0|- (id)initWithMaxSize:(NSUInteger)maxSize {
   32|      0|    self = [super init];
   33|      0|    if (self != nil) {
   34|      0|        self->_maxSize = maxSize;
   35|      0|    }
   36|      0|    return self;
   37|      0|}
   38|       |
   39|       |- (BOOL)shouldPruneCacheWithSize:(NSUInteger)cacheSize
   40|      0|          numberOfTrackedQueries:(NSUInteger)numTrackedQueries {
   41|      0|    return cacheSize > self.maxSize ||
   42|      0|           numTrackedQueries > kFMaxNumberOfPrunableQueriesToKeep;
   43|      0|}
   44|       |
   45|      0|- (BOOL)shouldCheckCacheSize:(NSUInteger)serverUpdatesSinceLastCheck {
   46|      0|    return serverUpdatesSinceLastCheck > kFServerUpdatesBetweenCacheSizeChecks;
   47|      0|}
   48|       |
   49|      0|- (float)percentOfQueriesToPruneAtOnce {
   50|      0|    return kFPercentOfQueriesToPruneAtOnce;
   51|      0|}
   52|       |
   53|      0|- (NSUInteger)maxNumberOfQueriesToKeep {
   54|      0|    return kFMaxNumberOfPrunableQueriesToKeep;
   55|      0|}
   56|       |
   57|       |@end
   58|       |
   59|       |@implementation FNoCachePolicy
   60|       |
   61|      0|+ (FNoCachePolicy *)noCachePolicy {
   62|      0|    return [[FNoCachePolicy alloc] init];
   63|      0|}
   64|       |
   65|       |- (BOOL)shouldPruneCacheWithSize:(NSUInteger)cacheSize
   66|      0|          numberOfTrackedQueries:(NSUInteger)numTrackedQueries {
   67|      0|    return NO;
   68|      0|}
   69|       |
   70|      0|- (BOOL)shouldCheckCacheSize:(NSUInteger)serverUpdatesSinceLastCheck {
   71|      0|    return NO;
   72|      0|}
   73|       |
   74|      0|- (float)percentOfQueriesToPruneAtOnce {
   75|      0|    return 0;
   76|      0|}
   77|       |
   78|      0|- (NSUInteger)maxNumberOfQueriesToKeep {
   79|      0|    return NSUIntegerMax;
   80|      0|}
   81|       |
   82|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FLevelDBStorageEngine.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import "FLevelDBStorageEngine.h"
   20|       |
   21|       |#import "APLevelDB.h"
   22|       |#import "FEmptyNode.h"
   23|       |#import "FPendingPut.h" // For legacy migration
   24|       |#import "FPruneForest.h"
   25|       |#import "FQueryParams.h"
   26|       |#import "FSnapshotUtilities.h"
   27|       |#import "FTrackedQuery.h"
   28|       |#import "FUtilities.h"
   29|       |#import "FWriteRecord.h"
   30|       |#import <FirebaseCore/FIRLogger.h>
   31|       |
   32|       |@interface FLevelDBStorageEngine ()
   33|       |
   34|       |@property(nonatomic, strong) NSString *basePath;
   35|       |@property(nonatomic, strong) APLevelDB *writesDB;
   36|       |@property(nonatomic, strong) APLevelDB *serverCacheDB;
   37|       |
   38|       |@end
   39|       |
   40|       |// WARNING: If you change this, you need to write a migration script
   41|       |static NSString *const kFPersistenceVersion = @"1";
   42|       |
   43|       |static NSString *const kFServerDBPath = @"server_data";
   44|       |static NSString *const kFWritesDBPath = @"writes";
   45|       |
   46|       |static NSString *const kFUserWriteId = @"id";
   47|       |static NSString *const kFUserWritePath = @"path";
   48|       |static NSString *const kFUserWriteOverwrite = @"o";
   49|       |static NSString *const kFUserWriteMerge = @"m";
   50|       |
   51|       |static NSString *const kFTrackedQueryId = @"id";
   52|       |static NSString *const kFTrackedQueryPath = @"path";
   53|       |static NSString *const kFTrackedQueryParams = @"p";
   54|       |static NSString *const kFTrackedQueryLastUse = @"lu";
   55|       |static NSString *const kFTrackedQueryIsComplete = @"c";
   56|       |static NSString *const kFTrackedQueryIsActive = @"a";
   57|       |
   58|       |static NSString *const kFServerCachePrefix = @"/server_cache/";
   59|       |// '~' is the last non-control character in the ASCII table until 127
   60|       |// We wan't the entire range of thing stored in the DB
   61|       |static NSString *const kFServerCacheRangeEnd = @"/server_cache~";
   62|       |static NSString *const kFTrackedQueriesPrefix = @"/tracked_queries/";
   63|       |static NSString *const kFTrackedQueryKeysPrefix = @"/tracked_query_keys/";
   64|       |
   65|       |// Failed to load JSON because a valid JSON turns out to be NaN while
   66|       |// deserializing
   67|       |static const NSInteger kFNanFailureCode = 3840;
   68|       |
   69|      0|static NSString *writeRecordKey(NSUInteger writeId) {
   70|      0|    return [NSString stringWithFormat:@"%lu", (unsigned long)(writeId)];
   71|      0|}
   72|       |
   73|      0|static NSString *serverCacheKey(FPath *path) {
   74|      0|    return [NSString stringWithFormat:@"%@%@", kFServerCachePrefix,
   75|      0|                                      ([path toStringWithTrailingSlash])];
   76|      0|}
   77|       |
   78|      0|static NSString *trackedQueryKey(NSUInteger trackedQueryId) {
   79|      0|    return [NSString stringWithFormat:@"%@%lu", kFTrackedQueriesPrefix,
   80|      0|                                      (unsigned long)trackedQueryId];
   81|      0|}
   82|       |
   83|      0|static NSString *trackedQueryKeysKeyPrefix(NSUInteger trackedQueryId) {
   84|      0|    return [NSString stringWithFormat:@"%@%lu/", kFTrackedQueryKeysPrefix,
   85|      0|                                      (unsigned long)trackedQueryId];
   86|      0|}
   87|       |
   88|      0|static NSString *trackedQueryKeysKey(NSUInteger trackedQueryId, NSString *key) {
   89|      0|    return [NSString stringWithFormat:@"%@%lu/%@", kFTrackedQueryKeysPrefix,
   90|      0|                                      (unsigned long)trackedQueryId, key];
   91|      0|}
   92|       |
   93|       |@implementation FLevelDBStorageEngine
   94|       |#pragma mark - Constructors
   95|       |
   96|      0|- (id)initWithPath:(NSString *)dbPath {
   97|      0|    self = [super init];
   98|      0|    if (self) {
   99|      0|        self.basePath = [[FLevelDBStorageEngine firebaseDir]
  100|      0|            stringByAppendingPathComponent:dbPath];
  101|      0|        /* For reference:
  102|      0|         serverDataDB = [aPersistence createDbByName:@"server_data"];
  103|      0|         FPangolinDB *completenessDb = [aPersistence
  104|      0|         createDbByName:@"server_complete"];
  105|      0|         */
  106|      0|        [FLevelDBStorageEngine ensureDir:self.basePath markAsDoNotBackup:YES];
  107|      0|        [self runMigration];
  108|      0|        [self openDatabases];
  109|      0|    }
  110|      0|    return self;
  111|      0|}
  112|       |
  113|      0|- (void)runMigration {
  114|      0|    // Currently we're at version 1, so all we need to do is write that to a
  115|      0|    // file
  116|      0|    NSString *versionFile =
  117|      0|        [self.basePath stringByAppendingPathComponent:@"version"];
  118|      0|    NSError *error;
  119|      0|    NSString *oldVersion =
  120|      0|        [NSString stringWithContentsOfFile:versionFile
  121|      0|                                  encoding:NSUTF8StringEncoding
  122|      0|                                     error:&error];
  123|      0|    if (!oldVersion) {
  124|      0|        // This is probably fine, we don't have a version file yet
  125|      0|        BOOL success = [kFPersistenceVersion writeToFile:versionFile
  126|      0|                                              atomically:NO
  127|      0|                                                encoding:NSUTF8StringEncoding
  128|      0|                                                   error:&error];
  129|      0|        if (!success) {
  130|      0|            FFWarn(@"I-RDB076001", @"Failed to write version for database: %@",
  131|      0|                   error);
  132|      0|        }
  133|      0|    } else if ([oldVersion isEqualToString:kFPersistenceVersion]) {
  134|      0|        // Everythings fine no need for migration
  135|      0|    } else {
  136|      0|        // If we add more versions in the future, we need to run migration here
  137|      0|        [NSException raise:NSInternalInconsistencyException
  138|      0|                    format:@"Unrecognized database version: %@", oldVersion];
  139|      0|    }
  140|      0|}
  141|       |
  142|      0|- (void)runLegacyMigration:(FRepoInfo *)info {
  143|      0|    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(
  144|      0|        NSDocumentDirectory, NSUserDomainMask, YES);
  145|      0|    NSString *documentsDir = [dirPaths objectAtIndex:0];
  146|      0|    NSString *firebaseDir =
  147|      0|        [documentsDir stringByAppendingPathComponent:@"firebase"];
  148|      0|    NSString *repoHashString =
  149|      0|        [NSString stringWithFormat:@"%@_%@", info.host, info.namespace];
  150|      0|    NSString *legacyBaseDir =
  151|      0|        [NSString stringWithFormat:@"%@/1/%@/v1", firebaseDir, repoHashString];
  152|      0|    if ([[NSFileManager defaultManager] fileExistsAtPath:legacyBaseDir]) {
  153|      0|        FFWarn(@"I-RDB076002", @"Legacy database found, migrating...");
  154|      0|        // We only need to migrate writes
  155|      0|        NSError *error = nil;
  156|      0|        APLevelDB *writes = [APLevelDB
  157|      0|            levelDBWithPath:[legacyBaseDir stringByAppendingPathComponent:
  158|      0|                                               @"outstanding_puts"]
  159|      0|                      error:&error];
  160|      0|        if (writes != nil) {
  161|      0|            __block NSUInteger numberOfWritesRestored = 0;
  162|      0|            // Maybe we could use write batches, but what the heck, I'm sure
  163|      0|            // it'll go fine :P
  164|      0|            [writes enumerateKeysAndValuesAsData:^(NSString *key, NSData *data,
  165|      0|                                                   BOOL *stop) {
  166|      0|              id pendingPut = [NSKeyedUnarchiver unarchiveObjectWithData:data];
  167|      0|              if ([pendingPut isKindOfClass:[FPendingPut class]]) {
  168|      0|                  FPendingPut *put = pendingPut;
  169|      0|                  id<FNode> newNode =
  170|      0|                      [FSnapshotUtilities nodeFrom:put.data
  171|      0|                                          priority:put.priority];
  172|      0|                  [self saveUserOverwrite:newNode
  173|      0|                                   atPath:put.path
  174|      0|                                  writeId:[key integerValue]];
  175|      0|                  numberOfWritesRestored++;
  176|      0|              } else if ([pendingPut
  177|      0|                             isKindOfClass:[FPendingPutPriority class]]) {
  178|      0|                  // This is for backwards compatibility. Older clients will
  179|      0|                  // save FPendingPutPriority. New ones will need to read it and
  180|      0|                  // translate.
  181|      0|                  FPendingPutPriority *putPriority = pendingPut;
  182|      0|                  FPath *priorityPath =
  183|      0|                      [putPriority.path childFromString:@".priority"];
  184|      0|                  id<FNode> newNode =
  185|      0|                      [FSnapshotUtilities nodeFrom:putPriority.priority
  186|      0|                                          priority:nil];
  187|      0|                  [self saveUserOverwrite:newNode
  188|      0|                                   atPath:priorityPath
  189|      0|                                  writeId:[key integerValue]];
  190|      0|                  numberOfWritesRestored++;
  191|      0|              } else if ([pendingPut isKindOfClass:[FPendingUpdate class]]) {
  192|      0|                  FPendingUpdate *update = pendingPut;
  193|      0|                  FCompoundWrite *merge = [FCompoundWrite
  194|      0|                      compoundWriteWithValueDictionary:update.data];
  195|      0|                  [self saveUserMerge:merge
  196|      0|                               atPath:update.path
  197|      0|                              writeId:[key integerValue]];
  198|      0|                  numberOfWritesRestored++;
  199|      0|              } else {
  200|      0|                  FFWarn(@"I-RDB076003",
  201|      0|                         @"Failed to migrate legacy write, meh!");
  202|      0|              }
  203|      0|            }];
  204|      0|            FFWarn(@"I-RDB076004", @"Migrated %lu writes",
  205|      0|                   (unsigned long)numberOfWritesRestored);
  206|      0|            [writes close];
  207|      0|            FFWarn(@"I-RDB076005", @"Deleting legacy database...");
  208|      0|            BOOL success =
  209|      0|                [[NSFileManager defaultManager] removeItemAtPath:legacyBaseDir
  210|      0|                                                           error:&error];
  211|      0|            if (!success) {
  212|      0|                FFWarn(@"I-RDB076006", @"Failed to delete legacy database: %@",
  213|      0|                       error);
  214|      0|            } else {
  215|      0|                FFWarn(@"I-RDB076007", @"Finished migrating legacy database.");
  216|      0|            }
  217|      0|        } else {
  218|      0|            FFWarn(@"I-RDB076008", @"Failed to migrate old database: %@",
  219|      0|                   error);
  220|      0|        }
  221|      0|    }
  222|      0|}
  223|       |
  224|      0|- (void)openDatabases {
  225|      0|    self.serverCacheDB = [self createDB:kFServerDBPath];
  226|      0|    self.writesDB = [self createDB:kFWritesDBPath];
  227|      0|}
  228|       |
  229|      0|- (void)purgeDatabase:(NSString *)dbPath {
  230|      0|    NSString *path = [self.basePath stringByAppendingPathComponent:dbPath];
  231|      0|    NSError *error;
  232|      0|    FFWarn(@"I-RDB076009", @"Deleting database at path %@", path);
  233|      0|    BOOL success = [[NSFileManager defaultManager] removeItemAtPath:path
  234|      0|                                                              error:&error];
  235|      0|    if (!success) {
  236|      0|        [NSException raise:NSInternalInconsistencyException
  237|      0|                    format:@"Failed to delete database files: %@", error];
  238|      0|    }
  239|      0|}
  240|       |
  241|      0|- (void)purgeEverything {
  242|      0|    [self close];
  243|      0|    [@[ kFServerDBPath, kFWritesDBPath ]
  244|      0|        enumerateObjectsUsingBlock:^(NSString *dbPath, NSUInteger idx,
  245|      0|                                     BOOL *stop) {
  246|      0|          [self purgeDatabase:dbPath];
  247|      0|        }];
  248|      0|
  249|      0|    [self openDatabases];
  250|      0|}
  251|       |
  252|      0|- (void)close {
  253|      0|    // autoreleasepool will cause deallocation which will close the DB
  254|      0|    @autoreleasepool {
  255|      0|        [self.serverCacheDB close];
  256|      0|        self.serverCacheDB = nil;
  257|      0|        [self.writesDB close];
  258|      0|        self.writesDB = nil;
  259|      0|    }
  260|      0|}
  261|       |
  262|      0|+ (NSString *)firebaseDir {
  263|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  264|      0|    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(
  265|      0|        NSDocumentDirectory, NSUserDomainMask, YES);
  266|      0|    NSString *documentsDir = [dirPaths objectAtIndex:0];
  267|      0|    return [documentsDir stringByAppendingPathComponent:@"firebase"];
  268|       |#elif TARGET_OS_OSX
  269|       |    return [NSHomeDirectory() stringByAppendingPathComponent:@".firebase"];
  270|       |#endif
  271|       |}
  272|       |
  273|      0|- (APLevelDB *)createDB:(NSString *)dbName {
  274|      0|    NSError *err = nil;
  275|      0|    NSString *path = [self.basePath stringByAppendingPathComponent:dbName];
  276|      0|    APLevelDB *db = [APLevelDB levelDBWithPath:path error:&err];
  277|      0|
  278|      0|    if (err) {
  279|      0|        FFWarn(@"I-RDB076036",
  280|      0|               @"Failed to read database persistence file '%@': %@", dbName,
  281|      0|               [err localizedDescription]);
  282|      0|        err = nil;
  283|      0|
  284|      0|        // Delete the database and try again.
  285|      0|        [self purgeDatabase:dbName];
  286|      0|        db = [APLevelDB levelDBWithPath:path error:&err];
  287|      0|
  288|      0|        if (err) {
  289|      0|            NSString *reason = [NSString
  290|      0|                stringWithFormat:@"Error initializing persistence: %@",
  291|      0|                                 [err description]];
  292|      0|            @throw [NSException
  293|      0|                exceptionWithName:@"FirebaseDatabasePersistenceFailure"
  294|      0|                           reason:reason
  295|      0|                         userInfo:nil];
  296|      0|        }
  297|      0|    }
  298|      0|
  299|      0|    return db;
  300|      0|}
  301|       |
  302|       |- (void)saveUserOverwrite:(id<FNode>)node
  303|       |                   atPath:(FPath *)path
  304|      0|                  writeId:(NSUInteger)writeId {
  305|      0|    NSDictionary *write = @{
  306|      0|        kFUserWriteId : @(writeId),
  307|      0|        kFUserWritePath : [path toStringWithTrailingSlash],
  308|      0|        kFUserWriteOverwrite : [node valForExport:YES]
  309|      0|    };
  310|      0|    NSError *error = nil;
  311|      0|    NSData *data = [NSJSONSerialization dataWithJSONObject:write
  312|      0|                                                   options:0
  313|      0|                                                     error:&error];
  314|      0|    NSAssert(data, @"Failed to serialize user overwrite: %@, (Error: %@)",
  315|      0|             write, error);
  316|      0|    [self.writesDB setData:data forKey:writeRecordKey(writeId)];
  317|      0|}
  318|       |
  319|       |- (void)saveUserMerge:(FCompoundWrite *)merge
  320|       |               atPath:(FPath *)path
  321|      0|              writeId:(NSUInteger)writeId {
  322|      0|    NSDictionary *write = @{
  323|      0|        kFUserWriteId : @(writeId),
  324|      0|        kFUserWritePath : [path toStringWithTrailingSlash],
  325|      0|        kFUserWriteMerge : [merge valForExport:YES]
  326|      0|    };
  327|      0|    NSError *error = nil;
  328|      0|    NSData *data = [NSJSONSerialization dataWithJSONObject:write
  329|      0|                                                   options:0
  330|      0|                                                     error:&error];
  331|      0|    NSAssert(data, @"Failed to serialize user merge: %@ (Error: %@)", write,
  332|      0|             error);
  333|      0|    [self.writesDB setData:data forKey:writeRecordKey(writeId)];
  334|      0|}
  335|       |
  336|      0|- (void)removeUserWrite:(NSUInteger)writeId {
  337|      0|    [self.writesDB removeKey:writeRecordKey(writeId)];
  338|      0|}
  339|       |
  340|      0|- (void)removeAllUserWrites {
  341|      0|    __block NSUInteger count = 0;
  342|      0|    NSDate *start = [NSDate date];
  343|      0|    id<APLevelDBWriteBatch> batch = [self.writesDB beginWriteBatch];
  344|      0|    [self.writesDB enumerateKeys:^(NSString *key, BOOL *stop) {
  345|      0|      [batch removeKey:key];
  346|      0|      count++;
  347|      0|    }];
  348|      0|    BOOL success = [batch commit];
  349|      0|    if (!success) {
  350|      0|        FFWarn(@"I-RDB076010", @"Failed to remove all users writes on disk!");
  351|      0|    } else {
  352|      0|        FFDebug(@"I-RDB076011", @"Removed %lu writes in %fms",
  353|      0|                (unsigned long)count, [start timeIntervalSinceNow] * -1000);
  354|      0|    }
  355|      0|}
  356|       |
  357|      0|- (NSArray *)userWrites {
  358|      0|    NSDate *date = [NSDate date];
  359|      0|    NSMutableArray *writes = [NSMutableArray array];
  360|      0|    [self.writesDB enumerateKeysAndValuesAsData:^(NSString *key, NSData *data,
  361|      0|                                                  BOOL *stop) {
  362|      0|      NSError *error = nil;
  363|      0|      NSDictionary *writeJSON = [NSJSONSerialization JSONObjectWithData:data
  364|      0|                                                                options:0
  365|      0|                                                                  error:&error];
  366|      0|      if (writeJSON == nil) {
  367|      0|          if (error.code == kFNanFailureCode) {
  368|      0|              FFWarn(@"I-RDB076012",
  369|      0|                     @"Failed to deserialize write (%@), likely because of out "
  370|      0|                     @"of range doubles (Error: %@)",
  371|      0|                     [[NSString alloc] initWithData:data
  372|      0|                                           encoding:NSUTF8StringEncoding],
  373|      0|                     error);
  374|      0|              FFWarn(@"I-RDB076013", @"Removing failed write with key %@", key);
  375|      0|              [self.writesDB removeKey:key];
  376|      0|          } else {
  377|      0|              [NSException raise:NSInternalInconsistencyException
  378|      0|                          format:@"Failed to deserialize write: %@", error];
  379|      0|          }
  380|      0|      } else {
  381|      0|          NSInteger writeId =
  382|      0|              ((NSNumber *)writeJSON[kFUserWriteId]).integerValue;
  383|      0|          FPath *path = [FPath pathWithString:writeJSON[kFUserWritePath]];
  384|      0|          FWriteRecord *writeRecord;
  385|      0|          if (writeJSON[kFUserWriteMerge] != nil) {
  386|      0|              // It's a merge
  387|      0|              FCompoundWrite *merge = [FCompoundWrite
  388|      0|                  compoundWriteWithValueDictionary:writeJSON[kFUserWriteMerge]];
  389|      0|              writeRecord = [[FWriteRecord alloc] initWithPath:path
  390|      0|                                                         merge:merge
  391|      0|                                                       writeId:writeId];
  392|      0|          } else {
  393|      0|              // It's an overwrite
  394|      0|              NSAssert(writeJSON[kFUserWriteOverwrite] != nil,
  395|      0|                       @"Persisted write did not contain merge or overwrite!");
  396|      0|              id<FNode> node =
  397|      0|                  [FSnapshotUtilities nodeFrom:writeJSON[kFUserWriteOverwrite]];
  398|      0|              writeRecord = [[FWriteRecord alloc] initWithPath:path
  399|      0|                                                     overwrite:node
  400|      0|                                                       writeId:writeId
  401|      0|                                                       visible:YES];
  402|      0|          }
  403|      0|          [writes addObject:writeRecord];
  404|      0|      }
  405|      0|    }];
  406|      0|    // Make sure writes are sorted
  407|      0|    [writes sortUsingComparator:^NSComparisonResult(FWriteRecord *one,
  408|      0|                                                    FWriteRecord *two) {
  409|      0|      if (one.writeId < two.writeId) {
  410|      0|          return NSOrderedAscending;
  411|      0|      } else if (one.writeId > two.writeId) {
  412|      0|          return NSOrderedDescending;
  413|      0|      } else {
  414|      0|          return NSOrderedSame;
  415|      0|      }
  416|      0|    }];
  417|      0|    FFDebug(@"I-RDB076014", @"Loaded %lu writes in %fms",
  418|      0|            (unsigned long)writes.count, [date timeIntervalSinceNow] * -1000);
  419|      0|    return writes;
  420|      0|}
  421|       |
  422|      0|- (id<FNode>)serverCacheAtPath:(FPath *)path {
  423|      0|    NSDate *start = [NSDate date];
  424|      0|    id data = [self internalNestedDataForPath:path];
  425|      0|    id<FNode> node = [FSnapshotUtilities nodeFrom:data];
  426|      0|    FFDebug(@"I-RDB076015", @"Loaded node with %d children at %@ in %fms",
  427|      0|            [node numChildren], path, [start timeIntervalSinceNow] * -1000);
  428|      0|    return node;
  429|      0|}
  430|       |
  431|      0|- (id<FNode>)serverCacheForKeys:(NSSet *)keys atPath:(FPath *)path {
  432|      0|    NSDate *start = [NSDate date];
  433|      0|    __block id<FNode> node = [FEmptyNode emptyNode];
  434|      0|    [keys enumerateObjectsUsingBlock:^(NSString *key, BOOL *stop) {
  435|      0|      id data = [self internalNestedDataForPath:[path childFromString:key]];
  436|      0|      node = [node updateImmediateChild:key
  437|      0|                           withNewChild:[FSnapshotUtilities nodeFrom:data]];
  438|      0|    }];
  439|      0|    FFDebug(@"I-RDB076016",
  440|      0|            @"Loaded node with %d children for %lu keys at %@ in %fms",
  441|      0|            [node numChildren], (unsigned long)keys.count, path,
  442|      0|            [start timeIntervalSinceNow] * -1000);
  443|      0|    return node;
  444|      0|}
  445|       |
  446|       |- (void)updateServerCache:(id<FNode>)node
  447|       |                   atPath:(FPath *)path
  448|      0|                    merge:(BOOL)merge {
  449|      0|    NSDate *start = [NSDate date];
  450|      0|    id<APLevelDBWriteBatch> batch = [self.serverCacheDB beginWriteBatch];
  451|      0|    // Remove any leaf nodes that might be higher up
  452|      0|    [self removeAllLeafNodesOnPath:path batch:batch];
  453|      0|    __block NSUInteger counter = 0;
  454|      0|    if (merge) {
  455|      0|        // remove any children that exist
  456|      0|        [node enumerateChildrenUsingBlock:^(NSString *childKey,
  457|      0|                                            id<FNode> childNode, BOOL *stop) {
  458|      0|          FPath *childPath = [path childFromString:childKey];
  459|      0|          [self removeAllWithPrefix:serverCacheKey(childPath)
  460|      0|                              batch:batch
  461|      0|                           database:self.serverCacheDB];
  462|      0|          [self saveNodeInternal:childNode
  463|      0|                          atPath:childPath
  464|      0|                           batch:batch
  465|      0|                         counter:&counter];
  466|      0|        }];
  467|      0|    } else {
  468|      0|        // remove everything
  469|      0|        [self removeAllWithPrefix:serverCacheKey(path)
  470|      0|                            batch:batch
  471|      0|                         database:self.serverCacheDB];
  472|      0|        [self saveNodeInternal:node atPath:path batch:batch counter:&counter];
  473|      0|    }
  474|      0|    BOOL success = [batch commit];
  475|      0|    if (!success) {
  476|      0|        FFWarn(@"I-RDB076017", @"Failed to update server cache on disk!");
  477|      0|    } else {
  478|      0|        FFDebug(@"I-RDB076018", @"Saved %lu leaf nodes for overwrite in %fms",
  479|      0|                (unsigned long)counter, [start timeIntervalSinceNow] * -1000);
  480|      0|    }
  481|      0|}
  482|       |
  483|       |- (void)updateServerCacheWithMerge:(FCompoundWrite *)merge
  484|      0|                            atPath:(FPath *)path {
  485|      0|    NSDate *start = [NSDate date];
  486|      0|    __block NSUInteger counter = 0;
  487|      0|    id<APLevelDBWriteBatch> batch = [self.serverCacheDB beginWriteBatch];
  488|      0|    // Remove any leaf nodes that might be higher up
  489|      0|    [self removeAllLeafNodesOnPath:path batch:batch];
  490|      0|    [merge enumerateWrites:^(FPath *relativePath, id<FNode> node, BOOL *stop) {
  491|      0|      FPath *childPath = [path child:relativePath];
  492|      0|      [self removeAllWithPrefix:serverCacheKey(childPath)
  493|      0|                          batch:batch
  494|      0|                       database:self.serverCacheDB];
  495|      0|      [self saveNodeInternal:node
  496|      0|                      atPath:childPath
  497|      0|                       batch:batch
  498|      0|                     counter:&counter];
  499|      0|    }];
  500|      0|    BOOL success = [batch commit];
  501|      0|    if (!success) {
  502|      0|        FFWarn(@"I-RDB076019", @"Failed to update server cache on disk!");
  503|      0|    } else {
  504|      0|        FFDebug(@"I-RDB076020", @"Saved %lu leaf nodes for merge in %fms",
  505|      0|                (unsigned long)counter, [start timeIntervalSinceNow] * -1000);
  506|      0|    }
  507|      0|}
  508|       |
  509|       |- (void)saveNodeInternal:(id<FNode>)node
  510|       |                  atPath:(FPath *)path
  511|       |                   batch:(id<APLevelDBWriteBatch>)batch
  512|      0|                 counter:(NSUInteger *)counter {
  513|      0|    id data = [node valForExport:YES];
  514|      0|    if (data != nil && ![data isKindOfClass:[NSNull class]]) {
  515|      0|        [self internalSetNestedData:data
  516|      0|                             forKey:serverCacheKey(path)
  517|      0|                          withBatch:batch
  518|      0|                            counter:counter];
  519|      0|    }
  520|      0|}
  521|       |
  522|      0|- (NSUInteger)serverCacheEstimatedSizeInBytes {
  523|      0|    // Use the exact size, because for pruning the approximate size can lead to
  524|      0|    // weird situations where we prune everything because no compaction is ever
  525|      0|    // run
  526|      0|    return [self.serverCacheDB exactSizeFrom:kFServerCachePrefix
  527|      0|                                          to:kFServerCacheRangeEnd];
  528|      0|}
  529|       |
  530|      0|- (void)pruneCache:(FPruneForest *)pruneForest atPath:(FPath *)path {
  531|      0|    // TODO: be more intelligent, don't scan entire database...
  532|      0|
  533|      0|    __block NSUInteger pruned = 0;
  534|      0|    __block NSUInteger kept = 0;
  535|      0|    NSDate *start = [NSDate date];
  536|      0|
  537|      0|    NSString *prefix = serverCacheKey(path);
  538|      0|    id<APLevelDBWriteBatch> batch = [self.serverCacheDB beginWriteBatch];
  539|      0|
  540|      0|    [self.serverCacheDB
  541|      0|        enumerateKeysWithPrefix:prefix
  542|      0|                     usingBlock:^(NSString *dbKey, BOOL *stop) {
  543|      0|                       NSString *pathStr =
  544|      0|                           [dbKey substringFromIndex:prefix.length];
  545|      0|                       FPath *relativePath = [[FPath alloc] initWith:pathStr];
  546|      0|                       if ([pruneForest shouldPruneUnkeptDescendantsAtPath:
  547|      0|                                            relativePath]) {
  548|      0|                           pruned++;
  549|      0|                           [batch removeKey:dbKey];
  550|      0|                       } else {
  551|      0|                           kept++;
  552|      0|                       }
  553|      0|                     }];
  554|      0|    BOOL success = [batch commit];
  555|      0|    if (!success) {
  556|      0|        FFWarn(@"I-RDB076021", @"Failed to prune cache on disk!");
  557|      0|    } else {
  558|      0|        FFDebug(@"I-RDB076022", @"Pruned %lu paths, kept %lu paths in %fms",
  559|      0|                (unsigned long)pruned, (unsigned long)kept,
  560|      0|                [start timeIntervalSinceNow] * -1000);
  561|      0|    }
  562|      0|}
  563|       |
  564|       |#pragma mark - Tracked Queries
  565|       |
  566|      0|- (NSArray *)loadTrackedQueries {
  567|      0|    NSDate *date = [NSDate date];
  568|      0|    NSMutableArray *trackedQueries = [NSMutableArray array];
  569|      0|    [self.serverCacheDB
  570|      0|        enumerateKeysWithPrefix:kFTrackedQueriesPrefix
  571|      0|                         asData:^(NSString *key, NSData *data, BOOL *stop) {
  572|      0|                           NSError *error = nil;
  573|      0|                           NSDictionary *queryJSON =
  574|      0|                               [NSJSONSerialization JSONObjectWithData:data
  575|      0|                                                               options:0
  576|      0|                                                                 error:&error];
  577|      0|                           if (queryJSON == nil) {
  578|      0|                               if (error.code == kFNanFailureCode) {
  579|      0|                                   FFWarn(
  580|      0|                                       @"I-RDB076023",
  581|      0|                                       @"Failed to deserialize tracked query "
  582|      0|                                       @"(%@), likely because of out of range "
  583|      0|                                       @"doubles (Error: %@)",
  584|      0|                                       [[NSString alloc]
  585|      0|                                           initWithData:data
  586|      0|                                               encoding:NSUTF8StringEncoding],
  587|      0|                                       error);
  588|      0|                                   FFWarn(@"I-RDB076024",
  589|      0|                                          @"Removing failed tracked query with "
  590|      0|                                          @"key %@",
  591|      0|                                          key);
  592|      0|                                   [self.serverCacheDB removeKey:key];
  593|      0|                               } else {
  594|      0|                                   [NSException
  595|      0|                                        raise:NSInternalInconsistencyException
  596|      0|                                       format:@"Failed to deserialize tracked "
  597|      0|                                              @"query: %@",
  598|      0|                                              error];
  599|      0|                               }
  600|      0|                           } else {
  601|      0|                               NSUInteger queryId =
  602|      0|                                   ((NSNumber *)queryJSON[kFTrackedQueryId])
  603|      0|                                       .unsignedIntegerValue;
  604|      0|                               FPath *path =
  605|      0|                                   [FPath pathWithString:
  606|      0|                                              queryJSON[kFTrackedQueryPath]];
  607|      0|                               FQueryParams *params = [FQueryParams
  608|      0|                                   fromQueryObject:queryJSON
  609|      0|                                                       [kFTrackedQueryParams]];
  610|      0|                               FQuerySpec *query =
  611|      0|                                   [[FQuerySpec alloc] initWithPath:path
  612|      0|                                                             params:params];
  613|      0|                               BOOL isComplete =
  614|      0|                                   [queryJSON[kFTrackedQueryIsComplete]
  615|      0|                                       boolValue];
  616|      0|                               BOOL isActive =
  617|      0|                                   [queryJSON[kFTrackedQueryIsActive]
  618|      0|                                       boolValue];
  619|      0|                               NSTimeInterval lastUse =
  620|      0|                                   [queryJSON[kFTrackedQueryLastUse]
  621|      0|                                       doubleValue];
  622|      0|
  623|      0|                               FTrackedQuery *trackedQuery =
  624|      0|                                   [[FTrackedQuery alloc]
  625|      0|                                       initWithId:queryId
  626|      0|                                            query:query
  627|      0|                                          lastUse:lastUse
  628|      0|                                         isActive:isActive
  629|      0|                                       isComplete:isComplete];
  630|      0|
  631|      0|                               [trackedQueries addObject:trackedQuery];
  632|      0|                           }
  633|      0|                         }];
  634|      0|    FFDebug(@"I-RDB076025", @"Loaded %lu tracked queries in %fms",
  635|      0|            (unsigned long)trackedQueries.count,
  636|      0|            [date timeIntervalSinceNow] * -1000);
  637|      0|    return trackedQueries;
  638|      0|}
  639|       |
  640|      0|- (void)removeTrackedQuery:(NSUInteger)queryId {
  641|      0|    NSDate *start = [NSDate date];
  642|      0|    id<APLevelDBWriteBatch> batch = [self.serverCacheDB beginWriteBatch];
  643|      0|    [batch removeKey:trackedQueryKey(queryId)];
  644|      0|    __block NSUInteger keyCount = 0;
  645|      0|    [self.serverCacheDB
  646|      0|        enumerateKeysWithPrefix:trackedQueryKeysKeyPrefix(queryId)
  647|      0|                     usingBlock:^(NSString *key, BOOL *stop) {
  648|      0|                       [batch removeKey:key];
  649|      0|                       keyCount++;
  650|      0|                     }];
  651|      0|
  652|      0|    BOOL success = [batch commit];
  653|      0|    if (!success) {
  654|      0|        FFWarn(@"I-RDB076026", @"Failed to remove tracked query on disk!");
  655|      0|    } else {
  656|      0|        FFDebug(@"I-RDB076027",
  657|      0|                @"Removed query with id %lu (and removed %lu keys) in %fms",
  658|      0|                (unsigned long)queryId, (unsigned long)keyCount,
  659|      0|                [start timeIntervalSinceNow] * -1000);
  660|      0|    }
  661|      0|}
  662|       |
  663|      0|- (void)saveTrackedQuery:(FTrackedQuery *)query {
  664|      0|    NSDate *start = [NSDate date];
  665|      0|    NSDictionary *trackedQuery = @{
  666|      0|        kFTrackedQueryId : @(query.queryId),
  667|      0|        kFTrackedQueryPath : [query.query.path toStringWithTrailingSlash],
  668|      0|        kFTrackedQueryParams : [query.query.params wireProtocolParams],
  669|      0|        kFTrackedQueryLastUse : @(query.lastUse),
  670|      0|        kFTrackedQueryIsComplete : @(query.isComplete),
  671|      0|        kFTrackedQueryIsActive : @(query.isActive)
  672|      0|    };
  673|      0|    NSError *error = nil;
  674|      0|    NSData *data = [NSJSONSerialization dataWithJSONObject:trackedQuery
  675|      0|                                                   options:0
  676|      0|                                                     error:&error];
  677|      0|    NSAssert(data, @"Failed to serialize tracked query (Error: %@)", error);
  678|      0|    [self.serverCacheDB setData:data forKey:trackedQueryKey(query.queryId)];
  679|      0|    FFDebug(@"I-RDB076028", @"Saved tracked query %lu in %fms",
  680|      0|            (unsigned long)query.queryId, [start timeIntervalSinceNow] * -1000);
  681|      0|}
  682|       |
  683|      0|- (void)setTrackedQueryKeys:(NSSet *)keys forQueryId:(NSUInteger)queryId {
  684|      0|    NSDate *start = [NSDate date];
  685|      0|    __block NSUInteger removed = 0;
  686|      0|    __block NSUInteger added = 0;
  687|      0|    id<APLevelDBWriteBatch> batch = [self.serverCacheDB beginWriteBatch];
  688|      0|    NSMutableSet *seenKeys = [NSMutableSet set];
  689|      0|    // First, delete any keys that might be stored and are not part of the
  690|      0|    // current keys
  691|      0|    [self.serverCacheDB
  692|      0|        enumerateKeysWithPrefix:trackedQueryKeysKeyPrefix(queryId)
  693|      0|                      asStrings:^(NSString *dbKey, NSString *actualKey,
  694|      0|                                  BOOL *stop) {
  695|      0|                        if ([keys containsObject:actualKey]) {
  696|      0|                            // Already in DB
  697|      0|                            [seenKeys addObject:actualKey];
  698|      0|                        } else {
  699|      0|                            // Not part of set, delete key
  700|      0|                            [batch removeKey:dbKey];
  701|      0|                            removed++;
  702|      0|                        }
  703|      0|                      }];
  704|      0|
  705|      0|    // Next add any keys that are missing in the database
  706|      0|    [keys enumerateObjectsUsingBlock:^(NSString *childKey, BOOL *stop) {
  707|      0|      if (![seenKeys containsObject:childKey]) {
  708|      0|          [batch setString:childKey
  709|      0|                    forKey:trackedQueryKeysKey(queryId, childKey)];
  710|      0|          added++;
  711|      0|      }
  712|      0|    }];
  713|      0|    BOOL success = [batch commit];
  714|      0|    if (!success) {
  715|      0|        FFWarn(@"I-RDB076029", @"Failed to set tracked queries on disk!");
  716|      0|    } else {
  717|      0|        FFDebug(@"I-RDB076030",
  718|      0|                @"Set %lu tracked keys (%lu added, %lu removed) for query %lu "
  719|      0|                @"in %fms",
  720|      0|                (unsigned long)keys.count, (unsigned long)added,
  721|      0|                (unsigned long)removed, (unsigned long)queryId,
  722|      0|                [start timeIntervalSinceNow] * -1000);
  723|      0|    }
  724|      0|}
  725|       |
  726|       |- (void)updateTrackedQueryKeysWithAddedKeys:(NSSet *)added
  727|       |                                removedKeys:(NSSet *)removed
  728|      0|                                 forQueryId:(NSUInteger)queryId {
  729|      0|    NSDate *start = [NSDate date];
  730|      0|    id<APLevelDBWriteBatch> batch = [self.serverCacheDB beginWriteBatch];
  731|      0|    [removed enumerateObjectsUsingBlock:^(NSString *key, BOOL *stop) {
  732|      0|      [batch removeKey:trackedQueryKeysKey(queryId, key)];
  733|      0|    }];
  734|      0|    [added enumerateObjectsUsingBlock:^(NSString *key, BOOL *stop) {
  735|      0|      [batch setString:key forKey:trackedQueryKeysKey(queryId, key)];
  736|      0|    }];
  737|      0|    BOOL success = [batch commit];
  738|      0|    if (!success) {
  739|      0|        FFWarn(@"I-RDB076031", @"Failed to update tracked queries on disk!");
  740|      0|    } else {
  741|      0|        FFDebug(@"I-RDB076032",
  742|      0|                @"Added %lu tracked keys, removed %lu for query %lu in %fms",
  743|      0|                (unsigned long)added.count, (unsigned long)removed.count,
  744|      0|                (unsigned long)queryId, [start timeIntervalSinceNow] * -1000);
  745|      0|    }
  746|      0|}
  747|       |
  748|      0|- (NSSet *)trackedQueryKeysForQuery:(NSUInteger)queryId {
  749|      0|    NSDate *start = [NSDate date];
  750|      0|    NSMutableSet *set = [NSMutableSet set];
  751|      0|    [self.serverCacheDB
  752|      0|        enumerateKeysWithPrefix:trackedQueryKeysKeyPrefix(queryId)
  753|      0|                      asStrings:^(NSString *dbKey, NSString *actualKey,
  754|      0|                                  BOOL *stop) {
  755|      0|                        [set addObject:actualKey];
  756|      0|                      }];
  757|      0|    FFDebug(@"I-RDB076033", @"Loaded %lu tracked keys for query %lu in %fms",
  758|      0|            (unsigned long)set.count, (unsigned long)queryId,
  759|      0|            [start timeIntervalSinceNow] * -1000);
  760|      0|    return set;
  761|      0|}
  762|       |
  763|       |#pragma mark - Internal methods
  764|       |
  765|       |- (void)removeAllLeafNodesOnPath:(FPath *)path
  766|      0|                           batch:(id<APLevelDBWriteBatch>)batch {
  767|      0|    while (!path.isEmpty) {
  768|      0|        [batch removeKey:serverCacheKey(path)];
  769|      0|        path = [path parent];
  770|      0|    }
  771|      0|    // Make sure to delete any nodes at the root
  772|      0|    [batch removeKey:serverCacheKey([FPath empty])];
  773|      0|}
  774|       |
  775|       |- (void)removeAllWithPrefix:(NSString *)prefix
  776|       |                      batch:(id<APLevelDBWriteBatch>)batch
  777|      0|                   database:(APLevelDB *)database {
  778|      0|    assert(prefix != nil);
  779|      0|
  780|      0|    [database enumerateKeysWithPrefix:prefix
  781|      0|                           usingBlock:^(NSString *key, BOOL *stop) {
  782|      0|                             [batch removeKey:key];
  783|      0|                           }];
  784|      0|}
  785|       |
  786|       |#pragma mark - Internal helper methods
  787|       |
  788|       |- (void)internalSetNestedData:(id)value
  789|       |                       forKey:(NSString *)key
  790|       |                    withBatch:(id<APLevelDBWriteBatch>)batch
  791|      0|                      counter:(NSUInteger *)counter {
  792|      0|    if ([value isKindOfClass:[NSDictionary class]]) {
  793|      0|        NSDictionary *dictionary = value;
  794|      0|        [dictionary enumerateKeysAndObjectsUsingBlock:^(id childKey, id obj,
  795|      0|                                                        BOOL *stop) {
  796|      0|          assert(obj != nil);
  797|      0|          NSString *childPath =
  798|      0|              [NSString stringWithFormat:@"%@%@/", key, childKey];
  799|      0|          [self internalSetNestedData:obj
  800|      0|                               forKey:childPath
  801|      0|                            withBatch:batch
  802|      0|                              counter:counter];
  803|      0|        }];
  804|      0|    } else {
  805|      0|        NSData *data = [self serializePrimitive:value];
  806|      0|        [batch setData:data forKey:key];
  807|      0|        (*counter)++;
  808|      0|    }
  809|      0|}
  810|       |
  811|      0|- (id)internalNestedDataForPath:(FPath *)path {
  812|      0|    NSAssert(path != nil, @"Path was nil!");
  813|      0|
  814|      0|    NSString *baseKey = serverCacheKey(path);
  815|      0|
  816|      0|    // HACK to make sure iter is freed now to avoid race conditions (if self.db
  817|      0|    // is deleted before iter, you get an access violation).
  818|      0|    @autoreleasepool {
  819|      0|        APLevelDBIterator *iter =
  820|      0|            [APLevelDBIterator iteratorWithLevelDB:self.serverCacheDB];
  821|      0|
  822|      0|        [iter seekToKey:baseKey];
  823|      0|        if (iter.key == nil || ![iter.key hasPrefix:baseKey]) {
  824|      0|            // No data.
  825|      0|            return nil;
  826|      0|        } else {
  827|      0|            return [self internalNestedDataFromIterator:iter
  828|      0|                                           andKeyPrefix:baseKey];
  829|      0|        }
  830|      0|    }
  831|      0|}
  832|       |
  833|       |- (id)internalNestedDataFromIterator:(APLevelDBIterator *)iterator
  834|      0|                        andKeyPrefix:(NSString *)prefix {
  835|      0|    NSString *key = iterator.key;
  836|      0|
  837|      0|    if ([key isEqualToString:prefix]) {
  838|      0|        id result = [self deserializePrimitive:iterator.valueAsData];
  839|      0|        [iterator nextKey];
  840|      0|        return result;
  841|      0|    } else {
  842|      0|        NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];
  843|      0|        while (key != nil && [key hasPrefix:prefix]) {
  844|      0|            NSString *relativePath = [key substringFromIndex:prefix.length];
  845|      0|            NSArray *pathPieces =
  846|      0|                [relativePath componentsSeparatedByString:@"/"];
  847|      0|            assert(pathPieces.count > 0);
  848|      0|            NSString *childName = pathPieces[0];
  849|      0|            NSString *childPath =
  850|      0|                [NSString stringWithFormat:@"%@%@/", prefix, childName];
  851|      0|            id childValue = [self internalNestedDataFromIterator:iterator
  852|      0|                                                    andKeyPrefix:childPath];
  853|      0|            [dict setValue:childValue forKey:childName];
  854|      0|
  855|      0|            key = iterator.key;
  856|      0|        }
  857|      0|        return dict;
  858|      0|    }
  859|      0|}
  860|       |
  861|      0|- (NSData *)serializePrimitive:(id)value {
  862|      0|    // HACK: The built-in serialization only works on dicts and arrays.  So we
  863|      0|    // create an array and then strip off the leading / trailing byte (the [ and
  864|      0|    // ]).
  865|      0|    NSError *error = nil;
  866|      0|    NSData *data = [NSJSONSerialization dataWithJSONObject:@[ value ]
  867|      0|                                                   options:0
  868|      0|                                                     error:&error];
  869|      0|    NSAssert(data, @"Failed to serialize primitive: %@", error);
  870|      0|
  871|      0|    return [data subdataWithRange:NSMakeRange(1, data.length - 2)];
  872|      0|}
  873|       |
  874|       |- (id)fixDoubleParsing:(id)value
  875|      0|    __attribute__((no_sanitize("float-cast-overflow"))) {
  876|      0|    if ([value isKindOfClass:[NSDecimalNumber class]]) {
  877|      0|        // In case the value is an NSDecimalNumber, we may be dealing with
  878|      0|        // precisions that are higher than what can be represented in a double.
  879|      0|        // In this case it does not suffice to check for integral numbers by
  880|      0|        // casting the [value doubleValue] to an int64_t, because this will
  881|      0|        // cause the compared values to be rounded to double precision.
  882|      0|        // Coupled with a bug in [NSDecimalNumber longLongValue] that triggers
  883|      0|        // when converting values with high precision, this would cause
  884|      0|        // values of high precision, but with an integral 'doubleValue'
  885|      0|        // representation to be converted to bogus values.
  886|      0|        // A radar for the NSDecimalNumber issue can be found here:
  887|      0|        // http://www.openradar.me/radar?id=5007005597040640
  888|      0|        // Consider the NSDecimalNumber value: 999.9999999999999487
  889|      0|        // This number has a 'doubleValue' of 1000. Using the previous version
  890|      0|        // of this method would cause the value to be interpreted to be integral
  891|      0|        // and then the resulting value would be based on the longLongValue
  892|      0|        // which due to the NSDecimalNumber issue would turn out as -844.
  893|      0|        // By using NSDecimal logic to test for integral values,
  894|      0|        // 999.9999999999999487 will not be considered integral, and instead
  895|      0|        // of triggering the 'longLongValue' issue, it will be returned as
  896|      0|        // the 'doubleValue' representation (1000).
  897|      0|        // Please note, that even without the NSDecimalNumber issue, the
  898|      0|        // 'correct' longLongValue of 999.9999999999999487 is 999 and not 1000,
  899|      0|        // so the previous code would cause issues even without the bug
  900|      0|        // referenced in the radar.
  901|      0|        NSDecimal original = [(NSDecimalNumber *)value decimalValue];
  902|      0|        NSDecimal rounded;
  903|      0|        NSDecimalRound(&rounded, &original, 0, NSRoundPlain);
  904|      0|        if (NSDecimalCompare(&original, &rounded) != NSOrderedSame) {
  905|      0|            NSString *doubleString = [value stringValue];
  906|      0|            return [NSNumber numberWithDouble:[doubleString doubleValue]];
  907|      0|        } else {
  908|      0|            return [NSNumber numberWithLongLong:[value longLongValue]];
  909|      0|        }
  910|      0|    } else if ([value isKindOfClass:[NSNumber class]]) {
  911|      0|        // The parser for double values in JSONSerialization at the root takes
  912|      0|        // some short-cuts and delivers wrong results (wrong rounding) for some
  913|      0|        // double values, including 2.47. Because we use the exact bytes for
  914|      0|        // hashing on the server this will lead to hash mismatches. The parser
  915|      0|        // of NSNumber seems to be more in line with what the server expects, so
  916|      0|        // we use that here
  917|      0|        CFNumberType type = CFNumberGetType((CFNumberRef)value);
  918|      0|        if (type == kCFNumberDoubleType || type == kCFNumberFloatType) {
  919|      0|            // The NSJSON parser returns all numbers as double values, even
  920|      0|            // those that contain no exponent. To make sure that the String
  921|      0|            // conversion below doesn't unexpectedly reduce precision, we make
  922|      0|            // sure that our number is indeed not an integer.
  923|      0|            if ((double)(int64_t)[value doubleValue] != [value doubleValue]) {
  924|      0|                NSString *doubleString = [value stringValue];
  925|      0|                return [NSNumber numberWithDouble:[doubleString doubleValue]];
  926|      0|            } else {
  927|      0|                return [NSNumber numberWithLongLong:[value longLongValue]];
  928|      0|            }
  929|      0|        }
  930|      0|    }
  931|      0|    return value;
  932|      0|}
  933|       |
  934|      0|- (id)deserializePrimitive:(NSData *)data {
  935|      0|    NSError *error = nil;
  936|      0|    id result =
  937|      0|        [NSJSONSerialization JSONObjectWithData:data
  938|      0|                                        options:NSJSONReadingAllowFragments
  939|      0|                                          error:&error];
  940|      0|    if (result != nil) {
  941|      0|        return [self fixDoubleParsing:result];
  942|      0|    } else {
  943|      0|        if (error.code == kFNanFailureCode) {
  944|      0|            FFWarn(@"I-RDB076034",
  945|      0|                   @"Failed to load primitive %@, likely because doubles where "
  946|      0|                   @"out of range (Error: %@)",
  947|      0|                   [[NSString alloc] initWithData:data
  948|      0|                                         encoding:NSUTF8StringEncoding],
  949|      0|                   error);
  950|      0|            return [NSNull null];
  951|      0|        } else {
  952|      0|            [NSException raise:NSInternalInconsistencyException
  953|      0|                        format:@"Failed to deserialiaze primitive: %@", error];
  954|      0|            return nil;
  955|      0|        }
  956|      0|    }
  957|      0|}
  958|       |
  959|      0|+ (void)ensureDir:(NSString *)path markAsDoNotBackup:(BOOL)markAsDoNotBackup {
  960|      0|    NSError *error;
  961|      0|    BOOL success =
  962|      0|        [[NSFileManager defaultManager] createDirectoryAtPath:path
  963|      0|                                  withIntermediateDirectories:YES
  964|      0|                                                   attributes:nil
  965|      0|                                                        error:&error];
  966|      0|    if (!success) {
  967|      0|        @throw [NSException
  968|      0|            exceptionWithName:@"FailedToCreatePersistenceDir"
  969|      0|                       reason:@"Failed to create persistence directory."
  970|      0|                     userInfo:@{@"path" : path}];
  971|      0|    }
  972|      0|
  973|      0|    if (markAsDoNotBackup) {
  974|      0|        NSURL *firebaseDirURL = [NSURL fileURLWithPath:path];
  975|      0|        success = [firebaseDirURL setResourceValue:@YES
  976|      0|                                            forKey:NSURLIsExcludedFromBackupKey
  977|      0|                                             error:&error];
  978|      0|        if (!success) {
  979|      0|            FFWarn(
  980|      0|                @"I-RDB076035",
  981|      0|                @"Failed to mark firebase database folder as do not backup: %@",
  982|      0|                error);
  983|      0|            [NSException raise:@"Error marking as do not backup"
  984|      0|                        format:@"Failed to mark folder %@ as do not backup",
  985|      0|                               firebaseDirURL];
  986|      0|        }
  987|      0|    }
  988|      0|}
  989|       |
  990|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FPendingPut.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FPendingPut.h"
   18|       |
   19|       |@implementation FPendingPut
   20|       |
   21|       |@synthesize path;
   22|       |@synthesize data;
   23|       |
   24|      0|- (id)initWithPath:(FPath *)aPath andData:(id)aData andPriority:(id)aPriority {
   25|      0|    self = [super init];
   26|      0|    if (self) {
   27|      0|        self.path = aPath;
   28|      0|        self.data = aData;
   29|      0|        self.priority = aPriority;
   30|      0|    }
   31|      0|    return self;
   32|      0|}
   33|       |
   34|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   35|      0|    [aCoder encodeObject:[self.path description] forKey:@"path"];
   36|      0|    [aCoder encodeObject:self.data forKey:@"data"];
   37|      0|    [aCoder encodeObject:self.priority forKey:@"priority"];
   38|      0|}
   39|       |
   40|      0|- (id)initWithCoder:(NSCoder *)aDecoder {
   41|      0|    self = [super init];
   42|      0|    if (self) {
   43|      0|        self.path =
   44|      0|            [[FPath alloc] initWith:[aDecoder decodeObjectForKey:@"path"]];
   45|      0|        self.data = [aDecoder decodeObjectForKey:@"data"];
   46|      0|        self.priority = [aDecoder decodeObjectForKey:@"priority"];
   47|      0|    }
   48|      0|    return self;
   49|      0|}
   50|       |
   51|       |@end
   52|       |
   53|       |@implementation FPendingPutPriority
   54|       |
   55|       |@synthesize path;
   56|       |@synthesize priority;
   57|       |
   58|      0|- (id)initWithPath:(FPath *)aPath andPriority:(id)aPriority {
   59|      0|    self = [super init];
   60|      0|    if (self) {
   61|      0|        self.path = aPath;
   62|      0|        self.priority = aPriority;
   63|      0|    }
   64|      0|    return self;
   65|      0|}
   66|       |
   67|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   68|      0|    [aCoder encodeObject:[self.path description] forKey:@"path"];
   69|      0|    [aCoder encodeObject:self.priority forKey:@"priority"];
   70|      0|}
   71|       |
   72|      0|- (id)initWithCoder:(NSCoder *)aDecoder {
   73|      0|    self = [super init];
   74|      0|    if (self) {
   75|      0|        self.path =
   76|      0|            [[FPath alloc] initWith:[aDecoder decodeObjectForKey:@"path"]];
   77|      0|        self.priority = [aDecoder decodeObjectForKey:@"priority"];
   78|      0|    }
   79|      0|    return self;
   80|      0|}
   81|       |
   82|       |@end
   83|       |
   84|       |@implementation FPendingUpdate
   85|       |
   86|       |@synthesize path;
   87|       |@synthesize data;
   88|       |
   89|      0|- (id)initWithPath:(FPath *)aPath andData:(id)aData {
   90|      0|    self = [super init];
   91|      0|    if (self) {
   92|      0|        self.path = aPath;
   93|      0|        self.data = aData;
   94|      0|    }
   95|      0|    return self;
   96|      0|}
   97|       |
   98|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   99|      0|    [aCoder encodeObject:[self.path description] forKey:@"path"];
  100|      0|    [aCoder encodeObject:self.data forKey:@"data"];
  101|      0|}
  102|       |
  103|      0|- (id)initWithCoder:(NSCoder *)aDecoder {
  104|      0|    self = [super init];
  105|      0|    if (self) {
  106|      0|        self.path =
  107|      0|            [[FPath alloc] initWith:[aDecoder decodeObjectForKey:@"path"]];
  108|      0|        self.data = [aDecoder decodeObjectForKey:@"data"];
  109|      0|    }
  110|      0|    return self;
  111|      0|}
  112|       |
  113|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FPersistenceManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FPersistenceManager.h"
   18|       |#import "FCacheNode.h"
   19|       |#import "FClock.h"
   20|       |#import "FIndexedNode.h"
   21|       |#import "FLevelDBStorageEngine.h"
   22|       |#import "FPruneForest.h"
   23|       |#import "FTrackedQuery.h"
   24|       |#import "FTrackedQueryManager.h"
   25|       |#import "FUtilities.h"
   26|       |#import <FirebaseCore/FIRLogger.h>
   27|       |
   28|       |@interface FPersistenceManager ()
   29|       |
   30|       |@property(nonatomic, strong) id<FStorageEngine> storageEngine;
   31|       |@property(nonatomic, strong) id<FCachePolicy> cachePolicy;
   32|       |@property(nonatomic, strong) FTrackedQueryManager *trackedQueryManager;
   33|       |@property(nonatomic) NSUInteger serverCacheUpdatesSinceLastPruneCheck;
   34|       |
   35|       |@end
   36|       |
   37|       |@implementation FPersistenceManager
   38|       |
   39|       |- (id)initWithStorageEngine:(id<FStorageEngine>)storageEngine
   40|      0|                cachePolicy:(id<FCachePolicy>)cachePolicy {
   41|      0|    self = [super init];
   42|      0|    if (self != nil) {
   43|      0|        self->_storageEngine = storageEngine;
   44|      0|        self->_cachePolicy = cachePolicy;
   45|      0|        self->_trackedQueryManager = [[FTrackedQueryManager alloc]
   46|      0|            initWithStorageEngine:self.storageEngine
   47|      0|                            clock:[FSystemClock clock]];
   48|      0|    }
   49|      0|    return self;
   50|      0|}
   51|       |
   52|      0|- (void)close {
   53|      0|    [self.storageEngine close];
   54|      0|    self.storageEngine = nil;
   55|      0|    self.trackedQueryManager = nil;
   56|      0|}
   57|       |
   58|       |- (void)saveUserOverwrite:(id<FNode>)node
   59|       |                   atPath:(FPath *)path
   60|      0|                  writeId:(NSUInteger)writeId {
   61|      0|    [self.storageEngine saveUserOverwrite:node atPath:path writeId:writeId];
   62|      0|}
   63|       |
   64|       |- (void)saveUserMerge:(FCompoundWrite *)merge
   65|       |               atPath:(FPath *)path
   66|      0|              writeId:(NSUInteger)writeId {
   67|      0|    [self.storageEngine saveUserMerge:merge atPath:path writeId:writeId];
   68|      0|}
   69|       |
   70|      0|- (void)removeUserWrite:(NSUInteger)writeId {
   71|      0|    [self.storageEngine removeUserWrite:writeId];
   72|      0|}
   73|       |
   74|      0|- (void)removeAllUserWrites {
   75|      0|    [self.storageEngine removeAllUserWrites];
   76|      0|}
   77|       |
   78|      0|- (NSArray *)userWrites {
   79|      0|    return [self.storageEngine userWrites];
   80|      0|}
   81|       |
   82|      0|- (FCacheNode *)serverCacheForQuery:(FQuerySpec *)query {
   83|      0|    NSSet *trackedKeys;
   84|      0|    BOOL complete;
   85|      0|    // TODO[offline]: Should we use trackedKeys to find out if this location is
   86|      0|    // a child of a complete query?
   87|      0|    if ([self.trackedQueryManager isQueryComplete:query]) {
   88|      0|        complete = YES;
   89|      0|        FTrackedQuery *trackedQuery =
   90|      0|            [self.trackedQueryManager findTrackedQuery:query];
   91|      0|        if (!query.loadsAllData && trackedQuery.isComplete) {
   92|      0|            trackedKeys = [self.storageEngine
   93|      0|                trackedQueryKeysForQuery:trackedQuery.queryId];
   94|      0|        } else {
   95|      0|            trackedKeys = nil;
   96|      0|        }
   97|      0|    } else {
   98|      0|        complete = NO;
   99|      0|        trackedKeys =
  100|      0|            [self.trackedQueryManager knownCompleteChildrenAtPath:query.path];
  101|      0|    }
  102|      0|
  103|      0|    id<FNode> node;
  104|      0|    if (trackedKeys != nil) {
  105|      0|        node = [self.storageEngine serverCacheForKeys:trackedKeys
  106|      0|                                               atPath:query.path];
  107|      0|    } else {
  108|      0|        node = [self.storageEngine serverCacheAtPath:query.path];
  109|      0|    }
  110|      0|
  111|      0|    FIndexedNode *indexedNode = [FIndexedNode indexedNodeWithNode:node
  112|      0|                                                            index:query.index];
  113|      0|    return [[FCacheNode alloc] initWithIndexedNode:indexedNode
  114|      0|                                isFullyInitialized:complete
  115|      0|                                        isFiltered:(trackedKeys != nil)];
  116|      0|}
  117|       |
  118|      0|- (void)updateServerCacheWithNode:(id<FNode>)node forQuery:(FQuerySpec *)query {
  119|      0|    BOOL merge = !query.loadsAllData;
  120|      0|    [self.storageEngine updateServerCache:node atPath:query.path merge:merge];
  121|      0|    [self setQueryComplete:query];
  122|      0|    [self doPruneCheckAfterServerUpdate];
  123|      0|}
  124|       |
  125|       |- (void)updateServerCacheWithMerge:(FCompoundWrite *)merge
  126|      0|                            atPath:(FPath *)path {
  127|      0|    [self.storageEngine updateServerCacheWithMerge:merge atPath:path];
  128|      0|    [self doPruneCheckAfterServerUpdate];
  129|      0|}
  130|       |
  131|       |- (void)applyUserMerge:(FCompoundWrite *)merge
  132|      0|    toServerCacheAtPath:(FPath *)path {
  133|      0|    // TODO[offline]: rework this to be more efficient
  134|      0|    [merge enumerateWrites:^(FPath *relativePath, id<FNode> node, BOOL *stop) {
  135|      0|      [self applyUserWrite:node toServerCacheAtPath:[path child:relativePath]];
  136|      0|    }];
  137|      0|}
  138|       |
  139|      0|- (void)applyUserWrite:(id<FNode>)write toServerCacheAtPath:(FPath *)path {
  140|      0|    // This is a hack to guess whether we already cached this because we got a
  141|      0|    // server data update for this write via an existing active default query.
  142|      0|    // If we didn't, then we'll manually cache this and add a tracked query to
  143|      0|    // mark it complete and keep it cached. Unfortunately this is just a guess
  144|      0|    // and it's possible that we *did* get an update (e.g. via a filtered query)
  145|      0|    // and by overwriting the cache here, we'll actually store an incorrect
  146|      0|    // value (e.g. in the case that we wrote a ServerValue.TIMESTAMP and the
  147|      0|    // server resolved it to a different value).
  148|      0|    // TODO[offline]: Consider reworking.
  149|      0|    if (![self.trackedQueryManager hasActiveDefaultQueryAtPath:path]) {
  150|      0|        [self.storageEngine updateServerCache:write atPath:path merge:NO];
  151|      0|        [self.trackedQueryManager ensureCompleteTrackedQueryAtPath:path];
  152|      0|    }
  153|      0|}
  154|       |
  155|      0|- (void)setQueryComplete:(FQuerySpec *)query {
  156|      0|    if (query.loadsAllData) {
  157|      0|        [self.trackedQueryManager setQueriesCompleteAtPath:query.path];
  158|      0|    } else {
  159|      0|        [self.trackedQueryManager setQueryComplete:query];
  160|      0|    }
  161|      0|}
  162|       |
  163|      0|- (void)setQueryActive:(FQuerySpec *)spec {
  164|      0|    [self.trackedQueryManager setQueryActive:spec];
  165|      0|}
  166|       |
  167|      0|- (void)setQueryInactive:(FQuerySpec *)spec {
  168|      0|    [self.trackedQueryManager setQueryInactive:spec];
  169|      0|}
  170|       |
  171|      0|- (void)doPruneCheckAfterServerUpdate {
  172|      0|    self.serverCacheUpdatesSinceLastPruneCheck++;
  173|      0|    if ([self.cachePolicy
  174|      0|            shouldCheckCacheSize:self.serverCacheUpdatesSinceLastPruneCheck]) {
  175|      0|        FFDebug(@"I-RDB078001", @"Reached prune check threshold. Checking...");
  176|      0|        NSDate *date = [NSDate date];
  177|      0|        self.serverCacheUpdatesSinceLastPruneCheck = 0;
  178|      0|        BOOL canPrune = YES;
  179|      0|        NSUInteger cacheSize =
  180|      0|            [self.storageEngine serverCacheEstimatedSizeInBytes];
  181|      0|        FFDebug(@"I-RDB078002", @"Server cache size: %lu",
  182|      0|                (unsigned long)cacheSize);
  183|      0|        while (canPrune &&
  184|      0|               [self.cachePolicy
  185|      0|                   shouldPruneCacheWithSize:cacheSize
  186|      0|                     numberOfTrackedQueries:self.trackedQueryManager
  187|      0|                                                .numberOfPrunableQueries]) {
  188|      0|            FPruneForest *pruneForest =
  189|      0|                [self.trackedQueryManager pruneOldQueries:self.cachePolicy];
  190|      0|            if (pruneForest.prunesAnything) {
  191|      0|                [self.storageEngine pruneCache:pruneForest
  192|      0|                                        atPath:[FPath empty]];
  193|      0|            } else {
  194|      0|                canPrune = NO;
  195|      0|            }
  196|      0|            cacheSize = [self.storageEngine serverCacheEstimatedSizeInBytes];
  197|      0|            FFDebug(@"I-RDB078003", @"Cache size after pruning: %lu",
  198|      0|                    (unsigned long)cacheSize);
  199|      0|        }
  200|      0|        FFDebug(@"I-RDB078004", @"Pruning round took %fms",
  201|      0|                [date timeIntervalSinceNow] * -1000);
  202|      0|    }
  203|      0|}
  204|       |
  205|      0|- (void)setTrackedQueryKeys:(NSSet *)keys forQuery:(FQuerySpec *)query {
  206|      0|    NSAssert(!query.loadsAllData,
  207|      0|             @"We should only track keys for filtered queries");
  208|      0|    FTrackedQuery *trackedQuery =
  209|      0|        [self.trackedQueryManager findTrackedQuery:query];
  210|      0|    NSAssert(trackedQuery.isActive,
  211|      0|             @"We only expect tracked keys for currently-active queries.");
  212|      0|    [self.storageEngine setTrackedQueryKeys:keys
  213|      0|                                 forQueryId:trackedQuery.queryId];
  214|      0|}
  215|       |
  216|       |- (void)updateTrackedQueryKeysWithAddedKeys:(NSSet *)added
  217|       |                                removedKeys:(NSSet *)removed
  218|      0|                                   forQuery:(FQuerySpec *)query {
  219|      0|    NSAssert(!query.loadsAllData,
  220|      0|             @"We should only track keys for filtered queries");
  221|      0|    FTrackedQuery *trackedQuery =
  222|      0|        [self.trackedQueryManager findTrackedQuery:query];
  223|      0|    NSAssert(trackedQuery.isActive,
  224|      0|             @"We only expect tracked keys for currently-active queries.");
  225|      0|    [self.storageEngine
  226|      0|        updateTrackedQueryKeysWithAddedKeys:added
  227|      0|                                removedKeys:removed
  228|      0|                                 forQueryId:trackedQuery.queryId];
  229|      0|}
  230|       |
  231|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FPruneForest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FPruneForest.h"
   18|       |
   19|       |#import "FImmutableTree.h"
   20|       |
   21|       |@interface FPruneForest ()
   22|       |
   23|       |@property(nonatomic, strong) FImmutableTree *pruneForest;
   24|       |
   25|       |@end
   26|       |
   27|       |@implementation FPruneForest
   28|       |
   29|      0|static BOOL (^kFPrunePredicate)(id) = ^BOOL(NSNumber *pruneValue) {
   30|      0|  return [pruneValue boolValue];
   31|      0|};
   32|       |
   33|      0|static BOOL (^kFKeepPredicate)(id) = ^BOOL(NSNumber *pruneValue) {
   34|      0|  return ![pruneValue boolValue];
   35|      0|};
   36|       |
   37|      0|+ (FImmutableTree *)pruneTree {
   38|      0|    static dispatch_once_t onceToken;
   39|      0|    static FImmutableTree *pruneTree;
   40|      0|    dispatch_once(&onceToken, ^{
   41|      0|      pruneTree = [[FImmutableTree alloc] initWithValue:@YES];
   42|      0|    });
   43|      0|    return pruneTree;
   44|      0|}
   45|       |
   46|      0|+ (FImmutableTree *)keepTree {
   47|      0|    static dispatch_once_t onceToken;
   48|      0|    static FImmutableTree *keepTree;
   49|      0|    dispatch_once(&onceToken, ^{
   50|      0|      keepTree = [[FImmutableTree alloc] initWithValue:@NO];
   51|      0|    });
   52|      0|    return keepTree;
   53|      0|}
   54|       |
   55|      0|- (id)initWithForest:(FImmutableTree *)tree {
   56|      0|    self = [super init];
   57|      0|    if (self != nil) {
   58|      0|        self->_pruneForest = tree;
   59|      0|    }
   60|      0|    return self;
   61|      0|}
   62|       |
   63|      0|+ (FPruneForest *)empty {
   64|      0|    static dispatch_once_t onceToken;
   65|      0|    static FPruneForest *forest;
   66|      0|    dispatch_once(&onceToken, ^{
   67|      0|      forest = [[FPruneForest alloc] initWithForest:[FImmutableTree empty]];
   68|      0|    });
   69|      0|    return forest;
   70|      0|}
   71|       |
   72|      0|- (BOOL)prunesAnything {
   73|      0|    return [self.pruneForest containsValueMatching:kFPrunePredicate];
   74|      0|}
   75|       |
   76|      0|- (BOOL)shouldPruneUnkeptDescendantsAtPath:(FPath *)path {
   77|      0|    NSNumber *shouldPrune = [self.pruneForest leafMostValueOnPath:path];
   78|      0|    return shouldPrune != nil && [shouldPrune boolValue];
   79|      0|}
   80|       |
   81|      0|- (BOOL)shouldKeepPath:(FPath *)path {
   82|      0|    NSNumber *shouldPrune = [self.pruneForest leafMostValueOnPath:path];
   83|      0|    return shouldPrune != nil && ![shouldPrune boolValue];
   84|      0|}
   85|       |
   86|      0|- (BOOL)affectsPath:(FPath *)path {
   87|      0|    return [self.pruneForest rootMostValueOnPath:path] != nil ||
   88|      0|           ![[self.pruneForest subtreeAtPath:path] isEmpty];
   89|      0|}
   90|       |
   91|      0|- (FPruneForest *)child:(NSString *)childKey {
   92|      0|    FImmutableTree *childPruneForest = [self.pruneForest.children get:childKey];
   93|      0|    if (childPruneForest == nil) {
   94|      0|        if (self.pruneForest.value != nil) {
   95|      0|            childPruneForest = [self.pruneForest.value boolValue]
   96|      0|                                   ? [FPruneForest pruneTree]
   97|      0|                                   : [FPruneForest keepTree];
   98|      0|        } else {
   99|      0|            childPruneForest = [FImmutableTree empty];
  100|      0|        }
  101|      0|    } else {
  102|      0|        if (childPruneForest.value == nil && self.pruneForest.value != nil) {
  103|      0|            childPruneForest = [childPruneForest setValue:self.pruneForest.value
  104|      0|                                                   atPath:[FPath empty]];
  105|      0|        }
  106|      0|    }
  107|      0|    return [[FPruneForest alloc] initWithForest:childPruneForest];
  108|      0|}
  109|       |
  110|      0|- (FPruneForest *)childAtPath:(FPath *)path {
  111|      0|    if (path.isEmpty) {
  112|      0|        return self;
  113|      0|    } else {
  114|      0|        return [[self child:path.getFront] childAtPath:[path popFront]];
  115|      0|    }
  116|      0|}
  117|       |
  118|      0|- (FPruneForest *)prunePath:(FPath *)path {
  119|      0|    if ([self.pruneForest rootMostValueOnPath:path matching:kFKeepPredicate]) {
  120|      0|        [NSException raise:NSInvalidArgumentException
  121|      0|                    format:@"Can't prune path that was kept previously!"];
  122|      0|    }
  123|      0|    if ([self.pruneForest rootMostValueOnPath:path matching:kFPrunePredicate]) {
  124|      0|        // This path will already be pruned
  125|      0|        return self;
  126|      0|    } else {
  127|      0|        FImmutableTree *newPruneForest =
  128|      0|            [self.pruneForest setTree:[FPruneForest pruneTree] atPath:path];
  129|      0|        return [[FPruneForest alloc] initWithForest:newPruneForest];
  130|      0|    }
  131|      0|}
  132|       |
  133|      0|- (FPruneForest *)keepPath:(FPath *)path {
  134|      0|    if ([self.pruneForest rootMostValueOnPath:path matching:kFKeepPredicate]) {
  135|      0|        // This path will already be kept
  136|      0|        return self;
  137|      0|    } else {
  138|      0|        FImmutableTree *newPruneForest =
  139|      0|            [self.pruneForest setTree:[FPruneForest keepTree] atPath:path];
  140|      0|        return [[FPruneForest alloc] initWithForest:newPruneForest];
  141|      0|    }
  142|      0|}
  143|       |
  144|      0|- (FPruneForest *)keepAll:(NSSet *)children atPath:(FPath *)path {
  145|      0|    if ([self.pruneForest rootMostValueOnPath:path matching:kFKeepPredicate]) {
  146|      0|        // This path will already be kept
  147|      0|        return self;
  148|      0|    } else {
  149|      0|        return [self setPruneValue:[FPruneForest keepTree]
  150|      0|                            forAll:children
  151|      0|                            atPath:path];
  152|      0|    }
  153|      0|}
  154|       |
  155|      0|- (FPruneForest *)pruneAll:(NSSet *)children atPath:(FPath *)path {
  156|      0|    if ([self.pruneForest rootMostValueOnPath:path matching:kFKeepPredicate]) {
  157|      0|        [NSException raise:NSInvalidArgumentException
  158|      0|                    format:@"Can't prune path that was kept previously!"];
  159|      0|    }
  160|      0|    if ([self.pruneForest rootMostValueOnPath:path matching:kFPrunePredicate]) {
  161|      0|        // This path will already be pruned
  162|      0|        return self;
  163|      0|    } else {
  164|      0|        return [self setPruneValue:[FPruneForest pruneTree]
  165|      0|                            forAll:children
  166|      0|                            atPath:path];
  167|      0|    }
  168|      0|}
  169|       |
  170|       |- (FPruneForest *)setPruneValue:(FImmutableTree *)pruneValue
  171|       |                         forAll:(NSSet *)children
  172|      0|                         atPath:(FPath *)path {
  173|      0|    FImmutableTree *subtree = [self.pruneForest subtreeAtPath:path];
  174|      0|    __block FImmutableSortedDictionary *childrenDictionary = subtree.children;
  175|      0|    [children enumerateObjectsUsingBlock:^(NSString *childKey, BOOL *stop) {
  176|      0|      childrenDictionary = [childrenDictionary insertKey:childKey
  177|      0|                                               withValue:pruneValue];
  178|      0|    }];
  179|      0|    FImmutableTree *newSubtree =
  180|      0|        [[FImmutableTree alloc] initWithValue:subtree.value
  181|      0|                                     children:childrenDictionary];
  182|      0|    return [[FPruneForest alloc]
  183|      0|        initWithForest:[self.pruneForest setTree:newSubtree atPath:path]];
  184|      0|}
  185|       |
  186|      0|- (void)enumarateKeptNodesUsingBlock:(void (^)(FPath *))block {
  187|      0|    [self.pruneForest forEach:^(FPath *path, id value) {
  188|      0|      if (value != nil && ![value boolValue]) {
  189|      0|          block(path);
  190|      0|      }
  191|      0|    }];
  192|      0|}
  193|       |
  194|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FTrackedQuery.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTrackedQuery.h"
   18|       |
   19|       |#import "FQuerySpec.h"
   20|       |
   21|       |@interface FTrackedQuery ()
   22|       |
   23|       |@property(nonatomic, readwrite) NSUInteger queryId;
   24|       |@property(nonatomic, strong, readwrite) FQuerySpec *query;
   25|       |@property(nonatomic, readwrite) NSTimeInterval lastUse;
   26|       |@property(nonatomic, readwrite) BOOL isComplete;
   27|       |@property(nonatomic, readwrite) BOOL isActive;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FTrackedQuery
   32|       |
   33|       |- (id)initWithId:(NSUInteger)queryId
   34|       |           query:(FQuerySpec *)query
   35|       |         lastUse:(NSTimeInterval)lastUse
   36|       |        isActive:(BOOL)isActive
   37|      0|      isComplete:(BOOL)isComplete {
   38|      0|    self = [super init];
   39|      0|    if (self != nil) {
   40|      0|        self->_queryId = queryId;
   41|      0|        self->_query = query;
   42|      0|        self->_lastUse = lastUse;
   43|      0|        self->_isComplete = isComplete;
   44|      0|        self->_isActive = isActive;
   45|      0|    }
   46|      0|    return self;
   47|      0|}
   48|       |
   49|       |- (id)initWithId:(NSUInteger)queryId
   50|       |           query:(FQuerySpec *)query
   51|       |         lastUse:(NSTimeInterval)lastUse
   52|      0|        isActive:(BOOL)isActive {
   53|      0|    return [self initWithId:queryId
   54|      0|                      query:query
   55|      0|                    lastUse:lastUse
   56|      0|                   isActive:isActive
   57|      0|                 isComplete:NO];
   58|      0|}
   59|       |
   60|      0|- (FTrackedQuery *)updateLastUse:(NSTimeInterval)lastUse {
   61|      0|    return [[FTrackedQuery alloc] initWithId:self.queryId
   62|      0|                                       query:self.query
   63|      0|                                     lastUse:lastUse
   64|      0|                                    isActive:self.isActive
   65|      0|                                  isComplete:self.isComplete];
   66|      0|}
   67|       |
   68|      0|- (FTrackedQuery *)setComplete {
   69|      0|    return [[FTrackedQuery alloc] initWithId:self.queryId
   70|      0|                                       query:self.query
   71|      0|                                     lastUse:self.lastUse
   72|      0|                                    isActive:self.isActive
   73|      0|                                  isComplete:YES];
   74|      0|}
   75|       |
   76|      0|- (FTrackedQuery *)setActiveState:(BOOL)isActive {
   77|      0|    return [[FTrackedQuery alloc] initWithId:self.queryId
   78|      0|                                       query:self.query
   79|      0|                                     lastUse:self.lastUse
   80|      0|                                    isActive:isActive
   81|      0|                                  isComplete:self.isComplete];
   82|      0|}
   83|       |
   84|      0|- (BOOL)isEqual:(id)object {
   85|      0|    if (![object isKindOfClass:[FTrackedQuery class]]) {
   86|      0|        return NO;
   87|      0|    }
   88|      0|    FTrackedQuery *other = (FTrackedQuery *)object;
   89|      0|    if (self.queryId != other.queryId)
   90|      0|        return NO;
   91|      0|    if (self.query != other.query && ![self.query isEqual:other.query])
   92|      0|        return NO;
   93|      0|    if (self.lastUse != other.lastUse)
   94|      0|        return NO;
   95|      0|    if (self.isComplete != other.isComplete)
   96|      0|        return NO;
   97|      0|    if (self.isActive != other.isActive)
   98|      0|        return NO;
   99|      0|
  100|      0|    return YES;
  101|      0|}
  102|       |
  103|      0|- (NSUInteger)hash {
  104|      0|    NSUInteger hash = self.queryId;
  105|      0|    hash = hash * 31 + self.query.hash;
  106|      0|    hash = hash * 31 + (self.isActive ? 1 : 0);
  107|      0|    hash = hash * 31 + (NSUInteger)self.lastUse;
  108|      0|    hash = hash * 31 + (self.isComplete ? 1 : 0);
  109|      0|    hash = hash * 31 + (self.isActive ? 1 : 0);
  110|      0|    return hash;
  111|      0|}
  112|       |
  113|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Persistence/FTrackedQueryManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTrackedQueryManager.h"
   18|       |#import "FCachePolicy.h"
   19|       |#import "FClock.h"
   20|       |#import "FImmutableTree.h"
   21|       |#import "FLevelDBStorageEngine.h"
   22|       |#import "FPruneForest.h"
   23|       |#import "FTrackedQuery.h"
   24|       |#import "FUtilities.h"
   25|       |#import <FirebaseCore/FIRLogger.h>
   26|       |
   27|       |@interface FTrackedQueryManager ()
   28|       |
   29|       |@property(nonatomic, strong) FImmutableTree *trackedQueryTree;
   30|       |@property(nonatomic, strong) id<FStorageEngine> storageEngine;
   31|       |@property(nonatomic, strong) id<FClock> clock;
   32|       |@property(nonatomic) NSUInteger currentQueryId;
   33|       |
   34|       |@end
   35|       |
   36|       |@implementation FTrackedQueryManager
   37|       |
   38|       |- (id)initWithStorageEngine:(id<FStorageEngine>)storageEngine
   39|      0|                      clock:(id<FClock>)clock {
   40|      0|    self = [super init];
   41|      0|    if (self != nil) {
   42|      0|        self->_storageEngine = storageEngine;
   43|      0|        self->_clock = clock;
   44|      0|        self->_trackedQueryTree = [FImmutableTree empty];
   45|      0|
   46|      0|        NSTimeInterval lastUse = [clock currentTime];
   47|      0|
   48|      0|        NSArray *trackedQueries = [self.storageEngine loadTrackedQueries];
   49|      0|        [trackedQueries enumerateObjectsUsingBlock:^(
   50|      0|                            FTrackedQuery *trackedQuery, NSUInteger idx,
   51|      0|                            BOOL *stop) {
   52|      0|          self.currentQueryId =
   53|      0|              MAX(trackedQuery.queryId + 1, self.currentQueryId);
   54|      0|          if (trackedQuery.isActive) {
   55|      0|              trackedQuery =
   56|      0|                  [[trackedQuery setActiveState:NO] updateLastUse:lastUse];
   57|      0|              FFDebug(
   58|      0|                  @"I-RDB081001",
   59|      0|                  @"Setting active query %lu from previous app start inactive",
   60|      0|                  (unsigned long)trackedQuery.queryId);
   61|      0|              [self.storageEngine saveTrackedQuery:trackedQuery];
   62|      0|          }
   63|      0|          [self cacheTrackedQuery:trackedQuery];
   64|      0|        }];
   65|      0|    }
   66|      0|    return self;
   67|      0|}
   68|       |
   69|      0|+ (void)assertValidTrackedQuery:(FQuerySpec *)query {
   70|      0|    NSAssert(!query.loadsAllData || query.isDefault,
   71|      0|             @"Can't have tracked non-default query that loads all data");
   72|      0|}
   73|       |
   74|      0|+ (FQuerySpec *)normalizeQuery:(FQuerySpec *)query {
   75|      0|    return query.loadsAllData ? [FQuerySpec defaultQueryAtPath:query.path]
   76|      0|                              : query;
   77|      0|}
   78|       |
   79|      0|- (FTrackedQuery *)findTrackedQuery:(FQuerySpec *)query {
   80|      0|    query = [FTrackedQueryManager normalizeQuery:query];
   81|      0|    NSDictionary *set = [self.trackedQueryTree valueAtPath:query.path];
   82|      0|    return set[query.params];
   83|      0|}
   84|       |
   85|      0|- (void)removeTrackedQuery:(FQuerySpec *)query {
   86|      0|    query = [FTrackedQueryManager normalizeQuery:query];
   87|      0|    FTrackedQuery *trackedQuery = [self findTrackedQuery:query];
   88|      0|    NSAssert(trackedQuery, @"Tracked query must exist to be removed!");
   89|      0|
   90|      0|    [self.storageEngine removeTrackedQuery:trackedQuery.queryId];
   91|      0|    NSMutableDictionary *trackedQueries =
   92|      0|        [self.trackedQueryTree valueAtPath:query.path];
   93|      0|    [trackedQueries removeObjectForKey:query.params];
   94|      0|}
   95|       |
   96|      0|- (void)setQueryActive:(FQuerySpec *)query {
   97|      0|    [self setQueryActive:YES forQuery:query];
   98|      0|}
   99|       |
  100|      0|- (void)setQueryInactive:(FQuerySpec *)query {
  101|      0|    [self setQueryActive:NO forQuery:query];
  102|      0|}
  103|       |
  104|      0|- (void)setQueryActive:(BOOL)isActive forQuery:(FQuerySpec *)query {
  105|      0|    query = [FTrackedQueryManager normalizeQuery:query];
  106|      0|    FTrackedQuery *trackedQuery = [self findTrackedQuery:query];
  107|      0|
  108|      0|    // Regardless of whether it's now active or no langer active, we update the
  109|      0|    // lastUse time
  110|      0|    NSTimeInterval lastUse = [self.clock currentTime];
  111|      0|    if (trackedQuery != nil) {
  112|      0|        trackedQuery =
  113|      0|            [[trackedQuery updateLastUse:lastUse] setActiveState:isActive];
  114|      0|        [self.storageEngine saveTrackedQuery:trackedQuery];
  115|      0|    } else {
  116|      0|        NSAssert(isActive, @"If we're setting the query to inactive, we should "
  117|      0|                           @"already be tracking it!");
  118|      0|        trackedQuery = [[FTrackedQuery alloc] initWithId:self.currentQueryId++
  119|      0|                                                   query:query
  120|      0|                                                 lastUse:lastUse
  121|      0|                                                isActive:isActive];
  122|      0|        [self.storageEngine saveTrackedQuery:trackedQuery];
  123|      0|    }
  124|      0|
  125|      0|    [self cacheTrackedQuery:trackedQuery];
  126|      0|}
  127|       |
  128|      0|- (void)setQueryComplete:(FQuerySpec *)query {
  129|      0|    query = [FTrackedQueryManager normalizeQuery:query];
  130|      0|    FTrackedQuery *trackedQuery = [self findTrackedQuery:query];
  131|      0|    if (!trackedQuery) {
  132|      0|        // We might have removed a query and pruned it before we got the
  133|      0|        // complete message from the server...
  134|      0|        FFWarn(@"I-RDB081002",
  135|      0|               @"Trying to set a query complete that is not tracked!");
  136|      0|    } else if (!trackedQuery.isComplete) {
  137|      0|        trackedQuery = [trackedQuery setComplete];
  138|      0|        [self.storageEngine saveTrackedQuery:trackedQuery];
  139|      0|        [self cacheTrackedQuery:trackedQuery];
  140|      0|    } else {
  141|      0|        // Nothing to do, already marked complete
  142|      0|    }
  143|      0|}
  144|       |
  145|      0|- (void)setQueriesCompleteAtPath:(FPath *)path {
  146|      0|    [[self.trackedQueryTree subtreeAtPath:path]
  147|      0|        forEach:^(FPath *childPath, NSDictionary *trackedQueries) {
  148|      0|          [trackedQueries enumerateKeysAndObjectsUsingBlock:^(
  149|      0|                              FQueryParams *parms, FTrackedQuery *trackedQuery,
  150|      0|                              BOOL *stop) {
  151|      0|            if (!trackedQuery.isComplete) {
  152|      0|                FTrackedQuery *newTrackedQuery = [trackedQuery setComplete];
  153|      0|                [self.storageEngine saveTrackedQuery:newTrackedQuery];
  154|      0|                [self cacheTrackedQuery:newTrackedQuery];
  155|      0|            }
  156|      0|          }];
  157|      0|        }];
  158|      0|}
  159|       |
  160|      0|- (BOOL)isQueryComplete:(FQuerySpec *)query {
  161|      0|    if ([self isIncludedInDefaultCompleteQuery:query]) {
  162|      0|        return YES;
  163|      0|    } else if (query.loadsAllData) {
  164|      0|        // We didn't find a default complete query, so must not be complete.
  165|      0|        return NO;
  166|      0|    } else {
  167|      0|        NSDictionary *trackedQueries =
  168|      0|            [self.trackedQueryTree valueAtPath:query.path];
  169|      0|        return [trackedQueries[query.params] isComplete];
  170|      0|    }
  171|      0|}
  172|       |
  173|      0|- (BOOL)hasActiveDefaultQueryAtPath:(FPath *)path {
  174|      0|    return [self.trackedQueryTree
  175|      0|               rootMostValueOnPath:path
  176|      0|                          matching:^BOOL(NSDictionary *trackedQueries) {
  177|      0|                            return
  178|      0|                                [trackedQueries[[FQueryParams defaultInstance]]
  179|      0|                                    isActive];
  180|      0|                          }] != nil;
  181|      0|}
  182|       |
  183|      0|- (void)ensureCompleteTrackedQueryAtPath:(FPath *)path {
  184|      0|    FQuerySpec *query = [FQuerySpec defaultQueryAtPath:path];
  185|      0|    if (![self isIncludedInDefaultCompleteQuery:query]) {
  186|      0|        FTrackedQuery *trackedQuery = [self findTrackedQuery:query];
  187|      0|        if (trackedQuery == nil) {
  188|      0|            trackedQuery =
  189|      0|                [[FTrackedQuery alloc] initWithId:self.currentQueryId++
  190|      0|                                            query:query
  191|      0|                                          lastUse:[self.clock currentTime]
  192|      0|                                         isActive:NO
  193|      0|                                       isComplete:YES];
  194|      0|        } else {
  195|      0|            NSAssert(!trackedQuery.isComplete,
  196|      0|                     @"This should have been handled above!");
  197|      0|            trackedQuery = [trackedQuery setComplete];
  198|      0|        }
  199|      0|        [self.storageEngine saveTrackedQuery:trackedQuery];
  200|      0|        [self cacheTrackedQuery:trackedQuery];
  201|      0|    }
  202|      0|}
  203|       |
  204|      0|- (BOOL)isIncludedInDefaultCompleteQuery:(FQuerySpec *)query {
  205|      0|    return
  206|      0|        [self.trackedQueryTree
  207|      0|            findRootMostMatchingPath:query.path
  208|      0|                           predicate:^BOOL(NSDictionary *trackedQueries) {
  209|      0|                             return
  210|      0|                                 [trackedQueries[[FQueryParams defaultInstance]]
  211|      0|                                     isComplete];
  212|      0|                           }] != nil;
  213|      0|}
  214|       |
  215|      0|- (void)cacheTrackedQuery:(FTrackedQuery *)query {
  216|      0|    [FTrackedQueryManager assertValidTrackedQuery:query.query];
  217|      0|    NSMutableDictionary *trackedDict =
  218|      0|        [self.trackedQueryTree valueAtPath:query.query.path];
  219|      0|    if (trackedDict == nil) {
  220|      0|        trackedDict = [NSMutableDictionary dictionary];
  221|      0|        self.trackedQueryTree =
  222|      0|            [self.trackedQueryTree setValue:trackedDict
  223|      0|                                     atPath:query.query.path];
  224|      0|    }
  225|      0|    trackedDict[query.query.params] = query;
  226|      0|}
  227|       |
  228|       |- (NSUInteger)numberOfQueriesToPrune:(id<FCachePolicy>)cachePolicy
  229|      0|                       prunableCount:(NSUInteger)numPrunable {
  230|      0|    NSUInteger numPercent = (NSUInteger)ceilf(
  231|      0|        numPrunable * [cachePolicy percentOfQueriesToPruneAtOnce]);
  232|      0|    NSUInteger maxToKeep = [cachePolicy maxNumberOfQueriesToKeep];
  233|      0|    NSUInteger numMax = (numPrunable > maxToKeep) ? numPrunable - maxToKeep : 0;
  234|      0|    // Make sure we get below number of max queries to prune
  235|      0|    return MAX(numMax, numPercent);
  236|      0|}
  237|       |
  238|      0|- (FPruneForest *)pruneOldQueries:(id<FCachePolicy>)cachePolicy {
  239|      0|    NSMutableArray *pruneableQueries = [NSMutableArray array];
  240|      0|    NSMutableArray *unpruneableQueries = [NSMutableArray array];
  241|      0|    [self.trackedQueryTree
  242|      0|        forEach:^(FPath *path, NSDictionary *trackedQueries) {
  243|      0|          [trackedQueries enumerateKeysAndObjectsUsingBlock:^(
  244|      0|                              FQueryParams *params, FTrackedQuery *trackedQuery,
  245|      0|                              BOOL *stop) {
  246|      0|            if (!trackedQuery.isActive) {
  247|      0|                [pruneableQueries addObject:trackedQuery];
  248|      0|            } else {
  249|      0|                [unpruneableQueries addObject:trackedQuery];
  250|      0|            }
  251|      0|          }];
  252|      0|        }];
  253|      0|    [pruneableQueries sortUsingComparator:^NSComparisonResult(
  254|      0|                          FTrackedQuery *q1, FTrackedQuery *q2) {
  255|      0|      if (q1.lastUse < q2.lastUse) {
  256|      0|          return NSOrderedAscending;
  257|      0|      } else if (q1.lastUse > q2.lastUse) {
  258|      0|          return NSOrderedDescending;
  259|      0|      } else {
  260|      0|          return NSOrderedSame;
  261|      0|      }
  262|      0|    }];
  263|      0|
  264|      0|    __block FPruneForest *pruneForest = [FPruneForest empty];
  265|      0|    NSUInteger numToPrune =
  266|      0|        [self numberOfQueriesToPrune:cachePolicy
  267|      0|                       prunableCount:pruneableQueries.count];
  268|      0|
  269|      0|    // TODO: do in transaction
  270|      0|    for (NSUInteger i = 0; i < numToPrune; i++) {
  271|      0|        FTrackedQuery *toPrune = pruneableQueries[i];
  272|      0|        pruneForest = [pruneForest prunePath:toPrune.query.path];
  273|      0|        [self removeTrackedQuery:toPrune.query];
  274|      0|    }
  275|      0|
  276|      0|    // Keep the rest of the prunable queries
  277|      0|    for (NSUInteger i = numToPrune; i < pruneableQueries.count; i++) {
  278|      0|        FTrackedQuery *toKeep = pruneableQueries[i];
  279|      0|        pruneForest = [pruneForest keepPath:toKeep.query.path];
  280|      0|    }
  281|      0|
  282|      0|    // Also keep unprunable queries
  283|      0|    [unpruneableQueries enumerateObjectsUsingBlock:^(
  284|      0|                            FTrackedQuery *toKeep, NSUInteger idx, BOOL *stop) {
  285|      0|      pruneForest = [pruneForest keepPath:toKeep.query.path];
  286|      0|    }];
  287|      0|
  288|      0|    return pruneForest;
  289|      0|}
  290|       |
  291|      0|- (NSUInteger)numberOfPrunableQueries {
  292|      0|    __block NSUInteger count = 0;
  293|      0|    [self.trackedQueryTree
  294|      0|        forEach:^(FPath *path, NSDictionary *trackedQueries) {
  295|      0|          [trackedQueries enumerateKeysAndObjectsUsingBlock:^(
  296|      0|                              FQueryParams *params, FTrackedQuery *trackedQuery,
  297|      0|                              BOOL *stop) {
  298|      0|            if (!trackedQuery.isActive) {
  299|      0|                count++;
  300|      0|            }
  301|      0|          }];
  302|      0|        }];
  303|      0|    return count;
  304|      0|}
  305|       |
  306|      0|- (NSSet *)filteredQueryIdsAtPath:(FPath *)path {
  307|      0|    NSDictionary *queries = [self.trackedQueryTree valueAtPath:path];
  308|      0|    if (queries) {
  309|      0|        NSMutableSet *ids = [NSMutableSet set];
  310|      0|        [queries enumerateKeysAndObjectsUsingBlock:^(
  311|      0|                     FQueryParams *params, FTrackedQuery *query, BOOL *stop) {
  312|      0|          if (!query.query.loadsAllData) {
  313|      0|              [ids addObject:@(query.queryId)];
  314|      0|          }
  315|      0|        }];
  316|      0|        return ids;
  317|      0|    } else {
  318|      0|        return [NSSet set];
  319|      0|    }
  320|      0|}
  321|       |
  322|      0|- (NSSet *)knownCompleteChildrenAtPath:(FPath *)path {
  323|      0|    NSAssert(![self isQueryComplete:[FQuerySpec defaultQueryAtPath:path]],
  324|      0|             @"Path is fully complete");
  325|      0|
  326|      0|    NSMutableSet *completeChildren = [NSMutableSet set];
  327|      0|    // First, get complete children from any queries at this location.
  328|      0|    NSSet *queryIds = [self filteredQueryIdsAtPath:path];
  329|      0|    [queryIds enumerateObjectsUsingBlock:^(NSNumber *queryId, BOOL *stop) {
  330|      0|      NSSet *keys = [self.storageEngine
  331|      0|          trackedQueryKeysForQuery:[queryId unsignedIntegerValue]];
  332|      0|      [completeChildren unionSet:keys];
  333|      0|    }];
  334|      0|
  335|      0|    // Second, get any complete default queries immediately below us.
  336|      0|    [[[self.trackedQueryTree subtreeAtPath:path] children]
  337|      0|        enumerateKeysAndObjectsUsingBlock:^(
  338|      0|            NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  339|      0|          if ([childTree.value[[FQueryParams defaultInstance]] isComplete]) {
  340|      0|              [completeChildren addObject:childKey];
  341|      0|          }
  342|      0|        }];
  343|      0|
  344|      0|    return completeChildren;
  345|      0|}
  346|       |
  347|      0|- (void)verifyCache {
  348|      0|    NSArray *storedTrackedQueries = [self.storageEngine loadTrackedQueries];
  349|      0|    NSMutableArray *trackedQueries = [NSMutableArray array];
  350|      0|
  351|      0|    [self.trackedQueryTree forEach:^(FPath *path, NSDictionary *queryDict) {
  352|      0|      [trackedQueries addObjectsFromArray:queryDict.allValues];
  353|      0|    }];
  354|      0|    NSComparator comparator =
  355|      0|        ^NSComparisonResult(FTrackedQuery *q1, FTrackedQuery *q2) {
  356|      0|          if (q1.queryId < q2.queryId) {
  357|      0|              return NSOrderedAscending;
  358|      0|          } else if (q1.queryId > q2.queryId) {
  359|      0|              return NSOrderedDescending;
  360|      0|          } else {
  361|      0|              return NSOrderedSame;
  362|      0|          }
  363|      0|        };
  364|      0|    [trackedQueries sortUsingComparator:comparator];
  365|      0|    storedTrackedQueries =
  366|      0|        [storedTrackedQueries sortedArrayUsingComparator:comparator];
  367|      0|
  368|      0|    if (![trackedQueries isEqualToArray:storedTrackedQueries]) {
  369|      0|        [NSException
  370|      0|             raise:NSInternalInconsistencyException
  371|      0|            format:@"Tracked queries and queries stored on disk don't match"];
  372|      0|    }
  373|      0|}
  374|       |
  375|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Realtime/FConnection.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FConnection.h"
   18|       |#import "FConstants.h"
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |
   21|       |typedef enum {
   22|       |    REALTIME_STATE_CONNECTING = 0,
   23|       |    REALTIME_STATE_CONNECTED = 1,
   24|       |    REALTIME_STATE_DISCONNECTED = 2,
   25|       |} FConnectionState;
   26|       |
   27|       |@interface FConnection () {
   28|       |    FConnectionState state;
   29|       |}
   30|       |
   31|       |@property(nonatomic, strong) FWebSocketConnection *conn;
   32|       |@property(nonatomic, strong) FRepoInfo *repoInfo;
   33|       |
   34|       |@end
   35|       |
   36|       |#pragma mark -
   37|       |#pragma mark FConnection implementation
   38|       |
   39|       |@implementation FConnection
   40|       |
   41|       |@synthesize delegate;
   42|       |@synthesize conn;
   43|       |@synthesize repoInfo;
   44|       |
   45|       |#pragma mark -
   46|       |#pragma mark Initializers
   47|       |
   48|       |- (id)initWith:(FRepoInfo *)aRepoInfo
   49|       |    andDispatchQueue:(dispatch_queue_t)queue
   50|      0|       lastSessionID:(NSString *)lastSessionID {
   51|      0|    self = [super init];
   52|      0|    if (self) {
   53|      0|        state = REALTIME_STATE_CONNECTING;
   54|      0|        self.repoInfo = aRepoInfo;
   55|      0|        self.conn = [[FWebSocketConnection alloc] initWith:self.repoInfo
   56|      0|                                                  andQueue:queue
   57|      0|                                             lastSessionID:lastSessionID];
   58|      0|        self.conn.delegate = self;
   59|      0|    }
   60|      0|    return self;
   61|      0|}
   62|       |
   63|       |#pragma mark -
   64|       |#pragma mark Public method implementation
   65|       |
   66|      0|- (void)open {
   67|      0|    FFLog(@"I-RDB082001", @"Calling open in FConnection");
   68|      0|    [self.conn open];
   69|      0|}
   70|       |
   71|      0|- (void)closeWithReason:(FDisconnectReason)reason {
   72|      0|    if (state != REALTIME_STATE_DISCONNECTED) {
   73|      0|        FFLog(@"I-RDB082002", @"Closing realtime connection.");
   74|      0|        state = REALTIME_STATE_DISCONNECTED;
   75|      0|
   76|      0|        if (self.conn) {
   77|      0|            FFLog(@"I-RDB082003", @"Calling close again.");
   78|      0|            [self.conn close];
   79|      0|            self.conn = nil;
   80|      0|        }
   81|      0|
   82|      0|        [self.delegate onDisconnect:self withReason:reason];
   83|      0|    }
   84|      0|}
   85|       |
   86|      0|- (void)close {
   87|      0|    [self closeWithReason:DISCONNECT_REASON_OTHER];
   88|      0|}
   89|       |
   90|      0|- (void)sendRequest:(NSDictionary *)dataMsg sensitive:(BOOL)sensitive {
   91|      0|    // since this came from the persistent connection, wrap it in a data message
   92|      0|    // envelope
   93|      0|    NSDictionary *msg = @{
   94|      0|        kFWPRequestType : kFWPRequestTypeData,
   95|      0|        kFWPRequestDataPayload : dataMsg
   96|      0|    };
   97|      0|    [self sendData:msg sensitive:sensitive];
   98|      0|}
   99|       |
  100|       |#pragma mark -
  101|       |#pragma mark Helpers
  102|       |
  103|      0|- (void)sendData:(NSDictionary *)data sensitive:(BOOL)sensitive {
  104|      0|    if (state != REALTIME_STATE_CONNECTED) {
  105|      0|        @throw [[NSException alloc]
  106|      0|            initWithName:@"InvalidConnectionState"
  107|      0|                  reason:@"Tried to send data on an unconnected FConnection"
  108|      0|                userInfo:nil];
  109|      0|    } else {
  110|      0|        if (sensitive) {
  111|      0|            FFLog(@"I-RDB082004", @"Sending data (contents hidden)");
  112|      0|        } else {
  113|      0|            FFLog(@"I-RDB082005", @"Sending: %@", data);
  114|      0|        }
  115|      0|        [self.conn send:data];
  116|      0|    }
  117|      0|}
  118|       |
  119|       |#pragma mark -
  120|       |#pragma mark FWebSocketConnectinDelegate implementation
  121|       |
  122|       |// Corresponds to onConnectionLost in JS
  123|       |- (void)onDisconnect:(FWebSocketConnection *)fwebSocket
  124|      0|    wasEverConnected:(BOOL)everConnected {
  125|      0|
  126|      0|    self.conn = nil;
  127|      0|    if (!everConnected && state == REALTIME_STATE_CONNECTING) {
  128|      0|        FFLog(@"I-RDB082006", @"Realtime connection failed.");
  129|      0|
  130|      0|        // Since we failed to connect at all, clear any cached entry for this
  131|      0|        // namespace in case the machine went away
  132|      0|        [self.repoInfo clearInternalHostCache];
  133|      0|    } else if (state == REALTIME_STATE_CONNECTED) {
  134|      0|        FFLog(@"I-RDB082007", @"Realtime connection lost.");
  135|      0|    }
  136|      0|
  137|      0|    [self close];
  138|      0|}
  139|       |
  140|       |// Corresponds to onMessageReceived in JS
  141|       |- (void)onMessage:(FWebSocketConnection *)fwebSocket
  142|      0|      withMessage:(NSDictionary *)message {
  143|      0|    NSString *rawMessageType =
  144|      0|        [message objectForKey:kFWPAsyncServerEnvelopeType];
  145|      0|    if (rawMessageType != nil) {
  146|      0|        if ([rawMessageType isEqualToString:kFWPAsyncServerDataMessage]) {
  147|      0|            [self onDataMessage:[message
  148|      0|                                    objectForKey:kFWPAsyncServerEnvelopeData]];
  149|      0|        } else if ([rawMessageType
  150|      0|                       isEqualToString:kFWPAsyncServerControlMessage]) {
  151|      0|            [self onControl:[message objectForKey:kFWPAsyncServerEnvelopeData]];
  152|      0|        } else {
  153|      0|            FFLog(@"I-RDB082008", @"Unrecognized server packet type: %@",
  154|      0|                  rawMessageType);
  155|      0|        }
  156|      0|    } else {
  157|      0|        FFLog(@"I-RDB082009", @"Unrecognized raw server packet received: %@",
  158|      0|              message);
  159|      0|    }
  160|      0|}
  161|       |
  162|      0|- (void)onDataMessage:(NSDictionary *)message {
  163|      0|    // we don't do anything with data messages, just kick them up a level
  164|      0|    FFLog(@"I-RDB082010", @"Got data message: %@", message);
  165|      0|    [self.delegate onDataMessage:self withMessage:message];
  166|      0|}
  167|       |
  168|      0|- (void)onControl:(NSDictionary *)message {
  169|      0|    FFLog(@"I-RDB082011", @"Got control message: %@", message);
  170|      0|    NSString *type = [message objectForKey:kFWPAsyncServerControlMessageType];
  171|      0|    if ([type isEqualToString:kFWPAsyncServerControlMessageShutdown]) {
  172|      0|        NSString *reason =
  173|      0|            [message objectForKey:kFWPAsyncServerControlMessageData];
  174|      0|        [self onConnectionShutdownWithReason:reason];
  175|      0|    } else if ([type isEqualToString:kFWPAsyncServerControlMessageReset]) {
  176|      0|        NSString *host =
  177|      0|            [message objectForKey:kFWPAsyncServerControlMessageData];
  178|      0|        [self onReset:host];
  179|      0|    } else if ([type isEqualToString:kFWPAsyncServerHello]) {
  180|      0|        NSDictionary *handshakeData =
  181|      0|            [message objectForKey:kFWPAsyncServerControlMessageData];
  182|      0|        [self onHandshake:handshakeData];
  183|      0|    } else {
  184|      0|        FFLog(@"I-RDB082012",
  185|      0|              @"Unknown control message returned from server: %@", message);
  186|      0|    }
  187|      0|}
  188|       |
  189|      0|- (void)onConnectionShutdownWithReason:(NSString *)reason {
  190|      0|    FFLog(@"I-RDB082013",
  191|      0|          @"Connection shutdown command received. Shutting down...");
  192|      0|
  193|      0|    [self.delegate onKill:self withReason:reason];
  194|      0|    [self close];
  195|      0|}
  196|       |
  197|      0|- (void)onHandshake:(NSDictionary *)handshake {
  198|      0|    NSNumber *timestamp =
  199|      0|        [handshake objectForKey:kFWPAsyncServerHelloTimestamp];
  200|      0|    //    NSString* version = [handshake
  201|      0|    //    objectForKey:kFWPAsyncServerHelloVersion];
  202|      0|    NSString *host = [handshake objectForKey:kFWPAsyncServerHelloConnectedHost];
  203|      0|    NSString *sessionID = [handshake objectForKey:kFWPAsyncServerHelloSession];
  204|      0|
  205|      0|    self.repoInfo.internalHost = host;
  206|      0|
  207|      0|    if (state == REALTIME_STATE_CONNECTING) {
  208|      0|        [self.conn start];
  209|      0|        [self onConnection:self.conn readyAtTime:timestamp sessionID:sessionID];
  210|      0|    }
  211|      0|}
  212|       |
  213|       |- (void)onConnection:(FWebSocketConnection *)conn
  214|       |         readyAtTime:(NSNumber *)timestamp
  215|      0|           sessionID:(NSString *)sessionID {
  216|      0|    FFLog(@"I-RDB082014", @"Realtime connection established");
  217|      0|    state = REALTIME_STATE_CONNECTED;
  218|      0|
  219|      0|    [self.delegate onReady:self atTime:timestamp sessionID:sessionID];
  220|      0|}
  221|       |
  222|      0|- (void)onReset:(NSString *)host {
  223|      0|    FFLog(
  224|      0|        @"I-RDB082015",
  225|      0|        @"Got a reset; killing connection to: %@; Updating internalHost to: %@",
  226|      0|        repoInfo.internalHost, host);
  227|      0|    self.repoInfo.internalHost = host;
  228|      0|
  229|      0|    // Explicitly close the connection with SERVER_RESET so calling code knows
  230|      0|    // to reconnect immediately.
  231|      0|    [self closeWithReason:DISCONNECT_REASON_SERVER_RESET];
  232|      0|}
  233|       |
  234|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Realtime/FWebSocketConnection.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |// Targetted compilation is ONLY for testing. UIKit is weak-linked in actual
   18|       |// release build.
   19|       |
   20|       |#import <Foundation/Foundation.h>
   21|       |
   22|       |#import "FConstants.h"
   23|       |#import "FIRDatabaseReference.h"
   24|       |#import "FIRDatabase_Private.h"
   25|       |#import "FStringUtilities.h"
   26|       |#import "FWebSocketConnection.h"
   27|       |#import <FirebaseCore/FIRLogger.h>
   28|       |
   29|       |#if TARGET_OS_IOS || TARGET_OS_TV
   30|       |#import <UIKit/UIKit.h>
   31|       |#endif
   32|       |
   33|       |@interface FWebSocketConnection () {
   34|       |    NSMutableString *frame;
   35|       |    BOOL everConnected;
   36|       |    BOOL isClosed;
   37|       |    NSTimer *keepAlive;
   38|       |}
   39|       |
   40|       |- (void)shutdown;
   41|       |- (void)onClosed;
   42|       |- (void)closeIfNeverConnected;
   43|       |
   44|       |@property(nonatomic, strong) FSRWebSocket *webSocket;
   45|       |@property(nonatomic, strong) NSNumber *connectionId;
   46|       |@property(nonatomic, readwrite) int totalFrames;
   47|       |@property(nonatomic, readonly) BOOL buffering;
   48|       |@property(nonatomic, readonly) NSString *userAgent;
   49|       |@property(nonatomic) dispatch_queue_t dispatchQueue;
   50|       |
   51|       |- (void)nop:(NSTimer *)timer;
   52|       |
   53|       |@end
   54|       |
   55|       |@implementation FWebSocketConnection
   56|       |
   57|       |@synthesize delegate;
   58|       |@synthesize webSocket;
   59|       |@synthesize connectionId;
   60|       |
   61|       |- (id)initWith:(FRepoInfo *)repoInfo
   62|       |         andQueue:(dispatch_queue_t)queue
   63|      0|    lastSessionID:(NSString *)lastSessionID {
   64|      0|    self = [super init];
   65|      0|    if (self) {
   66|      0|        everConnected = NO;
   67|      0|        isClosed = NO;
   68|      0|        self.connectionId = [FUtilities LUIDGenerator];
   69|      0|        self.totalFrames = 0;
   70|      0|        self.dispatchQueue = queue;
   71|      0|        frame = nil;
   72|      0|
   73|      0|        NSString *connectionUrl =
   74|      0|            [repoInfo connectionURLWithLastSessionID:lastSessionID];
   75|      0|        NSString *ua = [self userAgent];
   76|      0|        FFLog(@"I-RDB083001", @"(wsc:%@) Connecting to: %@ as %@",
   77|      0|              self.connectionId, connectionUrl, ua);
   78|      0|
   79|      0|        NSURLRequest *req = [[NSURLRequest alloc]
   80|      0|            initWithURL:[[NSURL alloc] initWithString:connectionUrl]];
   81|      0|        self.webSocket = [[FSRWebSocket alloc] initWithURLRequest:req
   82|      0|                                                            queue:queue
   83|      0|                                                     andUserAgent:ua];
   84|      0|        [self.webSocket setDelegateDispatchQueue:queue];
   85|      0|        self.webSocket.delegate = self;
   86|      0|    }
   87|      0|    return self;
   88|      0|}
   89|       |
   90|      0|- (NSString *)userAgent {
   91|      0|    NSString *systemVersion;
   92|      0|    NSString *deviceName;
   93|      0|    BOOL hasUiDeviceClass = NO;
   94|      0|
   95|      0|// Targetted compilation is ONLY for testing. UIKit is weak-linked in actual
   96|      0|// release build.
   97|      0|#if TARGET_OS_IOS || TARGET_OS_TV
   98|      0|    Class uiDeviceClass = NSClassFromString(@"UIDevice");
   99|      0|    if (uiDeviceClass) {
  100|      0|        systemVersion = [uiDeviceClass currentDevice].systemVersion;
  101|      0|        deviceName = [uiDeviceClass currentDevice].model;
  102|      0|        hasUiDeviceClass = YES;
  103|      0|    }
  104|      0|#endif
  105|      0|
  106|      0|    if (!hasUiDeviceClass) {
  107|      0|        NSDictionary *systemVersionDictionary = [NSDictionary
  108|      0|            dictionaryWithContentsOfFile:
  109|      0|                @"/System/Library/CoreServices/SystemVersion.plist"];
  110|      0|        systemVersion =
  111|      0|            [systemVersionDictionary objectForKey:@"ProductVersion"];
  112|      0|        deviceName = [systemVersionDictionary objectForKey:@"ProductName"];
  113|      0|    }
  114|      0|
  115|      0|    NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  116|      0|
  117|      0|    // Sanitize '/'s in deviceName and bundleIdentifier for stats
  118|      0|    deviceName = [FStringUtilities sanitizedForUserAgent:deviceName];
  119|      0|    bundleIdentifier =
  120|      0|        [FStringUtilities sanitizedForUserAgent:bundleIdentifier];
  121|      0|
  122|      0|    // Firebase/5/<semver>_<build date>_<git hash>/<os version>/{device model /
  123|      0|    // os (Mac OS X, iPhone, etc.}_<bundle id>
  124|      0|    NSString *ua = [NSString
  125|      0|        stringWithFormat:@"Firebase/%@/%@/%@/%@_%@", kWebsocketProtocolVersion,
  126|      0|                         [FIRDatabase buildVersion], systemVersion, deviceName,
  127|      0|                         bundleIdentifier];
  128|      0|    return ua;
  129|      0|}
  130|       |
  131|      0|- (BOOL)buffering {
  132|      0|    return frame != nil;
  133|      0|}
  134|       |
  135|       |#pragma mark -
  136|       |#pragma mark Public FWebSocketConnection methods
  137|       |
  138|      0|- (void)open {
  139|      0|    FFLog(@"I-RDB083002", @"(wsc:%@) FWebSocketConnection open.",
  140|      0|          self.connectionId);
  141|      0|    assert(delegate);
  142|      0|    everConnected = NO;
  143|      0|    // TODO Assert url
  144|      0|    [self.webSocket open];
  145|      0|    dispatch_time_t when = dispatch_time(
  146|      0|        DISPATCH_TIME_NOW, kWebsocketConnectTimeout * NSEC_PER_SEC);
  147|      0|    dispatch_after(when, self.dispatchQueue, ^{
  148|      0|      [self closeIfNeverConnected];
  149|      0|    });
  150|      0|}
  151|       |
  152|      0|- (void)close {
  153|      0|    FFLog(@"I-RDB083003", @"(wsc:%@) FWebSocketConnection is being closed.",
  154|      0|          self.connectionId);
  155|      0|    isClosed = YES;
  156|      0|    [self.webSocket close];
  157|      0|}
  158|       |
  159|      0|- (void)start {
  160|      0|    // Start is a no-op for websockets.
  161|      0|}
  162|       |
  163|      0|- (void)send:(NSDictionary *)dictionary {
  164|      0|
  165|      0|    [self resetKeepAlive];
  166|      0|
  167|      0|    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dictionary
  168|      0|                                                       options:kNilOptions
  169|      0|                                                         error:nil];
  170|      0|
  171|      0|    NSString *data = [[NSString alloc] initWithData:jsonData
  172|      0|                                           encoding:NSUTF8StringEncoding];
  173|      0|
  174|      0|    NSArray *dataSegs = [FUtilities splitString:data
  175|      0|                                    intoMaxSize:kWebsocketMaxFrameSize];
  176|      0|
  177|      0|    // First send the header so the server knows how many segments are
  178|      0|    // forthcoming
  179|      0|    if (dataSegs.count > 1) {
  180|      0|        [self.webSocket
  181|      0|            send:[NSString
  182|      0|                     stringWithFormat:@"%u", (unsigned int)dataSegs.count]];
  183|      0|    }
  184|      0|
  185|      0|    // Then, actually send the segments.
  186|      0|    for (NSString *segment in dataSegs) {
  187|      0|        [self.webSocket send:segment];
  188|      0|    }
  189|      0|}
  190|       |
  191|      0|- (void)nop:(NSTimer *)timer {
  192|      0|    if (!isClosed) {
  193|      0|        FFLog(@"I-RDB083004", @"(wsc:%@) nop", self.connectionId);
  194|      0|        [self.webSocket send:@"0"];
  195|      0|    } else {
  196|      0|        FFLog(@"I-RDB083005",
  197|      0|              @"(wsc:%@) No more websocket; invalidating nop timer.",
  198|      0|              self.connectionId);
  199|      0|        [timer invalidate];
  200|      0|    }
  201|      0|}
  202|       |
  203|      0|- (void)handleNewFrameCount:(int)numFrames {
  204|      0|    self.totalFrames = numFrames;
  205|      0|    frame = [[NSMutableString alloc] initWithString:@""];
  206|      0|    FFLog(@"I-RDB083006", @"(wsc:%@) handleNewFrameCount: %d",
  207|      0|          self.connectionId, self.totalFrames);
  208|      0|}
  209|       |
  210|      0|- (NSString *)extractFrameCount:(NSString *)message {
  211|      0|    if ([message length] <= 4) {
  212|      0|        int frameCount = [message intValue];
  213|      0|        if (frameCount > 0) {
  214|      0|            [self handleNewFrameCount:frameCount];
  215|      0|            return nil;
  216|      0|        }
  217|      0|    }
  218|      0|    [self handleNewFrameCount:1];
  219|      0|    return message;
  220|      0|}
  221|       |
  222|      0|- (void)appendFrame:(NSString *)message {
  223|      0|    [frame appendString:message];
  224|      0|    self.totalFrames = self.totalFrames - 1;
  225|      0|
  226|      0|    if (self.totalFrames == 0) {
  227|      0|        // Call delegate and pass an immutable version of the frame
  228|      0|        NSDictionary *json = [NSJSONSerialization
  229|      0|            JSONObjectWithData:[frame dataUsingEncoding:NSUTF8StringEncoding]
  230|      0|                       options:kNilOptions
  231|      0|                         error:nil];
  232|      0|        frame = nil;
  233|      0|        FFLog(@"I-RDB083007",
  234|      0|              @"(wsc:%@) handleIncomingFrame sending complete frame: %d",
  235|      0|              self.connectionId, self.totalFrames);
  236|      0|
  237|      0|        @autoreleasepool {
  238|      0|            [self.delegate onMessage:self withMessage:json];
  239|      0|        }
  240|      0|    }
  241|      0|}
  242|       |
  243|      0|- (void)handleIncomingFrame:(NSString *)message {
  244|      0|    [self resetKeepAlive];
  245|      0|    if (self.buffering) {
  246|      0|        [self appendFrame:message];
  247|      0|    } else {
  248|      0|        NSString *remaining = [self extractFrameCount:message];
  249|      0|        if (remaining) {
  250|      0|            [self appendFrame:remaining];
  251|      0|        }
  252|      0|    }
  253|      0|}
  254|       |
  255|       |#pragma mark -
  256|       |#pragma mark SRWebSocketDelegate implementation
  257|      0|- (void)webSocket:(FSRWebSocket *)webSocket didReceiveMessage:(id)message {
  258|      0|    [self handleIncomingFrame:message];
  259|      0|}
  260|       |
  261|      0|- (void)webSocketDidOpen:(FSRWebSocket *)webSocket {
  262|      0|    FFLog(@"I-RDB083008", @"(wsc:%@) webSocketDidOpen", self.connectionId);
  263|      0|
  264|      0|    everConnected = YES;
  265|      0|
  266|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  267|      0|      self->keepAlive =
  268|      0|          [NSTimer scheduledTimerWithTimeInterval:kWebsocketKeepaliveInterval
  269|      0|                                           target:self
  270|      0|                                         selector:@selector(nop:)
  271|      0|                                         userInfo:nil
  272|      0|                                          repeats:YES];
  273|      0|      FFLog(@"I-RDB083009", @"(wsc:%@) nop timer kicked off",
  274|      0|            self.connectionId);
  275|      0|    });
  276|      0|}
  277|       |
  278|      0|- (void)webSocket:(FSRWebSocket *)webSocket didFailWithError:(NSError *)error {
  279|      0|    FFLog(@"I-RDB083010", @"(wsc:%@) didFailWithError didFailWithError: %@",
  280|      0|          self.connectionId, [error description]);
  281|      0|    [self onClosed];
  282|      0|}
  283|       |
  284|       |- (void)webSocket:(FSRWebSocket *)webSocket
  285|       |    didCloseWithCode:(NSInteger)code
  286|       |              reason:(NSString *)reason
  287|      0|            wasClean:(BOOL)wasClean {
  288|      0|    FFLog(@"I-RDB083011", @"(wsc:%@) didCloseWithCode: %ld %@",
  289|      0|          self.connectionId, (long)code, reason);
  290|      0|    [self onClosed];
  291|      0|}
  292|       |
  293|       |#pragma mark -
  294|       |#pragma mark Private methods
  295|       |
  296|       |/**
  297|       | * Note that the close / onClosed / shutdown cycle here is a little different
  298|       | * from the javascript client. In order to properly handle deallocation, no
  299|       | * close-related action is taken at a higher level until we have received
  300|       | * notification from the websocket itself that it is closed. Otherwise, we end
  301|       | * up deallocating this class and the FConnection class before the websocket has
  302|       | * a change to call some of its delegate methods. So, since close is the
  303|       | * external close handler, we just set a flag saying not to call our own
  304|       | * delegate method and close the websocket. That will trigger a callback into
  305|       | * this class that can then do things like clean up the keepalive timer.
  306|       | */
  307|       |
  308|      0|- (void)closeIfNeverConnected {
  309|      0|    if (!everConnected) {
  310|      0|        FFLog(@"I-RDB083012", @"(wsc:%@) Websocket timed out on connect",
  311|      0|              self.connectionId);
  312|      0|        [self.webSocket close];
  313|      0|    }
  314|      0|}
  315|       |
  316|      0|- (void)shutdown {
  317|      0|    isClosed = YES;
  318|      0|
  319|      0|    // Call delegate methods
  320|      0|    [self.delegate onDisconnect:self wasEverConnected:everConnected];
  321|      0|}
  322|       |
  323|      0|- (void)onClosed {
  324|      0|    if (!isClosed) {
  325|      0|        FFLog(@"I-RDB083013", @"Websocket is closing itself");
  326|      0|        [self shutdown];
  327|      0|    }
  328|      0|    self.webSocket = nil;
  329|      0|    if (keepAlive.isValid) {
  330|      0|        [keepAlive invalidate];
  331|      0|    }
  332|      0|}
  333|       |
  334|      0|- (void)resetKeepAlive {
  335|      0|    NSDate *newTime =
  336|      0|        [NSDate dateWithTimeIntervalSinceNow:kWebsocketKeepaliveInterval];
  337|      0|    // Calling setFireDate is actually kinda' expensive, so wait at least 5
  338|      0|    // seconds before updating it.
  339|      0|    if ([newTime timeIntervalSinceDate:keepAlive.fireDate] > 5) {
  340|      0|        FFLog(@"I-RDB083014", @"(wsc:%@) resetting keepalive, to %@ ; old: %@",
  341|      0|              self.connectionId, newTime, [keepAlive fireDate]);
  342|      0|        [keepAlive setFireDate:newTime];
  343|      0|    }
  344|      0|}
  345|       |
  346|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Snapshot/FChildrenNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FChildrenNode.h"
   18|       |#import "FConstants.h"
   19|       |#import "FEmptyNode.h"
   20|       |#import "FMaxNode.h"
   21|       |#import "FNamedNode.h"
   22|       |#import "FPriorityIndex.h"
   23|       |#import "FSnapshotUtilities.h"
   24|       |#import "FStringUtilities.h"
   25|       |#import "FTransformedEnumerator.h"
   26|       |#import "FUtilities.h"
   27|       |
   28|       |@interface FChildrenNode ()
   29|       |@property(nonatomic, strong) NSString *lazyHash;
   30|       |@end
   31|       |
   32|       |@implementation FChildrenNode
   33|       |
   34|       |// Note: The only reason we allow nil priority is to for EmptyNode, since we
   35|       |// can't use EmptyNode as the priority of EmptyNode.  We might want to consider
   36|       |// making EmptyNode its own class instead of an empty ChildrenNode.
   37|       |
   38|      0|- (id)init {
   39|      0|    return [self
   40|      0|        initWithPriority:nil
   41|      0|                children:[FImmutableSortedDictionary
   42|      0|                             dictionaryWithComparator:[FUtilities
   43|      0|                                                          keyComparator]]];
   44|      0|}
   45|       |
   46|      0|- (id)initWithChildren:(FImmutableSortedDictionary *)someChildren {
   47|      0|    return [self initWithPriority:nil children:someChildren];
   48|      0|}
   49|       |
   50|       |- (id)initWithPriority:(id<FNode>)aPriority
   51|      0|              children:(FImmutableSortedDictionary *)someChildren {
   52|      0|    if (someChildren.isEmpty && aPriority != nil && ![aPriority isEmpty]) {
   53|      0|        [NSException raise:NSInvalidArgumentException
   54|      0|                    format:@"Can't create empty node with priority!"];
   55|      0|    }
   56|      0|    self = [super init];
   57|      0|    if (self) {
   58|      0|        self.children = someChildren;
   59|      0|        self.priorityNode = aPriority;
   60|      0|    }
   61|      0|    return self;
   62|      0|}
   63|       |
   64|      0|- (NSString *)description {
   65|      0|    return [[self valForExport:YES] description];
   66|      0|}
   67|       |
   68|       |#pragma mark -
   69|       |#pragma mark FNode methods
   70|       |
   71|      0|- (BOOL)isLeafNode {
   72|      0|    return NO;
   73|      0|}
   74|       |
   75|      0|- (id<FNode>)getPriority {
   76|      0|    if (self.priorityNode) {
   77|      0|        return self.priorityNode;
   78|      0|    } else {
   79|      0|        return [FEmptyNode emptyNode];
   80|      0|    }
   81|      0|}
   82|       |
   83|      0|- (id<FNode>)updatePriority:(id<FNode>)aPriority {
   84|      0|    if ([self.children isEmpty]) {
   85|      0|        return [FEmptyNode emptyNode];
   86|      0|    } else {
   87|      0|        return [[FChildrenNode alloc] initWithPriority:aPriority
   88|      0|                                              children:self.children];
   89|      0|    }
   90|      0|}
   91|       |
   92|      0|- (id<FNode>)getImmediateChild:(NSString *)childName {
   93|      0|    if ([childName isEqualToString:@".priority"]) {
   94|      0|        return [self getPriority];
   95|      0|    } else {
   96|      0|        id<FNode> child = [self.children objectForKey:childName];
   97|      0|        return (child == nil) ? [FEmptyNode emptyNode] : child;
   98|      0|    }
   99|      0|}
  100|       |
  101|      0|- (id<FNode>)getChild:(FPath *)path {
  102|      0|    NSString *front = [path getFront];
  103|      0|    if (front == nil) {
  104|      0|        return self;
  105|      0|    } else {
  106|      0|        return [[self getImmediateChild:front] getChild:[path popFront]];
  107|      0|    }
  108|      0|}
  109|       |
  110|      0|- (BOOL)hasChild:(NSString *)childName {
  111|      0|    return ![self getImmediateChild:childName].isEmpty;
  112|      0|}
  113|       |
  114|       |- (id<FNode>)updateImmediateChild:(NSString *)childName
  115|      0|                     withNewChild:(id<FNode>)newChildNode {
  116|      0|    NSAssert(newChildNode != nil, @"Should always be passing nodes.");
  117|      0|
  118|      0|    if ([childName isEqualToString:@".priority"]) {
  119|      0|        return [self updatePriority:newChildNode];
  120|      0|    } else {
  121|      0|        FImmutableSortedDictionary *newChildren;
  122|      0|        if (newChildNode.isEmpty) {
  123|      0|            newChildren = [self.children removeObjectForKey:childName];
  124|      0|        } else {
  125|      0|            newChildren = [self.children setObject:newChildNode
  126|      0|                                            forKey:childName];
  127|      0|        }
  128|      0|        if (newChildren.isEmpty) {
  129|      0|            return [FEmptyNode emptyNode];
  130|      0|        } else {
  131|      0|            return [[FChildrenNode alloc] initWithPriority:self.getPriority
  132|      0|                                                  children:newChildren];
  133|      0|        }
  134|      0|    }
  135|      0|}
  136|       |
  137|      0|- (id<FNode>)updateChild:(FPath *)path withNewChild:(id<FNode>)newChildNode {
  138|      0|    NSString *front = [path getFront];
  139|      0|    if (front == nil) {
  140|      0|        return newChildNode;
  141|      0|    } else {
  142|      0|        NSAssert(![front isEqualToString:@".priority"] || path.length == 1,
  143|      0|                 @".priority must be the last token in a path.");
  144|      0|        id<FNode> newImmediateChild =
  145|      0|            [[self getImmediateChild:front] updateChild:[path popFront]
  146|      0|                                           withNewChild:newChildNode];
  147|      0|        return [self updateImmediateChild:front withNewChild:newImmediateChild];
  148|      0|    }
  149|      0|}
  150|       |
  151|      0|- (BOOL)isEmpty {
  152|      0|    return [self.children isEmpty];
  153|      0|}
  154|       |
  155|      0|- (int)numChildren {
  156|      0|    return [self.children count];
  157|      0|}
  158|       |
  159|      0|- (id)val {
  160|      0|    return [self valForExport:NO];
  161|      0|}
  162|       |
  163|      0|- (id)valForExport:(BOOL)exp {
  164|      0|    if ([self isEmpty]) {
  165|      0|        return [NSNull null];
  166|      0|    }
  167|      0|
  168|      0|    __block int numKeys = 0;
  169|      0|    __block NSInteger maxKey = 0;
  170|      0|    __block BOOL allIntegerKeys = YES;
  171|      0|
  172|      0|    NSMutableDictionary *obj =
  173|      0|        [[NSMutableDictionary alloc] initWithCapacity:[self.children count]];
  174|      0|    [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> childNode,
  175|      0|                                        BOOL *stop) {
  176|      0|      [obj setObject:[childNode valForExport:exp] forKey:key];
  177|      0|
  178|      0|      numKeys++;
  179|      0|
  180|      0|      // If we already found a string key, don't bother with any of this
  181|      0|      if (!allIntegerKeys) {
  182|      0|          return;
  183|      0|      }
  184|      0|
  185|      0|      // Treat leading zeroes that are not exactly "0" as strings
  186|      0|      NSString *firstChar = [key substringWithRange:NSMakeRange(0, 1)];
  187|      0|      if ([firstChar isEqualToString:@"0"] && [key length] > 1) {
  188|      0|          allIntegerKeys = NO;
  189|      0|      } else {
  190|      0|          NSNumber *keyAsNum = [FUtilities intForString:key];
  191|      0|          if (keyAsNum != nil) {
  192|      0|              NSInteger keyAsInt = [keyAsNum integerValue];
  193|      0|              if (keyAsInt > maxKey) {
  194|      0|                  maxKey = keyAsInt;
  195|      0|              }
  196|      0|          } else {
  197|      0|              allIntegerKeys = NO;
  198|      0|          }
  199|      0|      }
  200|      0|    }];
  201|      0|
  202|      0|    if (!exp && allIntegerKeys && maxKey < 2 * numKeys) {
  203|      0|        // convert to an array
  204|      0|        NSMutableArray *array =
  205|      0|            [[NSMutableArray alloc] initWithCapacity:maxKey + 1];
  206|      0|        for (int i = 0; i <= maxKey; ++i) {
  207|      0|            NSString *keyString = [NSString stringWithFormat:@"%i", i];
  208|      0|            id child = obj[keyString];
  209|      0|            if (child != nil) {
  210|      0|                [array addObject:child];
  211|      0|            } else {
  212|      0|                [array addObject:[NSNull null]];
  213|      0|            }
  214|      0|        }
  215|      0|        return array;
  216|      0|    } else {
  217|      0|
  218|      0|        if (exp && [self getPriority] != nil && !self.getPriority.isEmpty) {
  219|      0|            obj[kPayloadPriority] = [self.getPriority val];
  220|      0|        }
  221|      0|
  222|      0|        return obj;
  223|      0|    }
  224|      0|}
  225|       |
  226|      0|- (NSString *)dataHash {
  227|      0|    if (self.lazyHash == nil) {
  228|      0|        NSMutableString *toHash = [[NSMutableString alloc] init];
  229|      0|
  230|      0|        if (!self.getPriority.isEmpty) {
  231|      0|            [toHash appendString:@"priority:"];
  232|      0|            [FSnapshotUtilities
  233|      0|                appendHashRepresentationForLeafNode:(FLeafNode *)
  234|      0|                                                        self.getPriority
  235|      0|                                           toString:toHash
  236|      0|                                        hashVersion:FDataHashVersionV1];
  237|      0|            [toHash appendString:@":"];
  238|      0|        }
  239|      0|
  240|      0|        __block BOOL sawPriority = NO;
  241|      0|        [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  242|      0|                                            BOOL *stop) {
  243|      0|          sawPriority = sawPriority || [[node getPriority] isEmpty];
  244|      0|          *stop = sawPriority;
  245|      0|        }];
  246|      0|        if (sawPriority) {
  247|      0|            NSMutableArray *array = [NSMutableArray array];
  248|      0|            [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  249|      0|                                                BOOL *stop) {
  250|      0|              FNamedNode *namedNode = [[FNamedNode alloc] initWithName:key
  251|      0|                                                               andNode:node];
  252|      0|              [array addObject:namedNode];
  253|      0|            }];
  254|      0|            [array sortUsingComparator:^NSComparisonResult(
  255|      0|                       FNamedNode *namedNode1, FNamedNode *namedNode2) {
  256|      0|              return
  257|      0|                  [[FPriorityIndex priorityIndex] compareNamedNode:namedNode1
  258|      0|                                                       toNamedNode:namedNode2];
  259|      0|            }];
  260|      0|            [array enumerateObjectsUsingBlock:^(FNamedNode *namedNode,
  261|      0|                                                NSUInteger idx, BOOL *stop) {
  262|      0|              NSString *childHash = [namedNode.node dataHash];
  263|      0|              if (![childHash isEqualToString:@""]) {
  264|      0|                  [toHash appendFormat:@":%@:%@", namedNode.name, childHash];
  265|      0|              }
  266|      0|            }];
  267|      0|        } else {
  268|      0|            [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  269|      0|                                                BOOL *stop) {
  270|      0|              NSString *childHash = [node dataHash];
  271|      0|              if (![childHash isEqualToString:@""]) {
  272|      0|                  [toHash appendFormat:@":%@:%@", key, childHash];
  273|      0|              }
  274|      0|            }];
  275|      0|        }
  276|      0|        self.lazyHash = [toHash isEqualToString:@""]
  277|      0|                            ? @""
  278|      0|                            : [FStringUtilities base64EncodedSha1:toHash];
  279|      0|    }
  280|      0|    return self.lazyHash;
  281|      0|}
  282|       |
  283|      0|- (NSComparisonResult)compare:(id<FNode>)other {
  284|      0|    // children nodes come last, unless this is actually an empty node, then we
  285|      0|    // come first.
  286|      0|    if (self.isEmpty) {
  287|      0|        if (other.isEmpty) {
  288|      0|            return NSOrderedSame;
  289|      0|        } else {
  290|      0|            return NSOrderedAscending;
  291|      0|        }
  292|      0|    } else if (other.isLeafNode || other.isEmpty) {
  293|      0|        return NSOrderedDescending;
  294|      0|    } else if (other == [FMaxNode maxNode]) {
  295|      0|        return NSOrderedAscending;
  296|      0|    } else {
  297|      0|        // Must be another node with children.
  298|      0|        return NSOrderedSame;
  299|      0|    }
  300|      0|}
  301|       |
  302|      0|- (BOOL)isEqual:(id<FNode>)other {
  303|      0|    if (other == self) {
  304|      0|        return YES;
  305|      0|    } else if (other == nil) {
  306|      0|        return NO;
  307|      0|    } else if (other.isLeafNode) {
  308|      0|        return NO;
  309|      0|    } else if (self.isEmpty && [other isEmpty]) {
  310|      0|        // Empty nodes do not have priority
  311|      0|        return YES;
  312|      0|    } else {
  313|      0|        FChildrenNode *otherChildrenNode = other;
  314|      0|        if (![self.getPriority isEqual:other.getPriority]) {
  315|      0|            return NO;
  316|      0|        } else if (self.children.count == otherChildrenNode.children.count) {
  317|      0|            __block BOOL equal = YES;
  318|      0|            [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  319|      0|                                                BOOL *stop) {
  320|      0|              id<FNode> child = [otherChildrenNode getImmediateChild:key];
  321|      0|              if (![child isEqual:node]) {
  322|      0|                  equal = NO;
  323|      0|                  *stop = YES;
  324|      0|              }
  325|      0|            }];
  326|      0|            return equal;
  327|      0|        } else {
  328|      0|            return NO;
  329|      0|        }
  330|      0|    }
  331|      0|}
  332|       |
  333|      0|- (NSUInteger)hash {
  334|      0|    __block NSUInteger hashCode = 0;
  335|      0|    [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  336|      0|                                        BOOL *stop) {
  337|      0|      hashCode = 31 * hashCode + key.hash;
  338|      0|      hashCode = 17 * hashCode + node.hash;
  339|      0|    }];
  340|      0|    return 17 * hashCode + self.priorityNode.hash;
  341|      0|}
  342|       |
  343|       |- (void)enumerateChildrenAndPriorityUsingBlock:(void (^)(NSString *, id<FNode>,
  344|      0|                                                         BOOL *))block {
  345|      0|    if ([self.getPriority isEmpty]) {
  346|      0|        [self enumerateChildrenUsingBlock:block];
  347|      0|    } else {
  348|      0|        __block BOOL passedPriorityKey = NO;
  349|      0|        [self enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  350|      0|                                            BOOL *stop) {
  351|      0|          if (!passedPriorityKey &&
  352|      0|              [FUtilities compareKey:key
  353|      0|                               toKey:@".priority"] == NSOrderedDescending) {
  354|      0|              passedPriorityKey = YES;
  355|      0|              BOOL stopAfterPriority = NO;
  356|      0|              block(@".priority", [self getPriority], &stopAfterPriority);
  357|      0|              if (stopAfterPriority)
  358|      0|                  return;
  359|      0|          }
  360|      0|          block(key, node, stop);
  361|      0|        }];
  362|      0|    }
  363|      0|}
  364|       |
  365|       |- (void)enumerateChildrenUsingBlock:(void (^)(NSString *, id<FNode>,
  366|      0|                                              BOOL *))block {
  367|      0|    [self.children enumerateKeysAndObjectsUsingBlock:block];
  368|      0|}
  369|       |
  370|       |- (void)enumerateChildrenReverse:(BOOL)reverse
  371|       |                      usingBlock:
  372|      0|                          (void (^)(NSString *, id<FNode>, BOOL *))block {
  373|      0|    [self.children enumerateKeysAndObjectsReverse:reverse usingBlock:block];
  374|      0|}
  375|       |
  376|      0|- (NSEnumerator *)childEnumerator {
  377|      0|    return [[FTransformedEnumerator alloc]
  378|      0|        initWithEnumerator:self.children.keyEnumerator
  379|      0|              andTransform:^id(NSString *key) {
  380|      0|                return [FNamedNode nodeWithName:key
  381|      0|                                           node:[self getImmediateChild:key]];
  382|      0|              }];
  383|      0|}
  384|       |
  385|      0|- (NSString *)predecessorChildKey:(NSString *)childKey {
  386|      0|    return [self.children getPredecessorKey:childKey];
  387|      0|}
  388|       |
  389|       |#pragma mark -
  390|       |#pragma mark FChildrenNode specific methods
  391|       |
  392|      0|- (id)childrenGetter:(id)key {
  393|      0|    return [self.children objectForKey:key];
  394|      0|}
  395|       |
  396|      0|- (FNamedNode *)firstChild {
  397|      0|    NSString *childKey = self.children.minKey;
  398|      0|    if (childKey) {
  399|      0|        return
  400|      0|            [[FNamedNode alloc] initWithName:childKey
  401|      0|                                     andNode:[self getImmediateChild:childKey]];
  402|      0|    } else {
  403|      0|        return nil;
  404|      0|    }
  405|      0|}
  406|       |
  407|      0|- (FNamedNode *)lastChild {
  408|      0|    NSString *childKey = self.children.maxKey;
  409|      0|    if (childKey) {
  410|      0|        return
  411|      0|            [[FNamedNode alloc] initWithName:childKey
  412|      0|                                     andNode:[self getImmediateChild:childKey]];
  413|      0|    } else {
  414|      0|        return nil;
  415|      0|    }
  416|      0|}
  417|       |
  418|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Snapshot/FCompoundWrite.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FCompoundWrite.h"
   18|       |#import "FImmutableTree.h"
   19|       |#import "FNamedNode.h"
   20|       |#import "FNode.h"
   21|       |#import "FPath.h"
   22|       |#import "FSnapshotUtilities.h"
   23|       |
   24|       |@interface FCompoundWrite ()
   25|       |@property(nonatomic, strong) FImmutableTree *writeTree;
   26|       |@end
   27|       |
   28|       |@implementation FCompoundWrite
   29|       |
   30|      0|- (id)initWithWriteTree:(FImmutableTree *)tree {
   31|      0|    self = [super init];
   32|      0|    if (self) {
   33|      0|        self.writeTree = tree;
   34|      0|    }
   35|      0|    return self;
   36|      0|}
   37|       |
   38|       |+ (FCompoundWrite *)compoundWriteWithValueDictionary:
   39|      0|    (NSDictionary *)dictionary {
   40|      0|    __block FImmutableTree *writeTree = [FImmutableTree empty];
   41|      0|    [dictionary enumerateKeysAndObjectsUsingBlock:^(NSString *pathString,
   42|      0|                                                    id value, BOOL *stop) {
   43|      0|      id<FNode> node = [FSnapshotUtilities nodeFrom:value];
   44|      0|      FImmutableTree *tree = [[FImmutableTree alloc] initWithValue:node];
   45|      0|      writeTree = [writeTree setTree:tree
   46|      0|                              atPath:[[FPath alloc] initWith:pathString]];
   47|      0|    }];
   48|      0|    return [[FCompoundWrite alloc] initWithWriteTree:writeTree];
   49|      0|}
   50|       |
   51|      0|+ (FCompoundWrite *)compoundWriteWithNodeDictionary:(NSDictionary *)dictionary {
   52|      0|    __block FImmutableTree *writeTree = [FImmutableTree empty];
   53|      0|    [dictionary enumerateKeysAndObjectsUsingBlock:^(NSString *pathString,
   54|      0|                                                    id node, BOOL *stop) {
   55|      0|      FImmutableTree *tree = [[FImmutableTree alloc] initWithValue:node];
   56|      0|      writeTree = [writeTree setTree:tree
   57|      0|                              atPath:[[FPath alloc] initWith:pathString]];
   58|      0|    }];
   59|      0|    return [[FCompoundWrite alloc] initWithWriteTree:writeTree];
   60|      0|}
   61|       |
   62|      0|+ (FCompoundWrite *)emptyWrite {
   63|      0|    static dispatch_once_t pred = 0;
   64|      0|    static FCompoundWrite *empty = nil;
   65|      0|    dispatch_once(&pred, ^{
   66|      0|      empty = [[FCompoundWrite alloc]
   67|      0|          initWithWriteTree:[[FImmutableTree alloc] initWithValue:nil]];
   68|      0|    });
   69|      0|    return empty;
   70|      0|}
   71|       |
   72|      0|- (FCompoundWrite *)addWrite:(id<FNode>)node atPath:(FPath *)path {
   73|      0|    if (path.isEmpty) {
   74|      0|        return [[FCompoundWrite alloc]
   75|      0|            initWithWriteTree:[[FImmutableTree alloc] initWithValue:node]];
   76|      0|    } else {
   77|      0|        FTuplePathValue *rootMost =
   78|      0|            [self.writeTree findRootMostValueAndPath:path];
   79|      0|        if (rootMost != nil) {
   80|      0|            FPath *relativePath = [FPath relativePathFrom:rootMost.path
   81|      0|                                                       to:path];
   82|      0|            id<FNode> value = [rootMost.value updateChild:relativePath
   83|      0|                                             withNewChild:node];
   84|      0|            return [[FCompoundWrite alloc]
   85|      0|                initWithWriteTree:[self.writeTree setValue:value
   86|      0|                                                    atPath:rootMost.path]];
   87|      0|        } else {
   88|      0|            FImmutableTree *subtree =
   89|      0|                [[FImmutableTree alloc] initWithValue:node];
   90|      0|            FImmutableTree *newWriteTree = [self.writeTree setTree:subtree
   91|      0|                                                            atPath:path];
   92|      0|            return [[FCompoundWrite alloc] initWithWriteTree:newWriteTree];
   93|      0|        }
   94|      0|    }
   95|      0|}
   96|       |
   97|      0|- (FCompoundWrite *)addWrite:(id<FNode>)node atKey:(NSString *)key {
   98|      0|    return [self addWrite:node atPath:[[FPath alloc] initWith:key]];
   99|      0|}
  100|       |
  101|       |- (FCompoundWrite *)addCompoundWrite:(FCompoundWrite *)compoundWrite
  102|      0|                              atPath:(FPath *)path {
  103|      0|    __block FCompoundWrite *newWrite = self;
  104|      0|    [compoundWrite.writeTree forEach:^(FPath *childPath, id<FNode> value) {
  105|      0|      newWrite = [newWrite addWrite:value atPath:[path child:childPath]];
  106|      0|    }];
  107|      0|    return newWrite;
  108|      0|}
  109|       |
  110|       |/**
  111|       | * Will remove a write at the given path and deeper paths. This will
  112|       | * <em>not</em> modify a write at a higher location, which must be removed by
  113|       | * calling this method with that path.
  114|       | * @param path The path at which a write and all deeper writes should be
  115|       | * removed.
  116|       | * @return The new FWriteCompound with the removed path.
  117|       | */
  118|      0|- (FCompoundWrite *)removeWriteAtPath:(FPath *)path {
  119|      0|    if (path.isEmpty) {
  120|      0|        return [FCompoundWrite emptyWrite];
  121|      0|    } else {
  122|      0|        FImmutableTree *newWriteTree =
  123|      0|            [self.writeTree setTree:[FImmutableTree empty] atPath:path];
  124|      0|        return [[FCompoundWrite alloc] initWithWriteTree:newWriteTree];
  125|      0|    }
  126|      0|}
  127|       |
  128|       |/**
  129|       | * Returns whether this FCompoundWrite will fully overwrite a node at a given
  130|       | * location and can therefore be considered "complete".
  131|       | * @param path The path to check for
  132|       | * @return Whether there is a complete write at that path.
  133|       | */
  134|      0|- (BOOL)hasCompleteWriteAtPath:(FPath *)path {
  135|      0|    return [self completeNodeAtPath:path] != nil;
  136|      0|}
  137|       |
  138|       |/**
  139|       | * Returns a node for a path if and only if the node is a "complete" overwrite
  140|       | * at that path. This will not aggregate writes from depeer paths, but will
  141|       | * return child nodes from a more shallow path.
  142|       | * @param path The path to get a complete write
  143|       | * @return The node if complete at that path, or nil otherwise.
  144|       | */
  145|      0|- (id<FNode>)completeNodeAtPath:(FPath *)path {
  146|      0|    FTuplePathValue *rootMost = [self.writeTree findRootMostValueAndPath:path];
  147|      0|    if (rootMost != nil) {
  148|      0|        FPath *relativePath = [FPath relativePathFrom:rootMost.path to:path];
  149|      0|        return [rootMost.value getChild:relativePath];
  150|      0|    } else {
  151|      0|        return nil;
  152|      0|    }
  153|      0|}
  154|       |
  155|       |// TODO: change into traversal method...
  156|      0|- (NSArray *)completeChildren {
  157|      0|    NSMutableArray *children = [[NSMutableArray alloc] init];
  158|      0|    if (self.writeTree.value != nil) {
  159|      0|        id<FNode> node = self.writeTree.value;
  160|      0|        [node enumerateChildrenUsingBlock:^(NSString *key, id<FNode> node,
  161|      0|                                            BOOL *stop) {
  162|      0|          [children addObject:[[FNamedNode alloc] initWithName:key
  163|      0|                                                       andNode:node]];
  164|      0|        }];
  165|      0|    } else {
  166|      0|        [self.writeTree.children
  167|      0|            enumerateKeysAndObjectsUsingBlock:^(
  168|      0|                NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  169|      0|              if (childTree.value != nil) {
  170|      0|                  [children addObject:[[FNamedNode alloc]
  171|      0|                                          initWithName:childKey
  172|      0|                                               andNode:childTree.value]];
  173|      0|              }
  174|      0|            }];
  175|      0|    }
  176|      0|    return children;
  177|      0|}
  178|       |
  179|       |// TODO: change into enumarate method
  180|      0|- (NSDictionary *)childCompoundWrites {
  181|      0|    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
  182|      0|    [self.writeTree.children
  183|      0|        enumerateKeysAndObjectsUsingBlock:^(
  184|      0|            NSString *key, FImmutableTree *childWrite, BOOL *stop) {
  185|      0|          dict[key] = [[FCompoundWrite alloc] initWithWriteTree:childWrite];
  186|      0|        }];
  187|      0|    return dict;
  188|      0|}
  189|       |
  190|      0|- (FCompoundWrite *)childCompoundWriteAtPath:(FPath *)path {
  191|      0|    if (path.isEmpty) {
  192|      0|        return self;
  193|      0|    } else {
  194|      0|        id<FNode> shadowingNode = [self completeNodeAtPath:path];
  195|      0|        if (shadowingNode != nil) {
  196|      0|            return [[FCompoundWrite alloc]
  197|      0|                initWithWriteTree:[[FImmutableTree alloc]
  198|      0|                                      initWithValue:shadowingNode]];
  199|      0|        } else {
  200|      0|            return [[FCompoundWrite alloc]
  201|      0|                initWithWriteTree:[self.writeTree subtreeAtPath:path]];
  202|      0|        }
  203|      0|    }
  204|      0|}
  205|       |
  206|       |- (id<FNode>)applySubtreeWrite:(FImmutableTree *)subtreeWrite
  207|       |                        atPath:(FPath *)relativePath
  208|      0|                        toNode:(id<FNode>)node {
  209|      0|    if (subtreeWrite.value != nil) {
  210|      0|        // Since a write there is always a leaf, we're done here.
  211|      0|        return [node updateChild:relativePath withNewChild:subtreeWrite.value];
  212|      0|    } else {
  213|      0|        __block id<FNode> priorityWrite = nil;
  214|      0|        __block id<FNode> blockNode = node;
  215|      0|        [subtreeWrite.children
  216|      0|            enumerateKeysAndObjectsUsingBlock:^(
  217|      0|                NSString *childKey, FImmutableTree *childTree, BOOL *stop) {
  218|      0|              if ([childKey isEqualToString:@".priority"]) {
  219|      0|                  // Apply priorities at the end so we don't update priorities
  220|      0|                  // for either empty nodes or forget to apply priorities to
  221|      0|                  // empty nodes that are later filled.
  222|      0|                  NSAssert(childTree.value != nil,
  223|      0|                           @"Priority writes must always be leaf nodes");
  224|      0|                  priorityWrite = childTree.value;
  225|      0|              } else {
  226|      0|                  blockNode = [self
  227|      0|                      applySubtreeWrite:childTree
  228|      0|                                 atPath:[relativePath childFromString:childKey]
  229|      0|                                 toNode:blockNode];
  230|      0|              }
  231|      0|            }];
  232|      0|        // If there was a priority write, we only apply it if the node is not
  233|      0|        // empty
  234|      0|        if (![blockNode getChild:relativePath].isEmpty &&
  235|      0|            priorityWrite != nil) {
  236|      0|            blockNode = [blockNode
  237|      0|                 updateChild:[relativePath childFromString:@".priority"]
  238|      0|                withNewChild:priorityWrite];
  239|      0|        }
  240|      0|        return blockNode;
  241|      0|    }
  242|      0|}
  243|       |
  244|      0|- (void)enumerateWrites:(void (^)(FPath *, id<FNode>, BOOL *))block {
  245|      0|    __block BOOL stop = NO;
  246|      0|    // TODO: add stop to tree iterator...
  247|      0|    [self.writeTree forEach:^(FPath *path, id value) {
  248|      0|      if (!stop) {
  249|      0|          block(path, value, &stop);
  250|      0|      }
  251|      0|    }];
  252|      0|}
  253|       |
  254|       |/**
  255|       | * Applies this FCompoundWrite to a node. The node is returned with all writes
  256|       | * from this FCompoundWrite applied to the node.
  257|       | * @param node The node to apply this FCompoundWrite to
  258|       | * @return The node with all writes applied
  259|       | */
  260|      0|- (id<FNode>)applyToNode:(id<FNode>)node {
  261|      0|    return [self applySubtreeWrite:self.writeTree
  262|      0|                            atPath:[FPath empty]
  263|      0|                            toNode:node];
  264|      0|}
  265|       |
  266|       |/**
  267|       | * Return true if this CompoundWrite is empty and therefore does not modify any
  268|       | * nodes.
  269|       | * @return Whether this CompoundWrite is empty
  270|       | */
  271|      0|- (BOOL)isEmpty {
  272|      0|    return self.writeTree.isEmpty;
  273|      0|}
  274|       |
  275|      0|- (id<FNode>)rootWrite {
  276|      0|    return self.writeTree.value;
  277|      0|}
  278|       |
  279|      0|- (BOOL)isEqual:(id)object {
  280|      0|    if (![object isKindOfClass:[FCompoundWrite class]]) {
  281|      0|        return NO;
  282|      0|    }
  283|      0|    FCompoundWrite *other = (FCompoundWrite *)object;
  284|      0|    return
  285|      0|        [[self valForExport:YES] isEqualToDictionary:[other valForExport:YES]];
  286|      0|}
  287|       |
  288|      0|- (NSUInteger)hash {
  289|      0|    return [[self valForExport:YES] hash];
  290|      0|}
  291|       |
  292|      0|- (NSDictionary *)valForExport:(BOOL)exportFormat {
  293|      0|    NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];
  294|      0|    [self.writeTree forEach:^(FPath *path, id<FNode> value) {
  295|      0|      dictionary[path.wireFormat] = [value valForExport:exportFormat];
  296|      0|    }];
  297|      0|    return dictionary;
  298|      0|}
  299|       |
  300|      0|- (NSString *)description {
  301|      0|    return [[self valForExport:YES] description];
  302|      0|}
  303|       |
  304|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Snapshot/FEmptyNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FEmptyNode.h"
   18|       |#import "FChildrenNode.h"
   19|       |
   20|       |@implementation FEmptyNode
   21|       |
   22|      0|+ (id<FNode>)emptyNode {
   23|      0|    static FChildrenNode *empty = nil;
   24|      0|    static dispatch_once_t onceToken;
   25|      0|    dispatch_once(&onceToken, ^{
   26|      0|      empty = [[FChildrenNode alloc] init];
   27|      0|    });
   28|      0|    return empty;
   29|      0|}
   30|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Snapshot/FIndexedNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIndexedNode.h"
   18|       |
   19|       |#import "FChildrenNode.h"
   20|       |#import "FImmutableSortedSet.h"
   21|       |#import "FIndex.h"
   22|       |#import "FKeyIndex.h"
   23|       |#import "FPriorityIndex.h"
   24|       |
   25|       |static FImmutableSortedSet *FALLBACK_INDEX;
   26|       |
   27|       |@interface FIndexedNode ()
   28|       |
   29|       |@property(nonatomic, strong) id<FNode> node;
   30|       |/**
   31|       | * The indexed set is initialized lazily to prevent creation when it is not
   32|       | * needed
   33|       | */
   34|       |@property(nonatomic, strong) FImmutableSortedSet *indexed;
   35|       |@property(nonatomic, strong) id<FIndex> index;
   36|       |
   37|       |@end
   38|       |
   39|       |@implementation FIndexedNode
   40|       |
   41|      0|+ (FImmutableSortedSet *)fallbackIndex {
   42|      0|    static FImmutableSortedSet *fallbackIndex;
   43|      0|    static dispatch_once_t once;
   44|      0|    dispatch_once(&once, ^{
   45|      0|      fallbackIndex = [[FImmutableSortedSet alloc] init];
   46|      0|    });
   47|      0|    return fallbackIndex;
   48|      0|}
   49|       |
   50|      0|+ (FIndexedNode *)indexedNodeWithNode:(id<FNode>)node {
   51|      0|    return [[FIndexedNode alloc] initWithNode:node
   52|      0|                                        index:[FPriorityIndex priorityIndex]];
   53|      0|}
   54|       |
   55|      0|+ (FIndexedNode *)indexedNodeWithNode:(id<FNode>)node index:(id<FIndex>)index {
   56|      0|    return [[FIndexedNode alloc] initWithNode:node index:index];
   57|      0|}
   58|       |
   59|      0|- (id)initWithNode:(id<FNode>)node index:(id<FIndex>)index {
   60|      0|    // Initialize indexed lazily
   61|      0|    return [self initWithNode:node index:index indexed:nil];
   62|      0|}
   63|       |
   64|       |- (id)initWithNode:(id<FNode>)node
   65|       |             index:(id<FIndex>)index
   66|      0|           indexed:(FImmutableSortedSet *)indexed {
   67|      0|    self = [super init];
   68|      0|    if (self != nil) {
   69|      0|        self->_node = node;
   70|      0|        self->_index = index;
   71|      0|        self->_indexed = indexed;
   72|      0|    }
   73|      0|    return self;
   74|      0|}
   75|       |
   76|      0|- (void)ensureIndexed {
   77|      0|    if (!self.indexed) {
   78|      0|        if ([self.index isEqual:[FKeyIndex keyIndex]]) {
   79|      0|            self.indexed = [FIndexedNode fallbackIndex];
   80|      0|        } else {
   81|      0|            __block BOOL sawChild = NO;
   82|      0|            [self.node enumerateChildrenUsingBlock:^(
   83|      0|                           NSString *key, id<FNode> node, BOOL *stop) {
   84|      0|              sawChild = sawChild || [self.index isDefinedOn:node];
   85|      0|              *stop = sawChild;
   86|      0|            }];
   87|      0|            if (sawChild) {
   88|      0|                NSMutableDictionary *dict = [NSMutableDictionary dictionary];
   89|      0|                [self.node enumerateChildrenUsingBlock:^(
   90|      0|                               NSString *key, id<FNode> node, BOOL *stop) {
   91|      0|                  FNamedNode *namedNode =
   92|      0|                      [[FNamedNode alloc] initWithName:key andNode:node];
   93|      0|                  dict[namedNode] = [NSNull null];
   94|      0|                }];
   95|      0|                // Make sure to assign index here, because the comparator will
   96|      0|                // be retained and using self will cause a cycle
   97|      0|                id<FIndex> index = self.index;
   98|      0|                self.indexed = [FImmutableSortedSet
   99|      0|                    setWithKeysFromDictionary:dict
  100|      0|                                   comparator:^NSComparisonResult(
  101|      0|                                       FNamedNode *namedNode1,
  102|      0|                                       FNamedNode *namedNode2) {
  103|      0|                                     return [index compareNamedNode:namedNode1
  104|      0|                                                        toNamedNode:namedNode2];
  105|      0|                                   }];
  106|      0|            } else {
  107|      0|                self.indexed = [FIndexedNode fallbackIndex];
  108|      0|            }
  109|      0|        }
  110|      0|    }
  111|      0|}
  112|       |
  113|      0|- (BOOL)hasIndex:(id<FIndex>)index {
  114|      0|    return [self.index isEqual:index];
  115|      0|}
  116|       |
  117|       |- (FIndexedNode *)updateChild:(NSString *)key
  118|      0|                 withNewChild:(id<FNode>)newChildNode {
  119|      0|    id<FNode> newNode = [self.node updateImmediateChild:key
  120|      0|                                           withNewChild:newChildNode];
  121|      0|    if (self.indexed == [FIndexedNode fallbackIndex] &&
  122|      0|        ![self.index isDefinedOn:newChildNode]) {
  123|      0|        // doesn't affect the index, no need to create an index
  124|      0|        return [[FIndexedNode alloc] initWithNode:newNode
  125|      0|                                            index:self.index
  126|      0|                                          indexed:[FIndexedNode fallbackIndex]];
  127|      0|    } else if (!self.indexed || self.indexed == [FIndexedNode fallbackIndex]) {
  128|      0|        // No need to index yet, index lazily
  129|      0|        return [[FIndexedNode alloc] initWithNode:newNode index:self.index];
  130|      0|    } else {
  131|      0|        id<FNode> oldChild = [self.node getImmediateChild:key];
  132|      0|        FImmutableSortedSet *newIndexed = [self.indexed
  133|      0|            removeObject:[FNamedNode nodeWithName:key node:oldChild]];
  134|      0|        if (![newChildNode isEmpty]) {
  135|      0|            newIndexed = [newIndexed
  136|      0|                addObject:[FNamedNode nodeWithName:key node:newChildNode]];
  137|      0|        }
  138|      0|        return [[FIndexedNode alloc] initWithNode:newNode
  139|      0|                                            index:self.index
  140|      0|                                          indexed:newIndexed];
  141|      0|    }
  142|      0|}
  143|       |
  144|      0|- (FIndexedNode *)updatePriority:(id<FNode>)priority {
  145|      0|    return
  146|      0|        [[FIndexedNode alloc] initWithNode:[self.node updatePriority:priority]
  147|      0|                                     index:self.index
  148|      0|                                   indexed:self.indexed];
  149|      0|}
  150|       |
  151|      0|- (FNamedNode *)firstChild {
  152|      0|    if (![self.node isKindOfClass:[FChildrenNode class]]) {
  153|      0|        return nil;
  154|      0|    } else {
  155|      0|        [self ensureIndexed];
  156|      0|        if (self.indexed == [FIndexedNode fallbackIndex]) {
  157|      0|            return [((FChildrenNode *)self.node) firstChild];
  158|      0|        } else {
  159|      0|            return self.indexed.firstObject;
  160|      0|        }
  161|      0|    }
  162|      0|}
  163|       |
  164|      0|- (FNamedNode *)lastChild {
  165|      0|    if (![self.node isKindOfClass:[FChildrenNode class]]) {
  166|      0|        return nil;
  167|      0|    } else {
  168|      0|        [self ensureIndexed];
  169|      0|        if (self.indexed == [FIndexedNode fallbackIndex]) {
  170|      0|            return [((FChildrenNode *)self.node) lastChild];
  171|      0|        } else {
  172|      0|            return self.indexed.lastObject;
  173|      0|        }
  174|      0|    }
  175|      0|}
  176|       |
  177|       |- (NSString *)predecessorForChildKey:(NSString *)childKey
  178|       |                           childNode:(id<FNode>)childNode
  179|      0|                               index:(id<FIndex>)index {
  180|      0|    if (![self.index isEqual:index]) {
  181|      0|        [NSException raise:NSInvalidArgumentException
  182|      0|                    format:@"Index not available in IndexedNode!"];
  183|      0|    }
  184|      0|    [self ensureIndexed];
  185|      0|    if (self.indexed == [FIndexedNode fallbackIndex]) {
  186|      0|        return [self.node predecessorChildKey:childKey];
  187|      0|    } else {
  188|      0|        FNamedNode *node = [self.indexed
  189|      0|            predecessorEntry:[FNamedNode nodeWithName:childKey node:childNode]];
  190|      0|        return node.name;
  191|      0|    }
  192|      0|}
  193|       |
  194|       |- (void)enumerateChildrenReverse:(BOOL)reverse
  195|       |                      usingBlock:
  196|      0|                          (void (^)(NSString *, id<FNode>, BOOL *))block {
  197|      0|    [self ensureIndexed];
  198|      0|    if (self.indexed == [FIndexedNode fallbackIndex]) {
  199|      0|        [self.node enumerateChildrenReverse:reverse usingBlock:block];
  200|      0|    } else {
  201|      0|        [self.indexed
  202|      0|            enumerateObjectsReverse:reverse
  203|      0|                         usingBlock:^(FNamedNode *namedNode, BOOL *stop) {
  204|      0|                           block(namedNode.name, namedNode.node, stop);
  205|      0|                         }];
  206|      0|    }
  207|      0|}
  208|       |
  209|      0|- (NSEnumerator *)childEnumerator {
  210|      0|    [self ensureIndexed];
  211|      0|    if (self.indexed == [FIndexedNode fallbackIndex]) {
  212|      0|        return [self.node childEnumerator];
  213|      0|    } else {
  214|      0|        return [self.indexed objectEnumerator];
  215|      0|    }
  216|      0|}
  217|       |
  218|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Snapshot/FLeafNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FLeafNode.h"
   18|       |#import "FChildrenNode.h"
   19|       |#import "FConstants.h"
   20|       |#import "FEmptyNode.h"
   21|       |#import "FImmutableSortedDictionary.h"
   22|       |#import "FSnapshotUtilities.h"
   23|       |#import "FStringUtilities.h"
   24|       |#import "FUtilities.h"
   25|       |
   26|       |@interface FLeafNode ()
   27|       |@property(nonatomic, strong) id<FNode> priorityNode;
   28|       |@property(nonatomic, strong) NSString *lazyHash;
   29|       |
   30|       |@end
   31|       |
   32|       |@implementation FLeafNode
   33|       |
   34|       |@synthesize value;
   35|       |@synthesize priorityNode;
   36|       |
   37|      0|- (id)initWithValue:(id)aValue {
   38|      0|    self = [super init];
   39|      0|    if (self) {
   40|      0|        self.value = aValue;
   41|      0|        self.priorityNode = [FEmptyNode emptyNode];
   42|      0|    }
   43|      0|    return self;
   44|      0|}
   45|       |
   46|      0|- (id)initWithValue:(id)aValue withPriority:(id<FNode>)aPriority {
   47|      0|    self = [super init];
   48|      0|    if (self) {
   49|      0|        self.value = aValue;
   50|      0|        [FSnapshotUtilities validatePriorityNode:aPriority];
   51|      0|        self.priorityNode = aPriority;
   52|      0|    }
   53|      0|    return self;
   54|      0|}
   55|       |
   56|       |#pragma mark -
   57|       |#pragma mark FNode methods
   58|       |
   59|      0|- (BOOL)isLeafNode {
   60|      0|    return YES;
   61|      0|}
   62|       |
   63|      0|- (id<FNode>)getPriority {
   64|      0|    return self.priorityNode;
   65|      0|}
   66|       |
   67|      0|- (id<FNode>)updatePriority:(id<FNode>)aPriority {
   68|      0|    return [[FLeafNode alloc] initWithValue:self.value withPriority:aPriority];
   69|      0|}
   70|       |
   71|      0|- (id<FNode>)getImmediateChild:(NSString *)childName {
   72|      0|    if ([childName isEqualToString:@".priority"]) {
   73|      0|        return self.priorityNode;
   74|      0|    } else {
   75|      0|        return [FEmptyNode emptyNode];
   76|      0|    }
   77|      0|}
   78|       |
   79|      0|- (id<FNode>)getChild:(FPath *)path {
   80|      0|    if (path.getFront == nil) {
   81|      0|        return self;
   82|      0|    } else if ([[path getFront] isEqualToString:@".priority"]) {
   83|      0|        return [self getPriority];
   84|      0|    } else {
   85|      0|        return [FEmptyNode emptyNode];
   86|      0|    }
   87|      0|}
   88|       |
   89|      0|- (BOOL)hasChild:(NSString *)childName {
   90|      0|    return
   91|      0|        [childName isEqualToString:@".priority"] && ![self getPriority].isEmpty;
   92|      0|}
   93|       |
   94|      0|- (NSString *)predecessorChildKey:(NSString *)childKey {
   95|      0|    return nil;
   96|      0|}
   97|       |
   98|       |- (id<FNode>)updateImmediateChild:(NSString *)childName
   99|      0|                     withNewChild:(id<FNode>)newChildNode {
  100|      0|    if ([childName isEqualToString:@".priority"]) {
  101|      0|        return [self updatePriority:newChildNode];
  102|      0|    } else if (newChildNode.isEmpty) {
  103|      0|        return self;
  104|      0|    } else {
  105|      0|        FChildrenNode *childrenNode = [[FChildrenNode alloc] init];
  106|      0|        childrenNode = [childrenNode updateImmediateChild:childName
  107|      0|                                             withNewChild:newChildNode];
  108|      0|        childrenNode = [childrenNode updatePriority:self.priorityNode];
  109|      0|        return childrenNode;
  110|      0|    }
  111|      0|}
  112|       |
  113|      0|- (id<FNode>)updateChild:(FPath *)path withNewChild:(id<FNode>)newChildNode {
  114|      0|    NSString *front = [path getFront];
  115|      0|    if (front == nil) {
  116|      0|        return newChildNode;
  117|      0|    } else if (newChildNode.isEmpty && ![front isEqualToString:@".priority"]) {
  118|      0|        return self;
  119|      0|    } else {
  120|      0|        NSAssert(![front isEqualToString:@".priority"] || path.length == 1,
  121|      0|                 @".priority must be the last token in a path.");
  122|      0|        return [self updateImmediateChild:front
  123|      0|                             withNewChild:[[FEmptyNode emptyNode]
  124|      0|                                               updateChild:[path popFront]
  125|      0|                                              withNewChild:newChildNode]];
  126|      0|    }
  127|      0|}
  128|       |
  129|      0|- (id)val {
  130|      0|    return [self valForExport:NO];
  131|      0|}
  132|       |
  133|      0|- (id)valForExport:(BOOL)exp {
  134|      0|    if (exp && !self.getPriority.isEmpty) {
  135|      0|        return @{
  136|      0|            kPayloadValue : self.value,
  137|      0|            kPayloadPriority : [[self getPriority] val]
  138|      0|        };
  139|      0|    } else {
  140|      0|        return self.value;
  141|      0|    }
  142|      0|}
  143|       |
  144|      0|- (BOOL)isEqual:(id<FNode>)other {
  145|      0|    if (other == self) {
  146|      0|        return YES;
  147|      0|    } else if (other.isLeafNode) {
  148|      0|        FLeafNode *otherLeaf = other;
  149|      0|        if ([FUtilities getJavascriptType:self.value] !=
  150|      0|            [FUtilities getJavascriptType:otherLeaf.value]) {
  151|      0|            return NO;
  152|      0|        }
  153|      0|        return [otherLeaf.value isEqual:self.value] &&
  154|      0|               [otherLeaf.priorityNode isEqual:self.priorityNode];
  155|      0|    } else {
  156|      0|        return NO;
  157|      0|    }
  158|      0|}
  159|       |
  160|      0|- (NSUInteger)hash {
  161|      0|    return [self.value hash] * 17 + self.priorityNode.hash;
  162|      0|}
  163|       |
  164|      0|- (id<FNode>)withIndex:(id<FIndex>)index {
  165|      0|    return self;
  166|      0|}
  167|       |
  168|      0|- (BOOL)isIndexed:(id<FIndex>)index {
  169|      0|    return YES;
  170|      0|}
  171|       |
  172|      0|- (BOOL)isEmpty {
  173|      0|    return NO;
  174|      0|}
  175|       |
  176|      0|- (int)numChildren {
  177|      0|    return 0;
  178|      0|}
  179|       |
  180|       |- (void)enumerateChildrenUsingBlock:(void (^)(NSString *, id<FNode>,
  181|      0|                                              BOOL *))block {
  182|      0|    // Nothing to iterate over
  183|      0|}
  184|       |
  185|       |- (void)enumerateChildrenReverse:(BOOL)reverse
  186|       |                      usingBlock:
  187|      0|                          (void (^)(NSString *, id<FNode>, BOOL *))block {
  188|      0|    // Nothing to iterate over
  189|      0|}
  190|       |
  191|      0|- (NSEnumerator *)childEnumerator {
  192|      0|    // Nothing to iterate over
  193|      0|    return [@[] objectEnumerator];
  194|      0|}
  195|       |
  196|      0|- (NSString *)dataHash {
  197|      0|    if (self.lazyHash == nil) {
  198|      0|        NSMutableString *toHash = [[NSMutableString alloc] init];
  199|      0|        [FSnapshotUtilities
  200|      0|            appendHashRepresentationForLeafNode:self
  201|      0|                                       toString:toHash
  202|      0|                                    hashVersion:FDataHashVersionV1];
  203|      0|
  204|      0|        self.lazyHash = [FStringUtilities base64EncodedSha1:toHash];
  205|      0|    }
  206|      0|    return self.lazyHash;
  207|      0|}
  208|       |
  209|      0|- (NSComparisonResult)compare:(id<FNode>)other {
  210|      0|    if (other == [FEmptyNode emptyNode]) {
  211|      0|        return NSOrderedDescending;
  212|      0|    } else if ([other isKindOfClass:[FChildrenNode class]]) {
  213|      0|        return NSOrderedAscending;
  214|      0|    } else {
  215|      0|        NSAssert(other.isLeafNode, @"Compared against unknown type of node.");
  216|      0|        return [self compareToLeafNode:(FLeafNode *)other];
  217|      0|    }
  218|      0|}
  219|       |
  220|      0|+ (NSArray *)valueTypeOrder {
  221|      0|    static NSArray *valueOrder = nil;
  222|      0|    static dispatch_once_t once;
  223|      0|    dispatch_once(&once, ^{
  224|      0|      valueOrder = @[
  225|      0|          kJavaScriptObject, kJavaScriptBoolean, kJavaScriptNumber,
  226|      0|          kJavaScriptString
  227|      0|      ];
  228|      0|    });
  229|      0|    return valueOrder;
  230|      0|}
  231|       |
  232|      0|- (NSComparisonResult)compareToLeafNode:(FLeafNode *)other {
  233|      0|    NSString *thisLeafType = [FUtilities getJavascriptType:self.value];
  234|      0|    NSString *otherLeafType = [FUtilities getJavascriptType:other.value];
  235|      0|    NSUInteger thisIndex =
  236|      0|        [[FLeafNode valueTypeOrder] indexOfObject:thisLeafType];
  237|      0|    NSUInteger otherIndex =
  238|      0|        [[FLeafNode valueTypeOrder] indexOfObject:otherLeafType];
  239|      0|    assert(thisIndex >= 0 && otherIndex >= 0);
  240|      0|    if (otherIndex == thisIndex) {
  241|      0|        // Same type.  Compare values.
  242|      0|        if (thisLeafType == kJavaScriptObject) {
  243|      0|            // Deferred value nodes are all equal, but we should also never get
  244|      0|            // to this point...
  245|      0|            return NSOrderedSame;
  246|      0|        } else if (thisLeafType == kJavaScriptString) {
  247|      0|            return [self.value compare:other.value options:NSLiteralSearch];
  248|      0|        } else {
  249|      0|            return [self.value compare:other.value];
  250|      0|        }
  251|      0|    } else {
  252|      0|        return thisIndex > otherIndex ? NSOrderedDescending
  253|      0|                                      : NSOrderedAscending;
  254|      0|    }
  255|      0|}
  256|       |
  257|      0|- (NSString *)description {
  258|      0|    return [[self valForExport:YES] description];
  259|      0|}
  260|       |
  261|      0|- (void)forEachChildDo:(fbt_bool_nsstring_node)action {
  262|      0|    // There are no children, so there is nothing to do.
  263|      0|    return;
  264|      0|}
  265|       |
  266|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Snapshot/FSnapshotUtilities.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FSnapshotUtilities.h"
   18|       |#import "FChildrenNode.h"
   19|       |#import "FCompoundWrite.h"
   20|       |#import "FConstants.h"
   21|       |#import "FEmptyNode.h"
   22|       |#import "FLLRBValueNode.h"
   23|       |#import "FLeafNode.h"
   24|       |#import "FMaxNode.h"
   25|       |#import "FNamedNode.h"
   26|       |#import "FUtilities.h"
   27|       |#import "FValidation.h"
   28|       |
   29|       |@implementation FSnapshotUtilities
   30|       |
   31|      0|+ (id<FNode>)nodeFrom:(id)val {
   32|      0|    return [FSnapshotUtilities nodeFrom:val priority:nil];
   33|      0|}
   34|       |
   35|      0|+ (id<FNode>)nodeFrom:(id)val priority:(id)priority {
   36|      0|    return [FSnapshotUtilities nodeFrom:val
   37|      0|                               priority:priority
   38|      0|                     withValidationFrom:@"nodeFrom:priority:"];
   39|      0|}
   40|       |
   41|      0|+ (id<FNode>)nodeFrom:(id)val withValidationFrom:(NSString *)fn {
   42|      0|    return [FSnapshotUtilities nodeFrom:val priority:nil withValidationFrom:fn];
   43|      0|}
   44|       |
   45|       |+ (id<FNode>)nodeFrom:(id)val
   46|       |              priority:(id)priority
   47|      0|    withValidationFrom:(NSString *)fn {
   48|      0|    return [FSnapshotUtilities nodeFrom:val
   49|      0|                               priority:priority
   50|      0|                     withValidationFrom:fn
   51|      0|                                atDepth:0
   52|      0|                                   path:[[NSMutableArray alloc] init]];
   53|      0|}
   54|       |
   55|       |+ (id<FNode>)nodeFrom:(id)val
   56|       |              priority:(id)aPriority
   57|       |    withValidationFrom:(NSString *)fn
   58|       |               atDepth:(int)depth
   59|      0|                  path:(NSMutableArray *)path {
   60|      0|    @autoreleasepool {
   61|      0|        return [FSnapshotUtilities internalNodeFrom:val
   62|      0|                                           priority:aPriority
   63|      0|                                 withValidationFrom:fn
   64|      0|                                            atDepth:depth
   65|      0|                                               path:path];
   66|      0|    }
   67|      0|}
   68|       |
   69|       |+ (id<FNode>)internalNodeFrom:(id)val
   70|       |                     priority:(id)aPriority
   71|       |           withValidationFrom:(NSString *)fn
   72|       |                      atDepth:(int)depth
   73|      0|                         path:(NSMutableArray *)path {
   74|      0|
   75|      0|    if (depth > kFirebaseMaxObjectDepth) {
   76|      0|        NSRange range;
   77|      0|        range.location = 0;
   78|      0|        range.length = 100;
   79|      0|        NSString *pathString =
   80|      0|            [[path subarrayWithRange:range] componentsJoinedByString:@"."];
   81|      0|        @throw [[NSException alloc]
   82|      0|            initWithName:@"InvalidFirebaseData"
   83|      0|                  reason:[NSString stringWithFormat:
   84|      0|                                       @"(%@) Max object depth exceeded: %@...",
   85|      0|                                       fn, pathString]
   86|      0|                userInfo:nil];
   87|      0|    }
   88|      0|
   89|      0|    if (val == nil || val == [NSNull null]) {
   90|      0|        // Null is a valid type to store
   91|      0|        return [FEmptyNode emptyNode];
   92|      0|    }
   93|      0|
   94|      0|    [FValidation validateFrom:fn isValidPriorityValue:aPriority withPath:path];
   95|      0|    id<FNode> priority = [FSnapshotUtilities nodeFrom:aPriority];
   96|      0|
   97|      0|    id value = val;
   98|      0|    BOOL isLeafNode = NO;
   99|      0|
  100|      0|    if ([value isKindOfClass:[NSDictionary class]]) {
  101|      0|        NSDictionary *dict = val;
  102|      0|        if (dict[kPayloadPriority] != nil) {
  103|      0|            id rawPriority = [dict objectForKey:kPayloadPriority];
  104|      0|            [FValidation validateFrom:fn
  105|      0|                 isValidPriorityValue:rawPriority
  106|      0|                             withPath:path];
  107|      0|            priority = [FSnapshotUtilities nodeFrom:rawPriority];
  108|      0|        }
  109|      0|
  110|      0|        if (dict[kPayloadValue] != nil) {
  111|      0|            value = [dict objectForKey:kPayloadValue];
  112|      0|            if ([FValidation validateFrom:fn
  113|      0|                         isValidLeafValue:value
  114|      0|                                 withPath:path]) {
  115|      0|                isLeafNode = YES;
  116|      0|            } else {
  117|      0|                @throw [[NSException alloc]
  118|      0|                    initWithName:@"InvalidLeafValueType"
  119|      0|                          reason:[NSString stringWithFormat:
  120|      0|                                               @"(%@) Invalid data type used "
  121|      0|                                               @"with .value. Can only use "
  122|      0|                                                "NSString and NSNumber or be "
  123|      0|                                                "null. Found %@ instead.",
  124|      0|                                               fn, [[value class] description]]
  125|      0|                        userInfo:nil];
  126|      0|            }
  127|      0|        }
  128|      0|    }
  129|      0|
  130|      0|    if ([FValidation validateFrom:fn isValidLeafValue:value withPath:path]) {
  131|      0|        isLeafNode = YES;
  132|      0|    }
  133|      0|
  134|      0|    if (isLeafNode) {
  135|      0|        return [[FLeafNode alloc] initWithValue:value withPriority:priority];
  136|      0|    }
  137|      0|
  138|      0|    // Unlike with JS, we have to handle the dictionary and array cases
  139|      0|    // separately.
  140|      0|    if ([value isKindOfClass:[NSDictionary class]]) {
  141|      0|        NSDictionary *dval = (NSDictionary *)value;
  142|      0|        NSMutableDictionary *children =
  143|      0|            [NSMutableDictionary dictionaryWithCapacity:dval.count];
  144|      0|
  145|      0|        // Avoid creating a million newPaths by appending to old one
  146|      0|        for (id keyId in dval) {
  147|      0|            [FValidation validateFrom:fn
  148|      0|                   validDictionaryKey:keyId
  149|      0|                             withPath:path];
  150|      0|            NSString *key = (NSString *)keyId;
  151|      0|
  152|      0|            if (![key hasPrefix:kPayloadMetadataPrefix]) {
  153|      0|                [path addObject:key];
  154|      0|                id<FNode> childNode = [FSnapshotUtilities nodeFrom:dval[key]
  155|      0|                                                          priority:nil
  156|      0|                                                withValidationFrom:fn
  157|      0|                                                           atDepth:depth + 1
  158|      0|                                                              path:path];
  159|      0|                [path removeLastObject];
  160|      0|
  161|      0|                if (![childNode isEmpty]) {
  162|      0|                    children[key] = childNode;
  163|      0|                }
  164|      0|            }
  165|      0|        }
  166|      0|
  167|      0|        if ([children count] == 0) {
  168|      0|            return [FEmptyNode emptyNode];
  169|      0|        } else {
  170|      0|            FImmutableSortedDictionary *childrenDict =
  171|      0|                [FImmutableSortedDictionary
  172|      0|                    fromDictionary:children
  173|      0|                    withComparator:[FUtilities keyComparator]];
  174|      0|            return [[FChildrenNode alloc] initWithPriority:priority
  175|      0|                                                  children:childrenDict];
  176|      0|        }
  177|      0|    } else if ([value isKindOfClass:[NSArray class]]) {
  178|      0|        NSArray *aval = (NSArray *)value;
  179|      0|        NSMutableDictionary *children =
  180|      0|            [NSMutableDictionary dictionaryWithCapacity:aval.count];
  181|      0|
  182|      0|        for (int i = 0; i < [aval count]; i++) {
  183|      0|            NSString *key = [NSString stringWithFormat:@"%i", i];
  184|      0|            [path addObject:key];
  185|      0|            id<FNode> childNode =
  186|      0|                [FSnapshotUtilities nodeFrom:[aval objectAtIndex:i]
  187|      0|                                    priority:nil
  188|      0|                          withValidationFrom:fn
  189|      0|                                     atDepth:depth + 1
  190|      0|                                        path:path];
  191|      0|            [path removeLastObject];
  192|      0|
  193|      0|            if (![childNode isEmpty]) {
  194|      0|                children[key] = childNode;
  195|      0|            }
  196|      0|        }
  197|      0|
  198|      0|        if ([children count] == 0) {
  199|      0|            return [FEmptyNode emptyNode];
  200|      0|        } else {
  201|      0|            FImmutableSortedDictionary *childrenDict =
  202|      0|                [FImmutableSortedDictionary
  203|      0|                    fromDictionary:children
  204|      0|                    withComparator:[FUtilities keyComparator]];
  205|      0|            return [[FChildrenNode alloc] initWithPriority:priority
  206|      0|                                                  children:childrenDict];
  207|      0|        }
  208|      0|    } else {
  209|      0|        NSRange range;
  210|      0|        range.location = 0;
  211|      0|        range.length = MIN(path.count, 50);
  212|      0|        NSString *pathString =
  213|      0|            [[path subarrayWithRange:range] componentsJoinedByString:@"."];
  214|      0|
  215|      0|        @throw [[NSException alloc]
  216|      0|            initWithName:@"InvalidFirebaseData"
  217|      0|                  reason:[NSString
  218|      0|                             stringWithFormat:
  219|      0|                                 @"(%@) Cannot store object of type %@ at %@. "
  220|      0|                                  "Can only store objects of type NSNumber, "
  221|      0|                                  "NSString, NSDictionary, and NSArray.",
  222|      0|                                 fn, [[value class] description], pathString]
  223|      0|                userInfo:nil];
  224|      0|    }
  225|      0|}
  226|       |
  227|       |+ (FCompoundWrite *)compoundWriteFromDictionary:(NSDictionary *)values
  228|      0|                             withValidationFrom:(NSString *)fn {
  229|      0|    FCompoundWrite *compoundWrite = [FCompoundWrite emptyWrite];
  230|      0|
  231|      0|    NSMutableArray *updatePaths =
  232|      0|        [NSMutableArray arrayWithCapacity:values.count];
  233|      0|    for (NSString *keyId in values) {
  234|      0|        id value = values[keyId];
  235|      0|        [FValidation validateFrom:fn
  236|      0|            validUpdateDictionaryKey:keyId
  237|      0|                           withValue:value];
  238|      0|
  239|      0|        FPath *path = [FPath pathWithString:keyId];
  240|      0|        id<FNode> node = [FSnapshotUtilities nodeFrom:value
  241|      0|                                   withValidationFrom:fn];
  242|      0|
  243|      0|        [updatePaths addObject:path];
  244|      0|        compoundWrite = [compoundWrite addWrite:node atPath:path];
  245|      0|    }
  246|      0|
  247|      0|    // Check that the update paths are not descendants of each other.
  248|      0|    [updatePaths
  249|      0|        sortUsingComparator:^NSComparisonResult(FPath *left, FPath *right) {
  250|      0|          return [left compare:right];
  251|      0|        }];
  252|      0|    FPath *prevPath = nil;
  253|      0|    for (FPath *path in updatePaths) {
  254|      0|        if (prevPath != nil && [prevPath contains:path]) {
  255|      0|            @throw [[NSException alloc]
  256|      0|                initWithName:@"InvalidFirebaseData"
  257|      0|                      reason:[NSString stringWithFormat:
  258|      0|                                           @"(%@) Invalid path in object. Path "
  259|      0|                                           @"(%@) is an ancestor of (%@).",
  260|      0|                                           fn, prevPath, path]
  261|      0|                    userInfo:nil];
  262|      0|        }
  263|      0|        prevPath = path;
  264|      0|    }
  265|      0|
  266|      0|    return compoundWrite;
  267|      0|}
  268|       |
  269|      0|+ (void)validatePriorityNode:(id<FNode>)priorityNode {
  270|      0|    assert(priorityNode != nil);
  271|      0|    if (priorityNode.isLeafNode) {
  272|      0|        id val = priorityNode.val;
  273|      0|        if ([val isKindOfClass:[NSDictionary class]]) {
  274|      0|            NSDictionary *valDict __unused = (NSDictionary *)val;
  275|      0|            NSAssert(valDict[kServerValueSubKey] != nil,
  276|      0|                     @"Priority can't be object unless it's a deferred value");
  277|      0|        } else {
  278|      0|            NSString *jsType __unused = [FUtilities getJavascriptType:val];
  279|      0|            NSAssert(jsType == kJavaScriptString || jsType == kJavaScriptNumber,
  280|      0|                     @"Priority of unexpected type.");
  281|      0|        }
  282|      0|    } else {
  283|      0|        NSAssert(priorityNode == [FMaxNode maxNode] || priorityNode.isEmpty,
  284|      0|                 @"Priority of unexpected type.");
  285|      0|    }
  286|      0|    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
  287|      0|    NSAssert(priorityNode == [FMaxNode maxNode] ||
  288|      0|                 priorityNode.getPriority.isEmpty,
  289|      0|             @"Priority nodes can't have a priority of their own.");
  290|      0|}
  291|       |
  292|       |+ (void)appendHashRepresentationForLeafNode:(FLeafNode *)leafNode
  293|       |                                   toString:(NSMutableString *)string
  294|      0|                                hashVersion:(FDataHashVersion)hashVersion {
  295|      0|    NSAssert(hashVersion == FDataHashVersionV1 ||
  296|      0|                 hashVersion == FDataHashVersionV2,
  297|      0|             @"Unknown hash version: %lu", (unsigned long)hashVersion);
  298|      0|    if (!leafNode.getPriority.isEmpty) {
  299|      0|        [string appendString:@"priority:"];
  300|      0|        [FSnapshotUtilities
  301|      0|            appendHashRepresentationForLeafNode:leafNode.getPriority
  302|      0|                                       toString:string
  303|      0|                                    hashVersion:hashVersion];
  304|      0|        [string appendString:@":"];
  305|      0|    }
  306|      0|
  307|      0|    NSString *jsType = [FUtilities getJavascriptType:leafNode.val];
  308|      0|    [string appendString:jsType];
  309|      0|    [string appendString:@":"];
  310|      0|
  311|      0|    if (jsType == kJavaScriptBoolean) {
  312|      0|        NSString *boolString =
  313|      0|            [leafNode.val boolValue] ? kJavaScriptTrue : kJavaScriptFalse;
  314|      0|        [string appendString:boolString];
  315|      0|    } else if (jsType == kJavaScriptNumber) {
  316|      0|        NSString *numberString =
  317|      0|            [FUtilities ieee754StringForNumber:leafNode.val];
  318|      0|        [string appendString:numberString];
  319|      0|    } else if (jsType == kJavaScriptString) {
  320|      0|        if (hashVersion == FDataHashVersionV1) {
  321|      0|            [string appendString:leafNode.val];
  322|      0|        } else {
  323|      0|            NSAssert(hashVersion == FDataHashVersionV2,
  324|      0|                     @"Invalid hash version found");
  325|      0|            [FSnapshotUtilities appendHashV2RepresentationForString:leafNode.val
  326|      0|                                                           toString:string];
  327|      0|        }
  328|      0|    } else {
  329|      0|        [NSException raise:NSInvalidArgumentException
  330|      0|                    format:@"Unknown value for hashing: %@", leafNode];
  331|      0|    }
  332|      0|}
  333|       |
  334|       |+ (void)appendHashV2RepresentationForString:(NSString *)string
  335|      0|                                   toString:(NSMutableString *)mutableString {
  336|      0|    string = [string stringByReplacingOccurrencesOfString:@"\\"
  337|      0|                                               withString:@"\\\\"];
  338|      0|    string = [string stringByReplacingOccurrencesOfString:@"\""
  339|      0|                                               withString:@"\\\""];
  340|      0|    [mutableString appendString:@"\""];
  341|      0|    [mutableString appendString:string];
  342|      0|    [mutableString appendString:@"\""];
  343|      0|}
  344|       |
  345|      0|+ (NSUInteger)estimateLeafNodeSize:(FLeafNode *)leafNode {
  346|      0|    NSString *jsType = [FUtilities getJavascriptType:leafNode.val];
  347|      0|    // These values are somewhat arbitrary, but we don't need an exact value so
  348|      0|    // prefer performance over exact value
  349|      0|    NSUInteger valueSize;
  350|      0|    if (jsType == kJavaScriptNumber) {
  351|      0|        valueSize = 8; // estimate each float with 8 bytes
  352|      0|    } else if (jsType == kJavaScriptBoolean) {
  353|      0|        valueSize = 4; // true or false need roughly 4 bytes
  354|      0|    } else if (jsType == kJavaScriptString) {
  355|      0|        valueSize = 2 + [leafNode.val length]; // add 2 for quotes
  356|      0|    } else {
  357|      0|        [NSException raise:NSInvalidArgumentException
  358|      0|                    format:@"Unknown leaf type: %@", leafNode];
  359|      0|        return 0;
  360|      0|    }
  361|      0|
  362|      0|    if (leafNode.getPriority.isEmpty) {
  363|      0|        return valueSize;
  364|      0|    } else {
  365|      0|        // Account for extra overhead due to the extra JSON object and the
  366|      0|        // ".value" and ".priority" keys, colons, comma
  367|      0|        NSUInteger leafPriorityOverhead = 2 + 8 + 11 + 2 + 1;
  368|      0|        return leafPriorityOverhead + valueSize +
  369|      0|               [FSnapshotUtilities estimateLeafNodeSize:leafNode.getPriority];
  370|      0|    }
  371|      0|}
  372|       |
  373|      0|+ (NSUInteger)estimateSerializedNodeSize:(id<FNode>)node {
  374|      0|    if ([node isEmpty]) {
  375|      0|        return 4; // null keyword
  376|      0|    } else if ([node isLeafNode]) {
  377|      0|        return [FSnapshotUtilities estimateLeafNodeSize:node];
  378|      0|    } else {
  379|      0|        NSAssert([node isKindOfClass:[FChildrenNode class]],
  380|      0|                 @"Unexpected node type: %@", [node class]);
  381|      0|        __block NSUInteger sum = 1; // opening brackets
  382|      0|        [((FChildrenNode *)node) enumerateChildrenAndPriorityUsingBlock:^(
  383|      0|                                     NSString *key, id<FNode> child,
  384|      0|                                     BOOL *stop) {
  385|      0|          sum += key.length;
  386|      0|          sum +=
  387|      0|              4; // quotes around key and colon and (comma or closing bracket)
  388|      0|          sum += [FSnapshotUtilities estimateSerializedNodeSize:child];
  389|      0|        }];
  390|      0|        return sum;
  391|      0|    }
  392|      0|}
  393|       |
  394|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FAtomicNumber.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FAtomicNumber.h"
   18|       |
   19|       |@interface FAtomicNumber () {
   20|       |    unsigned long number;
   21|       |}
   22|       |
   23|       |@property(nonatomic, strong) NSLock *lock;
   24|       |
   25|       |@end
   26|       |
   27|       |@implementation FAtomicNumber
   28|       |
   29|       |@synthesize lock;
   30|       |
   31|      0|- (id)init {
   32|      0|    self = [super init];
   33|      0|    if (self) {
   34|      0|        number = 1;
   35|      0|        self.lock = [[NSLock alloc] init];
   36|      0|    }
   37|      0|    return self;
   38|      0|}
   39|       |
   40|      0|- (NSNumber *)getAndIncrement {
   41|      0|    NSNumber *result;
   42|      0|
   43|      0|    // See:
   44|      0|    // http://developer.apple.com/library/ios/#DOCUMENTATION/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW14
   45|      0|    // to improve, etc.
   46|      0|
   47|      0|    [self.lock lock];
   48|      0|    result = [NSNumber numberWithUnsignedLong:number];
   49|      0|    number = number + 1;
   50|      0|    [self.lock unlock];
   51|      0|
   52|      0|    return result;
   53|      0|}
   54|       |
   55|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FEventEmitter.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FEventEmitter.h"
   18|       |#import "FIRDatabaseQuery_Private.h"
   19|       |#import "FRepoManager.h"
   20|       |#import "FUtilities.h"
   21|       |
   22|       |@interface FEventListener : NSObject
   23|       |
   24|       |@property(nonatomic, copy) fbt_void_id userCallback;
   25|       |@property(nonatomic) FIRDatabaseHandle handle;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FEventListener
   30|       |
   31|       |@synthesize userCallback;
   32|       |@synthesize handle;
   33|       |
   34|       |@end
   35|       |
   36|       |@interface FEventEmitter ()
   37|       |
   38|       |@property(nonatomic, strong) NSArray *allowedEvents;
   39|       |@property(nonatomic, strong) NSMutableDictionary *listeners;
   40|       |@property(nonatomic, strong) dispatch_queue_t queue;
   41|       |
   42|       |@end
   43|       |
   44|       |@implementation FEventEmitter
   45|       |
   46|       |@synthesize allowedEvents;
   47|       |@synthesize listeners;
   48|       |
   49|       |- (id)initWithAllowedEvents:(NSArray *)theAllowedEvents
   50|      0|                      queue:(dispatch_queue_t)queue {
   51|      0|    if (theAllowedEvents == nil || [theAllowedEvents count] == 0) {
   52|      0|        @throw [NSException
   53|      0|            exceptionWithName:@"AllowedEventsValidation"
   54|      0|                       reason:@"FEventEmitters must be initialized with at "
   55|      0|                              @"least one valid event."
   56|      0|                     userInfo:nil];
   57|      0|    }
   58|      0|
   59|      0|    self = [super init];
   60|      0|
   61|      0|    if (self) {
   62|      0|        self.allowedEvents = [theAllowedEvents copy];
   63|      0|        self.listeners = [[NSMutableDictionary alloc] init];
   64|      0|        self.queue = queue;
   65|      0|    }
   66|      0|
   67|      0|    return self;
   68|      0|}
   69|       |
   70|      0|- (id)getInitialEventForType:(NSString *)eventType {
   71|      0|    @throw [NSException exceptionWithName:NSInternalInconsistencyException
   72|      0|                                   reason:@"You must override getInitialEvent: "
   73|      0|                                          @"when subclassing FEventEmitter"
   74|      0|                                 userInfo:nil];
   75|      0|}
   76|       |
   77|      0|- (void)triggerEventType:(NSString *)eventType data:(id)data {
   78|      0|    [self validateEventType:eventType];
   79|      0|    NSMutableDictionary *eventTypeListeners =
   80|      0|        [self.listeners objectForKey:eventType];
   81|      0|    for (FEventListener *listener in eventTypeListeners) {
   82|      0|        [self triggerListener:listener withData:data];
   83|      0|    }
   84|      0|}
   85|       |
   86|      0|- (void)triggerListener:(FEventListener *)listener withData:(id)data {
   87|      0|    // TODO, should probably get this from FRepo or something although it ends
   88|      0|    // up being the same. (Except maybe for testing)
   89|      0|    if (listener.userCallback) {
   90|      0|        dispatch_async(self.queue, ^{
   91|      0|          listener.userCallback(data);
   92|      0|        });
   93|      0|    }
   94|      0|}
   95|       |
   96|       |- (FIRDatabaseHandle)observeEventType:(NSString *)eventType
   97|      0|                            withBlock:(fbt_void_id)block {
   98|      0|    [self validateEventType:eventType];
   99|      0|
  100|      0|    // Create listener
  101|      0|    FEventListener *listener = [[FEventListener alloc] init];
  102|      0|    listener.handle = [[FUtilities LUIDGenerator] integerValue];
  103|      0|    listener.userCallback = block; // copies block automatically
  104|      0|
  105|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  106|      0|      [self addEventListener:listener forEventType:eventType];
  107|      0|    });
  108|      0|
  109|      0|    return listener.handle;
  110|      0|}
  111|       |
  112|       |- (void)addEventListener:(FEventListener *)listener
  113|      0|            forEventType:(NSString *)eventType {
  114|      0|    // Get or initializer listeners map [FIRDatabaseHandle -> callback block]
  115|      0|    // for eventType
  116|      0|    NSMutableArray *eventTypeListeners =
  117|      0|        [self.listeners objectForKey:eventType];
  118|      0|    if (eventTypeListeners == nil) {
  119|      0|        eventTypeListeners = [[NSMutableArray alloc] init];
  120|      0|        [self.listeners setObject:eventTypeListeners forKey:eventType];
  121|      0|    }
  122|      0|
  123|      0|    // Add listener and fire the current event for this listener
  124|      0|    [eventTypeListeners addObject:listener];
  125|      0|    id initialData = [self getInitialEventForType:eventType];
  126|      0|    [self triggerListener:listener withData:initialData];
  127|      0|}
  128|       |
  129|       |- (void)removeObserverForEventType:(NSString *)eventType
  130|      0|                        withHandle:(FIRDatabaseHandle)handle {
  131|      0|    [self validateEventType:eventType];
  132|      0|
  133|      0|    dispatch_async([FIRDatabaseQuery sharedQueue], ^{
  134|      0|      [self removeEventListenerWithHandle:handle forEventType:eventType];
  135|      0|    });
  136|      0|}
  137|       |
  138|       |- (void)removeEventListenerWithHandle:(FIRDatabaseHandle)handle
  139|      0|                         forEventType:(NSString *)eventType {
  140|      0|    NSMutableArray *eventTypeListeners =
  141|      0|        [self.listeners objectForKey:eventType];
  142|      0|    for (FEventListener *listener in [eventTypeListeners copy]) {
  143|      0|        if (handle == NSNotFound || handle == listener.handle) {
  144|      0|            [eventTypeListeners removeObject:listener];
  145|      0|        }
  146|      0|    }
  147|      0|}
  148|       |
  149|      0|- (void)validateEventType:(NSString *)eventType {
  150|      0|    if ([self.allowedEvents indexOfObject:eventType] == NSNotFound) {
  151|      0|        @throw [NSException
  152|      0|            exceptionWithName:@"InvalidEventType"
  153|      0|                       reason:[NSString stringWithFormat:
  154|      0|                                            @"%@ is not a valid event type. %@ "
  155|      0|                                            @"is the list of valid events.",
  156|      0|                                            eventType, self.allowedEvents]
  157|      0|                     userInfo:nil];
  158|      0|    }
  159|      0|}
  160|       |
  161|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FNextPushId.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FNextPushId.h"
   18|       |#import "FUtilities.h"
   19|       |
   20|       |static NSString *const PUSH_CHARS =
   21|       |    @"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
   22|       |
   23|       |@implementation FNextPushId
   24|       |
   25|      0|+ (NSString *)get:(NSTimeInterval)currentTime {
   26|      0|    static long long lastPushTime = 0;
   27|      0|    static int lastRandChars[12];
   28|      0|
   29|      0|    long long now = (long long)(currentTime * 1000);
   30|      0|
   31|      0|    BOOL duplicateTime = now == lastPushTime;
   32|      0|    lastPushTime = now;
   33|      0|
   34|      0|    unichar timeStampChars[8];
   35|      0|    for (int i = 7; i >= 0; i--) {
   36|      0|        timeStampChars[i] = [PUSH_CHARS characterAtIndex:(now % 64)];
   37|      0|        now = (long long)floor(now / 64);
   38|      0|    }
   39|      0|
   40|      0|    NSMutableString *id = [[NSMutableString alloc] init];
   41|      0|    [id appendString:[NSString stringWithCharacters:timeStampChars length:8]];
   42|      0|
   43|      0|    if (!duplicateTime) {
   44|      0|        for (int i = 0; i < 12; i++) {
   45|      0|            lastRandChars[i] = (int)floor(arc4random() % 64);
   46|      0|        }
   47|      0|    } else {
   48|      0|        int i = 0;
   49|      0|        for (i = 11; i >= 0 && lastRandChars[i] == 63; i--) {
   50|      0|            lastRandChars[i] = 0;
   51|      0|        }
   52|      0|        lastRandChars[i]++;
   53|      0|    }
   54|      0|
   55|      0|    for (int i = 0; i < 12; i++) {
   56|      0|        [id appendFormat:@"%C", [PUSH_CHARS characterAtIndex:lastRandChars[i]]];
   57|      0|    }
   58|      0|
   59|      0|    return [NSString stringWithString:id];
   60|      0|}
   61|       |
   62|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FStringUtilities.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FStringUtilities.h"
   18|       |#import "NSData+SRB64Additions.h"
   19|       |#import <CommonCrypto/CommonDigest.h>
   20|       |
   21|       |@implementation FStringUtilities
   22|       |
   23|       |// http://stackoverflow.com/questions/3468268/objective-c-sha1
   24|       |// http://stackoverflow.com/questions/7310457/ios-objective-c-sha-1-and-base64-problem
   25|      0|+ (NSString *)base64EncodedSha1:(NSString *)str {
   26|      0|    const char *cstr = [str cStringUsingEncoding:NSUTF8StringEncoding];
   27|      0|    // NSString reports length in characters, but we want it in bytes, which
   28|      0|    // strlen will give us.
   29|      0|    unsigned long dataLen = strlen(cstr);
   30|      0|    NSData *data = [NSData dataWithBytes:cstr length:dataLen];
   31|      0|    uint8_t digest[CC_SHA1_DIGEST_LENGTH];
   32|      0|    CC_SHA1(data.bytes, (unsigned int)data.length, digest);
   33|      0|    NSData *output = [[NSData alloc] initWithBytes:digest
   34|      0|                                            length:CC_SHA1_DIGEST_LENGTH];
   35|      0|    return [FSRUtilities base64EncodedStringFromData:output];
   36|      0|}
   37|       |
   38|      0|+ (NSString *)urlDecoded:(NSString *)url {
   39|      0|    NSString *replaced = [url stringByReplacingOccurrencesOfString:@"+"
   40|      0|                                                        withString:@" "];
   41|      0|    NSString *decoded = [replaced stringByRemovingPercentEncoding];
   42|      0|    // This is kind of a hack, but is generally how the js client works. We
   43|      0|    // could run into trouble if some piece is a correctly escaped %-sequence,
   44|      0|    // and another isn't. But, that's bad input anyways...
   45|      0|    if (decoded) {
   46|      0|        return decoded;
   47|      0|    } else {
   48|      0|        return replaced;
   49|      0|    }
   50|      0|}
   51|       |
   52|      0|+ (NSString *)urlEncoded:(NSString *)url {
   53|      0|    // Didn't seem like there was an Apple NSCharacterSet that had our version
   54|      0|    // of the encoding So I made my own, following RFC 2396
   55|      0|    // https://www.ietf.org/rfc/rfc2396.txt allowedCharacters = alphanum | "-" |
   56|      0|    // "_" | "~"
   57|      0|    NSCharacterSet *allowedCharacters = [NSCharacterSet
   58|      0|        characterSetWithCharactersInString:@"abcdefghijklmnopqrstuvwxyzABCDEFGH"
   59|      0|                                           @"IJKLMNOPQRSTUVWXYZ0123456789-_~"];
   60|      0|    return [url
   61|      0|        stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];
   62|      0|}
   63|       |
   64|      0|+ (NSString *)sanitizedForUserAgent:(NSString *)str {
   65|      0|    return
   66|      0|        [str stringByReplacingOccurrencesOfString:@"/|_"
   67|      0|                                       withString:@"|"
   68|      0|                                          options:NSRegularExpressionSearch
   69|      0|                                            range:NSMakeRange(0, [str length])];
   70|      0|}
   71|       |
   72|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FUtilities.h:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <FirebaseCore/FIRLogger.h>
   18|       |#import <Foundation/Foundation.h>
   19|       |
   20|       |#import "FParsedUrl.h"
   21|       |
   22|       |@interface FUtilities : NSObject
   23|       |
   24|       |+ (NSArray *)splitString:(NSString *)str intoMaxSize:(const unsigned int)size;
   25|       |+ (NSNumber *)LUIDGenerator;
   26|       |+ (FParsedUrl *)parseUrl:(NSString *)url;
   27|       |+ (NSString *)getJavascriptType:(id)obj;
   28|       |+ (NSError *)errorForStatus:(NSString *)status andReason:(NSString *)reason;
   29|       |+ (NSNumber *)intForString:(NSString *)string;
   30|       |+ (NSString *)ieee754StringForNumber:(NSNumber *)val;
   31|       |+ (void)setLoggingEnabled:(BOOL)enabled;
   32|       |+ (BOOL)getLoggingEnabled;
   33|       |
   34|       |+ (NSString *)minName;
   35|       |+ (NSString *)maxName;
   36|       |+ (NSComparisonResult)compareKey:(NSString *)a toKey:(NSString *)b;
   37|       |+ (NSComparator)stringComparator;
   38|       |+ (NSComparator)keyComparator;
   39|       |
   40|       |+ (double)randomDouble;
   41|       |
   42|       |@end
   43|       |
   44|       |typedef enum {
   45|       |    FLogLevelDebug = 1,
   46|       |    FLogLevelInfo = 2,
   47|       |    FLogLevelWarn = 3,
   48|       |    FLogLevelError = 4,
   49|       |    FLogLevelNone = 5
   50|       |} FLogLevel;
   51|       |
   52|       |// Log tags
   53|       |FOUNDATION_EXPORT NSString *const kFPersistenceLogTag;
   54|       |
   55|      0|#define FFLog(code, format, ...) FFDebug((code), (format), ##__VA_ARGS__)
   56|       |
   57|       |#define FFDebug(code, format, ...)                                             \
   58|      0|    do {                                                                       \
   59|      0|        if (FFIsLoggingEnabled(FLogLevelDebug)) {                              \
   60|      0|            FIRLogDebug(kFIRLoggerDatabase, (code), (format), ##__VA_ARGS__);  \
   61|      0|        }                                                                      \
   62|      0|    } while (0)
   63|       |
   64|       |#define FFInfo(code, format, ...)                                              \
   65|      0|    do {                                                                       \
   66|      0|        if (FFIsLoggingEnabled(FLogLevelInfo)) {                               \
   67|      0|            FIRLogError(kFIRLoggerDatabase, (code), (format), ##__VA_ARGS__);  \
   68|      0|        }                                                                      \
   69|      0|    } while (0)
   70|       |
   71|       |#define FFWarn(code, format, ...)                                              \
   72|      0|    do {                                                                       \
   73|      0|        if (FFIsLoggingEnabled(FLogLevelWarn)) {                               \
   74|      0|            FIRLogWarning(kFIRLoggerDatabase, (code), (format),                \
   75|      0|                          ##__VA_ARGS__);                                      \
   76|      0|        }                                                                      \
   77|      0|    } while (0)
   78|       |
   79|       |extern FIRLoggerService kFIRLoggerDatabase;
   80|       |BOOL FFIsLoggingEnabled(FLogLevel logLevel);
   81|       |void firebaseUncaughtExceptionHandler(NSException *exception);
   82|       |void firebaseJobsTroll(void);

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FUtilities.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FUtilities.h"
   18|       |#import "FAtomicNumber.h"
   19|       |#import "FConstants.h"
   20|       |#import "FStringUtilities.h"
   21|       |#import <FirebaseCore/FIRLogger.h>
   22|       |
   23|      0|#define ARC4RANDOM_MAX 0x100000000
   24|      0|#define INTEGER_32_MIN (-2147483648)
   25|      0|#define INTEGER_32_MAX 2147483647
   26|       |
   27|       |#pragma mark -
   28|       |#pragma mark C functions
   29|       |
   30|       |FIRLoggerService kFIRLoggerDatabase = @"[Firebase/Database]";
   31|       |static FLogLevel logLevel = FLogLevelInfo; // Default log level is info
   32|       |static NSMutableDictionary *options = nil;
   33|       |
   34|      0|BOOL FFIsLoggingEnabled(FLogLevel level) { return level >= logLevel; }
   35|       |
   36|      0|void firebaseJobsTroll(void) {
   37|      0|    FFLog(@"I-RDB095001",
   38|      0|          @"password super secret; JFK conspiracy; Hello there! Having fun "
   39|      0|          @"digging through Firebase? We're always hiring! jobs@firebase.com");
   40|      0|}
   41|       |
   42|       |#pragma mark -
   43|       |#pragma mark Private property and singleton specification
   44|       |
   45|       |@interface FUtilities () {
   46|       |}
   47|       |
   48|       |@property(nonatomic, strong) FAtomicNumber *localUid;
   49|       |
   50|       |+ (FUtilities *)singleton;
   51|       |
   52|       |@end
   53|       |
   54|       |@implementation FUtilities
   55|       |
   56|       |@synthesize localUid;
   57|       |
   58|      0|- (id)init {
   59|      0|    self = [super init];
   60|      0|    if (self) {
   61|      0|        self.localUid = [[FAtomicNumber alloc] init];
   62|      0|    }
   63|      0|    return self;
   64|      0|}
   65|       |
   66|       |// TODO: We really want to be able to set the log level
   67|      0|+ (void)setLoggingEnabled:(BOOL)enabled {
   68|      0|    logLevel = enabled ? FLogLevelDebug : FLogLevelInfo;
   69|      0|}
   70|       |
   71|      0|+ (BOOL)getLoggingEnabled {
   72|      0|    return logLevel == FLogLevelDebug;
   73|      0|}
   74|       |
   75|      0|+ (FUtilities *)singleton {
   76|      0|    static dispatch_once_t pred = 0;
   77|      0|    __strong static id _sharedObject = nil;
   78|      0|    dispatch_once(&pred, ^{
   79|      0|      _sharedObject = [[self alloc] init]; // or some other init method
   80|      0|    });
   81|      0|    return _sharedObject;
   82|      0|}
   83|       |
   84|       |// Refactor as a category of NSString
   85|      0|+ (NSArray *)splitString:(NSString *)str intoMaxSize:(const unsigned int)size {
   86|      0|    if (str.length <= size) {
   87|      0|        return [NSArray arrayWithObject:str];
   88|      0|    }
   89|      0|
   90|      0|    NSMutableArray *dataSegs = [[NSMutableArray alloc] init];
   91|      0|    for (int c = 0; c < str.length; c += size) {
   92|      0|        if (c + size > str.length) {
   93|      0|            int rangeStart = c;
   94|      0|            unsigned long rangeLength = size - ((c + size) - str.length);
   95|      0|            [dataSegs
   96|      0|                addObject:[str substringWithRange:NSMakeRange(rangeStart,
   97|      0|                                                              rangeLength)]];
   98|      0|        } else {
   99|      0|            int rangeStart = c;
  100|      0|            int rangeLength = size;
  101|      0|            [dataSegs
  102|      0|                addObject:[str substringWithRange:NSMakeRange(rangeStart,
  103|      0|                                                              rangeLength)]];
  104|      0|        }
  105|      0|    }
  106|      0|    return dataSegs;
  107|      0|}
  108|       |
  109|      0|+ (NSNumber *)LUIDGenerator {
  110|      0|    FUtilities *f = [FUtilities singleton];
  111|      0|    return [f.localUid getAndIncrement];
  112|      0|}
  113|       |
  114|      0|+ (NSString *)decodePath:(NSString *)pathString {
  115|      0|    NSMutableArray *decodedPieces = [[NSMutableArray alloc] init];
  116|      0|    NSArray *pieces = [pathString componentsSeparatedByString:@"/"];
  117|      0|    for (NSString *piece in pieces) {
  118|      0|        if (piece.length > 0) {
  119|      0|            [decodedPieces addObject:[FStringUtilities urlDecoded:piece]];
  120|      0|        }
  121|      0|    }
  122|      0|    return [NSString
  123|      0|        stringWithFormat:@"/%@", [decodedPieces componentsJoinedByString:@"/"]];
  124|      0|}
  125|       |
  126|      0|+ (NSString *)extractPathFromUrlString:(NSString *)url {
  127|      0|    NSString *path = url;
  128|      0|
  129|      0|    NSRange schemeIndex = [path rangeOfString:@"//"];
  130|      0|    if (schemeIndex.location != NSNotFound) {
  131|      0|        path = [path substringFromIndex:schemeIndex.location + 2];
  132|      0|    }
  133|      0|
  134|      0|    NSUInteger pathIndex = [path rangeOfString:@"/"].location;
  135|      0|    if (pathIndex != NSNotFound) {
  136|      0|        path = [path substringFromIndex:pathIndex + 1];
  137|      0|    } else {
  138|      0|        path = @"";
  139|      0|    }
  140|      0|
  141|      0|    NSUInteger queryParamIndex = [path rangeOfString:@"?"].location;
  142|      0|    if (queryParamIndex != NSNotFound) {
  143|      0|        path = [path substringToIndex:queryParamIndex];
  144|      0|    }
  145|      0|
  146|      0|    return path;
  147|      0|}
  148|       |
  149|      0|+ (FParsedUrl *)parseUrl:(NSString *)url {
  150|      0|    // For backwards compatibility, support URLs without schemes on iOS.
  151|      0|    if (![url containsString:@"://"]) {
  152|      0|        url = [@"http://" stringByAppendingString:url];
  153|      0|    }
  154|      0|
  155|      0|    NSString *originalPathString = [self extractPathFromUrlString:url];
  156|      0|
  157|      0|    // Sanitize the database URL by removing the path component, which may
  158|      0|    // contain invalid URL characters.
  159|      0|    NSString *sanitizedUrlWithoutPath =
  160|      0|        [url stringByReplacingOccurrencesOfString:originalPathString
  161|      0|                                       withString:@""];
  162|      0|    NSURLComponents *urlComponents =
  163|      0|        [NSURLComponents componentsWithString:sanitizedUrlWithoutPath];
  164|      0|    if (!urlComponents) {
  165|      0|        [NSException raise:@"Failed to parse database URL"
  166|      0|                    format:@"Failed to parse database URL: %@", url];
  167|      0|    }
  168|      0|
  169|      0|    NSString *host = [urlComponents.host lowercaseString];
  170|      0|    NSString *namespace;
  171|      0|    bool secure;
  172|      0|
  173|      0|    if (urlComponents.port != nil) {
  174|      0|        secure = [urlComponents.scheme isEqualToString:@"https"] ||
  175|      0|                 [urlComponents.scheme isEqualToString:@"wss"];
  176|      0|        host = [host stringByAppendingFormat:@":%@", urlComponents.port];
  177|      0|    } else {
  178|      0|        secure = YES;
  179|      0|    };
  180|      0|
  181|      0|    NSArray *parts = [urlComponents.host componentsSeparatedByString:@"."];
  182|      0|    if ([parts count] == 3) {
  183|      0|        namespace = [parts[0] lowercaseString];
  184|      0|    } else {
  185|      0|        // Attempt to extract namespace from "ns" query param.
  186|      0|        NSArray *queryItems = urlComponents.queryItems;
  187|      0|        for (NSURLQueryItem *item in queryItems) {
  188|      0|            if ([item.name isEqualToString:@"ns"]) {
  189|      0|                namespace = item.value;
  190|      0|                break;
  191|      0|            }
  192|      0|        }
  193|      0|
  194|      0|        if (!namespace) {
  195|      0|            namespace = [parts[0] lowercaseString];
  196|      0|        }
  197|      0|    }
  198|      0|
  199|      0|    NSString *pathString = [self
  200|      0|        decodePath:[NSString stringWithFormat:@"/%@", originalPathString]];
  201|      0|    FPath *path = [[FPath alloc] initWith:pathString];
  202|      0|    FRepoInfo *repoInfo = [[FRepoInfo alloc] initWithHost:host
  203|      0|                                                 isSecure:secure
  204|      0|                                            withNamespace:namespace];
  205|      0|
  206|      0|    FFLog(@"I-RDB095002", @"---> Parsed (%@) to: (%@,%@); ns=(%@); path=(%@)",
  207|      0|          url, [repoInfo description], [repoInfo connectionURL],
  208|      0|          repoInfo.namespace, [path description]);
  209|      0|
  210|      0|    FParsedUrl *parsedUrl = [[FParsedUrl alloc] init];
  211|      0|    parsedUrl.repoInfo = repoInfo;
  212|      0|    parsedUrl.path = path;
  213|      0|
  214|      0|    return parsedUrl;
  215|      0|}
  216|       |
  217|       |/*
  218|       | case str: JString => priString + "string:" + str.s;
  219|       | case bool: JBool => priString + "boolean:" + bool.value;
  220|       | case double: JDouble => priString + "number:" + double.num;
  221|       | case int: JInt => priString + "number:" + int.num;
  222|       | case _ => {
  223|       | error("Leaf node has value '" + data.value + "' of invalid type '" +
  224|       | data.value.getClass.toString + "'");
  225|       | "";
  226|       | }
  227|       | */
  228|       |
  229|      0|+ (NSString *)getJavascriptType:(id)obj {
  230|      0|    if ([obj isKindOfClass:[NSDictionary class]]) {
  231|      0|        return kJavaScriptObject;
  232|      0|    } else if ([obj isKindOfClass:[NSString class]]) {
  233|      0|        return kJavaScriptString;
  234|      0|    } else if ([obj isKindOfClass:[NSNumber class]]) {
  235|      0|        // We used to just compare to @encode(BOOL) as suggested at
  236|      0|        // http://stackoverflow.com/questions/2518761/get-type-of-nsnumber, but
  237|      0|        // on arm64, @encode(BOOL) returns "B" instead of "c" even though
  238|      0|        // objCType still returns 'c' (signed char).  So check both.
  239|      0|        if (strcmp([obj objCType], @encode(BOOL)) == 0 ||
  240|      0|            strcmp([obj objCType], @encode(signed char)) == 0) {
  241|      0|            return kJavaScriptBoolean;
  242|      0|        } else {
  243|      0|            return kJavaScriptNumber;
  244|      0|        }
  245|      0|    } else {
  246|      0|        return kJavaScriptNull;
  247|      0|    }
  248|      0|}
  249|       |
  250|      0|+ (NSError *)errorForStatus:(NSString *)status andReason:(NSString *)reason {
  251|      0|    static dispatch_once_t pred = 0;
  252|      0|    __strong static NSDictionary *errorMap = nil;
  253|      0|    __strong static NSDictionary *errorCodes = nil;
  254|      0|    dispatch_once(&pred, ^{
  255|      0|      errorMap = @{
  256|      0|          @"permission_denied" : @"Permission Denied",
  257|      0|          @"unavailable" : @"Service is unavailable",
  258|      0|          kFErrorWriteCanceled : @"Write cancelled by user"
  259|      0|      };
  260|      0|      errorCodes = @{
  261|      0|          @"permission_denied" : @1,
  262|      0|          @"unavailable" : @2,
  263|      0|          kFErrorWriteCanceled : @3
  264|      0|      };
  265|      0|    });
  266|      0|
  267|      0|    if ([status isEqualToString:kFWPResponseForActionStatusOk]) {
  268|      0|        return nil;
  269|      0|    } else {
  270|      0|        NSInteger code;
  271|      0|        NSString *desc = nil;
  272|      0|        if (reason) {
  273|      0|            desc = reason;
  274|      0|        } else if ([errorMap objectForKey:status] != nil) {
  275|      0|            desc = [errorMap objectForKey:status];
  276|      0|        } else {
  277|      0|            desc = status;
  278|      0|        }
  279|      0|
  280|      0|        if ([errorCodes objectForKey:status] != nil) {
  281|      0|            NSNumber *num = [errorCodes objectForKey:status];
  282|      0|            code = [num integerValue];
  283|      0|        } else {
  284|      0|            // XXX what to do here?
  285|      0|            code = 9999;
  286|      0|        }
  287|      0|
  288|      0|        return [[NSError alloc]
  289|      0|            initWithDomain:kFErrorDomain
  290|      0|                      code:code
  291|      0|                  userInfo:@{NSLocalizedDescriptionKey : desc}];
  292|      0|    }
  293|      0|}
  294|       |
  295|      0|+ (NSNumber *)intForString:(NSString *)string {
  296|      0|    static NSCharacterSet *notDigits = nil;
  297|      0|    if (!notDigits) {
  298|      0|        notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];
  299|      0|    }
  300|      0|    if ([string rangeOfCharacterFromSet:notDigits].length == 0) {
  301|      0|        NSInteger num;
  302|      0|        NSScanner *scanner = [NSScanner scannerWithString:string];
  303|      0|        if ([scanner scanInteger:&num]) {
  304|      0|            return [NSNumber numberWithInteger:num];
  305|      0|        }
  306|      0|    }
  307|      0|    return nil;
  308|      0|}
  309|       |
  310|      0|+ (NSString *)ieee754StringForNumber:(NSNumber *)val {
  311|      0|    double d = [val doubleValue];
  312|      0|    NSData *data = [NSData dataWithBytes:&d length:sizeof(double)];
  313|      0|    NSMutableString *str = [[NSMutableString alloc] init];
  314|      0|    const unsigned char *buffer = (const unsigned char *)[data bytes];
  315|      0|    for (int i = 0; i < data.length; i++) {
  316|      0|        unsigned char byte = buffer[7 - i];
  317|      0|        [str appendFormat:@"%02x", byte];
  318|      0|    }
  319|      0|    return str;
  320|      0|}
  321|       |
  322|       |static inline BOOL tryParseStringToInt(__unsafe_unretained NSString *str,
  323|      0|                                       NSInteger *integer) {
  324|      0|    // First do some cheap checks (NOTE: The below checks are significantly
  325|      0|    // faster than an equivalent regex :-( ).
  326|      0|    NSUInteger length = str.length;
  327|      0|    if (length > 11 || length == 0) {
  328|      0|        return NO;
  329|      0|    }
  330|      0|    long long value = 0;
  331|      0|    BOOL negative = NO;
  332|      0|    NSUInteger i = 0;
  333|      0|    if ([str characterAtIndex:0] == '-') {
  334|      0|        if (length == 1) {
  335|      0|            return NO;
  336|      0|        }
  337|      0|        negative = YES;
  338|      0|        i = 1;
  339|      0|    }
  340|      0|    for (; i < length; i++) {
  341|      0|        unichar c = [str characterAtIndex:i];
  342|      0|        // Must be a digit, or '-' if it's the first char.
  343|      0|        if (c < '0' || c > '9') {
  344|      0|            return NO;
  345|      0|        } else {
  346|      0|            int charValue = c - '0';
  347|      0|            value = value * 10 + charValue;
  348|      0|        }
  349|      0|    }
  350|      0|
  351|      0|    value = (negative) ? -value : value;
  352|      0|
  353|      0|    if (value < INTEGER_32_MIN || value > INTEGER_32_MAX) {
  354|      0|        return NO;
  355|      0|    } else {
  356|      0|        *integer = (NSInteger)value;
  357|      0|        return YES;
  358|      0|    }
  359|      0|}
  360|       |
  361|      0|+ (NSString *)maxName {
  362|      0|    static dispatch_once_t once;
  363|      0|    static NSString *maxName;
  364|      0|    dispatch_once(&once, ^{
  365|      0|      maxName = [[NSString alloc] initWithFormat:@"[MAX_NAME]"];
  366|      0|    });
  367|      0|    return maxName;
  368|      0|}
  369|       |
  370|      0|+ (NSString *)minName {
  371|      0|    static dispatch_once_t once;
  372|      0|    static NSString *minName;
  373|      0|    dispatch_once(&once, ^{
  374|      0|      minName = [[NSString alloc] initWithFormat:@"[MIN_NAME]"];
  375|      0|    });
  376|      0|    return minName;
  377|      0|}
  378|       |
  379|      0|+ (NSComparisonResult)compareKey:(NSString *)a toKey:(NSString *)b {
  380|      0|    if (a == b) {
  381|      0|        return NSOrderedSame;
  382|      0|    } else if (a == [FUtilities minName] || b == [FUtilities maxName]) {
  383|      0|        return NSOrderedAscending;
  384|      0|    } else if (b == [FUtilities minName] || a == [FUtilities maxName]) {
  385|      0|        return NSOrderedDescending;
  386|      0|    } else {
  387|      0|        NSInteger aAsInt, bAsInt;
  388|      0|        if (tryParseStringToInt(a, &aAsInt)) {
  389|      0|            if (tryParseStringToInt(b, &bAsInt)) {
  390|      0|                if (aAsInt > bAsInt) {
  391|      0|                    return NSOrderedDescending;
  392|      0|                } else if (aAsInt < bAsInt) {
  393|      0|                    return NSOrderedAscending;
  394|      0|                } else if (a.length > b.length) {
  395|      0|                    return NSOrderedDescending;
  396|      0|                } else if (a.length < b.length) {
  397|      0|                    return NSOrderedAscending;
  398|      0|                } else {
  399|      0|                    return NSOrderedSame;
  400|      0|                }
  401|      0|            } else {
  402|      0|                return (NSComparisonResult)NSOrderedAscending;
  403|      0|            }
  404|      0|        } else if (tryParseStringToInt(b, &bAsInt)) {
  405|      0|            return (NSComparisonResult)NSOrderedDescending;
  406|      0|        } else {
  407|      0|            // Perform literal character by character search to prevent a > b &&
  408|      0|            // b > a issues. Note that calling -(NSString
  409|      0|            // *)decomposedStringWithCanonicalMapping also works.
  410|      0|            return [a compare:b options:NSLiteralSearch];
  411|      0|        }
  412|      0|    }
  413|      0|}
  414|       |
  415|      0|+ (NSComparator)keyComparator {
  416|      0|    return ^NSComparisonResult(__unsafe_unretained NSString *a,
  417|      0|                               __unsafe_unretained NSString *b) {
  418|      0|      return [FUtilities compareKey:a toKey:b];
  419|      0|    };
  420|      0|}
  421|       |
  422|      0|+ (NSComparator)stringComparator {
  423|      0|    return ^NSComparisonResult(__unsafe_unretained NSString *a,
  424|      0|                               __unsafe_unretained NSString *b) {
  425|      0|      return [a compare:b];
  426|      0|    };
  427|      0|}
  428|       |
  429|      0|+ (double)randomDouble {
  430|      0|    return ((double)arc4random() / ARC4RANDOM_MAX);
  431|      0|}
  432|       |
  433|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/FValidation.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FValidation.h"
   18|       |#import "FConstants.h"
   19|       |#import "FParsedUrl.h"
   20|       |#import "FTypedefs.h"
   21|       |
   22|       |// Have to escape:  * ? + [ ( ) { } ^ $ | \ . /
   23|       |// See:
   24|       |// https://developer.apple.com/library/mac/#documentation/Foundation/Reference/NSRegularExpression_Class/Reference/Reference.html
   25|       |
   26|       |NSString *const kInvalidPathCharacters = @"[].#$";
   27|       |NSString *const kInvalidKeyCharacters = @"[].#$/";
   28|       |
   29|       |@implementation FValidation
   30|       |
   31|      0|+ (void)validateFrom:(NSString *)fn writablePath:(FPath *)path {
   32|      0|    if ([[path getFront] isEqualToString:kDotInfoPrefix]) {
   33|      0|        @throw [[NSException alloc]
   34|      0|            initWithName:@"WritablePathValidation"
   35|      0|                  reason:[NSString
   36|      0|                             stringWithFormat:@"(%@) failed to path %@: Can't "
   37|      0|                                              @"modify data under %@",
   38|      0|                                              fn, [path description],
   39|      0|                                              kDotInfoPrefix]
   40|      0|                userInfo:nil];
   41|      0|    }
   42|      0|}
   43|       |
   44|      0|+ (void)validateFrom:(NSString *)fn knownEventType:(FIRDataEventType)event {
   45|      0|    switch (event) {
   46|      0|    case FIRDataEventTypeValue:
   47|      0|    case FIRDataEventTypeChildAdded:
   48|      0|    case FIRDataEventTypeChildChanged:
   49|      0|    case FIRDataEventTypeChildMoved:
   50|      0|    case FIRDataEventTypeChildRemoved:
   51|      0|        return;
   52|      0|        break;
   53|      0|    default:
   54|      0|        @throw [[NSException alloc]
   55|      0|            initWithName:@"KnownEventTypeValidation"
   56|      0|                  reason:[NSString
   57|      0|                             stringWithFormat:@"(%@) Unknown event type: %d",
   58|      0|                                              fn, (int)event]
   59|      0|                userInfo:nil];
   60|      0|        break;
   61|      0|    }
   62|      0|}
   63|       |
   64|      0|+ (BOOL)isValidPathString:(NSString *)pathString {
   65|      0|    static dispatch_once_t token;
   66|      0|    static NSCharacterSet *badPathChars = nil;
   67|      0|    dispatch_once(&token, ^{
   68|      0|      badPathChars = [NSCharacterSet
   69|      0|          characterSetWithCharactersInString:kInvalidPathCharacters];
   70|      0|    });
   71|      0|    return pathString != nil && [pathString length] != 0 &&
   72|      0|           [pathString rangeOfCharacterFromSet:badPathChars].location ==
   73|      0|               NSNotFound;
   74|      0|}
   75|       |
   76|      0|+ (void)validateFrom:(NSString *)fn validPathString:(NSString *)pathString {
   77|      0|    if (![self isValidPathString:pathString]) {
   78|      0|        @throw [[NSException alloc]
   79|      0|            initWithName:@"InvalidPathValidation"
   80|      0|                  reason:[NSString stringWithFormat:
   81|      0|                                       @"(%@) Must be a non-empty string and "
   82|      0|                                       @"not contain '.' '#' '$' '[' or ']'",
   83|      0|                                       fn]
   84|      0|                userInfo:nil];
   85|      0|    }
   86|      0|}
   87|       |
   88|      0|+ (void)validateFrom:(NSString *)fn validRootPathString:(NSString *)pathString {
   89|      0|    static dispatch_once_t token;
   90|      0|    static NSRegularExpression *dotInfoRegex = nil;
   91|      0|    dispatch_once(&token, ^{
   92|      0|      dotInfoRegex = [NSRegularExpression
   93|      0|          regularExpressionWithPattern:@"^\\/*\\.info(\\/|$)"
   94|      0|                               options:0
   95|      0|                                 error:nil];
   96|      0|    });
   97|      0|
   98|      0|    NSString *tempPath = pathString;
   99|      0|    // HACK: Obj-C regex are kinda' slow.  Do a plain string search first before
  100|      0|    // bothering with the regex.
  101|      0|    if ([pathString rangeOfString:@".info"].location != NSNotFound) {
  102|      0|        tempPath = [dotInfoRegex
  103|      0|            stringByReplacingMatchesInString:pathString
  104|      0|                                     options:0
  105|      0|                                       range:NSMakeRange(0, pathString.length)
  106|      0|                                withTemplate:@"/"];
  107|      0|    }
  108|      0|    [self validateFrom:fn validPathString:tempPath];
  109|      0|}
  110|       |
  111|      0|+ (BOOL)isValidKey:(NSString *)key {
  112|      0|    static dispatch_once_t token;
  113|      0|    static NSCharacterSet *badKeyChars = nil;
  114|      0|    dispatch_once(&token, ^{
  115|      0|      badKeyChars = [NSCharacterSet
  116|      0|          characterSetWithCharactersInString:kInvalidKeyCharacters];
  117|      0|    });
  118|      0|    return key != nil && key.length > 0 &&
  119|      0|           [key rangeOfCharacterFromSet:badKeyChars].location == NSNotFound;
  120|      0|}
  121|       |
  122|      0|+ (void)validateFrom:(NSString *)fn validKey:(NSString *)key {
  123|      0|    if (![self isValidKey:key]) {
  124|      0|        @throw [[NSException alloc]
  125|      0|            initWithName:@"InvalidKeyValidation"
  126|      0|                  reason:[NSString
  127|      0|                             stringWithFormat:
  128|      0|                                 @"(%@) Must be a non-empty string and not "
  129|      0|                                 @"contain '/' '.' '#' '$' '[' or ']'",
  130|      0|                                 fn]
  131|      0|                userInfo:nil];
  132|      0|    }
  133|      0|}
  134|       |
  135|      0|+ (void)validateFrom:(NSString *)fn validURL:(FParsedUrl *)parsedUrl {
  136|      0|    NSString *pathString = [parsedUrl.path description];
  137|      0|    [self validateFrom:fn validRootPathString:pathString];
  138|      0|}
  139|       |
  140|       |#pragma mark -
  141|       |#pragma mark Authentication validation
  142|       |
  143|      0|+ (BOOL)stringNonempty:(NSString *)str {
  144|      0|    return str != nil && ![str isKindOfClass:[NSNull class]] && str.length > 0;
  145|      0|}
  146|       |
  147|      0|+ (void)validateToken:(NSString *)token {
  148|      0|    if (![FValidation stringNonempty:token]) {
  149|      0|        [NSException raise:NSInvalidArgumentException
  150|      0|                    format:@"Can't have empty string or nil for custom token"];
  151|      0|    }
  152|      0|}
  153|       |
  154|       |#pragma mark -
  155|       |#pragma mark Handling authentication errors
  156|       |
  157|       |/**
  158|       | * This function immediately calls the callback.
  159|       | * It assumes that it is not on FirebaseWorker thread.
  160|       | * It assumes it's on a user-controlled thread.
  161|       | */
  162|       |+ (void)handleError:(NSError *)error
  163|      0|    withUserCallback:(fbt_void_nserror_id)userCallback {
  164|      0|    if (userCallback) {
  165|      0|        userCallback(error, nil);
  166|      0|    }
  167|      0|}
  168|       |
  169|       |/**
  170|       | * This function immediately calls the callback.
  171|       | * It assumes that it is not on FirebaseWorker thread.
  172|       | * It assumes it's on a user-controlled thread.
  173|       | */
  174|       |+ (void)handleError:(NSError *)error
  175|      0|    withSuccessCallback:(fbt_void_nserror)userCallback {
  176|      0|    if (userCallback) {
  177|      0|        userCallback(error);
  178|      0|    }
  179|      0|}
  180|       |
  181|       |#pragma mark -
  182|       |#pragma mark Snapshot validation
  183|       |
  184|       |+ (BOOL)validateFrom:(NSString *)fn
  185|       |    isValidLeafValue:(id)value
  186|      0|            withPath:(NSArray *)path {
  187|      0|    if ([value isKindOfClass:[NSString class]]) {
  188|      0|        // Try to avoid conversion to bytes if possible
  189|      0|        NSString *theString = value;
  190|      0|        if ([theString maximumLengthOfBytesUsingEncoding:NSUTF8StringEncoding] >
  191|      0|                kFirebaseMaxLeafSize &&
  192|      0|            [theString lengthOfBytesUsingEncoding:NSUTF8StringEncoding] >
  193|      0|                kFirebaseMaxLeafSize) {
  194|      0|            NSRange range;
  195|      0|            range.location = 0;
  196|      0|            range.length = MIN(path.count, 50);
  197|      0|            NSString *pathString =
  198|      0|                [[path subarrayWithRange:range] componentsJoinedByString:@"."];
  199|      0|            @throw [[NSException alloc]
  200|      0|                initWithName:@"InvalidFirebaseData"
  201|      0|                      reason:[NSString
  202|      0|                                 stringWithFormat:@"(%@) String exceeds max "
  203|      0|                                                  @"size of %u utf8 bytes: %@",
  204|      0|                                                  fn, (int)kFirebaseMaxLeafSize,
  205|      0|                                                  pathString]
  206|      0|                    userInfo:nil];
  207|      0|        }
  208|      0|        return YES;
  209|      0|    }
  210|      0|
  211|      0|    else if ([value isKindOfClass:[NSNumber class]]) {
  212|      0|        // Cannot store NaN, but otherwise can store NSNumbers.
  213|      0|        if ([[NSDecimalNumber notANumber] isEqualToNumber:value]) {
  214|      0|            NSRange range;
  215|      0|            range.location = 0;
  216|      0|            range.length = MIN(path.count, 50);
  217|      0|            NSString *pathString =
  218|      0|                [[path subarrayWithRange:range] componentsJoinedByString:@"."];
  219|      0|            @throw [[NSException alloc]
  220|      0|                initWithName:@"InvalidFirebaseData"
  221|      0|                      reason:[NSString
  222|      0|                                 stringWithFormat:
  223|      0|                                     @"(%@) Cannot store NaN at path: %@.", fn,
  224|      0|                                     pathString]
  225|      0|                    userInfo:nil];
  226|      0|        }
  227|      0|        return YES;
  228|      0|    }
  229|      0|
  230|      0|    else if ([value isKindOfClass:[NSDictionary class]]) {
  231|      0|        NSDictionary *dval = value;
  232|      0|        if (dval[kServerValueSubKey] != nil) {
  233|      0|            if ([dval count] > 1) {
  234|      0|                NSRange range;
  235|      0|                range.location = 0;
  236|      0|                range.length = MIN(path.count, 50);
  237|      0|                NSString *pathString = [[path subarrayWithRange:range]
  238|      0|                    componentsJoinedByString:@"."];
  239|      0|                @throw [[NSException alloc]
  240|      0|                    initWithName:@"InvalidFirebaseData"
  241|      0|                          reason:[NSString stringWithFormat:
  242|      0|                                               @"(%@) Cannot store other keys "
  243|      0|                                               @"with server value keys.%@.",
  244|      0|                                               fn, pathString]
  245|      0|                        userInfo:nil];
  246|      0|            }
  247|      0|            return YES;
  248|      0|        }
  249|      0|        return NO;
  250|      0|    }
  251|      0|
  252|      0|    else if (value == [NSNull null] || value == nil) {
  253|      0|        // Null is valid type to store at leaf
  254|      0|        return YES;
  255|      0|    }
  256|      0|
  257|      0|    return NO;
  258|      0|}
  259|       |
  260|       |+ (NSString *)parseAndValidateKey:(id)keyId
  261|       |                     fromFunction:(NSString *)fn
  262|      0|                             path:(NSArray *)path {
  263|      0|    if (![keyId isKindOfClass:[NSString class]]) {
  264|      0|        NSRange range;
  265|      0|        range.location = 0;
  266|      0|        range.length = MIN(path.count, 50);
  267|      0|        NSString *pathString =
  268|      0|            [[path subarrayWithRange:range] componentsJoinedByString:@"."];
  269|      0|        @throw [[NSException alloc]
  270|      0|            initWithName:@"InvalidFirebaseData"
  271|      0|                  reason:[NSString
  272|      0|                             stringWithFormat:@"(%@) Non-string keys are not "
  273|      0|                                              @"allowed in object at path: %@",
  274|      0|                                              fn, pathString]
  275|      0|                userInfo:nil];
  276|      0|    }
  277|      0|    return (NSString *)keyId;
  278|      0|}
  279|       |
  280|       |+ (void)validateFrom:(NSString *)fn
  281|       |    validDictionaryKey:(id)keyId
  282|      0|              withPath:(NSArray *)path {
  283|      0|    NSString *key = [self parseAndValidateKey:keyId fromFunction:fn path:path];
  284|      0|    if (![key isEqualToString:kPayloadPriority] &&
  285|      0|        ![key isEqualToString:kPayloadValue] &&
  286|      0|        ![key isEqualToString:kServerValueSubKey] &&
  287|      0|        ![FValidation isValidKey:key]) {
  288|      0|        NSRange range;
  289|      0|        range.location = 0;
  290|      0|        range.length = MIN(path.count, 50);
  291|      0|        NSString *pathString =
  292|      0|            [[path subarrayWithRange:range] componentsJoinedByString:@"."];
  293|      0|        @throw [[NSException alloc]
  294|      0|            initWithName:@"InvalidFirebaseData"
  295|      0|                  reason:[NSString stringWithFormat:
  296|      0|                                       @"(%@) Invalid key in object at path: "
  297|      0|                                       @"%@. Keys must be non-empty and cannot "
  298|      0|                                       @"contain '/' '.' '#' '$' '[' or ']'",
  299|      0|                                       fn, pathString]
  300|      0|                userInfo:nil];
  301|      0|    }
  302|      0|}
  303|       |
  304|       |+ (void)validateFrom:(NSString *)fn
  305|       |    validUpdateDictionaryKey:(id)keyId
  306|      0|                   withValue:(id)value {
  307|      0|    FPath *path = [FPath pathWithString:[self parseAndValidateKey:keyId
  308|      0|                                                     fromFunction:fn
  309|      0|                                                             path:@[]]];
  310|      0|    __block NSInteger keyNum = 0;
  311|      0|    [path enumerateComponentsUsingBlock:^void(NSString *key, BOOL *stop) {
  312|      0|      if ([key isEqualToString:kPayloadPriority] &&
  313|      0|          keyNum == [path length] - 1) {
  314|      0|          [self validateFrom:fn isValidPriorityValue:value withPath:@[]];
  315|      0|      } else {
  316|      0|          keyNum++;
  317|      0|
  318|      0|          if (![FValidation isValidKey:key]) {
  319|      0|              @throw [[NSException alloc]
  320|      0|                  initWithName:@"InvalidFirebaseData"
  321|      0|                        reason:[NSString
  322|      0|                                   stringWithFormat:
  323|      0|                                       @"(%@) Invalid key in object. Keys must "
  324|      0|                                       @"be non-empty and cannot contain '.' "
  325|      0|                                       @"'#' '$' '[' or ']'",
  326|      0|                                       fn]
  327|      0|                      userInfo:nil];
  328|      0|          }
  329|      0|      }
  330|      0|    }];
  331|      0|}
  332|       |
  333|       |+ (void)validateFrom:(NSString *)fn
  334|       |    isValidPriorityValue:(id)value
  335|      0|                withPath:(NSArray *)path {
  336|      0|    [self validateFrom:fn
  337|      0|        isValidPriorityValue:value
  338|      0|                    withPath:path
  339|      0|                  throwError:YES];
  340|      0|}
  341|       |
  342|       |/**
  343|       | * Returns YES if priority is valid.
  344|       | */
  345|      0|+ (BOOL)validatePriorityValue:value {
  346|      0|    return [self validateFrom:nil
  347|      0|         isValidPriorityValue:value
  348|      0|                     withPath:nil
  349|      0|                   throwError:NO];
  350|      0|}
  351|       |
  352|       |/**
  353|       | * Helper for validating priorities.  If passed YES for throwError, it'll throw
  354|       | * descriptive errors on validation problems.  Else, it'll just return YES/NO.
  355|       | */
  356|       |+ (BOOL)validateFrom:(NSString *)fn
  357|       |    isValidPriorityValue:(id)value
  358|       |                withPath:(NSArray *)path
  359|      0|              throwError:(BOOL)throwError {
  360|      0|    if ([value isKindOfClass:[NSNumber class]]) {
  361|      0|        if ([[NSDecimalNumber notANumber] isEqualToNumber:value]) {
  362|      0|            if (throwError) {
  363|      0|                NSRange range;
  364|      0|                range.location = 0;
  365|      0|                range.length = MIN(path.count, 50);
  366|      0|                NSString *pathString = [[path subarrayWithRange:range]
  367|      0|                    componentsJoinedByString:@"."];
  368|      0|                @throw [[NSException alloc]
  369|      0|                    initWithName:@"InvalidFirebaseData"
  370|      0|                          reason:[NSString stringWithFormat:
  371|      0|                                               @"(%@) Cannot store NaN as "
  372|      0|                                               @"priority at path: %@.",
  373|      0|                                               fn, pathString]
  374|      0|                        userInfo:nil];
  375|      0|            } else {
  376|      0|                return NO;
  377|      0|            }
  378|      0|        } else if (value == (id)kCFBooleanFalse ||
  379|      0|                   value == (id)kCFBooleanTrue) {
  380|      0|            if (throwError) {
  381|      0|                NSRange range;
  382|      0|                range.location = 0;
  383|      0|                range.length = MIN(path.count, 50);
  384|      0|                NSString *pathString = [[path subarrayWithRange:range]
  385|      0|                    componentsJoinedByString:@"."];
  386|      0|                @throw [[NSException alloc]
  387|      0|                    initWithName:@"InvalidFirebaseData"
  388|      0|                          reason:[NSString stringWithFormat:
  389|      0|                                               @"(%@) Cannot store true/false "
  390|      0|                                               @"as priority at path: %@.",
  391|      0|                                               fn, pathString]
  392|      0|                        userInfo:nil];
  393|      0|            } else {
  394|      0|                return NO;
  395|      0|            }
  396|      0|        }
  397|      0|    } else if ([value isKindOfClass:[NSDictionary class]]) {
  398|      0|        NSDictionary *dval = value;
  399|      0|        if (dval[kServerValueSubKey] != nil) {
  400|      0|            if ([dval count] > 1) {
  401|      0|                if (throwError) {
  402|      0|                    NSRange range;
  403|      0|                    range.location = 0;
  404|      0|                    range.length = MIN(path.count, 50);
  405|      0|                    NSString *pathString = [[path subarrayWithRange:range]
  406|      0|                        componentsJoinedByString:@"."];
  407|      0|                    @throw [[NSException alloc]
  408|      0|                        initWithName:@"InvalidFirebaseData"
  409|      0|                              reason:[NSString
  410|      0|                                         stringWithFormat:
  411|      0|                                             @"(%@) Cannot store other keys "
  412|      0|                                             @"with server value keys as "
  413|      0|                                             @"priority at path: %@.",
  414|      0|                                             fn, pathString]
  415|      0|                            userInfo:nil];
  416|      0|                } else {
  417|      0|                    return NO;
  418|      0|                }
  419|      0|            }
  420|      0|        } else {
  421|      0|            if (throwError) {
  422|      0|                NSRange range;
  423|      0|                range.location = 0;
  424|      0|                range.length = MIN(path.count, 50);
  425|      0|                NSString *pathString = [[path subarrayWithRange:range]
  426|      0|                    componentsJoinedByString:@"."];
  427|      0|                @throw [[NSException alloc]
  428|      0|                    initWithName:@"InvalidFirebaseData"
  429|      0|                          reason:[NSString
  430|      0|                                     stringWithFormat:
  431|      0|                                         @"(%@) Cannot store an NSDictionary "
  432|      0|                                         @"as priority at path: %@.",
  433|      0|                                         fn, pathString]
  434|      0|                        userInfo:nil];
  435|      0|            } else {
  436|      0|                return NO;
  437|      0|            }
  438|      0|        }
  439|      0|    } else if ([value isKindOfClass:[NSArray class]]) {
  440|      0|        if (throwError) {
  441|      0|            NSRange range;
  442|      0|            range.location = 0;
  443|      0|            range.length = MIN(path.count, 50);
  444|      0|            NSString *pathString =
  445|      0|                [[path subarrayWithRange:range] componentsJoinedByString:@"."];
  446|      0|            @throw [[NSException alloc]
  447|      0|                initWithName:@"InvalidFirebaseData"
  448|      0|                      reason:[NSString stringWithFormat:
  449|      0|                                           @"(%@) Cannot store an NSArray as "
  450|      0|                                           @"priority at path: %@.",
  451|      0|                                           fn, pathString]
  452|      0|                    userInfo:nil];
  453|      0|        } else {
  454|      0|            return NO;
  455|      0|        }
  456|      0|    }
  457|      0|
  458|      0|    // It's valid!
  459|      0|    return YES;
  460|      0|}
  461|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleNodePath.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTupleNodePath.h"
   18|       |
   19|       |@implementation FTupleNodePath
   20|       |
   21|       |@synthesize path;
   22|       |@synthesize node;
   23|       |
   24|      0|- (id)initWithNode:(id<FNode>)aNode andPath:(FPath *)aPath {
   25|      0|    self = [super init];
   26|      0|    if (self) {
   27|      0|        self.path = aPath;
   28|      0|        self.node = aNode;
   29|      0|    }
   30|      0|    return self;
   31|      0|}
   32|       |
   33|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleObjectNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import "FTupleObjectNode.h"
   17|       |
   18|       |@implementation FTupleObjectNode
   19|       |
   20|       |@synthesize obj;
   21|       |@synthesize node;
   22|       |
   23|      0|- (id)initWithObject:(id)aObj andNode:(id<FNode>)aNode {
   24|      0|    self = [super init];
   25|      0|    if (self) {
   26|      0|        self.obj = aObj;
   27|      0|        self.node = aNode;
   28|      0|    }
   29|      0|    return self;
   30|      0|}
   31|       |
   32|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTuplePathValue.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTuplePathValue.h"
   18|       |#import "FPath.h"
   19|       |
   20|       |@interface FTuplePathValue ()
   21|       |@property(nonatomic, strong, readwrite) id value;
   22|       |@property(nonatomic, strong, readwrite) FPath *path;
   23|       |@end
   24|       |
   25|       |@implementation FTuplePathValue
   26|       |@synthesize path;
   27|       |@synthesize value;
   28|       |
   29|      0|- (id)initWithPath:(FPath *)aPath value:(id)aValue {
   30|      0|    self = [super init];
   31|      0|    if (self) {
   32|      0|        self.value = aValue;
   33|      0|        self.path = aPath;
   34|      0|    }
   35|      0|    return self;
   36|      0|}
   37|       |
   38|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleRemovedQueriesEvents.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTupleRemovedQueriesEvents.h"
   18|       |
   19|       |@interface FTupleRemovedQueriesEvents ()
   20|       |@property(nonatomic, strong, readwrite) NSArray *removedQueries;
   21|       |@property(nonatomic, strong, readwrite) NSArray *cancelEvents;
   22|       |@end
   23|       |
   24|       |@implementation FTupleRemovedQueriesEvents
   25|       |@synthesize removedQueries;
   26|       |@synthesize cancelEvents;
   27|       |
   28|      0|- (id)initWithRemovedQueries:(NSArray *)removed cancelEvents:(NSArray *)events {
   29|      0|    self = [super init];
   30|      0|    if (self) {
   31|      0|        self.removedQueries = removed;
   32|      0|        self.cancelEvents = events;
   33|      0|    }
   34|      0|    return self;
   35|      0|}
   36|       |
   37|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleSetIdPath.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTupleSetIdPath.h"
   18|       |
   19|       |@implementation FTupleSetIdPath
   20|       |
   21|       |@synthesize path;
   22|       |@synthesize setId;
   23|       |
   24|      0|- (id)initWithSetId:(NSNumber *)aSetId andPath:(FPath *)aPath {
   25|      0|    self = [super init];
   26|      0|    if (self) {
   27|      0|        self.setId = aSetId;
   28|      0|        self.path = aPath;
   29|      0|    }
   30|      0|    return self;
   31|      0|}
   32|       |
   33|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleStringNode.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTupleStringNode.h"
   18|       |
   19|       |@implementation FTupleStringNode
   20|       |
   21|       |@synthesize string;
   22|       |@synthesize node;
   23|       |
   24|      0|- (id)initWithString:(NSString *)aString andNode:(id<FNode>)aNode {
   25|      0|    self = [super init];
   26|      0|    if (self) {
   27|      0|        self.string = aString;
   28|      0|        self.node = aNode;
   29|      0|    }
   30|      0|    return self;
   31|      0|}
   32|       |
   33|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleTransaction.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTupleTransaction.h"
   18|       |#import "FUtilities.h"
   19|       |
   20|       |@interface FTupleTransaction ()
   21|       |
   22|       |@property(nonatomic, strong) NSString *abortStatus;
   23|       |@property(nonatomic, strong) NSString *abortReason;
   24|       |
   25|       |@end
   26|       |
   27|       |@implementation FTupleTransaction
   28|       |
   29|      0|- (void)setAbortStatus:(NSString *)abortStatus reason:(NSString *)reason {
   30|      0|    self.abortStatus = abortStatus;
   31|      0|    self.abortReason = reason;
   32|      0|}
   33|       |
   34|      0|- (NSError *)abortError {
   35|      0|    return (self.abortStatus != nil)
   36|      0|               ? [FUtilities errorForStatus:self.abortStatus
   37|      0|                                  andReason:self.abortReason]
   38|      0|               : nil;
   39|      0|}
   40|       |
   41|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/Utilities/Tuples/FTupleUserCallback.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FTupleUserCallback.h"
   18|       |
   19|       |@implementation FTupleUserCallback
   20|       |
   21|       |@synthesize datasnapshotCallback;
   22|       |@synthesize datasnapshotPrevnameCallback;
   23|       |@synthesize cancelCallback;
   24|       |@synthesize queryParams;
   25|       |@synthesize handle;
   26|       |
   27|      0|- (id)initWithHandle:(NSUInteger)theHandle {
   28|      0|    self = [super init];
   29|      0|    if (self) {
   30|      0|        self.handle = theHandle;
   31|      0|    }
   32|      0|    return self;
   33|      0|}
   34|       |
   35|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FArraySortedDictionary.m:
    1|       |#import "FArraySortedDictionary.h"
    2|       |#import "FTreeSortedDictionary.h"
    3|       |
    4|       |@interface FArraySortedDictionaryEnumerator : NSEnumerator
    5|       |
    6|       |- (id)initWithKeys:(NSArray *)keys startPos:(NSInteger)pos isReverse:(BOOL)reverse;
    7|       |- (id)nextObject;
    8|       |
    9|       |@property (nonatomic) NSInteger pos;
   10|       |@property (nonatomic) BOOL reverse;
   11|       |@property (nonatomic, strong) NSArray *keys;
   12|       |
   13|       |@end
   14|       |
   15|       |@implementation FArraySortedDictionaryEnumerator
   16|       |
   17|       |- (id)initWithKeys:(NSArray *)keys startPos:(NSInteger)pos isReverse:(BOOL)reverse
   18|      0|{
   19|      0|    self = [super init];
   20|      0|    if (self != nil) {
   21|      0|        self->_pos = pos;
   22|      0|        self->_reverse = reverse;
   23|      0|        self->_keys = keys;
   24|      0|    }
   25|      0|    return self;
   26|      0|}
   27|       |
   28|       |- (id)nextObject
   29|      0|{
   30|      0|    NSInteger pos = self->_pos;
   31|      0|    if (pos >= 0 && pos < self.keys.count) {
   32|      0|        if (self.reverse) {
   33|      0|            self->_pos--;
   34|      0|        } else {
   35|      0|            self->_pos++;
   36|      0|        }
   37|      0|        return self.keys[pos];
   38|      0|    } else {
   39|      0|        return nil;
   40|      0|    }
   41|      0|}
   42|       |
   43|       |@end
   44|       |
   45|       |@interface FArraySortedDictionary ()
   46|       |
   47|       |- (id)initWithComparator:(NSComparator)comparator;
   48|       |
   49|       |@property (nonatomic, copy, readwrite) NSComparator comparator;
   50|       |@property (nonatomic, strong) NSArray *keys;
   51|       |@property (nonatomic, strong) NSArray *values;
   52|       |
   53|       |@end
   54|       |
   55|       |@implementation FArraySortedDictionary
   56|       |
   57|       |+ (FArraySortedDictionary *)fromDictionary:(NSDictionary *)dictionary withComparator:(NSComparator)comparator
   58|      0|{
   59|      0|    NSMutableArray *keys = [NSMutableArray arrayWithCapacity:dictionary.count];
   60|      0|    [dictionary enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
   61|      0|        [keys addObject:key];
   62|      0|    }];
   63|      0|    [keys sortUsingComparator:comparator];
   64|      0|
   65|      0|    [keys enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
   66|      0|        if (idx > 0) {
   67|      0|            if (comparator(keys[idx - 1], obj) != NSOrderedAscending) {
   68|      0|                [NSException raise:NSInvalidArgumentException format:@"Can't create FImmutableSortedDictionary with keys with same ordering!"];
   69|      0|            }
   70|      0|        }
   71|      0|    }];
   72|      0|
   73|      0|    NSMutableArray *values = [NSMutableArray arrayWithCapacity:keys.count];
   74|      0|    NSInteger pos = 0;
   75|      0|    for (id key in keys) {
   76|      0|        values[pos++] = dictionary[key];
   77|      0|    }
   78|      0|    NSAssert(values.count == keys.count, @"We added as many keys as values");
   79|      0|    return [[FArraySortedDictionary alloc] initWithComparator:comparator keys:keys values:values];
   80|      0|}
   81|       |
   82|       |- (id)initWithComparator:(NSComparator)comparator
   83|      0|{
   84|      0|    self = [super init];
   85|      0|    if (self != nil) {
   86|      0|        self->_comparator = comparator;
   87|      0|        self->_keys = [NSArray array];
   88|      0|        self->_values = [NSArray array];
   89|      0|    }
   90|      0|    return self;
   91|      0|}
   92|       |
   93|       |- (id)initWithComparator:(NSComparator)comparator keys:(NSArray *)keys values:(NSArray *)values
   94|      0|{
   95|      0|    self = [super init];
   96|      0|    if (self != nil) {
   97|      0|        self->_comparator = comparator;
   98|      0|        self->_keys = keys;
   99|      0|        self->_values = values;
  100|      0|    }
  101|      0|    return self;
  102|      0|}
  103|       |
  104|       |- (NSInteger) findInsertPositionForKey:(id)key
  105|      0|{
  106|      0|    NSInteger newPos = 0;
  107|      0|    while (newPos < self.keys.count && self.comparator(self.keys[newPos], key) < NSOrderedSame) {
  108|      0|        newPos++;
  109|      0|    }
  110|      0|    return newPos;
  111|      0|}
  112|       |
  113|       |- (NSInteger) findKey:(id)key
  114|      0|{
  115|      0|    if (key == nil) {
  116|      0|        return NSNotFound;
  117|      0|    }
  118|      0|    for (NSInteger pos = 0; pos < self.keys.count; pos++) {
  119|      0|        NSComparisonResult result = self.comparator(key, self.keys[pos]);
  120|      0|        if (result == NSOrderedSame) {
  121|      0|            return pos;
  122|      0|        } else if (result == NSOrderedAscending) {
  123|      0|            return NSNotFound;
  124|      0|        }
  125|      0|    }
  126|      0|    return NSNotFound;
  127|      0|}
  128|       |
  129|       |- (FImmutableSortedDictionary *) insertKey:(id)key withValue:(id)value
  130|      0|{
  131|      0|    NSInteger pos = [self findKey:key];
  132|      0|
  133|      0|    if (pos == NSNotFound) {
  134|      0|        /*
  135|      0|         * If we're above the threshold we want to convert it to a tree backed implementation to not have
  136|      0|         * degrading performance
  137|      0|         */
  138|      0|        if (self.count >= SORTED_DICTIONARY_ARRAY_TO_RB_TREE_SIZE_THRESHOLD) {
  139|      0|            NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithCapacity:self.count];
  140|      0|            for (NSInteger i = 0; i < self.keys.count; i++) {
  141|      0|                dict[self.keys[i]] = self.values[i];
  142|      0|            }
  143|      0|            dict[key] = value;
  144|      0|            return [FTreeSortedDictionary fromDictionary:dict withComparator:self.comparator];
  145|      0|        } else {
  146|      0|            NSMutableArray *newKeys = [NSMutableArray arrayWithArray:self.keys];
  147|      0|            NSMutableArray *newValues = [NSMutableArray arrayWithArray:self.values];
  148|      0|            NSInteger newPos = [self findInsertPositionForKey:key];
  149|      0|            [newKeys insertObject:key atIndex:newPos];
  150|      0|            [newValues insertObject:value atIndex:newPos];
  151|      0|            return [[FArraySortedDictionary alloc] initWithComparator:self.comparator keys:newKeys values:newValues];
  152|      0|        }
  153|      0|    } else {
  154|      0|        NSMutableArray *newKeys = [NSMutableArray arrayWithArray:self.keys];
  155|      0|        NSMutableArray *newValues = [NSMutableArray arrayWithArray:self.values];
  156|      0|        newKeys[pos] = key;
  157|      0|        newValues[pos] = value;
  158|      0|        return [[FArraySortedDictionary alloc] initWithComparator:self.comparator keys:newKeys values:newValues];
  159|      0|    }
  160|      0|}
  161|       |
  162|       |- (FImmutableSortedDictionary *) removeKey:(id)key
  163|      0|{
  164|      0|    NSInteger pos = [self findKey:key];
  165|      0|    if (pos == NSNotFound) {
  166|      0|        return self;
  167|      0|    } else {
  168|      0|        NSMutableArray *newKeys = [NSMutableArray arrayWithArray:self.keys];
  169|      0|        NSMutableArray *newValues = [NSMutableArray arrayWithArray:self.values];
  170|      0|        [newKeys removeObjectAtIndex:pos];
  171|      0|        [newValues removeObjectAtIndex:pos];
  172|      0|        return [[FArraySortedDictionary alloc] initWithComparator:self.comparator keys:newKeys values:newValues];
  173|      0|    }
  174|      0|}
  175|       |
  176|       |- (id) get:(id)key
  177|      0|{
  178|      0|    NSInteger pos = [self findKey:key];
  179|      0|    if (pos == NSNotFound) {
  180|      0|        return nil;
  181|      0|    } else {
  182|      0|        return self.values[pos];
  183|      0|    }
  184|      0|}
  185|       |
  186|      0|- (id) getPredecessorKey:(id) key {
  187|      0|    NSInteger pos = [self findKey:key];
  188|      0|    if (pos == NSNotFound) {
  189|      0|        [NSException raise:NSInternalInconsistencyException format:@"Can't get predecessor key for non-existent key"];
  190|      0|        return nil;
  191|      0|    } else if (pos == 0) {
  192|      0|        return nil;
  193|      0|    } else {
  194|      0|        return self.keys[pos - 1];
  195|      0|    }
  196|      0|}
  197|       |
  198|      0|- (BOOL) isEmpty {
  199|      0|    return self.keys.count == 0;
  200|      0|}
  201|       |
  202|       |- (int) count
  203|      0|{
  204|      0|    return (int)self.keys.count;
  205|      0|}
  206|       |
  207|       |- (id) minKey
  208|      0|{
  209|      0|    return [self.keys firstObject];
  210|      0|}
  211|       |
  212|       |- (id) maxKey
  213|      0|{
  214|      0|    return [self.keys lastObject];
  215|      0|}
  216|       |
  217|       |- (void) enumerateKeysAndObjectsUsingBlock:(void (^)(id, id, BOOL *))block
  218|      0|{
  219|      0|    [self enumerateKeysAndObjectsReverse:NO usingBlock:block];
  220|      0|}
  221|       |
  222|       |- (void) enumerateKeysAndObjectsReverse:(BOOL)reverse usingBlock:(void (^)(id, id, BOOL *))block
  223|      0|{
  224|      0|    if (reverse) {
  225|      0|        BOOL stop = NO;
  226|      0|        for (NSInteger i = self.keys.count - 1; i >= 0; i--) {
  227|      0|            block(self.keys[i], self.values[i], &stop);
  228|      0|            if (stop) return;
  229|      0|        }
  230|      0|    } else {
  231|      0|        BOOL stop = NO;
  232|      0|        for (NSInteger i = 0; i < self.keys.count; i++) {
  233|      0|            block(self.keys[i], self.values[i], &stop);
  234|      0|            if (stop) return;
  235|      0|        }
  236|      0|    }
  237|      0|}
  238|       |
  239|      0|- (BOOL) contains:(id)key {
  240|      0|    return [self findKey:key] != NSNotFound;
  241|      0|}
  242|       |
  243|      0|- (NSEnumerator *) keyEnumerator {
  244|      0|    return [self.keys objectEnumerator];
  245|      0|}
  246|       |
  247|      0|- (NSEnumerator *) keyEnumeratorFrom:(id)startKey {
  248|      0|    NSInteger startPos = [self findInsertPositionForKey:startKey];
  249|      0|    return [[FArraySortedDictionaryEnumerator alloc] initWithKeys:self.keys startPos:startPos isReverse:NO];
  250|      0|}
  251|       |
  252|      0|- (NSEnumerator *) reverseKeyEnumerator {
  253|      0|    return [self.keys reverseObjectEnumerator];
  254|      0|}
  255|       |
  256|      0|- (NSEnumerator *) reverseKeyEnumeratorFrom:(id)startKey {
  257|      0|    NSInteger startPos = [self findInsertPositionForKey:startKey];
  258|      0|    // if there's no exact match, findKeyOrInsertPosition will return the index *after* the closest match, but
  259|      0|    // since this is a reverse iterator, we want to start just *before* the closest match.
  260|      0|    if (startPos >= self.keys.count || self.comparator(self.keys[startPos], startKey) != NSOrderedSame) {
  261|      0|        startPos -= 1;
  262|      0|    }
  263|      0|    return [[FArraySortedDictionaryEnumerator alloc] initWithKeys:self.keys startPos:startPos isReverse:YES];
  264|      0|}
  265|       |
  266|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FImmutableSortedDictionary.h:
    1|       |/**
    2|       | * @fileoverview Implementation of an immutable SortedMap using a Left-leaning
    3|       | * Red-Black Tree, adapted from the implementation in Mugs
    4|       | * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen
    5|       | * (mads379@gmail.com).
    6|       | *
    7|       | * Original paper on Left-leaning Red-Black Trees:
    8|       | *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
    9|       | *
   10|       | * Invariant 1: No red node has a red child
   11|       | * Invariant 2: Every leaf path has the same number of black nodes
   12|       | * Invariant 3: Only the left child can be red (left leaning)
   13|       | */
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |/**
   18|       | * The size threshold where we use a tree backed sorted map instead of an array backed sorted map.
   19|       | * This is a more or less arbitrary chosen value, that was chosen to be large enough to fit most of object kind
   20|       | * of Firebase data, but small enough to not notice degradation in performance for inserting and lookups.
   21|       | * Feel free to empirically determine this constant, but don't expect much gain in real world performance.
   22|       | */
   23|      0|#define SORTED_DICTIONARY_ARRAY_TO_RB_TREE_SIZE_THRESHOLD 25
   24|       |
   25|       |@interface FImmutableSortedDictionary : NSObject
   26|       |
   27|       |+ (FImmutableSortedDictionary *)dictionaryWithComparator:(NSComparator)comparator;
   28|       |+ (FImmutableSortedDictionary *)fromDictionary:(NSDictionary *)dictionary withComparator:(NSComparator)comparator;
   29|       |
   30|       |- (FImmutableSortedDictionary *) insertKey:(id)aKey withValue:(id)aValue;
   31|       |- (FImmutableSortedDictionary *) removeKey:(id)aKey;
   32|       |- (id) get:(id) key;
   33|       |- (id) getPredecessorKey:(id) key;
   34|       |- (BOOL) isEmpty;
   35|       |- (int) count;
   36|       |- (id) minKey;
   37|       |- (id) maxKey;
   38|       |- (void) enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id value, BOOL *stop))block;
   39|       |- (void) enumerateKeysAndObjectsReverse:(BOOL)reverse usingBlock:(void(^)(id key, id value, BOOL *stop))block;
   40|       |- (BOOL) contains:(id)key;
   41|       |- (NSEnumerator *) keyEnumerator;
   42|       |- (NSEnumerator *) keyEnumeratorFrom:(id)startKey;
   43|       |- (NSEnumerator *) reverseKeyEnumerator;
   44|       |- (NSEnumerator *) reverseKeyEnumeratorFrom:(id)startKey;
   45|       |
   46|       |#pragma mark -
   47|       |#pragma mark Methods similar to NSMutableDictionary
   48|       |
   49|       |- (FImmutableSortedDictionary *) setObject:(id)anObject forKey:(id)aKey;
   50|       |- (id) objectForKey:(id)key;
   51|       |- (FImmutableSortedDictionary *) removeObjectForKey:(id)aKey;
   52|       |
   53|       |@end
   54|       |

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FImmutableSortedDictionary.m:
    1|       |#import "FImmutableSortedDictionary.h"
    2|       |#import "FArraySortedDictionary.h"
    3|       |#import "FTreeSortedDictionary.h"
    4|       |
    5|      0|#define THROW_ABSTRACT_METHOD_EXCEPTION(sel) do { \
    6|      0|  @throw [NSException exceptionWithName:NSInternalInconsistencyException \
    7|      0|  reason:[NSString stringWithFormat:@"You must override %@ in a subclass", NSStringFromSelector(sel)] \
    8|      0|  userInfo:nil]; \
    9|      0|} while(0)
   10|       |
   11|       |@implementation FImmutableSortedDictionary
   12|       |
   13|       |+ (FImmutableSortedDictionary *)dictionaryWithComparator:(NSComparator)comparator
   14|      0|{
   15|      0|    return [[FArraySortedDictionary alloc] initWithComparator:comparator];
   16|      0|}
   17|       |
   18|       |+ (FImmutableSortedDictionary *)fromDictionary:(NSDictionary *)dictionary withComparator:(NSComparator)comparator
   19|      0|{
   20|      0|    if (dictionary.count <= SORTED_DICTIONARY_ARRAY_TO_RB_TREE_SIZE_THRESHOLD) {
   21|      0|        return [FArraySortedDictionary fromDictionary:dictionary withComparator:comparator];
   22|      0|    } else {
   23|      0|        return [FTreeSortedDictionary fromDictionary:dictionary withComparator:comparator];
   24|      0|    }
   25|      0|}
   26|       |
   27|      0|- (FImmutableSortedDictionary *) insertKey:(id)aKey withValue:(id)aValue {
   28|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(insertKey:withValue:));
   29|      0|}
   30|       |
   31|      0|- (FImmutableSortedDictionary *) removeKey:(id)aKey {
   32|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(removeKey:));
   33|      0|}
   34|       |
   35|      0|- (id) get:(id) key {
   36|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(get:));
   37|      0|}
   38|       |
   39|      0|- (id) getPredecessorKey:(id) key {
   40|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(getPredecessorKey:));
   41|      0|}
   42|       |
   43|      0|- (BOOL) isEmpty {
   44|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(isEmpty));
   45|      0|}
   46|       |
   47|      0|- (int) count {
   48|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector((count)));
   49|      0|}
   50|       |
   51|      0|- (id) minKey {
   52|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(minKey));
   53|      0|}
   54|       |
   55|      0|- (id) maxKey {
   56|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(maxKey));
   57|      0|}
   58|       |
   59|      0|- (void) enumerateKeysAndObjectsUsingBlock:(void (^)(id, id, BOOL *))block {
   60|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(enumerateKeysAndObjectsUsingBlock:));
   61|      0|}
   62|       |
   63|      0|- (void) enumerateKeysAndObjectsReverse:(BOOL)reverse usingBlock:(void (^)(id, id, BOOL *))block {
   64|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(enumerateKeysAndObjectsReverse:usingBlock:));
   65|      0|}
   66|       |
   67|      0|- (BOOL) contains:(id)key {
   68|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(contains:));
   69|      0|}
   70|       |
   71|      0|- (NSEnumerator *) keyEnumerator {
   72|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(keyEnumerator));
   73|      0|}
   74|       |
   75|      0|- (NSEnumerator *) keyEnumeratorFrom:(id)startKey {
   76|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(keyEnumeratorFrom:));
   77|      0|}
   78|       |
   79|      0|- (NSEnumerator *) reverseKeyEnumerator {
   80|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(reverseKeyEnumerator));
   81|      0|}
   82|       |
   83|      0|- (NSEnumerator *) reverseKeyEnumeratorFrom:(id)startKey {
   84|      0|    THROW_ABSTRACT_METHOD_EXCEPTION(@selector(reverseKeyEnumeratorFrom:));
   85|      0|}
   86|       |
   87|      0|- (BOOL)isEqual:(id)object {
   88|      0|    if (![object isKindOfClass:[FImmutableSortedDictionary class]]) {
   89|      0|        return NO;
   90|      0|    }
   91|      0|    FImmutableSortedDictionary *other = (FImmutableSortedDictionary *)object;
   92|      0|    if (self.count != other.count) {
   93|      0|        return NO;
   94|      0|    }
   95|      0|    __block BOOL isEqual = YES;
   96|      0|    [self enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {
   97|      0|        id otherValue = [other objectForKey:key];
   98|      0|        isEqual = isEqual && (value == otherValue || [value isEqual:otherValue]);
   99|      0|        *stop = !isEqual;
  100|      0|    }];
  101|      0|    return isEqual;
  102|      0|}
  103|       |
  104|      0|- (NSUInteger)hash {
  105|      0|    __block NSUInteger hash = 0;
  106|      0|    [self enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {
  107|      0|        hash = (hash * 31 + [key hash]) * 17 + [value hash];
  108|      0|    }];
  109|      0|    return hash;
  110|      0|}
  111|       |
  112|      0|- (NSString *)description {
  113|      0|    NSMutableString *str = [[NSMutableString alloc] init];
  114|      0|    __block BOOL first = YES;
  115|      0|    [str appendString:@"{ "];
  116|      0|    [self enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {
  117|      0|        if (!first) {
  118|      0|            [str appendString:@", "];
  119|      0|        }
  120|      0|        first = NO;
  121|      0|        [str appendString:[NSString stringWithFormat:@"%@: %@", key, value]];
  122|      0|    }];
  123|      0|    [str appendString:@" }"];
  124|      0|    return str;
  125|      0|}
  126|       |
  127|       |#pragma mark -
  128|       |#pragma mark Methods similar to NSMutableDictionary
  129|       |
  130|      0|- (FImmutableSortedDictionary *) setObject:(__unsafe_unretained id)anObject forKey:(__unsafe_unretained id)aKey {
  131|      0|    return [self insertKey:aKey withValue:anObject];
  132|      0|}
  133|       |
  134|      0|- (FImmutableSortedDictionary *) removeObjectForKey:(__unsafe_unretained id)aKey {
  135|      0|    return [self removeKey:aKey];
  136|      0|}
  137|       |
  138|      0|- (id) objectForKey:(__unsafe_unretained id)key {
  139|      0|    return [self get:key];
  140|      0|}
  141|       |
  142|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FImmutableSortedSet.m:
    1|       |#import "FImmutableSortedSet.h"
    2|       |#import "FImmutableSortedDictionary.h"
    3|       |
    4|       |@interface FImmutableSortedSet ()
    5|       |
    6|       |@property (nonatomic, strong) FImmutableSortedDictionary *dictionary;
    7|       |
    8|       |@end
    9|       |
   10|       |@implementation FImmutableSortedSet
   11|       |
   12|       |+ (FImmutableSortedSet *)setWithKeysFromDictionary:(NSDictionary *)dictionary comparator:(NSComparator)comparator
   13|      0|{
   14|      0|    FImmutableSortedDictionary *setDict = [FImmutableSortedDictionary fromDictionary:dictionary withComparator:comparator];
   15|      0|    return [[FImmutableSortedSet alloc] initWithDictionary:setDict];
   16|      0|}
   17|       |
   18|       |- (id)initWithDictionary:(FImmutableSortedDictionary *)dictionary
   19|      0|{
   20|      0|    self = [super init];
   21|      0|    if (self != nil) {
   22|      0|        self->_dictionary = dictionary;
   23|      0|    }
   24|      0|    return self;
   25|      0|}
   26|       |
   27|       |- (BOOL)contains:(id)object
   28|      0|{
   29|      0|    return [self.dictionary contains:object];
   30|      0|}
   31|       |
   32|       |- (FImmutableSortedSet *)addObject:(id)object
   33|      0|{
   34|      0|    FImmutableSortedDictionary *newDictionary = [self.dictionary insertKey:object withValue:[NSNull null]];
   35|      0|    if (newDictionary != self.dictionary) {
   36|      0|        return [[FImmutableSortedSet alloc] initWithDictionary:newDictionary];
   37|      0|    } else {
   38|      0|        return self;
   39|      0|    }
   40|      0|}
   41|       |
   42|       |- (FImmutableSortedSet *)removeObject:(id)object
   43|      0|{
   44|      0|    FImmutableSortedDictionary *newDictionary = [self.dictionary removeObjectForKey:object];
   45|      0|    if (newDictionary != self.dictionary) {
   46|      0|        return [[FImmutableSortedSet alloc] initWithDictionary:newDictionary];
   47|      0|    } else {
   48|      0|        return self;
   49|      0|    }
   50|      0|}
   51|       |
   52|       |- (BOOL)containsObject:(id)object
   53|      0|{
   54|      0|    return [self.dictionary contains:object];
   55|      0|}
   56|       |
   57|       |- (id)firstObject
   58|      0|{
   59|      0|    return [self.dictionary minKey];
   60|      0|}
   61|       |
   62|       |- (id)lastObject
   63|      0|{
   64|      0|    return [self.dictionary maxKey];
   65|      0|}
   66|       |
   67|       |- (id)predecessorEntry:(id)entry
   68|      0|{
   69|      0|    return [self.dictionary getPredecessorKey:entry];
   70|      0|}
   71|       |
   72|       |- (NSUInteger)count
   73|      0|{
   74|      0|    return [self.dictionary count];
   75|      0|}
   76|       |
   77|       |- (BOOL)isEmpty
   78|      0|{
   79|      0|    return [self.dictionary isEmpty];
   80|      0|}
   81|       |
   82|       |- (void)enumerateObjectsUsingBlock:(void (^)(id, BOOL *))block
   83|      0|{
   84|      0|    [self enumerateObjectsReverse:NO usingBlock:block];
   85|      0|}
   86|       |
   87|       |- (void)enumerateObjectsReverse:(BOOL)reverse usingBlock:(void (^)(id, BOOL *))block
   88|      0|{
   89|      0|    [self.dictionary enumerateKeysAndObjectsReverse:reverse usingBlock:^(id key, id value, BOOL *stop) {
   90|      0|        block(key, stop);
   91|      0|    }];
   92|      0|}
   93|       |
   94|       |- (NSEnumerator *)objectEnumerator
   95|      0|{
   96|      0|    return [self.dictionary keyEnumerator];
   97|      0|}
   98|       |
   99|       |- (NSString *)description
  100|      0|{
  101|      0|    NSMutableString *str = [[NSMutableString alloc] init];
  102|      0|    __block BOOL first = YES;
  103|      0|    [str appendString:@"FImmutableSortedSet ( "];
  104|      0|    [self enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
  105|      0|        if (!first) {
  106|      0|            [str appendString:@", "];
  107|      0|        }
  108|      0|        first = NO;
  109|      0|        [str appendString:[NSString stringWithFormat:@"%@", obj]];
  110|      0|    }];
  111|      0|    [str appendString:@" )"];
  112|      0|    return str;
  113|      0|}
  114|       |
  115|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FLLRBEmptyNode.m:
    1|       |#import "FLLRBEmptyNode.h"
    2|       |#import "FLLRBValueNode.h"
    3|       |
    4|       |@implementation FLLRBEmptyNode
    5|       |
    6|       |@synthesize key, value, color, left, right;
    7|       |
    8|      0|- (NSString *) description {
    9|      0|    return [NSString stringWithFormat:@"[key=%@ val=%@ color=%@]", key, value,
   10|      0|            (color != nil ? @"true" : @"false")];
   11|      0|}
   12|       |
   13|       |+ (id)emptyNode
   14|      0|{
   15|      0|    static dispatch_once_t pred = 0;
   16|      0|    __strong static id _sharedObject = nil;
   17|      0|    dispatch_once(&pred, ^{
   18|      0|        _sharedObject = [[self alloc] init]; // or some other init method
   19|      0|    });
   20|      0|    return _sharedObject;
   21|      0|}
   22|       |
   23|      0|- (id)copyWith:(id) aKey withValue:(id) aValue withColor:(FLLRBColor*) aColor withLeft:(id<FLLRBNode>)aLeft withRight:(id<FLLRBNode>)aRight {
   24|      0|    return self;
   25|      0|}
   26|       |
   27|      0|- (id<FLLRBNode>) insertKey:(id) aKey forValue:(id)aValue withComparator:(NSComparator)aComparator {
   28|      0|    FLLRBValueNode* result = [[FLLRBValueNode alloc] initWithKey:aKey withValue:aValue withColor:nil withLeft:nil withRight:nil];
   29|      0|    return result;
   30|      0|}
   31|       |
   32|      0|- (id<FLLRBNode>) remove:(id) key withComparator:(NSComparator)aComparator {
   33|      0|    return self;
   34|      0|}
   35|       |
   36|      0|- (int) count {
   37|      0|    return 0;
   38|      0|}
   39|       |
   40|      0|- (BOOL) isEmpty {
   41|      0|    return YES;
   42|      0|}
   43|       |
   44|      0|- (BOOL) inorderTraversal:(BOOL (^)(id key, id value))action {
   45|      0|    return NO;
   46|      0|}
   47|       |
   48|      0|- (BOOL) reverseTraversal:(BOOL (^)(id key, id value))action {
   49|      0|    return NO;
   50|      0|}
   51|       |
   52|      0|- (id<FLLRBNode>) min {
   53|      0|    return self;
   54|      0|}
   55|       |
   56|      0|- (id) minKey {
   57|      0|    return nil;
   58|      0|}
   59|       |
   60|      0|- (id) maxKey {
   61|      0|    return nil;
   62|      0|}
   63|       |
   64|      0|- (BOOL) isRed {
   65|      0|    return NO;
   66|      0|}
   67|       |
   68|      0|- (int) check {
   69|      0|    return 0;
   70|      0|}
   71|       |
   72|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FLLRBNode.h:
    1|       |#import <Foundation/Foundation.h>
    2|       |
    3|      0|#define RED @true
    4|      0|#define BLACK @false
    5|       |
    6|       |typedef NSNumber FLLRBColor;
    7|       |
    8|       |@protocol FLLRBNode <NSObject>
    9|       |
   10|       |- (id)copyWith:(id) aKey withValue:(id) aValue withColor:(FLLRBColor*) aColor withLeft:(id<FLLRBNode>)aLeft withRight:(id<FLLRBNode>)aRight;
   11|       |- (id<FLLRBNode>) insertKey:(id) aKey forValue:(id)aValue withComparator:(NSComparator)aComparator;
   12|       |- (id<FLLRBNode>) remove:(id) key withComparator:(NSComparator)aComparator;
   13|       |- (int) count;
   14|       |- (BOOL) isEmpty;
   15|       |- (BOOL) inorderTraversal:(BOOL (^)(id key, id value))action;
   16|       |- (BOOL) reverseTraversal:(BOOL (^)(id key, id value))action;
   17|       |- (id<FLLRBNode>) min;
   18|       |- (id) minKey;
   19|       |- (id) maxKey;
   20|       |- (BOOL) isRed;
   21|       |- (int) check;
   22|       |
   23|       |@property (nonatomic, strong) id key;
   24|       |@property (nonatomic, strong) id value;
   25|       |@property (nonatomic, strong) FLLRBColor* color;
   26|       |@property (nonatomic, strong) id<FLLRBNode> left;
   27|       |@property (nonatomic, strong) id<FLLRBNode> right;
   28|       |
   29|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FLLRBValueNode.m:
    1|       |#import "FLLRBValueNode.h"
    2|       |#import "FLLRBEmptyNode.h"
    3|       |
    4|       |@implementation FLLRBValueNode
    5|       |
    6|       |@synthesize key, value, color, left, right;
    7|       |
    8|      0|- (NSString *) description {
    9|      0|    return [NSString stringWithFormat:@"[key=%@ val=%@ color=%@]", key, value,
   10|      0|            (color != nil ? @"true" : @"false")];
   11|      0|}
   12|       |
   13|       |- (id)initWithKey:(__unsafe_unretained id) aKey withValue:(__unsafe_unretained id) aValue withColor:(__unsafe_unretained FLLRBColor*) aColor withLeft:(__unsafe_unretained id<FLLRBNode>)aLeft withRight:(__unsafe_unretained id<FLLRBNode>)aRight
   14|      0|{
   15|      0|    self = [super init];
   16|      0|    if (self) {
   17|      0|        self.key = aKey;
   18|      0|        self.value = aValue;
   19|      0|        self.color = aColor != nil ? aColor : RED;
   20|      0|        self.left = aLeft != nil ? aLeft : [FLLRBEmptyNode emptyNode];
   21|      0|        self.right = aRight != nil ? aRight : [FLLRBEmptyNode emptyNode];
   22|      0|    }
   23|      0|    return self;
   24|      0|}
   25|       |
   26|      0|- (id)copyWith:(__unsafe_unretained id) aKey withValue:(__unsafe_unretained id) aValue withColor:(__unsafe_unretained FLLRBColor*) aColor withLeft:(__unsafe_unretained id<FLLRBNode>)aLeft withRight:(__unsafe_unretained id<FLLRBNode>)aRight {
   27|      0|    return [[FLLRBValueNode alloc] initWithKey:(aKey != nil) ? aKey : self.key
   28|      0|                                     withValue:(aValue != nil) ? aValue : self.value
   29|      0|                                     withColor:(aColor != nil) ? aColor : self.color
   30|      0|                                      withLeft:(aLeft != nil) ? aLeft : self.left
   31|      0|                                     withRight:(aRight != nil) ? aRight : self.right];
   32|      0|}
   33|       |
   34|      0|- (int) count {
   35|      0|    return [self.left count] + 1 + [self.right count];
   36|      0|}
   37|       |
   38|      0|- (BOOL) isEmpty {
   39|      0|    return NO;
   40|      0|}
   41|       |
   42|       |/**
   43|       |* Early terminates if aciton returns YES.
   44|       |* @return The first truthy value returned by action, or the last falsey value returned by action.
   45|       |*/
   46|      0|- (BOOL) inorderTraversal:(BOOL (^)(id key, id value))action {
   47|      0|    return [self.left inorderTraversal:action] ||
   48|      0|        action(self.key, self.value) ||
   49|      0|    [self.right inorderTraversal:action];
   50|      0|}
   51|       |
   52|      0|- (BOOL) reverseTraversal:(BOOL (^)(id key, id value))action {
   53|      0| return [self.right reverseTraversal:action] ||
   54|      0|        action(self.key, self.value) ||
   55|      0|    [self.left reverseTraversal:action];
   56|      0|}
   57|       |
   58|      0|- (id<FLLRBNode>) min {
   59|      0|    if([self.left isEmpty]) {
   60|      0|        return self;
   61|      0|    }
   62|      0|    else {
   63|      0|        return [self.left min];
   64|      0|    }
   65|      0|}
   66|       |
   67|      0|- (id) minKey {
   68|      0|    return [[self min] key];
   69|      0|}
   70|       |
   71|      0|- (id) maxKey {
   72|      0|    if([self.right isEmpty]) {
   73|      0|        return self.key;
   74|      0|    }
   75|      0|    else {
   76|      0|        return [self.right maxKey];
   77|      0|    }
   78|      0|}
   79|       |
   80|      0|- (id<FLLRBNode>) insertKey:(__unsafe_unretained id) aKey forValue:(__unsafe_unretained id)aValue withComparator:(NSComparator)aComparator {
   81|      0|    NSComparisonResult cmp = aComparator(aKey, self.key);
   82|      0|    FLLRBValueNode* n = self;
   83|      0|
   84|      0|    if(cmp == NSOrderedAscending) {
   85|      0|        n = [n copyWith:nil withValue:nil withColor:nil withLeft:[n.left insertKey:aKey forValue:aValue withComparator:aComparator] withRight:nil];
   86|      0|    }
   87|      0|    else if(cmp == NSOrderedSame) {
   88|      0|        n = [n copyWith:nil withValue:aValue withColor:nil withLeft:nil withRight:nil];
   89|      0|    }
   90|      0|    else {
   91|      0|        n = [n copyWith:nil withValue:nil withColor:nil withLeft:nil withRight:[n.right insertKey:aKey forValue:aValue withComparator:aComparator]];
   92|      0|    }
   93|      0|
   94|      0|    return [n fixUp];
   95|      0|}
   96|       |
   97|      0|- (id<FLLRBNode>) removeMin {
   98|      0|
   99|      0|    if([self.left isEmpty]) {
  100|      0|        return [FLLRBEmptyNode emptyNode];
  101|      0|    }
  102|      0|
  103|      0|    FLLRBValueNode* n = self;
  104|      0|    if(! [n.left isRed] && ! [n.left.left isRed]) {
  105|      0|        n = [n moveRedLeft];
  106|      0|    }
  107|      0|
  108|      0|    n = [n copyWith:nil withValue:nil withColor:nil withLeft:[(FLLRBValueNode*)n.left removeMin] withRight:nil];
  109|      0|    return [n fixUp];
  110|      0|}
  111|       |
  112|       |
  113|      0|- (id<FLLRBNode>) fixUp {
  114|      0|    FLLRBValueNode* n = self;
  115|      0|    if([n.right isRed] && ! [n.left isRed]) n = [n rotateLeft];
  116|      0|    if([n.left isRed] && [n.left.left isRed]) n = [n rotateRight];
  117|      0|    if([n.left isRed] && [n.right isRed]) n = [n colorFlip];
  118|      0|    return n;
  119|      0|}
  120|       |
  121|      0|- (FLLRBValueNode*) moveRedLeft {
  122|      0|    FLLRBValueNode* n = [self colorFlip];
  123|      0|    if([n.right.left isRed]) {
  124|      0|        n = [n copyWith:nil withValue:nil withColor:nil withLeft:nil withRight:[(FLLRBValueNode*)n.right rotateRight]];
  125|      0|        n = [n rotateLeft];
  126|      0|        n = [n colorFlip];
  127|      0|    }
  128|      0|    return n;
  129|      0|}
  130|       |
  131|      0|- (FLLRBValueNode*) moveRedRight {
  132|      0|    FLLRBValueNode* n = [self colorFlip];
  133|      0|    if([n.left.left isRed]) {
  134|      0|        n = [n rotateRight];
  135|      0|        n = [n colorFlip];
  136|      0|    }
  137|      0|    return n;
  138|      0|}
  139|       |
  140|      0|- (id<FLLRBNode>) rotateLeft {
  141|      0|    id<FLLRBNode> nl = [self copyWith:nil withValue:nil withColor:RED withLeft:nil withRight:self.right.left];
  142|      0|    return [self.right copyWith:nil withValue:nil withColor:self.color withLeft:nl withRight:nil];;
  143|      0|}
  144|       |
  145|      0|- (id<FLLRBNode>) rotateRight {
  146|      0|    id<FLLRBNode> nr = [self copyWith:nil withValue:nil withColor:RED withLeft:self.left.right withRight:nil];
  147|      0|    return [self.left copyWith:nil withValue:nil withColor:self.color withLeft:nil withRight:nr];
  148|      0|}
  149|       |
  150|      0|- (id<FLLRBNode>) colorFlip {
  151|      0|    id<FLLRBNode> nleft = [self.left copyWith:nil withValue:nil withColor:[NSNumber numberWithBool:![self.left.color boolValue]] withLeft:nil withRight:nil];
  152|      0|    id<FLLRBNode> nright = [self.right copyWith:nil withValue:nil withColor:[NSNumber numberWithBool:![self.right.color boolValue]] withLeft:nil withRight:nil];
  153|      0|
  154|      0|    return [self copyWith:nil withValue:nil withColor:[NSNumber numberWithBool:![self.color boolValue]] withLeft:nleft withRight:nright];
  155|      0|}
  156|       |
  157|      0|- (id<FLLRBNode>) remove:(__unsafe_unretained id) aKey withComparator:(NSComparator)comparator {
  158|      0|    id<FLLRBNode> smallest;
  159|      0|    FLLRBValueNode* n = self;
  160|      0|
  161|      0|    if(comparator(aKey, n.key) == NSOrderedAscending) {
  162|      0|        if(![n.left isEmpty] && ![n.left isRed] && ![n.left.left isRed]) {
  163|      0|            n = [n moveRedLeft];
  164|      0|        }
  165|      0|        n = [n copyWith:nil withValue:nil withColor:nil withLeft:[n.left remove:aKey withComparator:comparator] withRight:nil];
  166|      0|    }
  167|      0|    else {
  168|      0|        if([n.left isRed]) {
  169|      0|            n = [n rotateRight];
  170|      0|        }
  171|      0|
  172|      0|        if(![n.right isEmpty] && ![n.right isRed] && ![n.right.left isRed]) {
  173|      0|            n = [n moveRedRight];
  174|      0|        }
  175|      0|
  176|      0|        if(comparator(aKey, n.key) == NSOrderedSame) {
  177|      0|            if([n.right isEmpty]) {
  178|      0|                return [FLLRBEmptyNode emptyNode];
  179|      0|            }
  180|      0|            else {
  181|      0|                smallest = [n.right min];
  182|      0|                n = [n copyWith:smallest.key withValue:smallest.value withColor:nil withLeft:nil withRight:[(FLLRBValueNode*)n.right removeMin]];
  183|      0|            }
  184|      0|        }
  185|      0|        n = [n copyWith:nil withValue:nil withColor:nil withLeft:nil withRight:[n.right remove:aKey withComparator:comparator]];
  186|      0|    }
  187|      0|    return [n fixUp];
  188|      0|}
  189|       |
  190|      0|- (BOOL) isRed {
  191|      0|    return [self.color boolValue];
  192|      0|}
  193|       |
  194|      0|- (BOOL) checkMaxDepth {
  195|      0|    int blackDepth = [self check];
  196|      0|    if(pow(2.0, blackDepth) <= ([self count] + 1)) {
  197|      0|        return YES;
  198|      0|    }
  199|      0|    else {
  200|      0|        return NO;
  201|      0|    }
  202|      0|}
  203|       |
  204|      0|- (int) check {
  205|      0|    int blackDepth = 0;
  206|      0|
  207|      0|    if([self isRed] && [self.left isRed]) {
  208|      0|        @throw [[NSException alloc] initWithName:@"check" reason:@"Red node has a red child" userInfo:nil];
  209|      0|    }
  210|      0|
  211|      0|    if([self.right isRed]) {
  212|      0|        @throw [[NSException alloc] initWithName:@"check" reason:@"Right child is red" userInfo:nil];
  213|      0|    }
  214|      0|
  215|      0|    blackDepth = [self.left check];
  216|      0|//    NSLog(err);
  217|      0|    if(blackDepth != [self.right check]) {
  218|      0|        NSString* err = [NSString stringWithFormat:@"(%@ -> %@)blackDepth: %d ; self.right check: %d", self.value, [self.color boolValue] ? @"red" : @"black", blackDepth, [self.right check]];
  219|      0|//        return 10;
  220|      0|        @throw [[NSException alloc] initWithName:@"check" reason:err userInfo:nil];
  221|      0|    }
  222|      0|    else {
  223|      0|                int ret = blackDepth + ([self isRed] ? 0 : 1);
  224|      0|//        NSLog(@"black depth is: %d; other is: %d, ret is: %d", blackDepth, ([self isRed] ? 0 : 1), ret);
  225|      0|        return ret;
  226|      0|    }
  227|      0|}
  228|       |
  229|       |
  230|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FTreeSortedDictionary.m:
    1|       |#import "FTreeSortedDictionary.h"
    2|       |#import "FLLRBEmptyNode.h"
    3|       |#import "FLLRBValueNode.h"
    4|       |#import "FTreeSortedDictionaryEnumerator.h"
    5|       |
    6|       |typedef void (^fbt_void_nsnumber_int)(NSNumber* color, NSUInteger chunkSize);
    7|       |
    8|       |@interface FTreeSortedDictionary ()
    9|       |
   10|       |@property (nonatomic, strong) id<FLLRBNode> root;
   11|       |@property (nonatomic, copy, readwrite) NSComparator comparator;
   12|       |
   13|       |@end
   14|       |
   15|       |@implementation FTreeSortedDictionary
   16|       |
   17|      0|- (id)initWithComparator:(NSComparator)aComparator {
   18|      0|    self = [super init];
   19|      0|    if (self) {
   20|      0|        self.root = [FLLRBEmptyNode emptyNode];
   21|      0|        self.comparator = aComparator;
   22|      0|    }
   23|      0|    return self;
   24|      0|}
   25|       |
   26|      0|- (id)initWithComparator:(NSComparator)aComparator withRoot:(__unsafe_unretained id<FLLRBNode>)aRoot {
   27|      0|    self = [super init];
   28|      0|    if (self) {
   29|      0|        self.root = aRoot;
   30|      0|        self.comparator = aComparator;
   31|      0|    }
   32|      0|    return self;
   33|      0|}
   34|       |
   35|       |/**
   36|       | * Returns a copy of the map, with the specified key/value added or replaced.
   37|       | */
   38|      0|- (FTreeSortedDictionary *) insertKey:(__unsafe_unretained id)aKey withValue:(__unsafe_unretained id)aValue {
   39|      0|    return [[FTreeSortedDictionary alloc] initWithComparator:self.comparator
   40|      0|                                                    withRoot:[[self.root insertKey:aKey forValue:aValue withComparator:self.comparator]
   41|      0|                                                              copyWith:nil
   42|      0|                                                              withValue:nil
   43|      0|                                                              withColor:BLACK
   44|      0|                                                              withLeft:nil
   45|      0|                                                              withRight:nil]];
   46|      0|}
   47|       |
   48|       |
   49|      0|- (FTreeSortedDictionary *) removeKey:(__unsafe_unretained id)aKey {
   50|      0|    // Remove is somewhat expensive even if the key doesn't exist (the tree does rebalancing and stuff).  So avoid it.
   51|      0|    if (![self contains:aKey]) {
   52|      0|        return self;
   53|      0|    } else {
   54|      0|        return [[FTreeSortedDictionary alloc]
   55|      0|                initWithComparator:self.comparator
   56|      0|                withRoot:[[self.root remove:aKey withComparator:self.comparator]
   57|      0|                          copyWith:nil
   58|      0|                          withValue:nil
   59|      0|                          withColor:BLACK
   60|      0|                          withLeft:nil
   61|      0|                          withRight:nil]];
   62|      0|    }
   63|      0|}
   64|       |
   65|      0|- (id) get:(__unsafe_unretained id) key {
   66|      0|    if (key == nil) {
   67|      0|        return nil;
   68|      0|    }
   69|      0|    NSComparisonResult cmp;
   70|      0|    id<FLLRBNode> node = self.root;
   71|      0|    while(![node isEmpty]) {
   72|      0|        cmp = self.comparator(key, node.key);
   73|      0|        if(cmp == NSOrderedSame) {
   74|      0|            return node.value;
   75|      0|        }
   76|      0|        else if (cmp == NSOrderedAscending) {
   77|      0|            node = node.left;
   78|      0|        }
   79|      0|        else {
   80|      0|            node = node.right;
   81|      0|        }
   82|      0|    }
   83|      0|    return nil;
   84|      0|}
   85|       |
   86|      0|- (id) getPredecessorKey:(__unsafe_unretained id) key {
   87|      0|    NSComparisonResult cmp;
   88|      0|    id<FLLRBNode> node = self.root;
   89|      0|    id<FLLRBNode> rightParent = nil;
   90|      0|    while(![node isEmpty]) {
   91|      0|        cmp = self.comparator(key, node.key);
   92|      0|        if(cmp == NSOrderedSame) {
   93|      0|            if(![node.left isEmpty]) {
   94|      0|                node = node.left;
   95|      0|                while(! [node.right isEmpty]) {
   96|      0|                    node = node.right;
   97|      0|                }
   98|      0|                return node.key;
   99|      0|            }
  100|      0|            else if (rightParent != nil) {
  101|      0|                return rightParent.key;
  102|      0|            }
  103|      0|            else {
  104|      0|                return nil;
  105|      0|            }
  106|      0|        }
  107|      0|        else if (cmp == NSOrderedAscending) {
  108|      0|            node = node.left;
  109|      0|        }
  110|      0|        else if (cmp == NSOrderedDescending) {
  111|      0|            rightParent = node;
  112|      0|            node = node.right;
  113|      0|        }
  114|      0|    }
  115|      0|    @throw [NSException exceptionWithName:@"NonexistentKey" reason:@"getPredecessorKey called with nonexistent key." userInfo:@{@"key": [key description] }];
  116|      0|}
  117|       |
  118|      0|- (BOOL) isEmpty {
  119|      0|    return [self.root isEmpty];
  120|      0|}
  121|       |
  122|      0|- (int) count {
  123|      0|    return [self.root count];
  124|      0|}
  125|       |
  126|      0|- (id) minKey {
  127|      0|    return [self.root minKey];
  128|      0|}
  129|       |
  130|      0|- (id) maxKey {
  131|      0|    return [self.root maxKey];
  132|      0|}
  133|       |
  134|       |- (void) enumerateKeysAndObjectsUsingBlock:(void (^)(id, id, BOOL *))block
  135|      0|{
  136|      0|    [self enumerateKeysAndObjectsReverse:NO usingBlock:block];
  137|      0|}
  138|       |
  139|       |- (void) enumerateKeysAndObjectsReverse:(BOOL)reverse usingBlock:(void (^)(id, id, BOOL *))block
  140|      0|{
  141|      0|    if (reverse) {
  142|      0|        __block BOOL stop = NO;
  143|      0|        [self.root reverseTraversal:^BOOL(id key, id value) {
  144|      0|            block(key, value, &stop);
  145|      0|            return stop;
  146|      0|        }];
  147|      0|    } else {
  148|      0|        __block BOOL stop = NO;
  149|      0|        [self.root inorderTraversal:^BOOL(id key, id value) {
  150|      0|            block(key, value, &stop);
  151|      0|            return stop;
  152|      0|        }];
  153|      0|    }
  154|      0|}
  155|       |
  156|      0|- (BOOL) contains:(__unsafe_unretained id)key {
  157|      0|    return ([self objectForKey:key] != nil);
  158|      0|}
  159|       |
  160|      0|- (NSEnumerator *) keyEnumerator {
  161|      0|    return [[FTreeSortedDictionaryEnumerator alloc]
  162|      0|            initWithImmutableSortedDictionary:self startKey:nil isReverse:NO];
  163|      0|}
  164|       |
  165|      0|- (NSEnumerator *) keyEnumeratorFrom:(id)startKey {
  166|      0|    return [[FTreeSortedDictionaryEnumerator alloc]
  167|      0|            initWithImmutableSortedDictionary:self startKey:startKey isReverse:NO];
  168|      0|}
  169|       |
  170|      0|- (NSEnumerator *) reverseKeyEnumerator {
  171|      0|    return [[FTreeSortedDictionaryEnumerator alloc]
  172|      0|            initWithImmutableSortedDictionary:self startKey:nil isReverse:YES];
  173|      0|}
  174|       |
  175|      0|- (NSEnumerator *) reverseKeyEnumeratorFrom:(id)startKey {
  176|      0|    return [[FTreeSortedDictionaryEnumerator alloc]
  177|      0|            initWithImmutableSortedDictionary:self startKey:startKey isReverse:YES];
  178|      0|}
  179|       |
  180|       |
  181|       |#pragma mark -
  182|       |#pragma mark Tree Builder
  183|       |
  184|       |// Code to efficiently build a RB Tree
  185|       |typedef struct _base1_2list {
  186|       |    unsigned int bits;
  187|       |    unsigned short count;
  188|       |    unsigned short current;
  189|       |} Base1_2List;
  190|       |
  191|       |Base1_2List *base1_2List_new(unsigned int length);
  192|       |void base1_2List_free(Base1_2List* list);
  193|       |unsigned int log_base2(unsigned int num);
  194|       |BOOL base1_2List_next(Base1_2List* list);
  195|       |
  196|      0|unsigned int log_base2(unsigned int num) {
  197|      0|    return (unsigned int)(log(num) / log(2));
  198|      0|}
  199|       |
  200|       |/**
  201|       | * Works like an iterator, so it moves to the next bit. Do not call more than list->count times.
  202|       | * @return whether or not the next bit is a 1 in base {1,2}.
  203|       | */
  204|      0|BOOL base1_2List_next(Base1_2List* list) {
  205|      0|    BOOL result = !(list->bits & (0x1 << list->current));
  206|      0|    list->current--;
  207|      0|    return result;
  208|      0|}
  209|       |
  210|      0|static inline unsigned bit_mask(int x) {
  211|      0|    return (x >= sizeof(unsigned) * CHAR_BIT) ? (unsigned) -1 : (1U << x) - 1;
  212|      0|}
  213|       |
  214|       |/**
  215|       | * We represent the base{1,2} number as the combination of a binary number and a number of bits that we care about
  216|       | * We iterate backwards, from most significant bit to least, to build up the llrb nodes. 0 base 2 => 1 base {1,2}, 1 base 2 => 2 base {1,2}
  217|       | */
  218|      0|Base1_2List *base1_2List_new(unsigned int length) {
  219|      0|    size_t sz = sizeof(Base1_2List);
  220|      0|    Base1_2List* list = calloc(1, sz);
  221|      0|    // Calculate the number of bits that we care about
  222|      0|    list->count = (unsigned short)log_base2(length + 1);
  223|      0|    unsigned int mask = bit_mask(list->count);
  224|      0|    list->bits = (length + 1) & mask;
  225|      0|    list->current = list->count - 1;
  226|      0|    return list;
  227|      0|}
  228|       |
  229|       |
  230|      0|void base1_2List_free(Base1_2List* list) {
  231|      0|    free(list);
  232|      0|}
  233|       |
  234|      0|+ (id<FLLRBNode>) buildBalancedTree:(NSArray *)keys dictionary:(NSDictionary *)dictionary subArrayStartIndex:(NSUInteger)startIndex length:(NSUInteger)length {
  235|      0|    length = MIN(keys.count - startIndex, length); // Bound length by the actual length of the array
  236|      0|    if (length == 0) {
  237|      0|        return nil;
  238|      0|    } else if (length == 1) {
  239|      0|        id key = keys[startIndex];
  240|      0|        return [[FLLRBValueNode alloc] initWithKey:key withValue:dictionary[key] withColor:BLACK withLeft:nil withRight:nil];
  241|      0|    } else {
  242|      0|        NSUInteger middle = length / 2;
  243|      0|        id<FLLRBNode> left = [FTreeSortedDictionary buildBalancedTree:keys dictionary:dictionary subArrayStartIndex:startIndex length:middle];
  244|      0|        id<FLLRBNode> right = [FTreeSortedDictionary buildBalancedTree:keys dictionary:dictionary subArrayStartIndex:(startIndex+middle+1) length:middle];
  245|      0|        id key = keys[startIndex + middle];
  246|      0|        return [[FLLRBValueNode alloc] initWithKey:key withValue:dictionary[key] withColor:BLACK withLeft:left withRight:right];
  247|      0|    }
  248|      0|}
  249|       |
  250|      0|+ (id<FLLRBNode>) rootFrom12List:(Base1_2List *)base1_2List keyList:(NSArray *)keyList dictionary:(NSDictionary *)dictionary {
  251|      0|    __block id<FLLRBNode> root = nil;
  252|      0|    __block id<FLLRBNode> node = nil;
  253|      0|    __block NSUInteger index = keyList.count;
  254|      0|
  255|      0|    fbt_void_nsnumber_int buildPennant = ^(NSNumber* color, NSUInteger chunkSize) {
  256|      0|        NSUInteger startIndex = index - chunkSize + 1;
  257|      0|        index -= chunkSize;
  258|      0|        id key = keyList[index];
  259|      0|        id<FLLRBNode> childTree = [self buildBalancedTree:keyList dictionary:dictionary subArrayStartIndex:startIndex length:(chunkSize - 1)];
  260|      0|        id<FLLRBNode> pennant = [[FLLRBValueNode alloc] initWithKey:key withValue:dictionary[key] withColor:color withLeft:nil withRight:childTree];
  261|      0|        //attachPennant(pennant);
  262|      0|        if (node) {
  263|      0|            node.left = pennant;
  264|      0|            node = pennant;
  265|      0|        } else {
  266|      0|            root = pennant;
  267|      0|            node = pennant;
  268|      0|        }
  269|      0|    };
  270|      0|
  271|      0|    for (int i = 0; i < base1_2List->count; ++i) {
  272|      0|        BOOL isOne = base1_2List_next(base1_2List);
  273|      0|        NSUInteger chunkSize = (NSUInteger)pow(2.0, base1_2List->count - (i + 1));
  274|      0|        if (isOne) {
  275|      0|            buildPennant(BLACK, chunkSize);
  276|      0|        } else {
  277|      0|            buildPennant(BLACK, chunkSize);
  278|      0|            buildPennant(RED, chunkSize);
  279|      0|        }
  280|      0|    }
  281|      0|    return root;
  282|      0|}
  283|       |
  284|       |/**
  285|       | * Uses the algorithm linked here:
  286|       | * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
  287|       | */
  288|       |
  289|       |+ (FImmutableSortedDictionary *)fromDictionary:(NSDictionary *)dictionary withComparator:(NSComparator)comparator
  290|      0|{
  291|      0|    // Steps:
  292|      0|    // 0. Sort the array
  293|      0|    // 1. Calculate the 1-2 number
  294|      0|    // 2. Build From 1-2 number
  295|      0|    //   0. for each digit in 1-2 number
  296|      0|    //     0. calculate chunk size
  297|      0|    //     1. build 1 or 2 pennants of that size
  298|      0|    //     2. attach pennants and update node pointer
  299|      0|    //   1. return root
  300|      0|    NSMutableArray *sortedKeyList = [NSMutableArray arrayWithCapacity:dictionary.count];
  301|      0|    [dictionary enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  302|      0|        [sortedKeyList addObject:key];
  303|      0|    }];
  304|      0|    [sortedKeyList sortUsingComparator:comparator];
  305|      0|
  306|      0|    [sortedKeyList enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
  307|      0|        if (idx > 0) {
  308|      0|            if (comparator(sortedKeyList[idx - 1], obj) != NSOrderedAscending) {
  309|      0|                [NSException raise:NSInvalidArgumentException format:@"Can't create FImmutableSortedDictionary with keys with same ordering!"];
  310|      0|            }
  311|      0|        }
  312|      0|    }];
  313|      0|
  314|      0|    Base1_2List* list = base1_2List_new((unsigned int)sortedKeyList.count);
  315|      0|    id<FLLRBNode> root = [self rootFrom12List:list keyList:sortedKeyList dictionary:dictionary];
  316|      0|    base1_2List_free(list);
  317|      0|
  318|      0|    if (root != nil) {
  319|      0|        return [[FTreeSortedDictionary alloc] initWithComparator:comparator withRoot:root];
  320|      0|    } else {
  321|      0|        return [[FTreeSortedDictionary alloc] initWithComparator:comparator];
  322|      0|    }
  323|      0|}
  324|       |
  325|       |@end
  326|       |

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/FImmutableSortedDictionary/FImmutableSortedDictionary/FTreeSortedDictionaryEnumerator.m:
    1|       |#import "FTreeSortedDictionaryEnumerator.h"
    2|       |
    3|       |@interface FTreeSortedDictionaryEnumerator()
    4|       |@property (nonatomic, strong) FTreeSortedDictionary* immutableSortedDictionary;
    5|       |@property (nonatomic, strong) NSMutableArray* stack;
    6|       |@property (nonatomic) BOOL isReverse;
    7|       |
    8|       |@end
    9|       |
   10|       |@implementation FTreeSortedDictionaryEnumerator
   11|       |
   12|       |- (id)initWithImmutableSortedDictionary:(FTreeSortedDictionary *)aDict
   13|      0|                               startKey:(id)startKey isReverse:(BOOL)reverse {
   14|      0|    self = [super init];
   15|      0|    if (self) {
   16|      0|        self.immutableSortedDictionary = aDict;
   17|      0|        self.stack = [[NSMutableArray alloc] init];
   18|      0|        self.isReverse = reverse;
   19|      0|
   20|      0|        NSComparator comparator = aDict.comparator;
   21|      0|        id<FLLRBNode> node = self.immutableSortedDictionary.root;
   22|      0|
   23|      0|        NSInteger cmp;
   24|      0|        while(![node isEmpty]) {
   25|      0|            cmp = startKey ? comparator(node.key, startKey) : 1;
   26|      0|            // flip the comparison if we're going in reverse
   27|      0|            if (self.isReverse) cmp *= -1;
   28|      0|
   29|      0|            if (cmp < 0) {
   30|      0|                // This node is less than our start key. Ignore it.
   31|      0|                if (self.isReverse) {
   32|      0|                    node = node.left;
   33|      0|                } else {
   34|      0|                    node = node.right;
   35|      0|                }
   36|      0|            } else if (cmp == 0) {
   37|      0|                // This node is exactly equal to our start key. Push it on the stack, but stop iterating:
   38|      0|                [self.stack addObject:node];
   39|      0|                break;
   40|      0|            } else {
   41|      0|                // This node is greater than our start key, add it to the stack and move on to the next one.
   42|      0|                [self.stack addObject:node];
   43|      0|                if (self.isReverse) {
   44|      0|                    node = node.right;
   45|      0|                } else {
   46|      0|                    node = node.left;
   47|      0|                }
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|      0|    return self;
   52|      0|}
   53|       |
   54|      0|- (id)nextObject {
   55|      0|    if([self.stack count] == 0) {
   56|      0|        return nil;
   57|      0|    }
   58|      0|
   59|      0|    id<FLLRBNode> node = nil;
   60|      0|    @synchronized(self.stack) {
   61|      0|        node = [self.stack lastObject];
   62|      0|        [self.stack removeLastObject];
   63|      0|    }
   64|      0|    id result = node.key;
   65|      0|
   66|      0|    if (self.isReverse) {
   67|      0|        node = node.left;
   68|      0|        while (![node isEmpty]) {
   69|      0|            [self.stack addObject:node];
   70|      0|            node = node.right;
   71|      0|        }
   72|      0|    } else {
   73|      0|        node = node.right;
   74|      0|        while (![node isEmpty]) {
   75|      0|            [self.stack addObject:node];
   76|      0|            node = node.left;
   77|      0|        }
   78|      0|    }
   79|      0|
   80|      0|    return result;
   81|      0|}
   82|       |
   83|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/SocketRocket/FSRWebSocket.m:
    1|       |//
    2|       |//   Copyright 2012 Square Inc.
    3|       |//
    4|       |//   Licensed under the Apache License, Version 2.0 (the "License");
    5|       |//   you may not use this file except in compliance with the License.
    6|       |//   You may obtain a copy of the License at
    7|       |//
    8|       |//       http://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |//   Unless required by applicable law or agreed to in writing, software
   11|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   12|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |//   See the License for the specific language governing permissions and
   14|       |//   limitations under the License.
   15|       |//
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import "FSRWebSocket.h"
   20|       |
   21|       |#if __has_include(<unicode/utf8.h>)
   22|       |#define HAS_ICU
   23|       |#endif
   24|       |
   25|       |#import <sys/socket.h>
   26|       |
   27|       |#ifdef HAS_ICU
   28|       |#import <unicode/utf8.h>
   29|       |#endif
   30|       |
   31|       |#if __has_include(<Endian.h>)
   32|       |#import <Endian.h>
   33|       |#else
   34|       |#import <CoreServices/CoreServices.h>
   35|       |#endif
   36|       |
   37|       |#import <CommonCrypto/CommonDigest.h>
   38|       |#import <Security/SecRandom.h>
   39|       |#import "fbase64.h"
   40|       |#import "NSData+SRB64Additions.h"
   41|       |
   42|       |#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
   43|       |#define sr_dispatch_retain(x)
   44|       |#define sr_dispatch_release(x)
   45|      0|#define maybe_bridge(x) ((__bridge void *) x)
   46|       |#else
   47|       |#define sr_dispatch_retain(x) dispatch_retain(x)
   48|       |#define sr_dispatch_release(x) dispatch_release(x)
   49|       |#define maybe_bridge(x) (x)
   50|       |#endif
   51|       |
   52|       |typedef enum  {
   53|       |    SROpCodeTextFrame = 0x1,
   54|       |    SROpCodeBinaryFrame = 0x2,
   55|       |    //3-7Reserved
   56|       |    SROpCodeConnectionClose = 0x8,
   57|       |    SROpCodePing = 0x9,
   58|       |    SROpCodePong = 0xA,
   59|       |    //B-F reserved
   60|       |} FSROpCode;
   61|       |
   62|       |typedef enum {
   63|       |    SRStatusCodeNormal = 1000,
   64|       |    SRStatusCodeGoingAway = 1001,
   65|       |    SRStatusCodeProtocolError = 1002,
   66|       |    SRStatusCodeUnhandledType = 1003,
   67|       |    // 1004 reserved
   68|       |    SRStatusNoStatusReceived = 1005,
   69|       |    // 1004-1006 reserved
   70|       |    SRStatusCodeInvalidUTF8 = 1007,
   71|       |    SRStatusCodePolicyViolated = 1008,
   72|       |    SRStatusCodeMessageTooBig = 1009,
   73|       |} FSRStatusCode;
   74|       |
   75|       |typedef struct {
   76|       |    BOOL fin;
   77|       |//  BOOL rsv1;
   78|       |//  BOOL rsv2;
   79|       |//  BOOL rsv3;
   80|       |    uint8_t opcode;
   81|       |    BOOL masked;
   82|       |    uint64_t payload_length;
   83|       |} frame_header;
   84|       |
   85|       |static NSString *const SRWebSocketAppendToSecKeyString = @"258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
   86|       |
   87|       |static inline int32_t validate_dispatch_data_partial_string(NSData *data);
   88|       |static inline void SRFastLog(NSString *format, ...);
   89|       |
   90|       |@interface NSData (FSRWebSocket)
   91|       |
   92|       |- (NSString *)stringBySHA1ThenBase64Encoding;
   93|       |
   94|       |@end
   95|       |
   96|       |
   97|       |@interface NSString (FSRWebSocket)
   98|       |
   99|       |- (NSString *)stringBySHA1ThenBase64Encoding;
  100|       |
  101|       |@end
  102|       |
  103|       |
  104|       |@interface NSURL (FSRWebSocket)
  105|       |
  106|       |// The origin isn't really applicable for a native application
  107|       |// So instead, just map ws -> http and wss -> https
  108|       |- (NSString *)SR_origin;
  109|       |
  110|       |@end
  111|       |
  112|       |@interface _FSRRunLoopThread : NSThread
  113|       |
  114|       |@property (nonatomic, readonly) NSRunLoop *runLoop;
  115|       |
  116|       |@end
  117|       |
  118|      0|static NSString *newSHA1String(const char *bytes, size_t length) {
  119|      0|    uint8_t md[CC_SHA1_DIGEST_LENGTH];
  120|      0|
  121|      0|    CC_SHA1(bytes, (int)length, md);
  122|      0|
  123|      0|    size_t buffer_size = ((sizeof(md) * 3 + 2) / 2);
  124|      0|
  125|      0|    char *buffer =  (char *)malloc(buffer_size);
  126|      0|
  127|      0|    int len = f_b64_ntop(md, CC_SHA1_DIGEST_LENGTH, buffer, buffer_size);
  128|      0|    if (len == -1) {
  129|      0|        free(buffer);
  130|      0|        return nil;
  131|      0|    } else{
  132|      0|        return [[NSString alloc] initWithBytesNoCopy:buffer length:len encoding:NSASCIIStringEncoding freeWhenDone:YES];
  133|      0|    }
  134|      0|}
  135|       |
  136|       |@implementation NSData (FSRWebSocket)
  137|       |
  138|       |- (NSString *)stringBySHA1ThenBase64Encoding;
  139|      0|{
  140|      0|    return newSHA1String(self.bytes, self.length);
  141|      0|}
  142|       |
  143|       |@end
  144|       |
  145|       |
  146|       |@implementation NSString (FSRWebSocket)
  147|       |
  148|       |- (NSString *)stringBySHA1ThenBase64Encoding;
  149|      0|{
  150|      0|    return newSHA1String(self.UTF8String, self.length);
  151|      0|}
  152|       |
  153|       |@end
  154|       |
  155|       |NSString *const FSRWebSocketErrorDomain = @"FSRWebSocketErrorDomain";
  156|       |
  157|       |// Returns number of bytes consumed. returning 0 means you didn't match.
  158|       |// Sends bytes to callback handler;
  159|       |typedef size_t (^stream_scanner)(NSData *collected_data);
  160|       |
  161|       |typedef void (^data_callback)(FSRWebSocket *webSocket,  NSData *data);
  162|       |
  163|       |@interface FSRIOConsumer : NSObject {
  164|       |    stream_scanner _scanner;
  165|       |    data_callback _handler;
  166|       |    size_t _bytesNeeded;
  167|       |    BOOL _readToCurrentFrame;
  168|       |    BOOL _unmaskBytes;
  169|       |}
  170|       |@property (nonatomic, copy, readonly) stream_scanner consumer;
  171|       |@property (nonatomic, copy, readonly) data_callback handler;
  172|       |@property (nonatomic, assign) size_t bytesNeeded;
  173|       |@property (nonatomic, assign, readonly) BOOL readToCurrentFrame;
  174|       |@property (nonatomic, assign, readonly) BOOL unmaskBytes;
  175|       |
  176|       |@end
  177|       |
  178|       |// This class is not thread-safe, and is expected to always be run on the same queue.
  179|       |@interface FSRIOConsumerPool : NSObject
  180|       |
  181|       |- (id)initWithBufferCapacity:(NSUInteger)poolSize;
  182|       |
  183|       |- (FSRIOConsumer *)consumerWithScanner:(stream_scanner)scanner handler:(data_callback)handler bytesNeeded:(size_t)bytesNeeded readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes;
  184|       |- (void)returnConsumer:(FSRIOConsumer *)consumer;
  185|       |
  186|       |@end
  187|       |
  188|       |@interface FSRWebSocket ()  <NSStreamDelegate>
  189|       |
  190|       |- (void)_writeData:(NSData *)data;
  191|       |- (void)_closeWithProtocolError:(NSString *)message;
  192|       |- (void)_failWithError:(NSError *)error;
  193|       |
  194|       |- (void)_disconnect;
  195|       |
  196|       |- (void)_readFrameNew;
  197|       |- (void)_readFrameContinue;
  198|       |
  199|       |- (void)_pumpScanner;
  200|       |
  201|       |- (void)_pumpWriting;
  202|       |
  203|       |- (void)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback;
  204|       |- (void)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes;
  205|       |- (void)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback dataLength:(size_t)dataLength;
  206|       |- (void)_readUntilBytes:(const void *)bytes length:(size_t)length callback:(data_callback)dataHandler;
  207|       |- (void)_readUntilHeaderCompleteWithCallback:(data_callback)dataHandler;
  208|       |
  209|       |- (void)_sendFrameWithOpcode:(FSROpCode)opcode data:(id)data;
  210|       |
  211|       |- (BOOL)_checkHandshake:(CFHTTPMessageRef)httpMessage;
  212|       |- (void)_SR_commonInit;
  213|       |
  214|       |- (void)_initializeStreams;
  215|       |- (void)_connect;
  216|       |
  217|       |@property (nonatomic) FSRReadyState readyState;
  218|       |
  219|       |@property (nonatomic) NSOperationQueue *delegateOperationQueue;
  220|       |@property (nonatomic) dispatch_queue_t delegateDispatchQueue;
  221|       |
  222|       |@end
  223|       |
  224|       |
  225|       |@implementation FSRWebSocket {
  226|       |    NSInteger _webSocketVersion;
  227|       |
  228|       |    NSOperationQueue *_delegateOperationQueue;
  229|       |    dispatch_queue_t _delegateDispatchQueue;
  230|       |    dispatch_queue_t _workQueue;
  231|       |    NSMutableArray *_consumers;
  232|       |
  233|       |    NSInputStream *_inputStream;
  234|       |    NSOutputStream *_outputStream;
  235|       |
  236|       |    NSMutableData *_readBuffer;
  237|       |    NSInteger _readBufferOffset;
  238|       |
  239|       |    NSMutableData *_outputBuffer;
  240|       |    NSInteger _outputBufferOffset;
  241|       |
  242|       |    uint8_t _currentFrameOpcode;
  243|       |    size_t _currentFrameCount;
  244|       |    size_t _readOpCount;
  245|       |    uint32_t _currentStringScanPosition;
  246|       |    NSMutableData *_currentFrameData;
  247|       |
  248|       |    NSString *_closeReason;
  249|       |
  250|       |    NSString *_secKey;
  251|       |
  252|       |    BOOL _pinnedCertFound;
  253|       |
  254|       |    uint8_t _currentReadMaskKey[4];
  255|       |    size_t _currentReadMaskOffset;
  256|       |
  257|       |    BOOL _consumerStopped;
  258|       |
  259|       |    BOOL _closeWhenFinishedWriting;
  260|       |    BOOL _failed;
  261|       |
  262|       |    BOOL _secure;
  263|       |    NSURLRequest *_urlRequest;
  264|       |    NSString *_userAgent;
  265|       |
  266|       |    CFHTTPMessageRef _receivedHTTPHeaders;
  267|       |
  268|       |    BOOL _sentClose;
  269|       |    BOOL _didFail;
  270|       |    BOOL _cleanupScheduled;
  271|       |    int _closeCode;
  272|       |
  273|       |    BOOL _isPumping;
  274|       |
  275|       |    NSMutableSet *_scheduledRunloops;
  276|       |
  277|       |    // We use this to retain ourselves.
  278|       |    __strong FSRWebSocket *_selfRetain;
  279|       |
  280|       |    NSArray *_requestedProtocols;
  281|       |    FSRIOConsumerPool *_consumerPool;
  282|       |}
  283|       |
  284|       |@synthesize delegate = _delegate;
  285|       |@synthesize url = _url;
  286|       |@synthesize readyState = _readyState;
  287|       |@synthesize protocol = _protocol;
  288|       |
  289|       |static __strong NSData *CRLFCRLF;
  290|       |
  291|       |+ (void)initialize;
  292|      0|{
  293|      0|    CRLFCRLF = [[NSData alloc] initWithBytes:"\r\n\r\n" length:4];
  294|      0|}
  295|       |
  296|       |- (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols queue:(dispatch_queue_t)queue andUserAgent:(NSString *)userAgent;
  297|      0|{
  298|      0|    self = [super init];
  299|      0|    if (self) {
  300|      0|        assert(request.URL);
  301|      0|        _url = request.URL;
  302|      0|        NSString *scheme = [_url scheme];
  303|      0|
  304|      0|        _requestedProtocols = [protocols copy];
  305|      0|        _userAgent = userAgent;
  306|      0|
  307|      0|        assert([scheme isEqualToString:@"ws"] || [scheme isEqualToString:@"http"] || [scheme isEqualToString:@"wss"] || [scheme isEqualToString:@"https"]);
  308|      0|        _urlRequest = request;
  309|      0|
  310|      0|        if ([scheme isEqualToString:@"wss"] || [scheme isEqualToString:@"https"]) {
  311|      0|            _secure = YES;
  312|      0|        }
  313|      0|
  314|      0|        if (!queue) {
  315|      0|            _delegateDispatchQueue = dispatch_get_main_queue();
  316|      0|        } else {
  317|      0|            _delegateDispatchQueue = queue;
  318|      0|        }
  319|      0|
  320|      0|        [self _SR_commonInit];
  321|      0|    }
  322|      0|
  323|      0|    return self;
  324|      0|}
  325|       |
  326|       |- (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols;
  327|      0|{
  328|      0|    return [self initWithURLRequest:request protocols:nil queue:nil andUserAgent:nil];
  329|      0|}
  330|       |
  331|       |- (id)initWithURLRequest:(NSURLRequest *)request queue:(dispatch_queue_t)queue andUserAgent:(NSString *)userAgent;
  332|      0|{
  333|      0|    return [self initWithURLRequest:request protocols:nil queue:queue andUserAgent:userAgent];
  334|      0|}
  335|       |
  336|       |- (id)initWithURLRequest:(NSURLRequest *)request;
  337|      0|{
  338|      0|    return [self initWithURLRequest:request protocols:nil];
  339|      0|}
  340|       |
  341|       |- (id)initWithURL:(NSURL *)url;
  342|      0|{
  343|      0|    return [self initWithURL:url protocols:nil];
  344|      0|}
  345|       |
  346|       |- (id)initWithURL:(NSURL *)url protocols:(NSArray *)protocols;
  347|      0|{
  348|      0|    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];
  349|      0|    return [self initWithURLRequest:request protocols:protocols];
  350|      0|}
  351|       |
  352|       |- (void)_SR_commonInit;
  353|      0|{
  354|      0|    _readyState = SR_CONNECTING;
  355|      0|
  356|      0|    _consumerStopped = YES;
  357|      0|
  358|      0|    _webSocketVersion = 13;
  359|      0|
  360|      0|    _workQueue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);
  361|      0|
  362|      0|    // Going to set a specific on the queue so we can validate we're on the work queue
  363|      0|    dispatch_queue_set_specific(_workQueue, (__bridge void *)self, maybe_bridge(_workQueue), NULL);
  364|      0|
  365|      0|    sr_dispatch_retain(_delegateDispatchQueue);
  366|      0|
  367|      0|    _readBuffer = [[NSMutableData alloc] init];
  368|      0|    _outputBuffer = [[NSMutableData alloc] init];
  369|      0|
  370|      0|    _currentFrameData = [[NSMutableData alloc] init];
  371|      0|
  372|      0|    _consumers = [[NSMutableArray alloc] init];
  373|      0|
  374|      0|    _consumerPool = [[FSRIOConsumerPool alloc] init];
  375|      0|
  376|      0|    _scheduledRunloops = [[NSMutableSet alloc] init];
  377|      0|
  378|      0|    [self _initializeStreams];
  379|      0|
  380|      0|    // default handlers
  381|      0|}
  382|       |
  383|       |- (void)assertOnWorkQueue;
  384|      0|{
  385|      0|    assert(dispatch_get_specific((__bridge void *)self) == maybe_bridge(_workQueue));
  386|      0|}
  387|       |
  388|       |- (void)dealloc
  389|      0|{
  390|      0|    _inputStream.delegate = nil;
  391|      0|    _outputStream.delegate = nil;
  392|      0|
  393|      0|    [_inputStream close];
  394|      0|    [_outputStream close];
  395|      0|
  396|      0|    sr_dispatch_release(_workQueue);
  397|      0|    _workQueue = NULL;
  398|      0|
  399|      0|    if (_receivedHTTPHeaders) {
  400|      0|        CFRelease(_receivedHTTPHeaders);
  401|      0|        _receivedHTTPHeaders = NULL;
  402|      0|    }
  403|      0|
  404|      0|    if (_delegateDispatchQueue) {
  405|      0|        sr_dispatch_release(_delegateDispatchQueue);
  406|      0|        _delegateDispatchQueue = NULL;
  407|      0|    }
  408|      0|}
  409|       |
  410|       |#ifndef NDEBUG
  411|       |
  412|       |- (void)setReadyState:(FSRReadyState)aReadyState;
  413|      0|{
  414|      0|    [self willChangeValueForKey:@"readyState"];
  415|      0|    assert(aReadyState > _readyState);
  416|      0|    _readyState = aReadyState;
  417|      0|    [self didChangeValueForKey:@"readyState"];
  418|      0|}
  419|       |
  420|       |#endif
  421|       |
  422|       |- (void)open;
  423|      0|{
  424|      0|    assert(_url);
  425|      0|    NSAssert(_readyState == SR_CONNECTING, @"Cannot call -(void)open on SRWebSocket more than once");
  426|      0|
  427|      0|    _selfRetain = self;
  428|      0|
  429|      0|    [self _connect];
  430|      0|}
  431|       |
  432|       |// Calls block on delegate queue
  433|       |- (void)_performDelegateBlock:(dispatch_block_t)block;
  434|      0|{
  435|      0|    if (_delegateOperationQueue) {
  436|      0|        [_delegateOperationQueue addOperationWithBlock:block];
  437|      0|    } else {
  438|      0|        assert(_delegateDispatchQueue);
  439|      0|        dispatch_async(_delegateDispatchQueue, block);
  440|      0|    }
  441|      0|}
  442|       |
  443|       |- (void)setDelegateDispatchQueue:(dispatch_queue_t)queue;
  444|      0|{
  445|      0|    if (queue) {
  446|      0|        sr_dispatch_retain(queue);
  447|      0|    }
  448|      0|
  449|      0|    if (_delegateDispatchQueue) {
  450|      0|        sr_dispatch_release(_delegateDispatchQueue);
  451|      0|    }
  452|      0|
  453|      0|    _delegateDispatchQueue = queue;
  454|      0|}
  455|       |
  456|       |- (BOOL)_checkHandshake:(CFHTTPMessageRef)httpMessage;
  457|      0|{
  458|      0|    NSString *acceptHeader = CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(httpMessage, CFSTR("Sec-WebSocket-Accept")));
  459|      0|
  460|      0|    if (acceptHeader == nil) {
  461|      0|        return NO;
  462|      0|    }
  463|      0|
  464|      0|    NSString *concattedString = [_secKey stringByAppendingString:SRWebSocketAppendToSecKeyString];
  465|      0|    NSString *expectedAccept = [concattedString stringBySHA1ThenBase64Encoding];
  466|      0|
  467|      0|    return [acceptHeader isEqualToString:expectedAccept];
  468|      0|}
  469|       |
  470|       |- (void)_HTTPHeadersDidFinish;
  471|      0|{
  472|      0|    NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders);
  473|      0|
  474|      0|    if (responseCode >= 400) {
  475|      0|        SRFastLog(@"Request failed with response code %d", responseCode);
  476|      0|        [self _failWithError:[NSError errorWithDomain:@"org.lolrus.SocketRocket" code:2132 userInfo:[NSDictionary dictionaryWithObject:[NSString stringWithFormat:@"received bad response code from server %u", (int)responseCode] forKey:NSLocalizedDescriptionKey]]];
  477|      0|        return;
  478|      0|
  479|      0|    }
  480|      0|
  481|      0|    if(![self _checkHandshake:_receivedHTTPHeaders]) {
  482|      0|        [self _failWithError:[NSError errorWithDomain:FSRWebSocketErrorDomain code:2133 userInfo:[NSDictionary dictionaryWithObject:[NSString stringWithFormat:@"Invalid Sec-WebSocket-Accept response"] forKey:NSLocalizedDescriptionKey]]];
  483|      0|        return;
  484|      0|    }
  485|      0|
  486|      0|    NSString *negotiatedProtocol = CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(_receivedHTTPHeaders, CFSTR("Sec-WebSocket-Protocol")));
  487|      0|    if (negotiatedProtocol) {
  488|      0|        // Make sure we requested the protocol
  489|      0|        if ([_requestedProtocols indexOfObject:negotiatedProtocol] == NSNotFound) {
  490|      0|            [self _failWithError:[NSError errorWithDomain:FSRWebSocketErrorDomain code:2133 userInfo:[NSDictionary dictionaryWithObject:[NSString stringWithFormat:@"Server specified Sec-WebSocket-Protocol that wasn't requested"] forKey:NSLocalizedDescriptionKey]]];
  491|      0|            return;
  492|      0|        }
  493|      0|
  494|      0|        _protocol = negotiatedProtocol;
  495|      0|    }
  496|      0|
  497|      0|    self.readyState = SR_OPEN;
  498|      0|
  499|      0|    if (!_didFail) {
  500|      0|        [self _readFrameNew];
  501|      0|    }
  502|      0|
  503|      0|    [self _performDelegateBlock:^{
  504|      0|        if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) {
  505|      0|            [self.delegate webSocketDidOpen:self];
  506|      0|        };
  507|      0|    }];
  508|      0|}
  509|       |
  510|       |
  511|       |- (void)_readHTTPHeader;
  512|      0|{
  513|      0|    if (_receivedHTTPHeaders == NULL) {
  514|      0|        _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO);
  515|      0|    }
  516|      0|
  517|      0|    [self _readUntilHeaderCompleteWithCallback:^(FSRWebSocket *self,  NSData *data) {
  518|      0|        CFHTTPMessageAppendBytes(self->_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length);
  519|      0|
  520|      0|        if (CFHTTPMessageIsHeaderComplete(self->_receivedHTTPHeaders)) {
  521|      0|            SRFastLog(@"Finished reading headers %@", CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(self->_receivedHTTPHeaders)));
  522|      0|            [self _HTTPHeadersDidFinish];
  523|      0|        } else {
  524|      0|            [self _readHTTPHeader];
  525|      0|        }
  526|      0|    }];
  527|      0|}
  528|       |
  529|       |- (void)didConnect
  530|      0|{
  531|      0|    SRFastLog(@"Connected");
  532|      0|    CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR("GET"), (__bridge CFURLRef)_url, kCFHTTPVersion1_1);
  533|      0|
  534|      0|    // Set host first so it defaults
  535|      0|    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Host"), (__bridge CFStringRef)
  536|      0|                                     (_url.port != nil ? [NSString stringWithFormat:@"%@:%@",
  537|      0|                                                          _url.host, _url.port] : _url.host));
  538|      0|
  539|      0|    NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16];
  540|      0|    int result = SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);
  541|      0|    assert(result == 0);
  542|      0|    _secKey = [FSRUtilities base64EncodedStringFromData:keyBytes];
  543|      0|    assert([_secKey length] == 24);
  544|      0|
  545|      0|    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Upgrade"), CFSTR("websocket"));
  546|      0|    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Connection"), CFSTR("Upgrade"));
  547|      0|    if (_userAgent) {
  548|      0|        CFHTTPMessageSetHeaderFieldValue(request, CFSTR("User-Agent"), (__bridge CFStringRef)_userAgent);
  549|      0|    }
  550|      0|
  551|      0|    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Sec-WebSocket-Key"), (__bridge CFStringRef)_secKey);
  552|      0|    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Sec-WebSocket-Version"), (__bridge CFStringRef)[NSString stringWithFormat:@"%u", (int)_webSocketVersion]);
  553|      0|
  554|      0|    CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Origin"), (__bridge CFStringRef)_url.SR_origin);
  555|      0|
  556|      0|    if (_requestedProtocols) {
  557|      0|        CFHTTPMessageSetHeaderFieldValue(request, CFSTR("Sec-WebSocket-Protocol"), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@", "]);
  558|      0|    }
  559|      0|
  560|      0|    [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  561|      0|        CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj);
  562|      0|    }];
  563|      0|
  564|      0|    NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request));
  565|      0|
  566|      0|    CFRelease(request);
  567|      0|
  568|      0|    [self _writeData:message];
  569|      0|    [self _readHTTPHeader];
  570|      0|}
  571|       |
  572|       |//- (void)_connectToHost:(NSString *)host port:(NSInteger)port;
  573|       |- (void)_initializeStreams;
  574|      0|{
  575|      0|    NSInteger port = _url.port.integerValue;
  576|      0|    if (port == 0) {
  577|      0|        if (!_secure) {
  578|      0|            port = 80;
  579|      0|        } else {
  580|      0|            port = 443;
  581|      0|        }
  582|      0|    }
  583|      0|    NSString *host = _url.host;
  584|      0|
  585|      0|    CFReadStreamRef readStream = NULL;
  586|      0|    CFWriteStreamRef writeStream = NULL;
  587|      0|
  588|      0|    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, (int)port, &readStream, &writeStream);
  589|      0|
  590|      0|    // XXX
  591|      0|    CFReadStreamSetProperty(readStream,  kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeBackground);
  592|      0|    CFWriteStreamSetProperty(writeStream, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeBackground);
  593|      0|
  594|      0|    _outputStream = CFBridgingRelease(writeStream);
  595|      0|    _inputStream = CFBridgingRelease(readStream);
  596|      0|
  597|      0|
  598|      0|    if (_secure) {
  599|      0|        NSMutableDictionary *SSLOptions = [[NSMutableDictionary alloc] init];
  600|      0|
  601|      0|        [_outputStream setProperty:(__bridge id)kCFStreamSocketSecurityLevelNegotiatedSSL forKey:(__bridge id)kCFStreamPropertySocketSecurityLevel];
  602|      0|
  603|      0|        // If we're using pinned certs, don't validate the certificate chain
  604|      0|        if ([_urlRequest FSR_SSLPinnedCertificates].count) {
  605|      0|            [SSLOptions setValue:[NSNumber numberWithBool:NO] forKey:(__bridge id)kCFStreamSSLValidatesCertificateChain];
  606|      0|        }
  607|      0|
  608|      0|        [_outputStream setProperty:SSLOptions
  609|      0|                            forKey:(__bridge id)kCFStreamPropertySSLSettings];
  610|      0|    }
  611|      0|
  612|      0|    _inputStream.delegate = self;
  613|      0|    _outputStream.delegate = self;
  614|      0|
  615|      0|    [_outputStream open];
  616|      0|    [_inputStream open];
  617|      0|}
  618|       |
  619|       |- (void)_connect;
  620|      0|{
  621|      0|    if (!_scheduledRunloops.count) {
  622|      0|        [self scheduleInRunLoop:[NSRunLoop FSR_networkRunLoop] forMode:NSDefaultRunLoopMode];
  623|      0|    }
  624|      0|
  625|      0|
  626|      0|    [_outputStream open];
  627|      0|    [_inputStream open];
  628|      0|}
  629|       |
  630|       |- (void)scheduleInRunLoop:(NSRunLoop *)aRunLoop forMode:(NSString *)mode;
  631|      0|{
  632|      0|    [_outputStream scheduleInRunLoop:aRunLoop forMode:mode];
  633|      0|    [_inputStream scheduleInRunLoop:aRunLoop forMode:mode];
  634|      0|
  635|      0|    [_scheduledRunloops addObject:@[aRunLoop, mode]];
  636|      0|}
  637|       |
  638|       |- (void)unscheduleFromRunLoop:(NSRunLoop *)aRunLoop forMode:(NSString *)mode;
  639|      0|{
  640|      0|    [_outputStream removeFromRunLoop:aRunLoop forMode:mode];
  641|      0|    [_inputStream removeFromRunLoop:aRunLoop forMode:mode];
  642|      0|
  643|      0|    [_scheduledRunloops removeObject:@[aRunLoop, mode]];
  644|      0|}
  645|       |
  646|       |- (void)close;
  647|      0|{
  648|      0|    [self closeWithCode:-1 reason:nil];
  649|      0|}
  650|       |
  651|       |- (void)closeWithCode:(NSInteger)code reason:(NSString *)reason;
  652|      0|{
  653|      0|    assert(code);
  654|      0|    dispatch_async(_workQueue, ^{
  655|      0|        if (self.readyState == SR_CLOSING || self.readyState == SR_CLOSED) {
  656|      0|            return;
  657|      0|        }
  658|      0|
  659|      0|        BOOL wasConnecting = self.readyState == SR_CONNECTING;
  660|      0|
  661|      0|        self.readyState = SR_CLOSING;
  662|      0|
  663|      0|        SRFastLog(@"Closing with code %d reason %@", code, reason);
  664|      0|
  665|      0|        if (wasConnecting) {
  666|      0|            [self _disconnect];
  667|      0|            return;
  668|      0|        }
  669|      0|
  670|      0|        size_t maxMsgSize = [reason maximumLengthOfBytesUsingEncoding:NSUTF8StringEncoding];
  671|      0|        NSMutableData *mutablePayload = [[NSMutableData alloc] initWithLength:sizeof(uint16_t) + maxMsgSize];
  672|      0|        NSData *payload = mutablePayload;
  673|      0|
  674|      0|        ((uint16_t *)mutablePayload.mutableBytes)[0] = EndianU16_BtoN(code);
  675|      0|
  676|      0|        if (reason) {
  677|      0|            NSRange remainingRange = {0};
  678|      0|
  679|      0|            NSUInteger usedLength = 0;
  680|      0|
  681|      0|            BOOL success = [reason getBytes:(char *)mutablePayload.mutableBytes + sizeof(uint16_t) maxLength:payload.length - sizeof(uint16_t) usedLength:&usedLength encoding:NSUTF8StringEncoding options:NSStringEncodingConversionExternalRepresentation range:NSMakeRange(0, reason.length) remainingRange:&remainingRange];
  682|      0|
  683|      0|            assert(success);
  684|      0|            assert(remainingRange.length == 0);
  685|      0|
  686|      0|            if (usedLength != maxMsgSize) {
  687|      0|                payload = [payload subdataWithRange:NSMakeRange(0, usedLength + sizeof(uint16_t))];
  688|      0|            }
  689|      0|        }
  690|      0|
  691|      0|
  692|      0|        [self _sendFrameWithOpcode:SROpCodeConnectionClose data:payload];
  693|      0|    });
  694|      0|}
  695|       |
  696|       |- (void)_closeWithProtocolError:(NSString *)message;
  697|      0|{
  698|      0|    // Need to shunt this on the _callbackQueue first to see if they received any messages
  699|      0|    [self _performDelegateBlock:^{
  700|      0|        [self closeWithCode:SRStatusCodeProtocolError reason:message];
  701|      0|        dispatch_async(self->_workQueue, ^{
  702|      0|            [self _disconnect];
  703|      0|        });
  704|      0|    }];
  705|      0|}
  706|       |
  707|       |- (void)_failWithError:(NSError *)error;
  708|      0|{
  709|      0|    dispatch_async(_workQueue, ^{
  710|      0|        if (self.readyState != SR_CLOSED) {
  711|      0|            self->_failed = YES;
  712|      0|            [self _performDelegateBlock:^{
  713|      0|                if ([self.delegate respondsToSelector:@selector(webSocket:didFailWithError:)]) {
  714|      0|                    [self.delegate webSocket:self didFailWithError:error];
  715|      0|                }
  716|      0|            }];
  717|      0|
  718|      0|            self.readyState = SR_CLOSED;
  719|      0|
  720|      0|            SRFastLog(@"Failing with error %@", error.localizedDescription);
  721|      0|
  722|      0|            [self _disconnect];
  723|      0|            [self _scheduleCleanup];
  724|      0|        }
  725|      0|    });
  726|      0|}
  727|       |
  728|       |- (void)_writeData:(NSData *)data;
  729|      0|{
  730|      0|    [self assertOnWorkQueue];
  731|      0|
  732|      0|    if (_closeWhenFinishedWriting) {
  733|      0|            return;
  734|      0|    }
  735|      0|    [_outputBuffer appendData:data];
  736|      0|    [self _pumpWriting];
  737|      0|}
  738|       |- (void)send:(id)data;
  739|      0|{
  740|      0|    SRFastLog(@"Sending data %@", data);
  741|      0|    NSAssert(self.readyState != SR_CONNECTING, @"Invalid State: Cannot call send: until connection is open");
  742|      0|    // TODO: maybe not copy this for performance
  743|      0|    data = [data copy];
  744|      0|    dispatch_async(_workQueue, ^{
  745|      0|        if ([data isKindOfClass:[NSString class]]) {
  746|      0|            [self _sendFrameWithOpcode:SROpCodeTextFrame data:[(NSString *)data dataUsingEncoding:NSUTF8StringEncoding]];
  747|      0|        } else if ([data isKindOfClass:[NSData class]]) {
  748|      0|            [self _sendFrameWithOpcode:SROpCodeBinaryFrame data:data];
  749|      0|        } else if (data == nil) {
  750|      0|            [self _sendFrameWithOpcode:SROpCodeTextFrame data:data];
  751|      0|        } else {
  752|      0|            assert(NO);
  753|      0|        }
  754|      0|    });
  755|      0|}
  756|       |
  757|       |- (void)handlePing:(NSData *)pingData;
  758|      0|{
  759|      0|    // Need to pingpong this off _callbackQueue first to make sure messages happen in order
  760|      0|    [self _performDelegateBlock:^{
  761|      0|        dispatch_async(self->_workQueue, ^{
  762|      0|            [self _sendFrameWithOpcode:SROpCodePong data:pingData];
  763|      0|        });
  764|      0|    }];
  765|      0|}
  766|       |
  767|       |- (void)handlePong;
  768|      0|{
  769|      0|    // NOOP
  770|      0|}
  771|       |
  772|       |- (void)_handleMessage:(id)message
  773|      0|{
  774|      0|    SRFastLog(@"Received message");
  775|      0|    [self _performDelegateBlock:^{
  776|      0|        if ([self.delegate respondsToSelector:@selector(webSocket:didReceiveMessage:)]) {
  777|      0|            [self.delegate webSocket:self didReceiveMessage:message];
  778|      0|        }
  779|      0|    }];
  780|      0|}
  781|       |
  782|       |
  783|      0|static inline BOOL closeCodeIsValid(int closeCode) {
  784|      0|    if (closeCode < 1000) {
  785|      0|        return NO;
  786|      0|    }
  787|      0|
  788|      0|    if (closeCode >= 1000 && closeCode <= 1011) {
  789|      0|        if (closeCode == 1004 ||
  790|      0|            closeCode == 1005 ||
  791|      0|            closeCode == 1006) {
  792|      0|            return NO;
  793|      0|        }
  794|      0|        return YES;
  795|      0|    }
  796|      0|
  797|      0|    if (closeCode >= 3000 && closeCode <= 3999) {
  798|      0|        return YES;
  799|      0|    }
  800|      0|
  801|      0|    if (closeCode >= 4000 && closeCode <= 4999) {
  802|      0|        return YES;
  803|      0|    }
  804|      0|
  805|      0|    return NO;
  806|      0|}
  807|       |
  808|       |//  Note from RFC:
  809|       |//
  810|       |//  If there is a body, the first two
  811|       |//  bytes of the body MUST be a 2-byte unsigned integer (in network byte
  812|       |//  order) representing a status code with value /code/ defined in
  813|       |//  Section 7.4.  Following the 2-byte integer the body MAY contain UTF-8
  814|       |//  encoded data with value /reason/, the interpretation of which is not
  815|       |//  defined by this specification.
  816|       |
  817|       |- (void)handleCloseWithData:(NSData *)data;
  818|      0|{
  819|      0|    size_t dataSize = data.length;
  820|      0|    __block uint16_t closeCode = 0;
  821|      0|
  822|      0|    SRFastLog(@"Received close frame");
  823|      0|
  824|      0|    if (dataSize == 1) {
  825|      0|        // TODO handle error
  826|      0|        [self _closeWithProtocolError:@"Payload for close must be larger than 2 bytes"];
  827|      0|        return;
  828|      0|    } else if (dataSize >= 2) {
  829|      0|        [data getBytes:&closeCode length:sizeof(closeCode)];
  830|      0|        _closeCode = EndianU16_BtoN(closeCode);
  831|      0|        if (!closeCodeIsValid(_closeCode)) {
  832|      0|            [self _closeWithProtocolError:[NSString stringWithFormat:@"Cannot have close code of %d", _closeCode]];
  833|      0|            return;
  834|      0|        }
  835|      0|        if (dataSize > 2) {
  836|      0|            _closeReason = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(2, dataSize - 2)] encoding:NSUTF8StringEncoding];
  837|      0|            if (!_closeReason) {
  838|      0|                [self _closeWithProtocolError:@"Close reason MUST be valid UTF-8"];
  839|      0|                return;
  840|      0|            }
  841|      0|        }
  842|      0|    } else {
  843|      0|        _closeCode = SRStatusNoStatusReceived;
  844|      0|    }
  845|      0|
  846|      0|    [self assertOnWorkQueue];
  847|      0|
  848|      0|    if (self.readyState == SR_OPEN) {
  849|      0|        [self closeWithCode:1000 reason:nil];
  850|      0|    }
  851|      0|    dispatch_async(_workQueue, ^{
  852|      0|        [self _disconnect];
  853|      0|    });
  854|      0|}
  855|       |
  856|       |- (void)_disconnect;
  857|      0|{
  858|      0|    [self assertOnWorkQueue];
  859|      0|    SRFastLog(@"Trying to disconnect");
  860|      0|    _closeWhenFinishedWriting = YES;
  861|      0|    [self _pumpWriting];
  862|      0|}
  863|       |
  864|       |- (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode;
  865|      0|{
  866|      0|    // Check that the current data is valid UTF8
  867|      0|
  868|      0|    BOOL isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose);
  869|      0|    if (!isControlFrame) {
  870|      0|        [self _readFrameNew];
  871|      0|    } else {
  872|      0|        dispatch_async(_workQueue, ^{
  873|      0|            [self _readFrameContinue];
  874|      0|        });
  875|      0|    }
  876|      0|
  877|      0|    switch (opcode) {
  878|      0|        case SROpCodeTextFrame: {
  879|      0|            NSString *str = [[NSString alloc] initWithData:frameData encoding:NSUTF8StringEncoding];
  880|      0|            if (str == nil && frameData) {
  881|      0|                [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@"Text frames must be valid UTF-8"];
  882|      0|                dispatch_async(_workQueue, ^{
  883|      0|                    [self _disconnect];
  884|      0|                });
  885|      0|
  886|      0|                return;
  887|      0|            }
  888|      0|            [self _handleMessage:str];
  889|      0|            break;
  890|      0|        }
  891|      0|        case SROpCodeBinaryFrame:
  892|      0|            [self _handleMessage:[frameData copy]];
  893|      0|            break;
  894|      0|        case SROpCodeConnectionClose:
  895|      0|            [self handleCloseWithData:frameData];
  896|      0|            break;
  897|      0|        case SROpCodePing:
  898|      0|            [self handlePing:frameData];
  899|      0|            break;
  900|      0|        case SROpCodePong:
  901|      0|            [self handlePong];
  902|      0|            break;
  903|      0|        default:
  904|      0|            [self _closeWithProtocolError:[NSString stringWithFormat:@"Unknown opcode %u", (int)opcode]];
  905|      0|            // TODO: Handle invalid opcode
  906|      0|            break;
  907|      0|    }
  908|      0|}
  909|       |
  910|       |- (void)_handleFrameHeader:(frame_header)frame_header curData:(NSData *)curData;
  911|      0|{
  912|      0|    assert(frame_header.opcode != 0);
  913|      0|
  914|      0|    if (self.readyState != SR_OPEN) {
  915|      0|        return;
  916|      0|    }
  917|      0|
  918|      0|
  919|      0|    BOOL isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose);
  920|      0|
  921|      0|    if (isControlFrame && !frame_header.fin) {
  922|      0|        [self _closeWithProtocolError:@"Fragmented control frames not allowed"];
  923|      0|        return;
  924|      0|    }
  925|      0|
  926|      0|    if (isControlFrame && frame_header.payload_length >= 126) {
  927|      0|        [self _closeWithProtocolError:@"Control frames cannot have payloads larger than 126 bytes"];
  928|      0|        return;
  929|      0|    }
  930|      0|
  931|      0|    if (!isControlFrame) {
  932|      0|        _currentFrameOpcode = frame_header.opcode;
  933|      0|        _currentFrameCount += 1;
  934|      0|    }
  935|      0|
  936|      0|    if (frame_header.payload_length == 0) {
  937|      0|        if (isControlFrame) {
  938|      0|            [self _handleFrameWithData:curData opCode:frame_header.opcode];
  939|      0|        } else {
  940|      0|            if (frame_header.fin) {
  941|      0|                [self _handleFrameWithData:_currentFrameData opCode:frame_header.opcode];
  942|      0|            } else {
  943|      0|                // TODO add assert that opcode is not a control;
  944|      0|                [self _readFrameContinue];
  945|      0|            }
  946|      0|        }
  947|      0|    } else {
  948|      0|        [self _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(FSRWebSocket *self, NSData *newData) {
  949|      0|            if (isControlFrame) {
  950|      0|                [self _handleFrameWithData:newData opCode:frame_header.opcode];
  951|      0|            } else {
  952|      0|                if (frame_header.fin) {
  953|      0|                    [self _handleFrameWithData:self->_currentFrameData opCode:frame_header.opcode];
  954|      0|                } else {
  955|      0|                    // TODO add assert that opcode is not a control;
  956|      0|                    [self _readFrameContinue];
  957|      0|                }
  958|      0|
  959|      0|            }
  960|      0|        } readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked];
  961|      0|    }
  962|      0|}
  963|       |
  964|       |/* From RFC:
  965|       |
  966|       | 0                   1                   2                   3
  967|       | 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  968|       | +-+-+-+-+-------+-+-------------+-------------------------------+
  969|       | |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
  970|       | |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
  971|       | |N|V|V|V|       |S|             |   (if payload len==126/127)   |
  972|       | | |1|2|3|       |K|             |                               |
  973|       | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
  974|       | |     Extended payload length continued, if payload len == 127  |
  975|       | + - - - - - - - - - - - - - - - +-------------------------------+
  976|       | |                               |Masking-key, if MASK set to 1  |
  977|       | +-------------------------------+-------------------------------+
  978|       | | Masking-key (continued)       |          Payload Data         |
  979|       | +-------------------------------- - - - - - - - - - - - - - - - +
  980|       | :                     Payload Data continued ...                :
  981|       | + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
  982|       | |                     Payload Data continued ...                |
  983|       | +---------------------------------------------------------------+
  984|       | */
  985|       |
  986|       |static const uint8_t SRFinMask          = 0x80;
  987|       |static const uint8_t SROpCodeMask       = 0x0F;
  988|       |static const uint8_t SRRsvMask          = 0x70;
  989|       |static const uint8_t SRMaskMask         = 0x80;
  990|       |static const uint8_t SRPayloadLenMask   = 0x7F;
  991|       |
  992|       |
  993|       |- (void)_readFrameContinue;
  994|      0|{
  995|      0|    assert((_currentFrameCount == 0 && _currentFrameOpcode == 0) || (_currentFrameCount > 0 && _currentFrameOpcode > 0));
  996|      0|
  997|      0|    [self _addConsumerWithDataLength:2 callback:^(FSRWebSocket *self, NSData *data) {
  998|      0|        __block frame_header header = {0};
  999|      0|
 1000|      0|        const uint8_t *headerBuffer = data.bytes;
 1001|      0|        assert(data.length >= 2);
 1002|      0|
 1003|      0|        if (headerBuffer[0] & SRRsvMask) {
 1004|      0|            [self _closeWithProtocolError:@"Server used RSV bits"];
 1005|      0|            return;
 1006|      0|        }
 1007|      0|
 1008|      0|        uint8_t receivedOpcode = (SROpCodeMask & headerBuffer[0]);
 1009|      0|
 1010|      0|        BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose);
 1011|      0|
 1012|      0|        if (!isControlFrame && receivedOpcode != 0 && self->_currentFrameCount > 0) {
 1013|      0|            [self _closeWithProtocolError:@"all data frames after the initial data frame must have opcode 0"];
 1014|      0|            return;
 1015|      0|        }
 1016|      0|
 1017|      0|        if (receivedOpcode == 0 && self->_currentFrameCount == 0) {
 1018|      0|            [self _closeWithProtocolError:@"cannot continue a message"];
 1019|      0|            return;
 1020|      0|        }
 1021|      0|
 1022|      0|        header.opcode = receivedOpcode == 0 ? self->_currentFrameOpcode : receivedOpcode;
 1023|      0|
 1024|      0|        header.fin = !!(SRFinMask & headerBuffer[0]);
 1025|      0|
 1026|      0|
 1027|      0|        header.masked = !!(SRMaskMask & headerBuffer[1]);
 1028|      0|        header.payload_length = SRPayloadLenMask & headerBuffer[1];
 1029|      0|
 1030|      0|        headerBuffer = NULL;
 1031|      0|
 1032|      0|        if (header.masked) {
 1033|      0|            [self _closeWithProtocolError:@"Client must receive unmasked data"];
 1034|      0|        }
 1035|      0|
 1036|      0|        size_t extra_bytes_needed = header.masked ? sizeof(self->_currentReadMaskKey) : 0;
 1037|      0|
 1038|      0|        if (header.payload_length == 126) {
 1039|      0|            extra_bytes_needed += sizeof(uint16_t);
 1040|      0|        } else if (header.payload_length == 127) {
 1041|      0|            extra_bytes_needed += sizeof(uint64_t);
 1042|      0|        }
 1043|      0|
 1044|      0|        if (extra_bytes_needed == 0) {
 1045|      0|            [self _handleFrameHeader:header curData:self->_currentFrameData];
 1046|      0|        } else {
 1047|      0|            [self _addConsumerWithDataLength:extra_bytes_needed callback:^(FSRWebSocket *self, NSData *data) {
 1048|      0|                size_t mapped_size = data.length;
 1049|      0|                const void *mapped_buffer = data.bytes;
 1050|      0|                size_t offset = 0;
 1051|      0|
 1052|      0|                if (header.payload_length == 126) {
 1053|      0|                    assert(mapped_size >= sizeof(uint16_t));
 1054|      0|                    uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer));
 1055|      0|                    header.payload_length = newLen;
 1056|      0|                    offset += sizeof(uint16_t);
 1057|      0|                } else if (header.payload_length == 127) {
 1058|      0|                    assert(mapped_size >= sizeof(uint64_t));
 1059|      0|                    header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer));
 1060|      0|                    offset += sizeof(uint64_t);
 1061|      0|                } else {
 1062|      0|                    assert(header.payload_length < 126 && header.payload_length >= 0);
 1063|      0|                }
 1064|      0|
 1065|      0|
 1066|      0|                if (header.masked) {
 1067|      0|                    assert(mapped_size >= sizeof(self->_currentReadMaskOffset) + offset);
 1068|      0|                    memcpy(self->_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self->_currentReadMaskKey));
 1069|      0|                }
 1070|      0|
 1071|      0|                [self _handleFrameHeader:header curData:self->_currentFrameData];
 1072|      0|            } readToCurrentFrame:NO unmaskBytes:NO];
 1073|      0|        }
 1074|      0|    } readToCurrentFrame:NO unmaskBytes:NO];
 1075|      0|}
 1076|       |
 1077|       |- (void)_readFrameNew;
 1078|      0|{
 1079|      0|    dispatch_async(_workQueue, ^{
 1080|      0|        [self->_currentFrameData setLength:0];
 1081|      0|
 1082|      0|        self->_currentFrameOpcode = 0;
 1083|      0|        self->_currentFrameCount = 0;
 1084|      0|        self->_readOpCount = 0;
 1085|      0|        self->_currentStringScanPosition = 0;
 1086|      0|
 1087|      0|        [self _readFrameContinue];
 1088|      0|    });
 1089|      0|}
 1090|       |
 1091|       |- (void)_pumpWriting;
 1092|      0|{
 1093|      0|    [self assertOnWorkQueue];
 1094|      0|
 1095|      0|    NSUInteger dataLength = _outputBuffer.length;
 1096|      0|    if (dataLength - _outputBufferOffset > 0 && _outputStream.hasSpaceAvailable) {
 1097|      0|        NSUInteger bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset];
 1098|      0|        if (bytesWritten == -1) {
 1099|      0|            [self _failWithError:[NSError errorWithDomain:@"org.lolrus.SocketRocket" code:2145 userInfo:[NSDictionary dictionaryWithObject:@"Error writing to stream" forKey:NSLocalizedDescriptionKey]]];
 1100|      0|             return;
 1101|      0|        }
 1102|      0|
 1103|      0|        _outputBufferOffset += bytesWritten;
 1104|      0|
 1105|      0|        if (_outputBufferOffset > 4096 && _outputBufferOffset > (_outputBuffer.length >> 1)) {
 1106|      0|            _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset];
 1107|      0|            _outputBufferOffset = 0;
 1108|      0|        }
 1109|      0|    }
 1110|      0|
 1111|      0|    if (_closeWhenFinishedWriting &&
 1112|      0|        _outputBuffer.length - _outputBufferOffset == 0 &&
 1113|      0|        (_inputStream.streamStatus != NSStreamStatusNotOpen &&
 1114|      0|         _inputStream.streamStatus != NSStreamStatusClosed) &&
 1115|      0|        !_sentClose) {
 1116|      0|        _sentClose = YES;
 1117|      0|
 1118|      0|        @synchronized (self) {
 1119|      0|            [_outputStream close];
 1120|      0|            [_inputStream close];
 1121|      0|
 1122|      0|            // TODO: Why are we missing the SocketRocket code to call unscheduleFromRunLoop???
 1123|      0|        }
 1124|      0|
 1125|      0|        if (!_failed) {
 1126|      0|            [self _performDelegateBlock:^{
 1127|      0|                if ([self.delegate respondsToSelector:@selector(webSocket:didCloseWithCode:reason:wasClean:)]) {
 1128|      0|                    [self.delegate webSocket:self didCloseWithCode:self->_closeCode reason:self->_closeReason wasClean:YES];
 1129|      0|                }
 1130|      0|            }];
 1131|      0|        }
 1132|      0|        [self _scheduleCleanup];
 1133|      0|    }
 1134|      0|}
 1135|       |
 1136|       |- (void)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback;
 1137|      0|{
 1138|      0|    [self assertOnWorkQueue];
 1139|      0|    [self _addConsumerWithScanner:consumer callback:callback dataLength:0];
 1140|      0|}
 1141|       |
 1142|       |- (void)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes;
 1143|      0|{
 1144|      0|    [self assertOnWorkQueue];
 1145|      0|    assert(dataLength);
 1146|      0|
 1147|      0|    [_consumers addObject:[_consumerPool consumerWithScanner:nil handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]];
 1148|      0|    [self _pumpScanner];
 1149|      0|}
 1150|       |
 1151|       |- (void)_addConsumerWithScanner:(stream_scanner)consumer callback:(data_callback)callback dataLength:(size_t)dataLength;
 1152|      0|{
 1153|      0|    [self assertOnWorkQueue];
 1154|      0|    [_consumers addObject:[_consumerPool consumerWithScanner:consumer handler:callback bytesNeeded:dataLength readToCurrentFrame:NO unmaskBytes:NO]];
 1155|      0|    [self _pumpScanner];
 1156|      0|}
 1157|       |
 1158|       |
 1159|       |- (void)_scheduleCleanup
 1160|      0|{
 1161|      0|    @synchronized(self) {
 1162|      0|        if (_cleanupScheduled) {
 1163|      0|            return;
 1164|      0|        }
 1165|      0|
 1166|      0|        _cleanupScheduled = YES;
 1167|      0|
 1168|      0|        // Cleanup NSStream delegate's in the same RunLoop used by the streams themselves:
 1169|      0|        // This way we'll prevent race conditions between handleEvent and SRWebsocket's dealloc
 1170|      0|        NSTimer *timer = [NSTimer timerWithTimeInterval:(0.0f) target:self selector:@selector(_cleanupSelfReference:) userInfo:nil repeats:NO];
 1171|      0|        [[NSRunLoop FSR_networkRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
 1172|      0|    }
 1173|      0|}
 1174|       |
 1175|       |- (void)_cleanupSelfReference:(NSTimer *)timer
 1176|      0|{
 1177|      0|    @synchronized(self) {
 1178|      0|        // Nuke NSStream delegate's
 1179|      0|        _inputStream.delegate = nil;
 1180|      0|        _outputStream.delegate = nil;
 1181|      0|
 1182|      0|        // Remove the streams, right now, from the networkRunLoop
 1183|      0|        [_inputStream close];
 1184|      0|        [_outputStream close];
 1185|      0|    }
 1186|      0|
 1187|      0|    // Cleanup selfRetain in the same GCD queue as usual
 1188|      0|    dispatch_async(_workQueue, ^{
 1189|      0|        self->_selfRetain = nil;
 1190|      0|    });
 1191|      0|}
 1192|       |
 1193|       |
 1194|       |static const char CRLFCRLFBytes[] = {'\r', '\n', '\r', '\n'};
 1195|       |
 1196|       |- (void)_readUntilHeaderCompleteWithCallback:(data_callback)dataHandler;
 1197|      0|{
 1198|      0|    [self _readUntilBytes:CRLFCRLFBytes length:sizeof(CRLFCRLFBytes) callback:dataHandler];
 1199|      0|}
 1200|       |
 1201|       |- (void)_readUntilBytes:(const void *)bytes length:(size_t)length callback:(data_callback)dataHandler;
 1202|      0|{
 1203|      0|    // TODO optimize so this can continue from where we last searched
 1204|      0|    stream_scanner consumer = ^size_t(NSData *data) {
 1205|      0|        __block size_t found_size = 0;
 1206|      0|        __block size_t match_count = 0;
 1207|      0|
 1208|      0|        size_t size = data.length;
 1209|      0|        const unsigned char *buffer = data.bytes;
 1210|      0|        for (int i = 0; i < size; i++ ) {
 1211|      0|            if (((const unsigned char *)buffer)[i] == ((const unsigned char *)bytes)[match_count]) {
 1212|      0|                match_count += 1;
 1213|      0|                if (match_count == length) {
 1214|      0|                    found_size = i + 1;
 1215|      0|                    break;
 1216|      0|                }
 1217|      0|            } else {
 1218|      0|                match_count = 0;
 1219|      0|            }
 1220|      0|        }
 1221|      0|        return found_size;
 1222|      0|    };
 1223|      0|    [self _addConsumerWithScanner:consumer callback:dataHandler];
 1224|      0|}
 1225|       |
 1226|       |
 1227|       |// Returns true if did work
 1228|      0|- (BOOL)_innerPumpScanner {
 1229|      0|
 1230|      0|    BOOL didWork = NO;
 1231|      0|
 1232|      0|    if (self.readyState >= SR_CLOSING) {
 1233|      0|        return didWork;
 1234|      0|    }
 1235|      0|
 1236|      0|    if (!_consumers.count) {
 1237|      0|        return didWork;
 1238|      0|    }
 1239|      0|
 1240|      0|    size_t curSize = _readBuffer.length - _readBufferOffset;
 1241|      0|    if (!curSize) {
 1242|      0|        return didWork;
 1243|      0|    }
 1244|      0|
 1245|      0|    FSRIOConsumer *consumer = [_consumers objectAtIndex:0];
 1246|      0|
 1247|      0|    size_t bytesNeeded = consumer.bytesNeeded;
 1248|      0|
 1249|      0|    size_t foundSize = 0;
 1250|      0|    if (consumer.consumer) {
 1251|      0|        NSData *tempView = [NSData dataWithBytesNoCopy:(char *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset freeWhenDone:NO];
 1252|      0|        foundSize = consumer.consumer(tempView);
 1253|      0|    } else {
 1254|      0|        assert(consumer.bytesNeeded);
 1255|      0|        if (curSize >= bytesNeeded) {
 1256|      0|            foundSize = bytesNeeded;
 1257|      0|        } else if (consumer.readToCurrentFrame) {
 1258|      0|            foundSize = curSize;
 1259|      0|        }
 1260|      0|    }
 1261|      0|
 1262|      0|    NSData *slice = nil;
 1263|      0|    if (consumer.readToCurrentFrame || foundSize) {
 1264|      0|        NSRange sliceRange = NSMakeRange(_readBufferOffset, foundSize);
 1265|      0|        slice = [_readBuffer subdataWithRange:sliceRange];
 1266|      0|
 1267|      0|        _readBufferOffset += foundSize;
 1268|      0|
 1269|      0|        if (_readBufferOffset > 4096 && _readBufferOffset > (_readBuffer.length >> 1)) {
 1270|      0|            _readBuffer = [[NSMutableData alloc] initWithBytes:(char *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset];            _readBufferOffset = 0;
 1271|      0|        }
 1272|      0|
 1273|      0|        if (consumer.unmaskBytes) {
 1274|      0|            NSMutableData *mutableSlice = [slice mutableCopy];
 1275|      0|
 1276|      0|            NSUInteger len = mutableSlice.length;
 1277|      0|            uint8_t *bytes = mutableSlice.mutableBytes;
 1278|      0|
 1279|      0|            for (int i = 0; i < len; i++) {
 1280|      0|                bytes[i] = bytes[i] ^ _currentReadMaskKey[_currentReadMaskOffset % sizeof(_currentReadMaskKey)];
 1281|      0|                _currentReadMaskOffset += 1;
 1282|      0|            }
 1283|      0|
 1284|      0|            slice = mutableSlice;
 1285|      0|        }
 1286|      0|
 1287|      0|        if (consumer.readToCurrentFrame) {
 1288|      0|            [_currentFrameData appendData:slice];
 1289|      0|
 1290|      0|            _readOpCount += 1;
 1291|      0|
 1292|      0|            if (_currentFrameOpcode == SROpCodeTextFrame) {
 1293|      0|                // Validate UTF8 stuff.
 1294|      0|                size_t currentDataSize = _currentFrameData.length;
 1295|      0|                if (_currentFrameOpcode == SROpCodeTextFrame && currentDataSize > 0) {
 1296|      0|                    // TODO: Optimize the crap out of this.  Don't really have to copy all the data each time
 1297|      0|
 1298|      0|                    size_t scanSize = currentDataSize - _currentStringScanPosition;
 1299|      0|
 1300|      0|                    NSData *scan_data = [_currentFrameData subdataWithRange:NSMakeRange(_currentStringScanPosition, scanSize)];
 1301|      0|                    int32_t valid_utf8_size = validate_dispatch_data_partial_string(scan_data);
 1302|      0|
 1303|      0|                    if (valid_utf8_size == -1) {
 1304|      0|                        [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@"Text frames must be valid UTF-8"];
 1305|      0|                        dispatch_async(_workQueue, ^{
 1306|      0|                            [self _disconnect];
 1307|      0|                        });
 1308|      0|                        return didWork;
 1309|      0|                    } else {
 1310|      0|                        _currentStringScanPosition += valid_utf8_size;
 1311|      0|                    }
 1312|      0|                }
 1313|      0|
 1314|      0|            }
 1315|      0|
 1316|      0|            consumer.bytesNeeded -= foundSize;
 1317|      0|
 1318|      0|            if (consumer.bytesNeeded == 0) {
 1319|      0|                [_consumers removeObjectAtIndex:0];
 1320|      0|                consumer.handler(self, nil);
 1321|      0|                didWork = YES;
 1322|      0|            }
 1323|      0|        } else if (foundSize) {
 1324|      0|            [_consumers removeObjectAtIndex:0];
 1325|      0|            consumer.handler(self, slice);
 1326|      0|            didWork = YES;
 1327|      0|        }
 1328|      0|    }
 1329|      0|    return didWork;
 1330|      0|}
 1331|       |
 1332|       |-(void)_pumpScanner;
 1333|      0|{
 1334|      0|    [self assertOnWorkQueue];
 1335|      0|
 1336|      0|    if (!_isPumping) {
 1337|      0|        _isPumping = YES;
 1338|      0|    } else {
 1339|      0|        return;
 1340|      0|    }
 1341|      0|
 1342|      0|    while ([self _innerPumpScanner]) {
 1343|      0|
 1344|      0|    }
 1345|      0|
 1346|      0|    _isPumping = NO;
 1347|      0|}
 1348|       |
 1349|       |//#define NOMASK
 1350|       |
 1351|       |static const size_t SRFrameHeaderOverhead = 32;
 1352|       |
 1353|       |- (void)_sendFrameWithOpcode:(FSROpCode)opcode data:(id)data;
 1354|      0|{
 1355|      0|    [self assertOnWorkQueue];
 1356|      0|
 1357|      0|    if (data == nil) {
 1358|      0|        return;
 1359|      0|    }
 1360|      0|
 1361|      0|    NSAssert([data isKindOfClass:[NSData class]] || [data isKindOfClass:[NSString class]], @"Function expects nil, NSString or NSData");
 1362|      0|
 1363|      0|    size_t payloadLength = [data isKindOfClass:[NSString class]] ? [(NSString *)data lengthOfBytesUsingEncoding:NSUTF8StringEncoding] : [data length];
 1364|      0|
 1365|      0|    NSMutableData *frame = [[NSMutableData alloc] initWithLength:payloadLength + SRFrameHeaderOverhead];
 1366|      0|    if (!frame) {
 1367|      0|        [self closeWithCode:SRStatusCodeMessageTooBig reason:@"Message too big"];
 1368|      0|        return;
 1369|      0|    }
 1370|      0|    uint8_t *frame_buffer = (uint8_t *)[frame mutableBytes];
 1371|      0|
 1372|      0|    // set fin
 1373|      0|    frame_buffer[0] = SRFinMask | opcode;
 1374|      0|
 1375|      0|    BOOL useMask = YES;
 1376|       |#ifdef NOMASK
 1377|       |    useMask = NO;
 1378|       |#endif
 1379|       |
 1380|      0|    if (useMask) {
 1381|      0|    // set the mask and header
 1382|      0|        frame_buffer[1] |= SRMaskMask;
 1383|      0|    }
 1384|      0|
 1385|      0|    size_t frame_buffer_size = 2;
 1386|      0|
 1387|      0|    const uint8_t *unmasked_payload = NULL;
 1388|      0|    if ([data isKindOfClass:[NSData class]]) {
 1389|      0|        unmasked_payload = (uint8_t *)[data bytes];
 1390|      0|    } else if ([data isKindOfClass:[NSString class]]) {
 1391|      0|        unmasked_payload =  (const uint8_t *)[data UTF8String];
 1392|      0|    } else {
 1393|      0|        assert(NO);
 1394|      0|    }
 1395|      0|
 1396|      0|    if (payloadLength < 126) {
 1397|      0|        frame_buffer[1] |= payloadLength;
 1398|      0|    } else if (payloadLength <= UINT16_MAX) {
 1399|      0|        frame_buffer[1] |= 126;
 1400|      0|        *((uint16_t *)(frame_buffer + frame_buffer_size)) = EndianU16_BtoN((uint16_t)payloadLength);
 1401|      0|        frame_buffer_size += sizeof(uint16_t);
 1402|      0|    } else {
 1403|      0|        frame_buffer[1] |= 127;
 1404|      0|        *((uint64_t *)(frame_buffer + frame_buffer_size)) = EndianU64_BtoN((uint64_t)payloadLength);
 1405|      0|        frame_buffer_size += sizeof(uint64_t);
 1406|      0|    }
 1407|      0|
 1408|      0|    if (!useMask) {
 1409|      0|        for (int i = 0; i < payloadLength; i++) {
 1410|      0|            frame_buffer[frame_buffer_size] = unmasked_payload[i];
 1411|      0|            frame_buffer_size += 1;
 1412|      0|        }
 1413|      0|    } else {
 1414|      0|        uint8_t *mask_key = frame_buffer + frame_buffer_size;
 1415|      0|        int result = SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key);
 1416|      0|        assert(result == 0);
 1417|      0|        frame_buffer_size += sizeof(uint32_t);
 1418|      0|
 1419|      0|        // TODO: could probably optimize this with SIMD
 1420|      0|        for (int i = 0; i < payloadLength; i++) {
 1421|      0|            frame_buffer[frame_buffer_size] = unmasked_payload[i] ^ mask_key[i % sizeof(uint32_t)];
 1422|      0|            frame_buffer_size += 1;
 1423|      0|        }
 1424|      0|    }
 1425|      0|
 1426|      0|    assert(frame_buffer_size <= [frame length]);
 1427|      0|    frame.length = frame_buffer_size;
 1428|      0|
 1429|      0|    [self _writeData:frame];
 1430|      0|}
 1431|       |
 1432|       |- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;
 1433|      0|{
 1434|      0|    __weak __typeof__(self) weakSelf = self;
 1435|      0|
 1436|      0|    // turn on keep-alive for the output stream.
 1437|      0|    if (eventCode == NSStreamEventOpenCompleted && aStream == _outputStream) {
 1438|      0|        CFDataRef socketData = CFWriteStreamCopyProperty((CFWriteStreamRef)_outputStream, kCFStreamPropertySocketNativeHandle);
 1439|      0|        // In rare cases socketData might be nil (there are crash reports out there), in which case we'll have to just
 1440|      0|        // live without keep-alive :(
 1441|      0|        if (socketData != nil) {
 1442|      0|            CFSocketNativeHandle socket;
 1443|      0|            CFDataGetBytes(socketData, CFRangeMake(0, sizeof(CFSocketNativeHandle)), (UInt8 *)&socket);
 1444|      0|            CFRelease(socketData);
 1445|      0|
 1446|      0|            int keepAliveOn = 1;
 1447|      0|            if (setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, &keepAliveOn, sizeof(keepAliveOn)) == -1) {
 1448|      0|                SRFastLog(@"Failed to turn on TCP keepalive for websocket");
 1449|      0|            }
 1450|      0|        }
 1451|      0|    }
 1452|      0|
 1453|      0|    if (_secure && !_pinnedCertFound && (eventCode == NSStreamEventHasBytesAvailable || eventCode == NSStreamEventHasSpaceAvailable)) {
 1454|      0|
 1455|      0|        NSArray *sslCerts = [_urlRequest FSR_SSLPinnedCertificates];
 1456|      0|        if (sslCerts) {
 1457|      0|            SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge id)kCFStreamPropertySSLPeerTrust];
 1458|      0|            if (secTrust) {
 1459|      0|                NSInteger numCerts = SecTrustGetCertificateCount(secTrust);
 1460|      0|                for (NSInteger i = 0; i < numCerts && !_pinnedCertFound; i++) {
 1461|      0|                    SecCertificateRef cert = SecTrustGetCertificateAtIndex(secTrust, i);
 1462|      0|                    NSData *certData = CFBridgingRelease(SecCertificateCopyData(cert));
 1463|      0|
 1464|      0|                    for (id ref in sslCerts) {
 1465|      0|                        SecCertificateRef trustedCert = (__bridge SecCertificateRef)ref;
 1466|      0|                        NSData *trustedCertData = CFBridgingRelease(SecCertificateCopyData(trustedCert));
 1467|      0|
 1468|      0|                        if ([trustedCertData isEqualToData:certData]) {
 1469|      0|                            _pinnedCertFound = YES;
 1470|      0|                            break;
 1471|      0|                        }
 1472|      0|                    }
 1473|      0|                }
 1474|      0|            }
 1475|      0|
 1476|      0|            if (!_pinnedCertFound) {
 1477|      0|                dispatch_async(_workQueue, ^{
 1478|      0|                    NSDictionary *userInfo = @{ NSLocalizedDescriptionKey : @"Invalid server cert" };
 1479|      0|                    [weakSelf _failWithError:[NSError errorWithDomain:@"org.lolrus.SocketRocket" code:23556 userInfo:userInfo]];
 1480|      0|                });
 1481|      0|                return;
 1482|      0|            }
 1483|      0|        }
 1484|      0|    }
 1485|      0|
 1486|      0|    //    SRFastLog(@"%@ Got stream event %d", aStream, eventCode);
 1487|      0|    dispatch_async(_workQueue, ^{
 1488|      0|        [weakSelf safeHandleEvent:eventCode stream:aStream];
 1489|      0|    });
 1490|      0|}
 1491|       |
 1492|       |- (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream
 1493|      0|{
 1494|      0|    switch (eventCode) {
 1495|      0|        case NSStreamEventOpenCompleted: {
 1496|      0|            SRFastLog(@"NSStreamEventOpenCompleted %@", aStream);
 1497|      0|            if (self.readyState >= SR_CLOSING) {
 1498|      0|                return;
 1499|      0|            }
 1500|      0|
 1501|      0|
 1502|      0|            assert(_readBuffer);
 1503|      0|
 1504|      0|            if (self.readyState == SR_CONNECTING && aStream == _inputStream) {
 1505|      0|                [self didConnect];
 1506|      0|            }
 1507|      0|            [self _pumpWriting];
 1508|      0|            [self _pumpScanner];
 1509|      0|            break;
 1510|      0|        }
 1511|      0|
 1512|      0|        case NSStreamEventErrorOccurred: {
 1513|      0|            // Note: The upstream code for SocketRocket logs the error message, but this causes
 1514|      0|            // crashes on iOS 13 (https://github.com/firebase/firebase-ios-sdk/issues/3950)
 1515|      0|            SRFastLog(@"NSStreamEventErrorOccurred %@", aStream);
 1516|      0|            /// TODO specify error better!
 1517|      0|                    [self _failWithError:aStream.streamError];
 1518|      0|            _readBufferOffset = 0;
 1519|      0|            [_readBuffer setLength:0];
 1520|      0|            break;
 1521|      0|
 1522|      0|        }
 1523|      0|
 1524|      0|        case NSStreamEventEndEncountered: {
 1525|      0|            [self _pumpScanner];
 1526|      0|            SRFastLog(@"NSStreamEventEndEncountered %@", aStream);
 1527|      0|            if (aStream.streamError) {
 1528|      0|                [self _failWithError:aStream.streamError];
 1529|      0|            } else {
 1530|      0|                dispatch_async(_workQueue, ^{
 1531|      0|                    if (self.readyState != SR_CLOSED) {
 1532|      0|                        self.readyState = SR_CLOSED;
 1533|      0|                        [self _scheduleCleanup];
 1534|      0|                    }
 1535|      0|
 1536|      0|                    if (!self->_sentClose && !self->_failed) {
 1537|      0|                        self->_sentClose = YES;
 1538|      0|                        // If we get closed in this state it's probably not clean because we should be sending this when we send messages
 1539|      0|                        [self _performDelegateBlock:^{
 1540|      0|                            if ([self.delegate respondsToSelector:@selector(webSocket:didCloseWithCode:reason:wasClean:)]) {
 1541|      0|                                [self.delegate webSocket:self didCloseWithCode:0 reason:@"Stream end encountered" wasClean:NO];
 1542|      0|                            }
 1543|      0|                        }];
 1544|      0|                    }
 1545|      0|                });
 1546|      0|            }
 1547|      0|
 1548|      0|            break;
 1549|      0|        }
 1550|      0|
 1551|      0|        case NSStreamEventHasBytesAvailable: {
 1552|      0|            SRFastLog(@"NSStreamEventHasBytesAvailable %@", aStream);
 1553|      0|            const NSUInteger bufferSize = 2048;
 1554|      0|            uint8_t buffer[bufferSize];
 1555|      0|
 1556|      0|            while (_inputStream.hasBytesAvailable) {
 1557|      0|                NSInteger bytes_read = [_inputStream read:buffer maxLength:bufferSize];
 1558|      0|
 1559|      0|                if (bytes_read > 0) {
 1560|      0|                    [_readBuffer appendBytes:buffer length:bytes_read];
 1561|      0|                } else if (bytes_read < 0) {
 1562|      0|                    [self _failWithError:_inputStream.streamError];
 1563|      0|                }
 1564|      0|
 1565|      0|                if (bytes_read != bufferSize) {
 1566|      0|                    break;
 1567|      0|                }
 1568|      0|            };
 1569|      0|            [self _pumpScanner];
 1570|      0|            break;
 1571|      0|        }
 1572|      0|
 1573|      0|        case NSStreamEventHasSpaceAvailable: {
 1574|      0|            SRFastLog(@"NSStreamEventHasSpaceAvailable %@", aStream);
 1575|      0|            [self _pumpWriting];
 1576|      0|            break;
 1577|      0|        }
 1578|      0|
 1579|      0|        default:
 1580|      0|            SRFastLog(@"(default)  %@", aStream);
 1581|      0|            break;
 1582|      0|    }
 1583|      0|}
 1584|       |
 1585|       |@end
 1586|       |
 1587|       |
 1588|       |@implementation FSRIOConsumer
 1589|       |
 1590|       |@synthesize bytesNeeded = _bytesNeeded;
 1591|       |@synthesize consumer = _scanner;
 1592|       |@synthesize handler = _handler;
 1593|       |@synthesize readToCurrentFrame = _readToCurrentFrame;
 1594|       |@synthesize unmaskBytes = _unmaskBytes;
 1595|       |
 1596|       |- (void)setupWithScanner:(stream_scanner)scanner handler:(data_callback)handler bytesNeeded:(size_t)bytesNeeded readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes;
 1597|      0|{
 1598|      0|    _scanner = [scanner copy];
 1599|      0|    _handler = [handler copy];
 1600|      0|    _bytesNeeded = bytesNeeded;
 1601|      0|    _readToCurrentFrame = readToCurrentFrame;
 1602|      0|    _unmaskBytes = unmaskBytes;
 1603|      0|    assert(_scanner || _bytesNeeded);
 1604|      0|}
 1605|       |
 1606|       |@end
 1607|       |
 1608|       |@implementation FSRIOConsumerPool {
 1609|       |    NSUInteger _poolSize;
 1610|       |    NSMutableArray *_bufferedConsumers;
 1611|       |}
 1612|       |
 1613|       |- (id)initWithBufferCapacity:(NSUInteger)poolSize;
 1614|      0|{
 1615|      0|    self = [super init];
 1616|      0|    if (self) {
 1617|      0|        _poolSize = poolSize;
 1618|      0|        _bufferedConsumers = [[NSMutableArray alloc] initWithCapacity:poolSize];
 1619|      0|    }
 1620|      0|    return self;
 1621|      0|}
 1622|       |
 1623|       |- (id)init
 1624|      0|{
 1625|      0|    return [self initWithBufferCapacity:8];
 1626|      0|}
 1627|       |
 1628|       |- (FSRIOConsumer *)consumerWithScanner:(stream_scanner)scanner handler:(data_callback)handler bytesNeeded:(size_t)bytesNeeded readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes;
 1629|      0|{
 1630|      0|    FSRIOConsumer *consumer = nil;
 1631|      0|    if (_bufferedConsumers.count) {
 1632|      0|        consumer = [_bufferedConsumers lastObject];
 1633|      0|        [_bufferedConsumers removeLastObject];
 1634|      0|    } else {
 1635|      0|        consumer = [[FSRIOConsumer alloc] init];
 1636|      0|    }
 1637|      0|
 1638|      0|    [consumer setupWithScanner:scanner handler:handler bytesNeeded:bytesNeeded readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes];
 1639|      0|
 1640|      0|    return consumer;
 1641|      0|}
 1642|       |
 1643|       |- (void)returnConsumer:(FSRIOConsumer *)consumer;
 1644|      0|{
 1645|      0|    if (_bufferedConsumers.count < _poolSize) {
 1646|      0|        [_bufferedConsumers addObject:consumer];
 1647|      0|    }
 1648|      0|}
 1649|       |
 1650|       |@end
 1651|       |
 1652|       |@implementation  NSURLRequest (FCertificateAdditions)
 1653|       |
 1654|       |- (NSArray *)FSR_SSLPinnedCertificates;
 1655|      0|{
 1656|      0|    return [NSURLProtocol propertyForKey:@"FSR_SSLPinnedCertificates" inRequest:self];
 1657|      0|}
 1658|       |
 1659|       |@end
 1660|       |
 1661|       |@implementation  NSMutableURLRequest (FCertificateAdditions)
 1662|       |
 1663|       |- (NSArray *)FSR_SSLPinnedCertificates;
 1664|      0|{
 1665|      0|    return [NSURLProtocol propertyForKey:@"FSR_SSLPinnedCertificates" inRequest:self];
 1666|      0|}
 1667|       |
 1668|       |- (void)setFSR_SSLPinnedCertificates:(NSArray *)FSR_SSLPinnedCertificates;
 1669|      0|{
 1670|      0|    [NSURLProtocol setProperty:FSR_SSLPinnedCertificates forKey:@"FSR_SSLPinnedCertificates" inRequest:self];
 1671|      0|}
 1672|       |
 1673|       |@end
 1674|       |
 1675|       |@implementation NSURL (FSRWebSocket)
 1676|       |
 1677|       |- (NSString *)SR_origin;
 1678|      0|{
 1679|      0|    NSString *scheme = [self.scheme lowercaseString];
 1680|      0|
 1681|      0|    if ([scheme isEqualToString:@"wss"]) {
 1682|      0|        scheme = @"https";
 1683|      0|    } else if ([scheme isEqualToString:@"ws"]) {
 1684|      0|        scheme = @"http";
 1685|      0|    }
 1686|      0|
 1687|      0|    if (self.port != nil) {
 1688|      0|        return [NSString stringWithFormat:@"%@://%@:%@/", scheme, self.host, self.port];
 1689|      0|    } else {
 1690|      0|        return [NSString stringWithFormat:@"%@://%@/", scheme, self.host];
 1691|      0|    }
 1692|      0|}
 1693|       |
 1694|       |@end
 1695|       |
 1696|       |// #define SR_ENABLE_LOG
 1697|       |
 1698|      0|static inline void SRFastLog(NSString *format, ...)  {
 1699|       |#ifdef SR_ENABLE_LOG
 1700|       |    __block va_list arg_list;
 1701|       |    va_start (arg_list, format);
 1702|       |
 1703|       |    NSString *formattedString = [[NSString alloc] initWithFormat:format arguments:arg_list];
 1704|       |
 1705|       |    va_end(arg_list);
 1706|       |
 1707|       |    NSLog(@"[SR] %@", formattedString);
 1708|       |#endif
 1709|       |}
 1710|       |
 1711|       |
 1712|       |#ifdef HAS_ICU
 1713|       |
 1714|      0|static inline int32_t validate_dispatch_data_partial_string(NSData *data) {
 1715|      0|
 1716|      0|    const void * contents = [data bytes];
 1717|      0|    long size = [data length];
 1718|      0|
 1719|      0|    const uint8_t *str = (const uint8_t *)contents;
 1720|      0|
 1721|      0|
 1722|      0|    UChar32 codepoint = 1;
 1723|      0|    int32_t offset = 0;
 1724|      0|    int32_t lastOffset = 0;
 1725|      0|    while(offset < size && codepoint > 0)  {
 1726|      0|        lastOffset = offset;
 1727|      0|        U8_NEXT(str, offset, size, codepoint);
 1728|      0|    }
 1729|      0|
 1730|      0|    if (codepoint == -1) {
 1731|      0|        // Check to see if the last byte is valid or whether it was just continuing
 1732|      0|        if (!U8_IS_LEAD(str[lastOffset]) || U8_COUNT_TRAIL_BYTES(str[lastOffset]) + lastOffset < (int32_t)size) {
 1733|      0|
 1734|      0|            size = -1;
 1735|      0|        } else {
 1736|      0|            uint8_t leadByte = str[lastOffset];
 1737|      0|            U8_MASK_LEAD_BYTE(leadByte, U8_COUNT_TRAIL_BYTES(leadByte));
 1738|      0|
 1739|      0|            for (int i = lastOffset + 1; i < offset; i++) {
 1740|      0|
 1741|      0|                if (U8_IS_SINGLE(str[i]) || U8_IS_LEAD(str[i]) || !U8_IS_TRAIL(str[i])) {
 1742|      0|                    size = -1;
 1743|      0|                }
 1744|      0|            }
 1745|      0|
 1746|      0|            if (size != -1) {
 1747|      0|                size = lastOffset;
 1748|      0|            }
 1749|      0|        }
 1750|      0|    }
 1751|      0|
 1752|      0|    if (size != -1 && ![[NSString alloc] initWithBytesNoCopy:(char *)[data bytes] length:size encoding:NSUTF8StringEncoding freeWhenDone:NO]) {
 1753|      0|        size = -1;
 1754|      0|    }
 1755|      0|
 1756|      0|    return (int32_t)size;
 1757|      0|}
 1758|       |
 1759|       |#else
 1760|       |
 1761|       |// This is a hack, and probably not optimal
 1762|       |static inline int32_t validate_dispatch_data_partial_string(NSData *data) {
 1763|       |    static const int maxCodepointSize = 3;
 1764|       |
 1765|       |    for (int i = 0; i < maxCodepointSize; i++) {
 1766|       |        NSString *str = [[NSString alloc] initWithBytesNoCopy:(char *)data.bytes length:data.length - i encoding:NSUTF8StringEncoding freeWhenDone:NO];
 1767|       |        if (str) {
 1768|       |            return (int)(data.length - i);
 1769|       |        }
 1770|       |    }
 1771|       |
 1772|       |    return -1;
 1773|       |}
 1774|       |
 1775|       |#endif
 1776|       |
 1777|       |static _FSRRunLoopThread *networkThread = nil;
 1778|       |static NSRunLoop *networkRunLoop = nil;
 1779|       |
 1780|       |@implementation NSRunLoop (FSRWebSocket)
 1781|       |
 1782|      0|+ (NSRunLoop *)FSR_networkRunLoop {
 1783|      0|    static dispatch_once_t onceToken;
 1784|      0|    dispatch_once(&onceToken, ^{
 1785|      0|        networkThread = [[_FSRRunLoopThread alloc] init];
 1786|      0|        networkThread.name = @"com.squareup.SocketRocket.NetworkThread";
 1787|      0|        [networkThread start];
 1788|      0|        networkRunLoop = networkThread.runLoop;
 1789|      0|    });
 1790|      0|
 1791|      0|    return networkRunLoop;
 1792|      0|}
 1793|       |
 1794|       |@end
 1795|       |
 1796|       |
 1797|       |@implementation _FSRRunLoopThread {
 1798|       |    dispatch_group_t _waitGroup;
 1799|       |}
 1800|       |
 1801|       |@synthesize runLoop = _runLoop;
 1802|       |
 1803|       |- (void)dealloc
 1804|      0|{
 1805|      0|    sr_dispatch_release(_waitGroup);
 1806|      0|}
 1807|       |
 1808|       |- (id)init
 1809|      0|{
 1810|      0|    self = [super init];
 1811|      0|    if (self) {
 1812|      0|        _waitGroup = dispatch_group_create();
 1813|      0|        dispatch_group_enter(_waitGroup);
 1814|      0|    }
 1815|      0|    return self;
 1816|      0|}
 1817|       |
 1818|       |
 1819|       |/**
 1820|       | * This is the main method of the thread on which the socket events are scheduled in a run loop.
 1821|       | */
 1822|       |- (void)main;
 1823|      0|{
 1824|      0|    @autoreleasepool {
 1825|      0|        _runLoop = [NSRunLoop currentRunLoop];
 1826|      0|        dispatch_group_leave(_waitGroup);
 1827|      0|
 1828|      0|        // Add an empty run loop source to prevent runloop from spinning.
 1829|      0|        CFRunLoopSourceContext sourceCtx = {
 1830|      0|            .version = 0,
 1831|      0|            .info = NULL,
 1832|      0|            .retain = NULL,
 1833|      0|            .release = NULL,
 1834|      0|            .copyDescription = NULL,
 1835|      0|            .equal = NULL,
 1836|      0|            .hash = NULL,
 1837|      0|            .schedule = NULL,
 1838|      0|            .cancel = NULL,
 1839|      0|            .perform = NULL
 1840|      0|        };
 1841|      0|        CFRunLoopSourceRef source = CFRunLoopSourceCreate(NULL, 0, &sourceCtx);
 1842|      0|        CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);
 1843|      0|        CFRelease(source);
 1844|      0|
 1845|      0|        while ([_runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]) {
 1846|      0|
 1847|      0|        }
 1848|      0|        assert(NO);
 1849|      0|    }
 1850|      0|}
 1851|       |
 1852|       |- (NSRunLoop *)runLoop;
 1853|      0|{
 1854|      0|    dispatch_group_wait(_waitGroup, DISPATCH_TIME_FOREVER);
 1855|      0|    return _runLoop;
 1856|      0|}
 1857|       |
 1858|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/SocketRocket/NSData+SRB64Additions.m:
    1|       |//
    2|       |//   Copyright 2012 Square Inc.
    3|       |//
    4|       |//   Licensed under the Apache License, Version 2.0 (the "License");
    5|       |//   you may not use this file except in compliance with the License.
    6|       |//   You may obtain a copy of the License at
    7|       |//
    8|       |//       http://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |//   Unless required by applicable law or agreed to in writing, software
   11|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   12|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |//   See the License for the specific language governing permissions and
   14|       |//   limitations under the License.
   15|       |//
   16|       |
   17|       |#import "NSData+SRB64Additions.h"
   18|       |#import "fbase64.h"
   19|       |
   20|       |@implementation FSRUtilities
   21|       |
   22|      0|+ (NSString *)base64EncodedStringFromData:(NSData *)data {
   23|      0|    size_t buffer_size = ((data.length * 3 + 2) / 2);
   24|      0|
   25|      0|    char *buffer = (char *)malloc(buffer_size);
   26|      0|
   27|      0|    int len = f_b64_ntop(data.bytes, data.length, buffer, buffer_size);
   28|      0|
   29|      0|    if (len == -1) {
   30|      0|        free(buffer);
   31|      0|        return nil;
   32|      0|    } else{
   33|      0|        return [[NSString alloc] initWithBytesNoCopy:buffer length:len encoding:NSUTF8StringEncoding freeWhenDone:YES];
   34|      0|    }
   35|      0|}
   36|       |
   37|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/SocketRocket/fbase64.c:
    1|       |/*	$OpenBSD: base64.c,v 1.5 2006/10/21 09:55:03 otto Exp $	*/
    2|       |
    3|       |/*
    4|       | * Copyright (c) 1996 by Internet Software Consortium.
    5|       | *
    6|       | * Permission to use, copy, modify, and distribute this software for any
    7|       | * purpose with or without fee is hereby granted, provided that the above
    8|       | * copyright notice and this permission notice appear in all copies.
    9|       | *
   10|       | * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
   11|       | * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
   12|       | * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
   13|       | * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
   14|       | * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
   15|       | * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
   16|       | * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
   17|       | * SOFTWARE.
   18|       | */
   19|       |
   20|       |/*
   21|       | * Portions Copyright (c) 1995 by International Business Machines, Inc.
   22|       | *
   23|       | * International Business Machines, Inc. (hereinafter called IBM) grants
   24|       | * permission under its copyrights to use, copy, modify, and distribute this
   25|       | * Software with or without fee, provided that the above copyright notice and
   26|       | * all paragraphs of this notice appear in all copies, and that the name of IBM
   27|       | * not be used in connection with the marketing of any product incorporating
   28|       | * the Software or modifications thereof, without specific, written prior
   29|       | * permission.
   30|       | *
   31|       | * To the extent it has a right to do so, IBM grants an immunity from suit
   32|       | * under its patents, if any, for the use, sale or manufacture of products to
   33|       | * the extent that such products are used for performing Domain Name System
   34|       | * dynamic updates in TCP/IP networks by means of the Software.  No immunity is
   35|       | * granted for any product per se or for any other function of any product.
   36|       | *
   37|       | * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,
   38|       | * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   39|       | * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
   40|       | * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING
   41|       | * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN
   42|       | * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.
   43|       | */
   44|       |
   45|       |/* OPENBSD ORIGINAL: lib/libc/net/base64.c */
   46|       |
   47|       |
   48|       |//
   49|       |//   Distributed with modifications by Firebase ( https://www.firebase.com )
   50|       |//
   51|       |
   52|       |#if (!defined(HAVE_B64_NTOP) && !defined(HAVE___B64_NTOP)) || (!defined(HAVE_B64_PTON) && !defined(HAVE___B64_PTON))
   53|       |
   54|       |#include <sys/types.h>
   55|       |#include <sys/param.h>
   56|       |#include <sys/socket.h>
   57|       |#include <netinet/in.h>
   58|       |#include <arpa/inet.h>
   59|       |
   60|       |#include <ctype.h>
   61|       |#include <stdio.h>
   62|       |
   63|       |#include <stdlib.h>
   64|       |#include <string.h>
   65|       |
   66|       |#include "fbase64.h"
   67|       |
   68|       |static const char Base64[] =
   69|       |"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
   70|       |static const char Pad64 = '=';
   71|       |
   72|       |/* (From RFC1521 and draft-ietf-dnssec-secext-03.txt)
   73|       | The following encoding technique is taken from RFC 1521 by Borenstein
   74|       | and Freed.  It is reproduced here in a slightly edited form for
   75|       | convenience.
   76|       |
   77|       | A 65-character subset of US-ASCII is used, enabling 6 bits to be
   78|       | represented per printable character. (The extra 65th character, "=",
   79|       | is used to signify a special processing function.)
   80|       |
   81|       | The encoding process represents 24-bit groups of input bits as output
   82|       | strings of 4 encoded characters. Proceeding from left to right, a
   83|       | 24-bit input group is formed by concatenating 3 8-bit input groups.
   84|       | These 24 bits are then treated as 4 concatenated 6-bit groups, each
   85|       | of which is translated into a single digit in the base64 alphabet.
   86|       |
   87|       | Each 6-bit group is used as an index into an array of 64 printable
   88|       | characters. The character referenced by the index is placed in the
   89|       | output string.
   90|       |
   91|       | Table 1: The Base64 Alphabet
   92|       |
   93|       | Value Encoding  Value Encoding  Value Encoding  Value Encoding
   94|       | 0 A            17 R            34 i            51 z
   95|       | 1 B            18 S            35 j            52 0
   96|       | 2 C            19 T            36 k            53 1
   97|       | 3 D            20 U            37 l            54 2
   98|       | 4 E            21 V            38 m            55 3
   99|       | 5 F            22 W            39 n            56 4
  100|       | 6 G            23 X            40 o            57 5
  101|       | 7 H            24 Y            41 p            58 6
  102|       | 8 I            25 Z            42 q            59 7
  103|       | 9 J            26 a            43 r            60 8
  104|       | 10 K            27 b            44 s            61 9
  105|       | 11 L            28 c            45 t            62 +
  106|       | 12 M            29 d            46 u            63 /
  107|       | 13 N            30 e            47 v
  108|       | 14 O            31 f            48 w         (pad) =
  109|       | 15 P            32 g            49 x
  110|       | 16 Q            33 h            50 y
  111|       |
  112|       | Special processing is performed if fewer than 24 bits are available
  113|       | at the end of the data being encoded.  A full encoding quantum is
  114|       | always completed at the end of a quantity.  When fewer than 24 input
  115|       | bits are available in an input group, zero bits are added (on the
  116|       | right) to form an integral number of 6-bit groups.  Padding at the
  117|       | end of the data is performed using the '=' character.
  118|       |
  119|       | Since all base64 input is an integral number of octets, only the
  120|       | -------------------------------------------------
  121|       | following cases can arise:
  122|       |
  123|       | (1) the final quantum of encoding input is an integral
  124|       | multiple of 24 bits; here, the final unit of encoded
  125|       | output will be an integral multiple of 4 characters
  126|       | with no "=" padding,
  127|       | (2) the final quantum of encoding input is exactly 8 bits;
  128|       | here, the final unit of encoded output will be two
  129|       | characters followed by two "=" padding characters, or
  130|       | (3) the final quantum of encoding input is exactly 16 bits;
  131|       | here, the final unit of encoded output will be three
  132|       | characters followed by one "=" padding character.
  133|       | */
  134|       |
  135|       |#if !defined(HAVE_B64_NTOP) && !defined(HAVE___B64_NTOP)
  136|       |int
  137|       |f_b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)
  138|      0|{
  139|      0|    size_t datalength = 0;
  140|      0|	u_char input[3];
  141|      0|	u_char output[4];
  142|      0|	u_int i;
  143|      0|
  144|      0|	while (2 < srclength) {
  145|      0|		input[0] = *src++;
  146|      0|		input[1] = *src++;
  147|      0|		input[2] = *src++;
  148|      0|		srclength -= 3;
  149|      0|
  150|      0|		output[0] = input[0] >> 2;
  151|      0|		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
  152|      0|		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
  153|      0|		output[3] = input[2] & 0x3f;
  154|      0|
  155|      0|		if (datalength + 4 > targsize)
  156|      0|			return (-1);
  157|      0|		target[datalength++] = Base64[output[0]];
  158|      0|		target[datalength++] = Base64[output[1]];
  159|      0|		target[datalength++] = Base64[output[2]];
  160|      0|		target[datalength++] = Base64[output[3]];
  161|      0|	}
  162|      0|
  163|      0|	/* Now we worry about padding. */
  164|      0|	if (0 != srclength) {
  165|      0|		/* Get what's left. */
  166|      0|		input[0] = input[1] = input[2] = '\0';
  167|      0|		for (i = 0; i < srclength; i++)
  168|      0|			input[i] = *src++;
  169|      0|
  170|      0|		output[0] = input[0] >> 2;
  171|      0|		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
  172|      0|		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
  173|      0|
  174|      0|		if (datalength + 4 > targsize)
  175|      0|			return (-1);
  176|      0|		target[datalength++] = Base64[output[0]];
  177|      0|		target[datalength++] = Base64[output[1]];
  178|      0|		if (srclength == 1)
  179|      0|			target[datalength++] = Pad64;
  180|      0|		else
  181|      0|			target[datalength++] = Base64[output[2]];
  182|      0|		target[datalength++] = Pad64;
  183|      0|	}
  184|      0|	if (datalength >= targsize)
  185|      0|		return (-1);
  186|      0|	target[datalength] = '\0';	/* Returned value doesn't count \0. */
  187|      0|	return (int)(datalength);
  188|      0|}
  189|       |#endif /* !defined(HAVE_B64_NTOP) && !defined(HAVE___B64_NTOP) */
  190|       |
  191|       |#if !defined(HAVE_B64_PTON) && !defined(HAVE___B64_PTON)
  192|       |
  193|       |/* skips all whitespace anywhere.
  194|       | converts characters, four at a time, starting at (or after)
  195|       | src from base - 64 numbers into three 8 bit bytes in the target area.
  196|       | it returns the number of data bytes stored at the target, or -1 on error.
  197|       | */
  198|       |
  199|       |int
  200|       |f_b64_pton(char const *src, u_char *target, size_t targsize)
  201|      0|{
  202|      0|	u_int tarindex, state;
  203|      0|	int ch;
  204|      0|	char *pos;
  205|      0|
  206|      0|	state = 0;
  207|      0|	tarindex = 0;
  208|      0|
  209|      0|	while ((ch = *src++) != '\0') {
  210|      0|		if (isspace(ch))	/* Skip whitespace anywhere. */
  211|      0|			continue;
  212|      0|
  213|      0|		if (ch == Pad64)
  214|      0|			break;
  215|      0|
  216|      0|		pos = strchr(Base64, ch);
  217|      0|		if (pos == 0) 		/* A non-base64 character. */
  218|      0|			return (-1);
  219|      0|
  220|      0|		switch (state) {
  221|      0|            case 0:
  222|      0|                if (target) {
  223|      0|                    if (tarindex >= targsize)
  224|      0|                        return (-1);
  225|      0|                    target[tarindex] = (pos - Base64) << 2;
  226|      0|                }
  227|      0|                state = 1;
  228|      0|                break;
  229|      0|            case 1:
  230|      0|                if (target) {
  231|      0|                    if (tarindex + 1 >= targsize)
  232|      0|                        return (-1);
  233|      0|                    target[tarindex]   |=  (pos - Base64) >> 4;
  234|      0|                    target[tarindex+1]  = ((pos - Base64) & 0x0f)
  235|      0|                    << 4 ;
  236|      0|                }
  237|      0|                tarindex++;
  238|      0|                state = 2;
  239|      0|                break;
  240|      0|            case 2:
  241|      0|                if (target) {
  242|      0|                    if (tarindex + 1 >= targsize)
  243|      0|                        return (-1);
  244|      0|                    target[tarindex]   |=  (pos - Base64) >> 2;
  245|      0|                    target[tarindex+1]  = ((pos - Base64) & 0x03)
  246|      0|                    << 6;
  247|      0|                }
  248|      0|                tarindex++;
  249|      0|                state = 3;
  250|      0|                break;
  251|      0|            case 3:
  252|      0|                if (target) {
  253|      0|                    if (tarindex >= targsize)
  254|      0|                        return (-1);
  255|      0|                    target[tarindex] |= (pos - Base64);
  256|      0|                }
  257|      0|                tarindex++;
  258|      0|                state = 0;
  259|      0|                break;
  260|      0|		}
  261|      0|	}
  262|      0|
  263|      0|	/*
  264|      0|	 * We are done decoding Base-64 chars.  Let's see if we ended
  265|      0|	 * on a byte boundary, and/or with erroneous trailing characters.
  266|      0|	 */
  267|      0|
  268|      0|	if (ch == Pad64) {		/* We got a pad char. */
  269|      0|		ch = *src++;		/* Skip it, get next. */
  270|      0|		switch (state) {
  271|      0|            case 0:		/* Invalid = in first position */
  272|      0|            case 1:		/* Invalid = in second position */
  273|      0|                return (-1);
  274|      0|
  275|      0|            case 2:		/* Valid, means one byte of info */
  276|      0|                /* Skip any number of spaces. */
  277|      0|                for (; ch != '\0'; ch = *src++)
  278|      0|                    if (!isspace(ch))
  279|      0|                        break;
  280|      0|                /* Make sure there is another trailing = sign. */
  281|      0|                if (ch != Pad64)
  282|      0|                    return (-1);
  283|      0|                ch = *src++;		/* Skip the = */
  284|      0|                /* Fall through to "single trailing =" case. */
  285|      0|                /* FALLTHROUGH */
  286|      0|
  287|      0|            case 3:		/* Valid, means two bytes of info */
  288|      0|                /*
  289|      0|                 * We know this char is an =.  Is there anything but
  290|      0|                 * whitespace after it?
  291|      0|                 */
  292|      0|                for (; ch != '\0'; ch = *src++)
  293|      0|                    if (!isspace(ch))
  294|      0|                        return (-1);
  295|      0|
  296|      0|                /*
  297|      0|                 * Now make sure for cases 2 and 3 that the "extra"
  298|      0|                 * bits that slopped past the last full byte were
  299|      0|                 * zeros.  If we don't check them, they become a
  300|      0|                 * subliminal channel.
  301|      0|                 */
  302|      0|                if (target && target[tarindex] != 0)
  303|      0|                    return (-1);
  304|      0|		}
  305|      0|	} else {
  306|      0|		/*
  307|      0|		 * We ended by seeing the end of the string.  Make sure we
  308|      0|		 * have no partial bytes lying around.
  309|      0|		 */
  310|      0|		if (state != 0)
  311|      0|			return (-1);
  312|      0|	}
  313|      0|
  314|      0|	return (tarindex);
  315|      0|}
  316|       |
  317|       |#endif /* !defined(HAVE_B64_PTON) && !defined(HAVE___B64_PTON) */
  318|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseDatabase/Firebase/Database/third_party/Wrap-leveldb/APLevelDB.mm:
    1|       |//
    2|       |//  APLevelDB.m
    3|       |//
    4|       |//  Created by Adam Preble on 1/23/12.
    5|       |//  Copyright (c) 2012 Adam Preble. All rights reserved.
    6|       |//
    7|       |//	Permission is hereby granted, free of charge, to any person obtaining a copy
    8|       |//	of this software and associated documentation files (the "Software"), to deal
    9|       |//	in the Software without restriction, including without limitation the rights
   10|       |//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   11|       |//	copies of the Software, and to permit persons to whom the Software is
   12|       |//	furnished to do so, subject to the following conditions:
   13|       |//
   14|       |//	The above copyright notice and this permission notice shall be included in
   15|       |//	all copies or substantial portions of the Software.
   16|       |//
   17|       |//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   18|       |//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   19|       |//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   20|       |//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   21|       |//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   22|       |//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   23|       |//	THE SOFTWARE.
   24|       |
   25|       |//
   26|       |//  Portions of APLevelDB are based on LevelDB-ObjC:
   27|       |//	https://github.com/hoisie/LevelDB-ObjC
   28|       |//  Specifically the SliceFromString/StringFromSlice macros, and the structure of
   29|       |//  the enumeration methods.  License for those potions follows:
   30|       |//
   31|       |//	Copyright (c) 2011 Pave Labs
   32|       |//
   33|       |//	Permission is hereby granted, free of charge, to any person obtaining a copy
   34|       |//	of this software and associated documentation files (the "Software"), to deal
   35|       |//	in the Software without restriction, including without limitation the rights
   36|       |//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   37|       |//	copies of the Software, and to permit persons to whom the Software is
   38|       |//	furnished to do so, subject to the following conditions:
   39|       |//
   40|       |//	The above copyright notice and this permission notice shall be included in
   41|       |//	all copies or substantial portions of the Software.
   42|       |//
   43|       |//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   44|       |//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   45|       |//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   46|       |//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   47|       |//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   48|       |//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   49|       |//	THE SOFTWARE.
   50|       |//
   51|       |
   52|       |#import "APLevelDB.h"
   53|       |
   54|       |#import "leveldb/db.h"
   55|       |#import "leveldb/options.h"
   56|       |#import "leveldb/write_batch.h"
   57|       |
   58|       |NSString * const APLevelDBErrorDomain = @"APLevelDBErrorDomain";
   59|       |
   60|      0|#define SliceFromString(_string_) (leveldb::Slice((char *)[_string_ UTF8String], [_string_ lengthOfBytesUsingEncoding:NSUTF8StringEncoding]))
   61|      0|#define StringFromSlice(_slice_) ([[NSString alloc] initWithBytes:_slice_.data() length:_slice_.size() encoding:NSUTF8StringEncoding])
   62|       |
   63|       |
   64|       |@interface APLevelDBWriteBatch : NSObject <APLevelDBWriteBatch> {
   65|       |    @package
   66|       |    leveldb::WriteBatch _batch;
   67|       |}
   68|       |
   69|       |@property (nonatomic, strong) APLevelDB *levelDB;
   70|       |
   71|       |- (id)initWithLevelDB:(APLevelDB *)levelDB;
   72|       |@end
   73|       |
   74|       |
   75|       |#pragma mark - APLevelDB
   76|       |
   77|       |@interface APLevelDB () {
   78|       |    leveldb::DB *_db;
   79|       |    leveldb::ReadOptions _readOptions;
   80|       |    leveldb::WriteOptions _writeOptions;
   81|       |}
   82|       |- (id)initWithPath:(NSString *)path error:(NSError **)errorOut;
   83|       |+ (leveldb::Options)defaultCreateOptions;
   84|       |@property (nonatomic, readonly) leveldb::DB *db;
   85|       |@end
   86|       |
   87|       |
   88|       |@implementation APLevelDB
   89|       |
   90|       |@synthesize path = _path;
   91|       |@synthesize db = _db;
   92|       |
   93|       |+ (APLevelDB *)levelDBWithPath:(NSString *)path error:(NSError *__autoreleasing *)errorOut
   94|      0|{
   95|      0|    return [[APLevelDB alloc] initWithPath:path error:errorOut];
   96|      0|}
   97|       |
   98|       |- (id)initWithPath:(NSString *)path error:(NSError *__autoreleasing *)errorOut
   99|      0|{
  100|      0|    if ((self = [super init]))
  101|      0|    {
  102|      0|        _path = path;
  103|      0|
  104|      0|        leveldb::Options options = [[self class] defaultCreateOptions];
  105|      0|
  106|      0|        leveldb::Status status = leveldb::DB::Open(options, [_path UTF8String], &_db);
  107|      0|
  108|      0|        if (!status.ok())
  109|      0|        {
  110|      0|            if (errorOut)
  111|      0|            {
  112|      0|                NSString *statusString = [[NSString alloc] initWithCString:status.ToString().c_str() encoding:NSUTF8StringEncoding];
  113|      0|                *errorOut = [NSError errorWithDomain:APLevelDBErrorDomain
  114|      0|                                                code:0
  115|      0|                                            userInfo:[NSDictionary dictionaryWithObjectsAndKeys:statusString, NSLocalizedDescriptionKey, nil]];
  116|      0|            }
  117|      0|            return nil;
  118|      0|        }
  119|      0|
  120|      0|        _writeOptions.sync = false;
  121|      0|    }
  122|      0|    return self;
  123|      0|}
  124|       |
  125|      0|- (void)close {
  126|      0|    if (_db != NULL) {
  127|      0|        delete _db;
  128|      0|        _db = NULL;
  129|      0|    }
  130|      0|}
  131|       |
  132|       |- (void)dealloc
  133|      0|{
  134|      0|    if (_db != NULL) {
  135|      0|        delete _db;
  136|      0|        _db = NULL;
  137|      0|    }
  138|      0|}
  139|       |
  140|       |+ (leveldb::Options)defaultCreateOptions
  141|      0|{
  142|      0|    leveldb::Options options;
  143|      0|    options.create_if_missing = true;
  144|      0|    return options;
  145|      0|}
  146|       |
  147|       |- (BOOL)setData:(NSData *)data forKey:(NSString *)key
  148|      0|{
  149|      0|    leveldb::Slice keySlice = SliceFromString(key);
  150|      0|    leveldb::Slice valueSlice = leveldb::Slice((const char *)[data bytes], (size_t)[data length]);
  151|      0|    leveldb::Status status = _db->Put(_writeOptions, keySlice, valueSlice);
  152|      0|    return (status.ok() == true);
  153|      0|}
  154|       |
  155|       |- (BOOL)setString:(NSString *)str forKey:(NSString *)key
  156|      0|{
  157|      0|    // This could have been based on
  158|      0|    leveldb::Slice keySlice = SliceFromString(key);
  159|      0|    leveldb::Slice valueSlice = SliceFromString(str);
  160|      0|    leveldb::Status status = _db->Put(_writeOptions, keySlice, valueSlice);
  161|      0|    return (status.ok() == true);
  162|      0|}
  163|       |
  164|       |- (NSData *)dataForKey:(NSString *)key
  165|      0|{
  166|      0|    leveldb::Slice keySlice = SliceFromString(key);
  167|      0|    std::string valueCPPString;
  168|      0|    leveldb::Status status = _db->Get(_readOptions, keySlice, &valueCPPString);
  169|      0|
  170|      0|    if (!status.ok())
  171|      0|        return nil;
  172|      0|    else
  173|      0|        return [NSData dataWithBytes:valueCPPString.data() length:valueCPPString.size()];
  174|      0|}
  175|       |
  176|       |- (NSString *)stringForKey:(NSString *)key
  177|      0|{
  178|      0|    leveldb::Slice keySlice = SliceFromString(key);
  179|      0|    std::string valueCPPString;
  180|      0|    leveldb::Status status = _db->Get(_readOptions, keySlice, &valueCPPString);
  181|      0|
  182|      0|    // We assume (dangerously?) UTF-8 string encoding:
  183|      0|    if (!status.ok())
  184|      0|        return nil;
  185|      0|    else
  186|      0|        return [[NSString alloc] initWithBytes:valueCPPString.data() length:valueCPPString.size() encoding:NSUTF8StringEncoding];
  187|      0|}
  188|       |
  189|       |- (BOOL)removeKey:(NSString *)key
  190|      0|{
  191|      0|    leveldb::Slice keySlice = SliceFromString(key);
  192|      0|    leveldb::Status status = _db->Delete(_writeOptions, keySlice);
  193|      0|    return (status.ok() == true);
  194|      0|}
  195|       |
  196|       |- (NSArray *)allKeys
  197|      0|{
  198|      0|    NSMutableArray *keys = [NSMutableArray array];
  199|      0|    [self enumerateKeys:^(NSString *key, BOOL *stop) {
  200|      0|        [keys addObject:key];
  201|      0|    }];
  202|      0|    return keys;
  203|      0|}
  204|       |
  205|       |- (void)enumerateKeysAndValuesAsStrings:(void (^)(NSString *key, NSString *value, BOOL *stop))block
  206|      0|{
  207|      0|    [self enumerateKeysWithPrefix:@"" asStrings:block];
  208|      0|}
  209|       |
  210|       |- (void)enumerateKeysWithPrefix:(NSString *)prefixString asStrings:(void (^)(NSString *, NSString *, BOOL *))block
  211|      0|{
  212|      0|    @autoreleasepool {
  213|      0|        BOOL stop = NO;
  214|      0|        leveldb::Iterator* iter = _db->NewIterator(leveldb::ReadOptions());
  215|      0|        leveldb::Slice prefix = SliceFromString(prefixString);
  216|      0|        for (iter->Seek(prefix); iter->Valid(); iter->Next()) {
  217|      0|            leveldb::Slice key = iter->key(), value = iter->value();
  218|      0|            if (key.starts_with(prefix)) {
  219|      0|                NSString *k = StringFromSlice(key);
  220|      0|                NSString *v = [[NSString alloc] initWithBytes:value.data() length:value.size() encoding:NSUTF8StringEncoding];
  221|      0|                block(k, v, &stop);
  222|      0|                if (stop)
  223|      0|                    break;
  224|      0|            } else {
  225|      0|                break;
  226|      0|            }
  227|      0|        }
  228|      0|
  229|      0|        delete iter;
  230|      0|    }
  231|      0|}
  232|       |
  233|       |- (void)enumerateKeys:(void (^)(NSString *key, BOOL *stop))block
  234|      0|{
  235|      0|    [self enumerateKeysWithPrefix:@"" usingBlock:block];
  236|      0|}
  237|       |
  238|       |- (void)enumerateKeysWithPrefix:(NSString *)prefixString usingBlock:(void (^)(NSString *key, BOOL *stop))block;
  239|      0|{
  240|      0|    @autoreleasepool {
  241|      0|        BOOL stop = NO;
  242|      0|        leveldb::Slice prefix = SliceFromString(prefixString);
  243|      0|        leveldb::Iterator* iter = _db->NewIterator(leveldb::ReadOptions());
  244|      0|        for (iter->Seek(prefix); iter->Valid(); iter->Next()) {
  245|      0|            leveldb::Slice key = iter->key();
  246|      0|            if (key.starts_with(prefix)) {
  247|      0|                NSString *k = StringFromSlice(key);
  248|      0|                block(k, &stop);
  249|      0|                if (stop)
  250|      0|                    break;
  251|      0|            } else {
  252|      0|                break;
  253|      0|            }
  254|      0|        }
  255|      0|
  256|      0|        delete iter;
  257|      0|    }
  258|      0|}
  259|       |
  260|       |- (void)enumerateKeysAndValuesAsData:(void (^)(NSString *key, NSData *data, BOOL *stop))block
  261|      0|{
  262|      0|    [self enumerateKeysWithPrefix:@"" asData:block];
  263|      0|}
  264|       |
  265|       |- (void)enumerateKeysWithPrefix:(NSString *)prefixString asData:(void (^)(NSString *, NSData *, BOOL *))block
  266|      0|{
  267|      0|    @autoreleasepool {
  268|      0|        BOOL stop = NO;
  269|      0|        leveldb::Iterator* iter = _db->NewIterator(leveldb::ReadOptions());
  270|      0|        leveldb::Slice prefix = SliceFromString(prefixString);
  271|      0|        for (iter->Seek(prefix); iter->Valid(); iter->Next()) {
  272|      0|            leveldb::Slice key = iter->key(), value = iter->value();
  273|      0|            if (key.starts_with(prefix)) {
  274|      0|                NSString *k = StringFromSlice(key);
  275|      0|                NSData *data = [NSData dataWithBytes:value.data() length:value.size()];
  276|      0|                block(k, data, &stop);
  277|      0|                if (stop)
  278|      0|                    break;
  279|      0|            } else {
  280|      0|                break;
  281|      0|            }
  282|      0|        }
  283|      0|
  284|      0|        delete iter;
  285|      0|    }
  286|      0|}
  287|       |
  288|      0|- (NSUInteger)exactSizeFrom:(NSString *)from to:(NSString *)to {
  289|      0|    NSUInteger size = 0;
  290|      0|    leveldb::Iterator* iter = _db->NewIterator(leveldb::ReadOptions());
  291|      0|    leveldb::Slice fromSlice = SliceFromString(from);
  292|      0|    leveldb::Slice toSlice = SliceFromString(to);
  293|      0|    iter->Seek(fromSlice);
  294|      0|    while (iter->Valid() && iter->key().compare(toSlice) <= 0) {
  295|      0|        size += iter->value().size();
  296|      0|        iter->Next();
  297|      0|    }
  298|      0|    delete iter;
  299|      0|    return size;
  300|      0|}
  301|       |
  302|       |
  303|      0|- (NSUInteger)approximateSizeFrom:(NSString *)from to:(NSString *)to {
  304|      0|    leveldb::Range ranges[1];
  305|      0|    leveldb::Slice fromSlice = SliceFromString(from);
  306|      0|    leveldb::Slice toSlice = SliceFromString(to);
  307|      0|    ranges[0] = leveldb::Range(fromSlice, toSlice);
  308|      0|    uint64_t sizes[1];
  309|      0|    _db->GetApproximateSizes(ranges, 1, sizes);
  310|      0|    return (NSUInteger)sizes[0];
  311|      0|}
  312|       |
  313|       |#pragma mark - Subscripting Support
  314|       |
  315|       |- (id)objectForKeyedSubscript:(id)key
  316|      0|{
  317|      0|    if (![key respondsToSelector: @selector(componentsSeparatedByString:)])
  318|      0|    {
  319|      0|        [NSException raise:NSInvalidArgumentException format:@"key must be an NSString"];
  320|      0|    }
  321|      0|    return [self stringForKey:key];
  322|      0|}
  323|       |- (void)setObject:(id)thing forKeyedSubscript:(id<NSCopying>)key
  324|      0|{
  325|      0|    id idKey = (id) key;
  326|      0|    if (![idKey respondsToSelector: @selector(componentsSeparatedByString:)])
  327|      0|    {
  328|      0|        [NSException raise:NSInvalidArgumentException format:@"key must be NSString or NSData"];
  329|      0|    }
  330|      0|
  331|      0|    if ([thing respondsToSelector:@selector(componentsSeparatedByString:)])
  332|      0|        [self setString:thing forKey:(NSString *)key];
  333|      0|    else if ([thing respondsToSelector:@selector(subdataWithRange:)])
  334|      0|        [self setData:thing forKey:(NSString *)key];
  335|      0|    else
  336|      0|        [NSException raise:NSInvalidArgumentException format:@"object must be NSString or NSData"];
  337|      0|}
  338|       |
  339|       |#pragma mark - Atomic Updates
  340|       |
  341|       |- (id<APLevelDBWriteBatch>)beginWriteBatch
  342|      0|{
  343|      0|    APLevelDBWriteBatch *batch = [[APLevelDBWriteBatch alloc] initWithLevelDB:self];
  344|      0|    return batch;
  345|      0|}
  346|       |
  347|       |- (BOOL)commitWriteBatch:(id<APLevelDBWriteBatch>)theBatch
  348|      0|{
  349|      0|    if (!theBatch)
  350|      0|        return NO;
  351|      0|
  352|      0|    APLevelDBWriteBatch *batch = theBatch;
  353|      0|
  354|      0|    leveldb::Status status;
  355|      0|    status = _db->Write(_writeOptions, &batch->_batch);
  356|      0|    return (status.ok() == true);
  357|      0|}
  358|       |
  359|       |@end
  360|       |
  361|       |
  362|       |#pragma mark - APLevelDBIterator
  363|       |
  364|       |@interface APLevelDBIterator () {
  365|       |    leveldb::Iterator *_iter;
  366|       |}
  367|       |
  368|       |@property (nonatomic, strong) APLevelDB *levelDB;
  369|       |@end
  370|       |
  371|       |
  372|       |
  373|       |@implementation APLevelDBIterator
  374|       |
  375|       |+ (id)iteratorWithLevelDB:(APLevelDB *)db
  376|      0|{
  377|      0|    APLevelDBIterator *iter = [[[self class] alloc] initWithLevelDB:db];
  378|      0|    return iter;
  379|      0|}
  380|       |
  381|       |- (id)initWithLevelDB:(APLevelDB *)db
  382|      0|{
  383|      0|    if ((self = [super init]))
  384|      0|    {
  385|      0|        // Hold on to the database so it doesn't get deallocated before the iterator is deallocated
  386|      0|        self->_levelDB = db;
  387|      0|        _iter = db.db->NewIterator(leveldb::ReadOptions());
  388|      0|        _iter->SeekToFirst();
  389|      0|        if (!_iter->Valid())
  390|      0|            return nil;
  391|      0|    }
  392|      0|    return self;
  393|      0|}
  394|       |
  395|       |- (id)init
  396|      0|{
  397|      0|    [NSException raise:@"BadInitializer" format:@"Use the designated initializer, -initWithLevelDB:, instead."];
  398|      0|    return nil;
  399|      0|}
  400|       |
  401|       |- (void)dealloc
  402|      0|{
  403|      0|    self->_levelDB = nil;
  404|      0|    delete _iter;
  405|      0|    _iter = NULL;
  406|      0|}
  407|       |
  408|       |- (BOOL)seekToKey:(NSString *)key
  409|      0|{
  410|      0|    leveldb::Slice target = SliceFromString(key);
  411|      0|    _iter->Seek(target);
  412|      0|    return _iter->Valid() == true;
  413|      0|}
  414|       |
  415|       |- (void)seekToFirst
  416|      0|{
  417|      0|    _iter->SeekToFirst();
  418|      0|}
  419|       |
  420|       |- (void)seekToLast
  421|      0|{
  422|      0|    _iter->SeekToLast();
  423|      0|}
  424|       |
  425|       |- (NSString *)nextKey
  426|      0|{
  427|      0|    _iter->Next();
  428|      0|    return [self key];
  429|      0|}
  430|       |
  431|       |- (NSString *)key
  432|      0|{
  433|      0|    if (_iter->Valid() == false)
  434|      0|        return nil;
  435|      0|    leveldb::Slice value = _iter->key();
  436|      0|    return StringFromSlice(value);
  437|      0|}
  438|       |
  439|       |- (NSString *)valueAsString
  440|      0|{
  441|      0|    if (_iter->Valid() == false)
  442|      0|        return nil;
  443|      0|    leveldb::Slice value = _iter->value();
  444|      0|    return StringFromSlice(value);
  445|      0|}
  446|       |
  447|       |- (NSData *)valueAsData
  448|      0|{
  449|      0|    if (_iter->Valid() == false)
  450|      0|        return nil;
  451|      0|    leveldb::Slice value = _iter->value();
  452|      0|    return [NSData dataWithBytes:value.data() length:value.size()];
  453|      0|}
  454|       |
  455|       |@end
  456|       |
  457|       |
  458|       |
  459|       |#pragma mark - APLevelDBWriteBatch
  460|       |
  461|       |@implementation APLevelDBWriteBatch
  462|       |
  463|      0|- (id)initWithLevelDB:(APLevelDB *)levelDB {
  464|      0|    self = [super init];
  465|      0|    if (self != nil) {
  466|      0|        self->_levelDB = levelDB;
  467|      0|    }
  468|      0|    return self;
  469|      0|}
  470|       |
  471|       |- (void)setData:(NSData *)data forKey:(NSString *)key
  472|      0|{
  473|      0|    leveldb::Slice keySlice = SliceFromString(key);
  474|      0|    leveldb::Slice valueSlice = leveldb::Slice((const char *)[data bytes], (size_t)[data length]);
  475|      0|    _batch.Put(keySlice, valueSlice);
  476|      0|}
  477|       |- (void)setString:(NSString *)str forKey:(NSString *)key
  478|      0|{
  479|      0|    leveldb::Slice keySlice = SliceFromString(key);
  480|      0|    leveldb::Slice valueSlice = SliceFromString(str);
  481|      0|    _batch.Put(keySlice, valueSlice);
  482|      0|}
  483|       |
  484|       |- (void)removeKey:(NSString *)key
  485|      0|{
  486|      0|    leveldb::Slice keySlice = SliceFromString(key);
  487|      0|    _batch.Delete(keySlice);
  488|      0|}
  489|       |
  490|       |- (void)clear
  491|      0|{
  492|      0|    _batch.Clear();
  493|      0|}
  494|       |
  495|      0|- (BOOL)commit {
  496|      0|    return [self.levelDB commitWriteBatch:self];
  497|      0|}
  498|       |
  499|       |@end
  500|       |

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsErrorUtil.h"
   18|       |
   19|       |#import "FIRInstallationsHTTPError.h"
   20|       |
   21|       |NSString *const kFirebaseInstallationsErrorDomain = @"com.firebase.installations";
   22|       |
   23|      0|void FIRInstallationsItemSetErrorToPointer(NSError *error, NSError **pointer) {
   24|      0|  if (pointer != NULL) {
   25|      0|    *pointer = error;
   26|      0|  }
   27|      0|}
   28|       |
   29|       |@implementation FIRInstallationsErrorUtil
   30|       |
   31|      0|+ (NSError *)keyedArchiverErrorWithException:(NSException *)exception {
   32|      0|  NSString *failureReason = [NSString
   33|      0|      stringWithFormat:@"NSKeyedArchiver exception with name: %@, reason: %@, userInfo: %@",
   34|      0|                       exception.name, exception.reason, exception.userInfo];
   35|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   36|      0|                            failureReason:failureReason
   37|      0|                          underlyingError:nil];
   38|      0|}
   39|       |
   40|      0|+ (NSError *)keyedArchiverErrorWithError:(NSError *)error {
   41|      0|  NSString *failureReason = [NSString stringWithFormat:@"NSKeyedArchiver error."];
   42|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   43|      0|                            failureReason:failureReason
   44|      0|                          underlyingError:error];
   45|      0|}
   46|       |
   47|      0|+ (NSError *)keychainErrorWithFunction:(NSString *)keychainFunction status:(OSStatus)status {
   48|      0|  NSString *failureReason = [NSString stringWithFormat:@"%@ (%li)", keychainFunction, (long)status];
   49|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeKeychain
   50|      0|                            failureReason:failureReason
   51|      0|                          underlyingError:nil];
   52|      0|}
   53|       |
   54|      0|+ (NSError *)installationItemNotFoundForAppID:(NSString *)appID appName:(NSString *)appName {
   55|      0|  NSString *failureReason =
   56|      0|      [NSString stringWithFormat:@"Installation for appID %@ appName %@ not found", appID, appName];
   57|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   58|      0|                            failureReason:failureReason
   59|      0|                          underlyingError:nil];
   60|      0|}
   61|       |
   62|      0|+ (NSError *)corruptedIIDTokenData {
   63|      0|  NSString *failureReason =
   64|      0|      @"IID token data stored in Keychain is corrupted or in an incompatible format.";
   65|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   66|      0|                            failureReason:failureReason
   67|      0|                          underlyingError:nil];
   68|      0|}
   69|       |
   70|       |+ (FIRInstallationsHTTPError *)APIErrorWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   71|      0|                                                   data:(nullable NSData *)data {
   72|      0|  return [[FIRInstallationsHTTPError alloc] initWithHTTPResponse:HTTPResponse data:data];
   73|      0|}
   74|       |
   75|      0|+ (BOOL)isAPIError:(NSError *)error withHTTPCode:(NSInteger)HTTPCode {
   76|      0|  if (![error isKindOfClass:[FIRInstallationsHTTPError class]]) {
   77|      0|    return NO;
   78|      0|  }
   79|      0|
   80|      0|  return [(FIRInstallationsHTTPError *)error HTTPResponse].statusCode == HTTPCode;
   81|      0|}
   82|       |
   83|      0|+ (NSError *)JSONSerializationError:(NSError *)error {
   84|      0|  NSString *failureReason = [NSString stringWithFormat:@"Failed to serialize JSON data."];
   85|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   86|      0|                            failureReason:failureReason
   87|      0|                          underlyingError:nil];
   88|      0|}
   89|       |
   90|      0|+ (NSError *)FIDRegistrationErrorWithResponseMissingField:(NSString *)missingFieldName {
   91|      0|  NSString *failureReason = [NSString
   92|      0|      stringWithFormat:@"A required response field with name %@ is missing", missingFieldName];
   93|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   94|      0|                            failureReason:failureReason
   95|      0|                          underlyingError:nil];
   96|      0|}
   97|       |
   98|      0|+ (NSError *)networkErrorWithError:(NSError *)error {
   99|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeServerUnreachable
  100|      0|                            failureReason:@"Network connection error."
  101|      0|                          underlyingError:error];
  102|      0|}
  103|       |
  104|      0|+ (NSError *)publicDomainErrorWithError:(NSError *)error {
  105|      0|  if ([error.domain isEqualToString:kFirebaseInstallationsErrorDomain]) {
  106|      0|    return error;
  107|      0|  }
  108|      0|
  109|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
  110|      0|                            failureReason:nil
  111|      0|                          underlyingError:error];
  112|      0|}
  113|       |
  114|       |+ (NSError *)installationsErrorWithCode:(FIRInstallationsErrorCode)code
  115|       |                          failureReason:(nullable NSString *)failureReason
  116|      0|                        underlyingError:(nullable NSError *)underlyingError {
  117|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  118|      0|  userInfo[NSUnderlyingErrorKey] = underlyingError;
  119|      0|  userInfo[NSLocalizedFailureReasonErrorKey] = failureReason;
  120|      0|
  121|      0|  return [NSError errorWithDomain:kFirebaseInstallationsErrorDomain code:code userInfo:userInfo];
  122|      0|}
  123|       |
  124|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsHTTPError.h"
   18|       |#import "FIRInstallationsErrorUtil.h"
   19|       |
   20|       |@implementation FIRInstallationsHTTPError
   21|       |
   22|       |- (instancetype)initWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   23|      0|                                data:(nullable NSData *)data {
   24|      0|  NSDictionary *userInfo = [FIRInstallationsHTTPError userInfoWithHTTPResponse:HTTPResponse
   25|      0|                                                                          data:data];
   26|      0|  self = [super
   27|      0|      initWithDomain:kFirebaseInstallationsErrorDomain
   28|      0|                code:[FIRInstallationsHTTPError errorCodeWithHTTPCode:HTTPResponse.statusCode]
   29|      0|            userInfo:userInfo];
   30|      0|  if (self) {
   31|      0|    _HTTPResponse = HTTPResponse;
   32|      0|    _data = data;
   33|      0|  }
   34|      0|  return self;
   35|      0|}
   36|       |
   37|      0|+ (FIRInstallationsErrorCode)errorCodeWithHTTPCode:(NSInteger)HTTPCode {
   38|      0|  return FIRInstallationsErrorCodeUnknown;
   39|      0|}
   40|       |
   41|       |+ (NSDictionary *)userInfoWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   42|      0|                                      data:(nullable NSData *)data {
   43|      0|  NSString *responseString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
   44|      0|  NSString *failureReason = [NSString
   45|      0|      stringWithFormat:@"The server responded with an error. HTTP response: %@\nResponse body: %@",
   46|      0|                       HTTPResponse, responseString];
   47|      0|  return @{NSLocalizedFailureReasonErrorKey : failureReason};
   48|      0|}
   49|       |
   50|       |#pragma mark - NSCopying
   51|       |
   52|      0|- (id)copyWithZone:(NSZone *)zone {
   53|      0|  return [[FIRInstallationsHTTPError alloc] initWithHTTPResponse:self.HTTPResponse data:self.data];
   54|      0|}
   55|       |
   56|       |#pragma mark - NSSecureCoding
   57|       |
   58|      0|- (nullable instancetype)initWithCoder:(NSCoder *)coder {
   59|      0|  NSHTTPURLResponse *HTTPResponse = [coder decodeObjectOfClass:[NSHTTPURLResponse class]
   60|      0|                                                        forKey:@"HTTPResponse"];
   61|      0|  if (!HTTPResponse) {
   62|      0|    return nil;
   63|      0|  }
   64|      0|  NSData *data = [coder decodeObjectOfClass:[NSData class] forKey:@"data"];
   65|      0|
   66|      0|  return [self initWithHTTPResponse:HTTPResponse data:data];
   67|      0|}
   68|       |
   69|      0|- (void)encodeWithCoder:(NSCoder *)coder {
   70|      0|  [coder encodeObject:self.HTTPResponse forKey:@"HTTPResponse"];
   71|      0|  [coder encodeObject:self.data forKey:@"data"];
   72|      0|}
   73|       |
   74|      0|+ (BOOL)supportsSecureCoding {
   75|      0|  return YES;
   76|      0|}
   77|       |
   78|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallations.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallations.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRAppInternal.h>
   26|       |#import <FirebaseCore/FIRComponent.h>
   27|       |#import <FirebaseCore/FIRComponentContainer.h>
   28|       |#import <FirebaseCore/FIRLibrary.h>
   29|       |#import <FirebaseCore/FIRLogger.h>
   30|       |#import <FirebaseCore/FIROptions.h>
   31|       |
   32|       |#import "FIRInstallationsAuthTokenResultInternal.h"
   33|       |
   34|       |#import "FIRInstallationsErrorUtil.h"
   35|       |#import "FIRInstallationsIDController.h"
   36|       |#import "FIRInstallationsItem.h"
   37|       |#import "FIRInstallationsLogger.h"
   38|       |#import "FIRInstallationsStoredAuthToken.h"
   39|       |#import "FIRInstallationsVersion.h"
   40|       |
   41|       |NS_ASSUME_NONNULL_BEGIN
   42|       |
   43|       |@protocol FIRInstallationsInstanceProvider <FIRLibrary>
   44|       |@end
   45|       |
   46|       |@interface FIRInstallations () <FIRInstallationsInstanceProvider>
   47|       |@property(nonatomic, readonly) FIROptions *appOptions;
   48|       |@property(nonatomic, readonly) NSString *appName;
   49|       |
   50|       |@property(nonatomic, readonly) FIRInstallationsIDController *installationsIDController;
   51|       |
   52|       |@end
   53|       |
   54|       |@implementation FIRInstallations
   55|       |
   56|       |#pragma mark - Firebase component
   57|       |
   58|      1|+ (void)load {
   59|      1|  [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self
   60|      1|                         withName:@"fire-install"
   61|      1|                      withVersion:[NSString stringWithUTF8String:FIRInstallationsVersionStr]];
   62|      1|}
   63|       |
   64|      1|+ (nonnull NSArray<FIRComponent *> *)componentsToRegister {
   65|      1|  FIRComponentCreationBlock creationBlock =
   66|      1|      ^id _Nullable(FIRComponentContainer *container, BOOL *isCacheable) {
   67|      1|    *isCacheable = YES;
   68|      1|    FIRInstallations *installations = [[FIRInstallations alloc] initWithApp:container.app];
   69|      1|    return installations;
   70|      1|  };
   71|      1|
   72|      1|  FIRComponent *installationsProvider =
   73|      1|      [FIRComponent componentWithProtocol:@protocol(FIRInstallationsInstanceProvider)
   74|      1|                      instantiationTiming:FIRInstantiationTimingAlwaysEager
   75|      1|                             dependencies:@[]
   76|      1|                            creationBlock:creationBlock];
   77|      1|  return @[ installationsProvider ];
   78|      1|}
   79|       |
   80|      1|- (instancetype)initWithApp:(FIRApp *)app {
   81|      1|  return [self initWitAppOptions:app.options appName:app.name];
   82|      1|}
   83|       |
   84|      1|- (instancetype)initWitAppOptions:(FIROptions *)appOptions appName:(NSString *)appName {
   85|      1|  FIRInstallationsIDController *IDController =
   86|      1|      [[FIRInstallationsIDController alloc] initWithGoogleAppID:appOptions.googleAppID
   87|      1|                                                        appName:appName
   88|      1|                                                         APIKey:appOptions.APIKey
   89|      1|                                                      projectID:appOptions.projectID
   90|      1|                                                    GCMSenderID:appOptions.GCMSenderID
   91|      1|                                                    accessGroup:appOptions.appGroupID];
   92|      1|  return [self initWithAppOptions:appOptions
   93|      1|                          appName:appName
   94|      1|        installationsIDController:IDController
   95|      1|                prefetchAuthToken:YES];
   96|      1|}
   97|       |
   98|       |/// The initializer is supposed to be used by tests to inject `installationsStore`.
   99|       |- (instancetype)initWithAppOptions:(FIROptions *)appOptions
  100|       |                           appName:(NSString *)appName
  101|       |         installationsIDController:(FIRInstallationsIDController *)installationsIDController
  102|      1|                 prefetchAuthToken:(BOOL)prefetchAuthToken {
  103|      1|  self = [super init];
  104|      1|  if (self) {
  105|      1|    [[self class] validateAppOptions:appOptions appName:appName];
  106|      1|    [[self class] assertCompatibleIIDVersion];
  107|      1|
  108|      1|    _appOptions = [appOptions copy];
  109|      1|    _appName = [appName copy];
  110|      1|    _installationsIDController = installationsIDController;
  111|      1|
  112|      1|    // Pre-fetch auth token.
  113|      1|    if (prefetchAuthToken) {
  114|      1|      [self authTokenWithCompletion:^(FIRInstallationsAuthTokenResult *_Nullable tokenResult,
  115|      1|                                      NSError *_Nullable error){
  116|      0|      }];
  117|      1|    }
  118|      1|  }
  119|      1|  return self;
  120|      1|}
  121|       |
  122|      1|+ (void)validateAppOptions:(FIROptions *)appOptions appName:(NSString *)appName {
  123|      1|  NSMutableArray *missingFields = [NSMutableArray array];
  124|      1|  if (appName.length < 1) {
  125|      0|    [missingFields addObject:@"`FirebaseApp.name`"];
  126|      0|  }
  127|      1|  if (appOptions.APIKey.length < 1) {
  128|      0|    [missingFields addObject:@"`FirebaseOptions.APIKey`"];
  129|      0|  }
  130|      1|  if (appOptions.googleAppID.length < 1) {
  131|      0|    [missingFields addObject:@"`FirebaseOptions.googleAppID`"];
  132|      0|  }
  133|      1|
  134|      1|  // TODO(#4692): Check for `appOptions.projectID.length < 1` only.
  135|      1|  // We can use `GCMSenderID` instead of `projectID` temporary.
  136|      1|  if (appOptions.projectID.length < 1 && appOptions.GCMSenderID.length < 1) {
  137|      0|    [missingFields addObject:@"`FirebaseOptions.projectID`"];
  138|      0|  }
  139|      1|
  140|      1|  if (missingFields.count > 0) {
  141|      0|    [NSException
  142|      0|         raise:kFirebaseInstallationsErrorDomain
  143|      0|        format:
  144|      0|            @"%@[%@] Could not configure Firebase Installations due to invalid FirebaseApp "
  145|      0|            @"options. The following parameters are nil or empty: %@. If you use "
  146|      0|            @"GoogleServices-Info.plist please download the most recent version from the Firebase "
  147|      0|            @"Console. If you configure Firebase in code, please make sure you specify all "
  148|      0|            @"required parameters.",
  149|      0|            kFIRLoggerInstallations, kFIRInstallationsMessageCodeInvalidFirebaseAppOptions,
  150|      0|            [missingFields componentsJoinedByString:@", "]];
  151|      0|  }
  152|      1|}
  153|       |
  154|       |#pragma mark - Public
  155|       |
  156|      1|+ (FIRInstallations *)installations {
  157|      1|  FIRApp *defaultApp = [FIRApp defaultApp];
  158|      1|  if (!defaultApp) {
  159|      0|    [NSException raise:kFirebaseInstallationsErrorDomain
  160|      0|                format:@"The default FirebaseApp instance must be configured before the default"
  161|      0|                       @"FirebaseApp instance can be initialized. One way to ensure that is to "
  162|      0|                       @"call `[FIRApp configure];` (`FirebaseApp.configure()` in Swift) in the App"
  163|      0|                       @" Delegate's `application:didFinishLaunchingWithOptions:` "
  164|      0|                       @"(`application(_:didFinishLaunchingWithOptions:)` in Swift)."];
  165|      0|  }
  166|      1|
  167|      1|  return [self installationsWithApp:defaultApp];
  168|      1|}
  169|       |
  170|      1|+ (FIRInstallations *)installationsWithApp:(FIRApp *)app {
  171|      1|  id<FIRInstallationsInstanceProvider> installations =
  172|      1|      FIR_COMPONENT(FIRInstallationsInstanceProvider, app.container);
  173|      1|  return (FIRInstallations *)installations;
  174|      1|}
  175|       |
  176|      1|- (void)installationIDWithCompletion:(FIRInstallationsIDHandler)completion {
  177|      1|  [self.installationsIDController getInstallationItem]
  178|      1|      .then(^id(FIRInstallationsItem *installation) {
  179|      1|        completion(installation.firebaseInstallationID, nil);
  180|      1|        return nil;
  181|      1|      })
  182|      1|      .catch(^(NSError *error) {
  183|      0|        completion(nil, [FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  184|      0|      });
  185|      1|}
  186|       |
  187|      1|- (void)authTokenWithCompletion:(FIRInstallationsTokenHandler)completion {
  188|      1|  [self authTokenForcingRefresh:NO completion:completion];
  189|      1|}
  190|       |
  191|       |- (void)authTokenForcingRefresh:(BOOL)forceRefresh
  192|      1|                     completion:(FIRInstallationsTokenHandler)completion {
  193|      1|  [self.installationsIDController getAuthTokenForcingRefresh:forceRefresh]
  194|      1|      .then(^FIRInstallationsAuthTokenResult *(FIRInstallationsItem *installation) {
  195|      0|        FIRInstallationsAuthTokenResult *result = [[FIRInstallationsAuthTokenResult alloc]
  196|      0|             initWithToken:installation.authToken.token
  197|      0|            expirationDate:installation.authToken.expirationDate];
  198|      0|        return result;
  199|      0|      })
  200|      1|      .then(^id(FIRInstallationsAuthTokenResult *token) {
  201|      0|        completion(token, nil);
  202|      0|        return nil;
  203|      0|      })
  204|      1|      .catch(^void(NSError *error) {
  205|      0|        completion(nil, [FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  206|      0|      });
  207|      1|}
  208|       |
  209|      0|- (void)deleteWithCompletion:(void (^)(NSError *__nullable error))completion {
  210|      0|  [self.installationsIDController deleteInstallation]
  211|      0|      .then(^id(id result) {
  212|      0|        completion(nil);
  213|      0|        return nil;
  214|      0|      })
  215|      0|      .catch(^void(NSError *error) {
  216|      0|        completion([FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  217|      0|      });
  218|      0|}
  219|       |
  220|       |#pragma mark - IID version compatibility
  221|       |
  222|      1|+ (void)assertCompatibleIIDVersion {
  223|      1|  // We use this flag to disable IID compatibility exception for unit tests.
  224|      1|#ifdef FIR_INSTALLATIONS_ALLOWS_INCOMPATIBLE_IID_VERSION
  225|      1|  return;
  226|       |#else
  227|       |  if (![self isIIDVersionCompatible]) {
  228|       |    [NSException raise:kFirebaseInstallationsErrorDomain
  229|       |                format:@"FirebaseInstallations will not work correctly with current version of "
  230|       |                       @"Firebase Instance ID. Please update your Firebase Instance ID version."];
  231|       |  }
  232|       |#endif
  233|       |}
  234|       |
  235|      0|+ (BOOL)isIIDVersionCompatible {
  236|      0|  Class IIDClass = NSClassFromString(@"FIRInstanceID");
  237|      0|  if (IIDClass == nil) {
  238|      0|    // It is OK if there is no IID at all.
  239|      0|    return YES;
  240|      0|  }
  241|      0|  // We expect a compatible version having the method `+[FIRInstanceID usesFIS]` defined.
  242|      0|  BOOL isCompatibleVersion = [IIDClass respondsToSelector:NSSelectorFromString(@"usesFIS")];
  243|      0|  return isCompatibleVersion;
  244|      0|}
  245|       |
  246|       |@end
  247|       |
  248|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallationsAuthTokenResult.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsAuthTokenResultInternal.h"
   18|       |
   19|       |@implementation FIRInstallationsAuthTokenResult
   20|       |
   21|      0|- (instancetype)initWithToken:(NSString *)token expirationDate:(NSDate *)expirationDate {
   22|      0|  self = [super init];
   23|      0|  if (self) {
   24|      0|    _authToken = [token copy];
   25|      0|    _expirationDate = expirationDate;
   26|      0|  }
   27|      0|  return self;
   28|      0|}
   29|       |
   30|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallationsItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsItem.h"
   18|       |
   19|       |#import "FIRInstallationsStoredAuthToken.h"
   20|       |#import "FIRInstallationsStoredItem.h"
   21|       |
   22|       |@implementation FIRInstallationsItem
   23|       |
   24|      1|- (instancetype)initWithAppID:(NSString *)appID firebaseAppName:(NSString *)firebaseAppName {
   25|      1|  self = [super init];
   26|      1|  if (self) {
   27|      1|    _appID = [appID copy];
   28|      1|    _firebaseAppName = [firebaseAppName copy];
   29|      1|  }
   30|      1|  return self;
   31|      1|}
   32|       |
   33|      0|- (nonnull id)copyWithZone:(nullable NSZone *)zone {
   34|      0|  FIRInstallationsItem *clone = [[FIRInstallationsItem alloc] initWithAppID:self.appID
   35|      0|                                                            firebaseAppName:self.firebaseAppName];
   36|      0|  clone.firebaseInstallationID = [self.firebaseInstallationID copy];
   37|      0|  clone.refreshToken = [self.refreshToken copy];
   38|      0|  clone.authToken = [self.authToken copy];
   39|      0|  clone.registrationStatus = self.registrationStatus;
   40|      0|
   41|      0|  return clone;
   42|      0|}
   43|       |
   44|      1|- (void)updateWithStoredItem:(FIRInstallationsStoredItem *)item {
   45|      1|  self.firebaseInstallationID = item.firebaseInstallationID;
   46|      1|  self.refreshToken = item.refreshToken;
   47|      1|  self.authToken = item.authToken;
   48|      1|  self.registrationStatus = item.registrationStatus;
   49|      1|  self.IIDDefaultToken = item.IIDDefaultToken;
   50|      1|}
   51|       |
   52|      0|- (FIRInstallationsStoredItem *)storedItem {
   53|      0|  FIRInstallationsStoredItem *storedItem = [[FIRInstallationsStoredItem alloc] init];
   54|      0|  storedItem.firebaseInstallationID = self.firebaseInstallationID;
   55|      0|  storedItem.refreshToken = self.refreshToken;
   56|      0|  storedItem.authToken = self.authToken;
   57|      0|  storedItem.registrationStatus = self.registrationStatus;
   58|      0|  storedItem.IIDDefaultToken = self.IIDDefaultToken;
   59|      0|  return storedItem;
   60|      0|}
   61|       |
   62|      0|- (nonnull NSString *)identifier {
   63|      0|  return [[self class] identifierWithAppID:self.appID appName:self.firebaseAppName];
   64|      0|}
   65|       |
   66|      2|+ (NSString *)identifierWithAppID:(NSString *)appID appName:(NSString *)appName {
   67|      2|  return [appID stringByAppendingString:appName];
   68|      2|}
   69|       |
   70|      0|+ (NSString *)generateFID {
   71|      0|  NSUUID *UUID = [NSUUID UUID];
   72|      0|  uuid_t UUIDBytes;
   73|      0|  [UUID getUUIDBytes:UUIDBytes];
   74|      0|
   75|      0|  NSUInteger UUIDLength = sizeof(uuid_t);
   76|      0|  NSData *UUIDData = [NSData dataWithBytes:UUIDBytes length:UUIDLength];
   77|      0|
   78|      0|  uint8_t UUIDLast4Bits = UUIDBytes[UUIDLength - 1] & 0b00001111;
   79|      0|
   80|      0|  // FID first 4 bits must be `0111`. The last 4 UUID bits will be cut later to form a proper FID.
   81|      0|  // To keep 16 random bytes we copy these last 4 UUID to the FID 1st byte after `0111` prefix.
   82|      0|  uint8_t FIDPrefix = 0b01110000 | UUIDLast4Bits;
   83|      0|  NSMutableData *FIDData = [NSMutableData dataWithBytes:&FIDPrefix length:1];
   84|      0|
   85|      0|  [FIDData appendData:UUIDData];
   86|      0|  NSString *FIDString = [self base64URLEncodedStringWithData:FIDData];
   87|      0|
   88|      0|  // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5 bytes.
   89|      0|  // Our generated ID has 16 bytes UUID + 1 byte prefix which after encoding with base64 will become
   90|      0|  // 23 characters plus 1 character for "=" padding.
   91|      0|
   92|      0|  // Remove the 23rd character that was added because of the extra 4 bits at the
   93|      0|  // end of our 17 byte data and the '=' padding.
   94|      0|  return [FIDString substringWithRange:NSMakeRange(0, 22)];
   95|      0|}
   96|       |
   97|      0|+ (NSString *)base64URLEncodedStringWithData:(NSData *)data {
   98|      0|  NSString *string = [data base64EncodedStringWithOptions:0];
   99|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
  100|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
  101|      0|  return string;
  102|      0|}
  103|       |
  104|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsIIDStore.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <CommonCrypto/CommonDigest.h>
   26|       |#import "FIRInstallationsErrorUtil.h"
   27|       |
   28|       |static NSString *const kFIRInstallationsIIDKeyPairPublicTagPrefix =
   29|       |    @"com.google.iid.keypair.public-";
   30|       |static NSString *const kFIRInstallationsIIDKeyPairPrivateTagPrefix =
   31|       |    @"com.google.iid.keypair.private-";
   32|       |static NSString *const kFIRInstallationsIIDCreationTimePlistKey = @"|S|cre";
   33|       |
   34|       |@implementation FIRInstallationsIIDStore
   35|       |
   36|      0|- (FBLPromise<NSString *> *)existingIID {
   37|      0|  return [FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   38|      0|                          do:^id _Nullable {
   39|      0|                            if (![self hasPlistIIDFlag]) {
   40|      0|                              return nil;
   41|      0|                            }
   42|      0|
   43|      0|                            NSData *IIDPublicKeyData = [self IIDPublicKeyData];
   44|      0|                            return [self IIDWithPublicKeyData:IIDPublicKeyData];
   45|      0|                          }]
   46|      0|      .validate(^BOOL(NSString *_Nullable IID) {
   47|      0|        return IID.length > 0;
   48|      0|      });
   49|      0|}
   50|       |
   51|      0|- (FBLPromise<NSNull *> *)deleteExistingIID {
   52|      0|  return [FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   53|      0|                          do:^id _Nullable {
   54|      0|                            NSError *error;
   55|      0|                            if (![self deleteIIDFlagFromPlist:&error]) {
   56|      0|                              return error;
   57|      0|                            }
   58|      0|
   59|      0|                            if (![self deleteIID:&error]) {
   60|      0|                              return error;
   61|      0|                            }
   62|      0|
   63|      0|                            return [NSNull null];
   64|      0|                          }];
   65|      0|}
   66|       |
   67|       |#pragma mark - IID decoding
   68|       |
   69|      0|- (NSString *)IIDWithPublicKeyData:(NSData *)publicKeyData {
   70|      0|  NSData *publicKeySHA1 = [self sha1WithData:publicKeyData];
   71|      0|
   72|      0|  const uint8_t *bytes = publicKeySHA1.bytes;
   73|      0|  NSMutableData *identityData = [NSMutableData dataWithData:publicKeySHA1];
   74|      0|
   75|      0|  uint8_t b0 = bytes[0];
   76|      0|  // Take the first byte and make the initial four 7 by initially making the initial 4 bits 0
   77|      0|  // and then adding 0x70 to it.
   78|      0|  b0 = 0x70 + (0xF & b0);
   79|      0|  // failsafe should give you back b0 itself
   80|      0|  b0 = (b0 & 0xFF);
   81|      0|  [identityData replaceBytesInRange:NSMakeRange(0, 1) withBytes:&b0];
   82|      0|  NSData *data = [identityData subdataWithRange:NSMakeRange(0, 8 * sizeof(Byte))];
   83|      0|  return [self base64URLEncodedStringWithData:data];
   84|      0|}
   85|       |
   86|      0|- (NSData *)sha1WithData:(NSData *)data {
   87|      0|  unsigned char output[CC_SHA1_DIGEST_LENGTH];
   88|      0|  unsigned int length = (unsigned int)[data length];
   89|      0|
   90|      0|  CC_SHA1(data.bytes, length, output);
   91|      0|  return [NSData dataWithBytes:output length:CC_SHA1_DIGEST_LENGTH];
   92|      0|}
   93|       |
   94|      0|- (NSString *)base64URLEncodedStringWithData:(NSData *)data {
   95|      0|  NSString *string = [data base64EncodedStringWithOptions:0];
   96|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
   97|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
   98|      0|  string = [string stringByReplacingOccurrencesOfString:@"=" withString:@""];
   99|      0|  return string;
  100|      0|}
  101|       |
  102|       |#pragma mark - Keychain
  103|       |
  104|      0|- (NSData *)IIDPublicKeyData {
  105|      0|  NSString *tag = [self keychainKeyTagWithPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix];
  106|      0|  NSDictionary *query = [self keyPairQueryWithTag:tag returnData:YES];
  107|      0|
  108|      0|  CFTypeRef keyRef = NULL;
  109|      0|  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, (CFTypeRef *)&keyRef);
  110|      0|
  111|      0|  if (status != noErr) {
  112|      0|    if (keyRef) {
  113|      0|      CFRelease(keyRef);
  114|      0|    }
  115|      0|    return nil;
  116|      0|  }
  117|      0|
  118|      0|  return (__bridge NSData *)keyRef;
  119|      0|}
  120|       |
  121|      0|- (BOOL)deleteIID:(NSError **)outError {
  122|      0|  if (![self deleteKeychainKeyWithTagPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix
  123|      0|                                      error:outError]) {
  124|      0|    return NO;
  125|      0|  }
  126|      0|
  127|      0|  if (![self deleteKeychainKeyWithTagPrefix:kFIRInstallationsIIDKeyPairPrivateTagPrefix
  128|      0|                                      error:outError]) {
  129|      0|    return NO;
  130|      0|  }
  131|      0|
  132|      0|  return YES;
  133|      0|}
  134|       |
  135|      0|- (BOOL)deleteKeychainKeyWithTagPrefix:(NSString *)tagPrefix error:(NSError **)outError {
  136|      0|  NSString *keyTag = [self keychainKeyTagWithPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix];
  137|      0|  NSDictionary *keyQuery = [self keyPairQueryWithTag:keyTag returnData:NO];
  138|      0|
  139|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)keyQuery);
  140|      0|
  141|      0|  // When item is not found, it should NOT be considered as an error. The operation should
  142|      0|  // continue.
  143|      0|  if (status != noErr && status != errSecItemNotFound) {
  144|      0|    FIRInstallationsItemSetErrorToPointer(
  145|      0|        [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemDelete" status:status],
  146|      0|        outError);
  147|      0|    return NO;
  148|      0|  }
  149|      0|
  150|      0|  return YES;
  151|      0|}
  152|       |
  153|      0|- (NSDictionary *)keyPairQueryWithTag:(NSString *)tag returnData:(BOOL)shouldReturnData {
  154|      0|  NSMutableDictionary *query = [NSMutableDictionary dictionary];
  155|      0|  NSData *tagData = [tag dataUsingEncoding:NSUTF8StringEncoding];
  156|      0|
  157|      0|  query[(__bridge id)kSecClass] = (__bridge id)kSecClassKey;
  158|      0|  query[(__bridge id)kSecAttrApplicationTag] = tagData;
  159|      0|  query[(__bridge id)kSecAttrKeyType] = (__bridge id)kSecAttrKeyTypeRSA;
  160|      0|  if (shouldReturnData) {
  161|      0|    query[(__bridge id)kSecReturnData] = @(YES);
  162|      0|  }
  163|      0|
  164|       |#if TARGET_OS_OSX
  165|       |  if (self.keychainRef) {
  166|       |    query[(__bridge NSString *)kSecMatchSearchList] = @[ (__bridge id)(self.keychainRef) ];
  167|       |  }
  168|       |#endif  // TARGET_OSX
  169|       |
  170|      0|  return query;
  171|      0|}
  172|       |
  173|      0|- (NSString *)keychainKeyTagWithPrefix:(NSString *)prefix {
  174|      0|  NSString *mainAppBundleID = [[NSBundle mainBundle] bundleIdentifier];
  175|      0|  if (mainAppBundleID.length == 0) {
  176|      0|    return nil;
  177|      0|  }
  178|      0|  return [NSString stringWithFormat:@"%@%@", prefix, mainAppBundleID];
  179|      0|}
  180|       |
  181|      0|- (NSString *)mainbundleIdentifier {
  182|      0|  NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  183|      0|  if (!bundleIdentifier.length) {
  184|      0|    return nil;
  185|      0|  }
  186|      0|  return bundleIdentifier;
  187|      0|}
  188|       |
  189|       |#pragma mark - Plist
  190|       |
  191|      0|- (BOOL)deleteIIDFlagFromPlist:(NSError **)outError {
  192|      0|  NSString *path = [self plistPath];
  193|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
  194|      0|    return YES;
  195|      0|  }
  196|      0|
  197|      0|  NSMutableDictionary *plistContent = [[NSMutableDictionary alloc] initWithContentsOfFile:path];
  198|      0|  plistContent[kFIRInstallationsIIDCreationTimePlistKey] = nil;
  199|      0|
  200|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  201|      0|    return [plistContent writeToURL:[NSURL fileURLWithPath:path] error:outError];
  202|      0|  }
  203|      0|
  204|      0|  return [plistContent writeToFile:path atomically:YES];
  205|      0|}
  206|       |
  207|      0|- (BOOL)hasPlistIIDFlag {
  208|      0|  NSString *path = [self plistPath];
  209|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
  210|      0|    return NO;
  211|      0|  }
  212|      0|
  213|      0|  NSDictionary *plistContent = [[NSDictionary alloc] initWithContentsOfFile:path];
  214|      0|  return plistContent[kFIRInstallationsIIDCreationTimePlistKey] != nil;
  215|      0|}
  216|       |
  217|      0|- (NSString *)plistPath {
  218|      0|  NSString *plistNameWithExtension = @"com.google.iid-keypair.plist";
  219|      0|  NSString *_subDirectoryName = @"Google/FirebaseInstanceID";
  220|      0|
  221|      0|  NSArray *directoryPaths =
  222|      0|      NSSearchPathForDirectoriesInDomains([self supportedDirectory], NSUserDomainMask, YES);
  223|      0|  NSArray *components = @[ directoryPaths.lastObject, _subDirectoryName, plistNameWithExtension ];
  224|      0|
  225|      0|  return [NSString pathWithComponents:components];
  226|      0|}
  227|       |
  228|      0|- (NSSearchPathDirectory)supportedDirectory {
  229|       |#if TARGET_OS_TV
  230|       |  return NSCachesDirectory;
  231|       |#else
  232|       |  return NSApplicationSupportDirectory;
  233|      0|#endif
  234|      0|}
  235|       |
  236|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDTokenStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsIIDTokenStore.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "FIRInstallationsErrorUtil.h"
   26|       |#import "FIRInstallationsKeychainUtils.h"
   27|       |
   28|       |static NSString *const kFIRInstallationsIIDTokenKeychainId = @"com.google.iid-tokens";
   29|       |
   30|       |@interface FIRInstallationsIIDTokenInfo : NSObject <NSSecureCoding>
   31|       |@property(nonatomic, nullable, copy) NSString *token;
   32|       |@end
   33|       |
   34|       |@implementation FIRInstallationsIIDTokenInfo
   35|       |
   36|      0|+ (BOOL)supportsSecureCoding {
   37|      0|  return YES;
   38|      0|}
   39|       |
   40|      0|- (void)encodeWithCoder:(nonnull NSCoder *)coder {
   41|      0|}
   42|       |
   43|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)coder {
   44|      0|  self = [super init];
   45|      0|  if (self) {
   46|      0|    _token = [coder decodeObjectOfClass:[NSString class] forKey:@"token"];
   47|      0|  }
   48|      0|  return self;
   49|      0|}
   50|       |
   51|       |@end
   52|       |
   53|       |@interface FIRInstallationsIIDTokenStore ()
   54|       |@property(nonatomic, readonly) NSString *GCMSenderID;
   55|       |@end
   56|       |
   57|       |@implementation FIRInstallationsIIDTokenStore
   58|       |
   59|      1|- (instancetype)initWithGCMSenderID:(NSString *)GCMSenderID {
   60|      1|  self = [super init];
   61|      1|  if (self) {
   62|      1|    _GCMSenderID = GCMSenderID;
   63|      1|  }
   64|      1|  return self;
   65|      1|}
   66|       |
   67|      0|- (FBLPromise<NSString *> *)existingIIDDefaultToken {
   68|      0|  return [[FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   69|      0|                           do:^id _Nullable {
   70|      0|                             return [self IIDDefaultTokenData];
   71|      0|                           }] onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   72|      0|                                 then:^id _Nullable(NSData *_Nullable keychainData) {
   73|      0|                                   return [self IIDCheckinWithData:keychainData];
   74|      0|                                 }];
   75|      0|}
   76|       |
   77|      0|- (FBLPromise<NSString *> *)IIDCheckinWithData:(NSData *)data {
   78|      0|  FBLPromise<NSString *> *resultPromise = [FBLPromise pendingPromise];
   79|      0|
   80|      0|  NSError *archiverError;
   81|      0|  NSKeyedUnarchiver *unarchiver;
   82|      0|  if (@available(iOS 11.0, tvOS 11.0, macOS 10.13, *)) {
   83|      0|    unarchiver = [[NSKeyedUnarchiver alloc] initForReadingFromData:data error:&archiverError];
   84|      0|  } else {
   85|      0|    @try {
   86|      0|#pragma clang diagnostic push
   87|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   88|      0|      unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   89|      0|#pragma clang diagnostic pop
   90|      0|    } @catch (NSException *exception) {
   91|      0|      archiverError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
   92|      0|    }
   93|      0|  }
   94|      0|
   95|      0|  if (!unarchiver) {
   96|      0|    NSError *error = archiverError ?: [FIRInstallationsErrorUtil corruptedIIDTokenData];
   97|      0|    [resultPromise reject:error];
   98|      0|    return resultPromise;
   99|      0|  }
  100|      0|
  101|      0|  [unarchiver setClass:[FIRInstallationsIIDTokenInfo class] forClassName:@"FIRInstanceIDTokenInfo"];
  102|      0|  FIRInstallationsIIDTokenInfo *IIDTokenInfo =
  103|      0|      [unarchiver decodeObjectOfClass:[FIRInstallationsIIDTokenInfo class]
  104|      0|                               forKey:NSKeyedArchiveRootObjectKey];
  105|      0|
  106|      0|  if (IIDTokenInfo.token.length < 1) {
  107|      0|    [resultPromise reject:[FIRInstallationsErrorUtil corruptedIIDTokenData]];
  108|      0|    return resultPromise;
  109|      0|  }
  110|      0|
  111|      0|  [resultPromise fulfill:IIDTokenInfo.token];
  112|      0|
  113|      0|  return resultPromise;
  114|      0|}
  115|       |
  116|      0|- (FBLPromise<NSData *> *)IIDDefaultTokenData {
  117|      0|  FBLPromise<NSData *> *resultPromise = [FBLPromise pendingPromise];
  118|      0|
  119|      0|  NSMutableDictionary *keychainQuery = [self IIDDefaultTokenDataKeychainQuery];
  120|      0|  NSError *error;
  121|      0|  NSData *data = [FIRInstallationsKeychainUtils getItemWithQuery:keychainQuery error:&error];
  122|      0|
  123|      0|  if (data) {
  124|      0|    [resultPromise fulfill:data];
  125|      0|    return resultPromise;
  126|      0|  } else {
  127|      0|    NSError *outError = error ?: [FIRInstallationsErrorUtil corruptedIIDTokenData];
  128|      0|    [resultPromise reject:outError];
  129|      0|    return resultPromise;
  130|      0|  }
  131|      0|}
  132|       |
  133|      0|- (NSMutableDictionary *)IIDDefaultTokenDataKeychainQuery {
  134|      0|  NSDictionary *query = @{(__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword};
  135|      0|
  136|      0|  NSMutableDictionary *finalQuery = [NSMutableDictionary dictionaryWithDictionary:query];
  137|      0|  finalQuery[(__bridge NSString *)kSecAttrGeneric] = kFIRInstallationsIIDTokenKeychainId;
  138|      0|
  139|      0|  NSString *account = [self IIDAppIdentifier];
  140|      0|  if ([account length]) {
  141|      0|    finalQuery[(__bridge NSString *)kSecAttrAccount] = account;
  142|      0|  }
  143|      0|
  144|      0|  finalQuery[(__bridge NSString *)kSecAttrService] =
  145|      0|      [self serviceKeyForAuthorizedEntity:self.GCMSenderID scope:@"*"];
  146|      0|  return finalQuery;
  147|      0|}
  148|       |
  149|      0|- (NSString *)IIDAppIdentifier {
  150|      0|  return [[NSBundle mainBundle] bundleIdentifier] ?: @"";
  151|      0|}
  152|       |
  153|      0|- (NSString *)serviceKeyForAuthorizedEntity:(NSString *)authorizedEntity scope:(NSString *)scope {
  154|      0|  return [NSString stringWithFormat:@"%@:%@", authorizedEntity, scope];
  155|      0|}
  156|       |
  157|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsAPIService.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsAPIService.h"
   18|       |
   19|       |#import <FirebaseInstallations/FIRInstallationsVersion.h>
   20|       |
   21|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   22|       |#import <FBLPromises/FBLPromises.h>
   23|       |#else
   24|       |#import "FBLPromises.h"
   25|       |#endif
   26|       |
   27|       |#import <FirebaseCore/FIRAppInternal.h>
   28|       |#import <FirebaseCore/FIRHeartbeatInfo.h>
   29|       |#import "FIRInstallationsErrorUtil.h"
   30|       |#import "FIRInstallationsItem+RegisterInstallationAPI.h"
   31|       |#import "FIRInstallationsLogger.h"
   32|       |
   33|       |NSString *const kFIRInstallationsAPIBaseURL = @"https://firebaseinstallations.googleapis.com";
   34|       |NSString *const kFIRInstallationsAPIKey = @"X-Goog-Api-Key";
   35|       |NSString *const kFIRInstallationsBundleId = @"X-Ios-Bundle-Identifier";
   36|       |NSString *const kFIRInstallationsIIDMigrationAuthHeader = @"x-goog-fis-ios-iid-migration-auth";
   37|       |NSString *const kFIRInstallationsHeartbeatKey = @"X-firebase-client-log-type";
   38|       |NSString *const kFIRInstallationsHeartbeatTag = @"fire-installations";
   39|       |NSString *const kFIRInstallationsUserAgentKey = @"X-firebase-client";
   40|       |
   41|       |NS_ASSUME_NONNULL_BEGIN
   42|       |
   43|       |@interface FIRInstallationsURLSessionResponse : NSObject
   44|       |@property(nonatomic) NSHTTPURLResponse *HTTPResponse;
   45|       |@property(nonatomic) NSData *data;
   46|       |
   47|       |- (instancetype)initWithResponse:(NSHTTPURLResponse *)response data:(nullable NSData *)data;
   48|       |@end
   49|       |
   50|       |@implementation FIRInstallationsURLSessionResponse
   51|       |
   52|      0|- (instancetype)initWithResponse:(NSHTTPURLResponse *)response data:(nullable NSData *)data {
   53|      0|  self = [super init];
   54|      0|  if (self) {
   55|      0|    _HTTPResponse = response;
   56|      0|    _data = data ?: [NSData data];
   57|      0|  }
   58|      0|  return self;
   59|      0|}
   60|       |
   61|       |@end
   62|       |
   63|       |@interface FIRInstallationsAPIService ()
   64|       |@property(nonatomic, readonly) NSURLSession *URLSession;
   65|       |@property(nonatomic, readonly) NSString *APIKey;
   66|       |@property(nonatomic, readonly) NSString *projectID;
   67|       |@end
   68|       |
   69|       |NS_ASSUME_NONNULL_END
   70|       |
   71|       |@implementation FIRInstallationsAPIService
   72|       |
   73|      1|- (instancetype)initWithAPIKey:(NSString *)APIKey projectID:(NSString *)projectID {
   74|      1|  NSURLSession *URLSession = [NSURLSession
   75|      1|      sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
   76|      1|  return [self initWithURLSession:URLSession APIKey:APIKey projectID:projectID];
   77|      1|}
   78|       |
   79|       |/// The initializer for tests.
   80|       |- (instancetype)initWithURLSession:(NSURLSession *)URLSession
   81|       |                            APIKey:(NSString *)APIKey
   82|      1|                         projectID:(NSString *)projectID {
   83|      1|  self = [super init];
   84|      1|  if (self) {
   85|      1|    _URLSession = URLSession;
   86|      1|    _APIKey = [APIKey copy];
   87|      1|    _projectID = [projectID copy];
   88|      1|  }
   89|      1|  return self;
   90|      1|}
   91|       |
   92|       |#pragma mark - Public
   93|       |
   94|      1|- (FBLPromise<FIRInstallationsItem *> *)registerInstallation:(FIRInstallationsItem *)installation {
   95|      1|  NSURLRequest *request = [self registerRequestWithInstallation:installation];
   96|      1|  return [self sendURLRequest:request].then(
   97|      1|      ^id _Nullable(FIRInstallationsURLSessionResponse *response) {
   98|      0|        return [self registeredInstallationWithInstallation:installation serverResponse:response];
   99|      0|      });
  100|      1|}
  101|       |
  102|       |- (FBLPromise<FIRInstallationsItem *> *)refreshAuthTokenForInstallation:
  103|      0|    (FIRInstallationsItem *)installation {
  104|      0|  NSURLRequest *request = [self authTokenRequestWithInstallation:installation];
  105|      0|  return [self sendURLRequest:request]
  106|      0|      .then(^FBLPromise<FIRInstallationsStoredAuthToken *> *(
  107|      0|          FIRInstallationsURLSessionResponse *response) {
  108|      0|        return [self authTokenWithServerResponse:response];
  109|      0|      })
  110|      0|      .then(^FIRInstallationsItem *(FIRInstallationsStoredAuthToken *authToken) {
  111|      0|        FIRInstallationsItem *updatedInstallation = [installation copy];
  112|      0|        updatedInstallation.authToken = authToken;
  113|      0|        return updatedInstallation;
  114|      0|      });
  115|      0|}
  116|       |
  117|      0|- (FBLPromise<FIRInstallationsItem *> *)deleteInstallation:(FIRInstallationsItem *)installation {
  118|      0|  NSURLRequest *request = [self deleteInstallationRequestWithInstallation:installation];
  119|      0|  return [[self sendURLRequest:request]
  120|      0|      then:^id _Nullable(FIRInstallationsURLSessionResponse *_Nullable value) {
  121|      0|        // Return the original installation on success.
  122|      0|        return installation;
  123|      0|      }];
  124|      0|}
  125|       |
  126|       |#pragma mark - Register Installation
  127|       |
  128|      1|- (NSURLRequest *)registerRequestWithInstallation:(FIRInstallationsItem *)installation {
  129|      1|  NSString *URLString = [NSString stringWithFormat:@"%@/v1/projects/%@/installations/",
  130|      1|                                                   kFIRInstallationsAPIBaseURL, self.projectID];
  131|      1|  NSURL *URL = [NSURL URLWithString:URLString];
  132|      1|
  133|      1|  NSDictionary *bodyDict = @{
  134|      1|    @"fid" : installation.firebaseInstallationID,
  135|      1|    @"authVersion" : @"FIS_v2",
  136|      1|    @"appId" : installation.appID,
  137|      1|    @"sdkVersion" : [self SDKVersion]
  138|      1|  };
  139|      1|
  140|      1|  NSDictionary *headers;
  141|      1|  if (installation.IIDDefaultToken) {
  142|      0|    headers = @{kFIRInstallationsIIDMigrationAuthHeader : installation.IIDDefaultToken};
  143|      0|  }
  144|      1|
  145|      1|  return [self requestWithURL:URL
  146|      1|                   HTTPMethod:@"POST"
  147|      1|                     bodyDict:bodyDict
  148|      1|                 refreshToken:nil
  149|      1|            additionalHeaders:headers];
  150|      1|}
  151|       |
  152|       |- (FBLPromise<FIRInstallationsItem *> *)
  153|       |    registeredInstallationWithInstallation:(FIRInstallationsItem *)installation
  154|      0|                            serverResponse:(FIRInstallationsURLSessionResponse *)response {
  155|      0|  return [FBLPromise do:^id {
  156|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeParsingAPIResponse,
  157|      0|                @"Parsing server response for %@.", response.HTTPResponse.URL);
  158|      0|    NSError *error;
  159|      0|    FIRInstallationsItem *registeredInstallation =
  160|      0|        [installation registeredInstallationWithJSONData:response.data
  161|      0|                                                    date:[NSDate date]
  162|      0|                                                   error:&error];
  163|      0|    if (registeredInstallation == nil) {
  164|      0|      FIRLogDebug(kFIRLoggerInstallations,
  165|      0|                  kFIRInstallationsMessageCodeAPIResponseParsingInstallationFailed,
  166|      0|                  @"Failed to parse FIRInstallationsItem: %@.", error);
  167|      0|      return error;
  168|      0|    }
  169|      0|
  170|      0|    FIRLogDebug(kFIRLoggerInstallations,
  171|      0|                kFIRInstallationsMessageCodeAPIResponseParsingInstallationSucceed,
  172|      0|                @"FIRInstallationsItem parsed successfully.");
  173|      0|    return registeredInstallation;
  174|      0|  }];
  175|      0|}
  176|       |
  177|       |#pragma mark - Auth token
  178|       |
  179|      0|- (NSURLRequest *)authTokenRequestWithInstallation:(FIRInstallationsItem *)installation {
  180|      0|  NSString *URLString =
  181|      0|      [NSString stringWithFormat:@"%@/v1/projects/%@/installations/%@/authTokens:generate",
  182|      0|                                 kFIRInstallationsAPIBaseURL, self.projectID,
  183|      0|                                 installation.firebaseInstallationID];
  184|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  185|      0|
  186|      0|  NSDictionary *bodyDict = @{@"installation" : @{@"sdkVersion" : [self SDKVersion]}};
  187|      0|  return [self requestWithURL:URL
  188|      0|                   HTTPMethod:@"POST"
  189|      0|                     bodyDict:bodyDict
  190|      0|                 refreshToken:installation.refreshToken];
  191|      0|}
  192|       |
  193|       |- (FBLPromise<FIRInstallationsStoredAuthToken *> *)authTokenWithServerResponse:
  194|      0|    (FIRInstallationsURLSessionResponse *)response {
  195|      0|  return [FBLPromise do:^id {
  196|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeParsingAPIResponse,
  197|      0|                @"Parsing server response for %@.", response.HTTPResponse.URL);
  198|      0|    NSError *error;
  199|      0|    FIRInstallationsStoredAuthToken *token =
  200|      0|        [FIRInstallationsItem authTokenWithGenerateTokenAPIJSONData:response.data
  201|      0|                                                               date:[NSDate date]
  202|      0|                                                              error:&error];
  203|      0|    if (token == nil) {
  204|      0|      FIRLogDebug(kFIRLoggerInstallations,
  205|      0|                  kFIRInstallationsMessageCodeAPIResponseParsingAuthTokenFailed,
  206|      0|                  @"Failed to parse FIRInstallationsStoredAuthToken: %@.", error);
  207|      0|      return error;
  208|      0|    }
  209|      0|
  210|      0|    FIRLogDebug(kFIRLoggerInstallations,
  211|      0|                kFIRInstallationsMessageCodeAPIResponseParsingAuthTokenSucceed,
  212|      0|                @"FIRInstallationsStoredAuthToken parsed successfully.");
  213|      0|    return token;
  214|      0|  }];
  215|      0|}
  216|       |
  217|       |#pragma mark - Delete Installation
  218|       |
  219|      0|- (NSURLRequest *)deleteInstallationRequestWithInstallation:(FIRInstallationsItem *)installation {
  220|      0|  NSString *URLString = [NSString stringWithFormat:@"%@/v1/projects/%@/installations/%@/",
  221|      0|                                                   kFIRInstallationsAPIBaseURL, self.projectID,
  222|      0|                                                   installation.firebaseInstallationID];
  223|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  224|      0|
  225|      0|  return [self requestWithURL:URL
  226|      0|                   HTTPMethod:@"DELETE"
  227|      0|                     bodyDict:@{}
  228|      0|                 refreshToken:installation.refreshToken];
  229|      0|}
  230|       |
  231|       |#pragma mark - URL Request
  232|       |- (NSURLRequest *)requestWithURL:(NSURL *)requestURL
  233|       |                      HTTPMethod:(NSString *)HTTPMethod
  234|       |                        bodyDict:(NSDictionary *)bodyDict
  235|      0|                    refreshToken:(nullable NSString *)refreshToken {
  236|      0|  return [self requestWithURL:requestURL
  237|      0|                   HTTPMethod:HTTPMethod
  238|      0|                     bodyDict:bodyDict
  239|      0|                 refreshToken:refreshToken
  240|      0|            additionalHeaders:nil];
  241|      0|}
  242|       |
  243|       |- (NSURLRequest *)requestWithURL:(NSURL *)requestURL
  244|       |                      HTTPMethod:(NSString *)HTTPMethod
  245|       |                        bodyDict:(NSDictionary *)bodyDict
  246|       |                    refreshToken:(nullable NSString *)refreshToken
  247|       |               additionalHeaders:
  248|      1|                   (nullable NSDictionary<NSString *, NSString *> *)additionalHeaders {
  249|      1|  __block NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:requestURL];
  250|      1|  request.HTTPMethod = HTTPMethod;
  251|      1|  NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  252|      1|  [request addValue:self.APIKey forHTTPHeaderField:kFIRInstallationsAPIKey];
  253|      1|  [request addValue:bundleIdentifier forHTTPHeaderField:kFIRInstallationsBundleId];
  254|      1|  [self setJSONHTTPBody:bodyDict forRequest:request];
  255|      1|  if (refreshToken) {
  256|      0|    NSString *authHeader = [NSString stringWithFormat:@"FIS_v2 %@", refreshToken];
  257|      0|    [request setValue:authHeader forHTTPHeaderField:@"Authorization"];
  258|      0|  }
  259|      1|  // User agent Header.
  260|      1|  [request setValue:[FIRApp firebaseUserAgent] forHTTPHeaderField:kFIRInstallationsUserAgentKey];
  261|      1|  // Heartbeat Header.
  262|      1|  [request setValue:@([FIRHeartbeatInfo heartbeatCodeForTag:kFIRInstallationsHeartbeatTag])
  263|      1|                        .stringValue
  264|      1|      forHTTPHeaderField:kFIRInstallationsHeartbeatKey];
  265|      1|  [additionalHeaders enumerateKeysAndObjectsUsingBlock:^(
  266|      1|                         NSString *_Nonnull key, NSString *_Nonnull obj, BOOL *_Nonnull stop) {
  267|      0|    [request setValue:obj forHTTPHeaderField:key];
  268|      0|  }];
  269|      1|
  270|      1|  return [request copy];
  271|      1|}
  272|       |
  273|      1|- (FBLPromise<FIRInstallationsURLSessionResponse *> *)URLRequestPromise:(NSURLRequest *)request {
  274|      1|  return [[FBLPromise async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  275|      1|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeSendAPIRequest,
  276|      1|                @"Sending request: %@, body:%@, headers: %@.", request,
  277|      1|                [[NSString alloc] initWithData:request.HTTPBody encoding:NSUTF8StringEncoding],
  278|      1|                request.allHTTPHeaderFields);
  279|      1|    [[self.URLSession
  280|      1|        dataTaskWithRequest:request
  281|      1|          completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response,
  282|      1|                              NSError *_Nullable error) {
  283|      0|            if (error) {
  284|      0|              FIRLogDebug(kFIRLoggerInstallations,
  285|      0|                          kFIRInstallationsMessageCodeAPIRequestNetworkError,
  286|      0|                          @"Request failed: %@, error: %@.", request, error);
  287|      0|              reject(error);
  288|      0|            } else {
  289|      0|              FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeAPIRequestResponse,
  290|      0|                          @"Request response received: %@, error: %@, body: %@.", request, error,
  291|      0|                          [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
  292|      0|              fulfill([[FIRInstallationsURLSessionResponse alloc]
  293|      0|                  initWithResponse:(NSHTTPURLResponse *)response
  294|      0|                              data:data]);
  295|      0|            }
  296|      0|          }] resume];
  297|      1|  }] then:^id _Nullable(FIRInstallationsURLSessionResponse *response) {
  298|      0|    return [self validateHTTPResponseStatusCode:response];
  299|      0|  }];
  300|      1|}
  301|       |
  302|       |- (FBLPromise<FIRInstallationsURLSessionResponse *> *)validateHTTPResponseStatusCode:
  303|      0|    (FIRInstallationsURLSessionResponse *)response {
  304|      0|  NSInteger statusCode = response.HTTPResponse.statusCode;
  305|      0|  return [FBLPromise do:^id _Nullable {
  306|      0|    if (statusCode < 200 || statusCode >= 300) {
  307|      0|      FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeUnexpectedAPIRequestResponse,
  308|      0|                  @"Unexpected API response: %@, body: %@.", response.HTTPResponse,
  309|      0|                  [[NSString alloc] initWithData:response.data encoding:NSUTF8StringEncoding]);
  310|      0|      return [FIRInstallationsErrorUtil APIErrorWithHTTPResponse:response.HTTPResponse
  311|      0|                                                            data:response.data];
  312|      0|    }
  313|      0|    return response;
  314|      0|  }];
  315|      0|}
  316|       |
  317|      1|- (FBLPromise<FIRInstallationsURLSessionResponse *> *)sendURLRequest:(NSURLRequest *)request {
  318|      1|  return [FBLPromise attempts:1
  319|      1|      delay:1
  320|      1|      condition:^BOOL(NSInteger remainingAttempts, NSError *_Nonnull error) {
  321|      0|        return [FIRInstallationsErrorUtil isAPIError:error withHTTPCode:500];
  322|      0|      }
  323|      1|      retry:^id _Nullable {
  324|      1|        return [self URLRequestPromise:request];
  325|      1|      }];
  326|      1|}
  327|       |
  328|      1|- (NSString *)SDKVersion {
  329|      1|  return [NSString stringWithFormat:@"i:%s", FIRInstallationsVersionStr];
  330|      1|}
  331|       |
  332|       |#pragma mark - JSON
  333|       |
  334|       |- (void)setJSONHTTPBody:(NSDictionary<NSString *, id> *)body
  335|      1|             forRequest:(NSMutableURLRequest *)request {
  336|      1|  [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
  337|      1|
  338|      1|  NSError *error;
  339|      1|  NSData *JSONData = [NSJSONSerialization dataWithJSONObject:body options:0 error:&error];
  340|      1|  if (JSONData == nil) {
  341|      0|    // TODO: Log or return an error.
  342|      0|  }
  343|      1|  request.HTTPBody = JSONData;
  344|      1|}
  345|       |
  346|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsItem+RegisterInstallationAPI.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsItem+RegisterInstallationAPI.h"
   18|       |
   19|       |#import "FIRInstallationsErrorUtil.h"
   20|       |#import "FIRInstallationsStoredAuthToken.h"
   21|       |
   22|       |@implementation FIRInstallationsItem (RegisterInstallationAPI)
   23|       |
   24|       |- (nullable FIRInstallationsItem *)
   25|       |    registeredInstallationWithJSONData:(NSData *)data
   26|       |                                  date:(NSDate *)date
   27|      0|                                 error:(NSError *__autoreleasing _Nullable *_Nullable)outError {
   28|      0|  NSDictionary *responseJSON = [FIRInstallationsItem dictionaryFromJSONData:data error:outError];
   29|      0|  if (!responseJSON) {
   30|      0|    return nil;
   31|      0|  }
   32|      0|
   33|      0|  NSString *refreshToken = [FIRInstallationsItem validStringOrNilForKey:@"refreshToken"
   34|      0|                                                               fromDict:responseJSON];
   35|      0|  if (refreshToken == nil) {
   36|      0|    FIRInstallationsItemSetErrorToPointer(
   37|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"refreshToken"],
   38|      0|        outError);
   39|      0|    return nil;
   40|      0|  }
   41|      0|
   42|      0|  NSDictionary *authTokenDict = responseJSON[@"authToken"];
   43|      0|  if (![authTokenDict isKindOfClass:[NSDictionary class]]) {
   44|      0|    FIRInstallationsItemSetErrorToPointer(
   45|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"authToken"],
   46|      0|        outError);
   47|      0|    return nil;
   48|      0|  }
   49|      0|
   50|      0|  FIRInstallationsStoredAuthToken *authToken =
   51|      0|      [FIRInstallationsItem authTokenWithJSONDict:authTokenDict date:date error:outError];
   52|      0|  if (authToken == nil) {
   53|      0|    return nil;
   54|      0|  }
   55|      0|
   56|      0|  FIRInstallationsItem *installation =
   57|      0|      [[FIRInstallationsItem alloc] initWithAppID:self.appID firebaseAppName:self.firebaseAppName];
   58|      0|  NSString *installationID = [FIRInstallationsItem validStringOrNilForKey:@"fid"
   59|      0|                                                                 fromDict:responseJSON];
   60|      0|  installation.firebaseInstallationID = installationID ?: self.firebaseInstallationID;
   61|      0|  installation.refreshToken = refreshToken;
   62|      0|  installation.authToken = authToken;
   63|      0|  installation.registrationStatus = FIRInstallationStatusRegistered;
   64|      0|
   65|      0|  return installation;
   66|      0|}
   67|       |
   68|       |#pragma mark - Auth token
   69|       |
   70|       |+ (nullable FIRInstallationsStoredAuthToken *)authTokenWithGenerateTokenAPIJSONData:(NSData *)data
   71|       |                                                                               date:(NSDate *)date
   72|       |                                                                              error:(NSError **)
   73|      0|                                                                                        outError {
   74|      0|  NSDictionary *dict = [self dictionaryFromJSONData:data error:outError];
   75|      0|  if (!dict) {
   76|      0|    return nil;
   77|      0|  }
   78|      0|
   79|      0|  return [self authTokenWithJSONDict:dict date:date error:outError];
   80|      0|}
   81|       |
   82|       |+ (nullable FIRInstallationsStoredAuthToken *)authTokenWithJSONDict:
   83|       |                                                  (NSDictionary<NSString *, id> *)dict
   84|       |                                                               date:(NSDate *)date
   85|      0|                                                              error:(NSError **)outError {
   86|      0|  NSString *token = [self validStringOrNilForKey:@"token" fromDict:dict];
   87|      0|  if (token == nil) {
   88|      0|    FIRInstallationsItemSetErrorToPointer(
   89|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"authToken.token"],
   90|      0|        outError);
   91|      0|    return nil;
   92|      0|  }
   93|      0|
   94|      0|  NSString *expiresInString = [self validStringOrNilForKey:@"expiresIn" fromDict:dict];
   95|      0|  if (expiresInString == nil) {
   96|      0|    FIRInstallationsItemSetErrorToPointer(
   97|      0|        [FIRInstallationsErrorUtil
   98|      0|            FIDRegistrationErrorWithResponseMissingField:@"authToken.expiresIn"],
   99|      0|        outError);
  100|      0|    return nil;
  101|      0|  }
  102|      0|
  103|      0|  // The response should contain the string in format like "604800s".
  104|      0|  // The server should never response with anything else except seconds.
  105|      0|  // Just drop the last character and parse a number from string.
  106|      0|  NSString *expiresInSeconds = [expiresInString substringToIndex:expiresInString.length - 1];
  107|      0|  NSTimeInterval expiresIn = [expiresInSeconds doubleValue];
  108|      0|  NSDate *expirationDate = [date dateByAddingTimeInterval:expiresIn];
  109|      0|
  110|      0|  FIRInstallationsStoredAuthToken *authToken = [[FIRInstallationsStoredAuthToken alloc] init];
  111|      0|  authToken.status = FIRInstallationsAuthTokenStatusTokenReceived;
  112|      0|  authToken.token = token;
  113|      0|  authToken.expirationDate = expirationDate;
  114|      0|
  115|      0|  return authToken;
  116|      0|}
  117|       |
  118|       |#pragma mark - JSON
  119|       |
  120|       |+ (nullable NSDictionary<NSString *, id> *)dictionaryFromJSONData:(NSData *)data
  121|      0|                                                            error:(NSError **)outError {
  122|      0|  NSError *error;
  123|      0|  NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
  124|      0|
  125|      0|  if (![responseJSON isKindOfClass:[NSDictionary class]]) {
  126|      0|    FIRInstallationsItemSetErrorToPointer([FIRInstallationsErrorUtil JSONSerializationError:error],
  127|      0|                                          outError);
  128|      0|    return nil;
  129|      0|  }
  130|      0|
  131|      0|  return responseJSON;
  132|      0|}
  133|       |
  134|      0|+ (NSString *)validStringOrNilForKey:(NSString *)key fromDict:(NSDictionary *)dict {
  135|      0|  NSString *string = dict[key];
  136|      0|  if ([string isKindOfClass:[NSString class]] && string.length > 0) {
  137|      0|    return string;
  138|      0|  }
  139|      0|  return nil;
  140|      0|}
  141|       |
  142|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsIDController.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsIDController.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRAppInternal.h>
   26|       |
   27|       |#import "FIRInstallationsAPIService.h"
   28|       |#import "FIRInstallationsErrorUtil.h"
   29|       |#import "FIRInstallationsIIDStore.h"
   30|       |#import "FIRInstallationsIIDTokenStore.h"
   31|       |#import "FIRInstallationsItem.h"
   32|       |#import "FIRInstallationsLogger.h"
   33|       |#import "FIRInstallationsSingleOperationPromiseCache.h"
   34|       |#import "FIRInstallationsStore.h"
   35|       |#import "FIRSecureStorage.h"
   36|       |
   37|       |#import "FIRInstallationsHTTPError.h"
   38|       |#import "FIRInstallationsStoredAuthToken.h"
   39|       |
   40|       |const NSNotificationName FIRInstallationIDDidChangeNotification =
   41|       |    @"FIRInstallationIDDidChangeNotification";
   42|       |NSString *const kFIRInstallationIDDidChangeNotificationAppNameKey =
   43|       |    @"FIRInstallationIDDidChangeNotification";
   44|       |
   45|       |NSTimeInterval const kFIRInstallationsTokenExpirationThreshold = 60 * 60;  // 1 hour.
   46|       |
   47|       |@interface FIRInstallationsIDController ()
   48|       |@property(nonatomic, readonly) NSString *appID;
   49|       |@property(nonatomic, readonly) NSString *appName;
   50|       |
   51|       |@property(nonatomic, readonly) FIRInstallationsStore *installationsStore;
   52|       |@property(nonatomic, readonly) FIRInstallationsIIDStore *IIDStore;
   53|       |@property(nonatomic, readonly) FIRInstallationsIIDTokenStore *IIDTokenStore;
   54|       |
   55|       |@property(nonatomic, readonly) FIRInstallationsAPIService *APIService;
   56|       |
   57|       |@property(nonatomic, readonly) FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *>
   58|       |    *getInstallationPromiseCache;
   59|       |@property(nonatomic, readonly)
   60|       |    FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *> *authTokenPromiseCache;
   61|       |@property(nonatomic, readonly) FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *>
   62|       |    *authTokenForcingRefreshPromiseCache;
   63|       |@property(nonatomic, readonly)
   64|       |    FIRInstallationsSingleOperationPromiseCache<NSNull *> *deleteInstallationPromiseCache;
   65|       |@end
   66|       |
   67|       |@implementation FIRInstallationsIDController
   68|       |
   69|       |- (instancetype)initWithGoogleAppID:(NSString *)appID
   70|       |                            appName:(NSString *)appName
   71|       |                             APIKey:(NSString *)APIKey
   72|       |                          projectID:(NSString *)projectID
   73|       |                        GCMSenderID:(NSString *)GCMSenderID
   74|      1|                        accessGroup:(NSString *)accessGroup {
   75|      1|  FIRSecureStorage *secureStorage = [[FIRSecureStorage alloc] init];
   76|      1|  FIRInstallationsStore *installationsStore =
   77|      1|      [[FIRInstallationsStore alloc] initWithSecureStorage:secureStorage accessGroup:accessGroup];
   78|      1|
   79|      1|  // Use `GCMSenderID` as project identifier when `projectID` is not available.
   80|      1|  NSString *APIServiceProjectID = (projectID.length > 0) ? projectID : GCMSenderID;
   81|      1|  FIRInstallationsAPIService *apiService =
   82|      1|      [[FIRInstallationsAPIService alloc] initWithAPIKey:APIKey projectID:APIServiceProjectID];
   83|      1|
   84|      1|  FIRInstallationsIIDStore *IIDStore = [[FIRInstallationsIIDStore alloc] init];
   85|      1|  FIRInstallationsIIDTokenStore *IIDCheckingStore =
   86|      1|      [[FIRInstallationsIIDTokenStore alloc] initWithGCMSenderID:GCMSenderID];
   87|      1|
   88|      1|  return [self initWithGoogleAppID:appID
   89|      1|                           appName:appName
   90|      1|                installationsStore:installationsStore
   91|      1|                        APIService:apiService
   92|      1|                          IIDStore:IIDStore
   93|      1|                     IIDTokenStore:IIDCheckingStore];
   94|      1|}
   95|       |
   96|       |/// The initializer is supposed to be used by tests to inject `installationsStore`.
   97|       |- (instancetype)initWithGoogleAppID:(NSString *)appID
   98|       |                            appName:(NSString *)appName
   99|       |                 installationsStore:(FIRInstallationsStore *)installationsStore
  100|       |                         APIService:(FIRInstallationsAPIService *)APIService
  101|       |                           IIDStore:(FIRInstallationsIIDStore *)IIDStore
  102|      1|                      IIDTokenStore:(FIRInstallationsIIDTokenStore *)IIDTokenStore {
  103|      1|  self = [super init];
  104|      1|  if (self) {
  105|      1|    _appID = appID;
  106|      1|    _appName = appName;
  107|      1|    _installationsStore = installationsStore;
  108|      1|    _APIService = APIService;
  109|      1|    _IIDStore = IIDStore;
  110|      1|    _IIDTokenStore = IIDTokenStore;
  111|      1|
  112|      1|    __weak FIRInstallationsIDController *weakSelf = self;
  113|      1|
  114|      1|    _getInstallationPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  115|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  116|      1|          FIRInstallationsIDController *strongSelf = weakSelf;
  117|      1|          return [strongSelf createGetInstallationItemPromise];
  118|      1|        }];
  119|      1|
  120|      1|    _authTokenPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  121|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  122|      1|          FIRInstallationsIDController *strongSelf = weakSelf;
  123|      1|          return [strongSelf installationWithValidAuthTokenForcingRefresh:NO];
  124|      1|        }];
  125|      1|
  126|      1|    _authTokenForcingRefreshPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  127|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  128|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  129|      0|          return [strongSelf installationWithValidAuthTokenForcingRefresh:YES];
  130|      0|        }];
  131|      1|
  132|      1|    _deleteInstallationPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  133|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  134|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  135|      0|          return [strongSelf createDeleteInstallationPromise];
  136|      0|        }];
  137|      1|  }
  138|      1|  return self;
  139|      1|}
  140|       |
  141|       |#pragma mark - Get Installation.
  142|       |
  143|      2|- (FBLPromise<FIRInstallationsItem *> *)getInstallationItem {
  144|      2|  return [self.getInstallationPromiseCache getExistingPendingOrCreateNewPromise];
  145|      2|}
  146|       |
  147|      1|- (FBLPromise<FIRInstallationsItem *> *)createGetInstallationItemPromise {
  148|      1|  FIRLogDebug(kFIRLoggerInstallations,
  149|      1|              kFIRInstallationsMessageCodeNewGetInstallationOperationCreated, @"%s, appName: %@",
  150|      1|              __PRETTY_FUNCTION__, self.appName);
  151|      1|
  152|      1|  FBLPromise<FIRInstallationsItem *> *installationItemPromise =
  153|      1|      [self getStoredInstallation].recover(^id(NSError *error) {
  154|      0|        return [self createAndSaveFID];
  155|      0|      });
  156|      1|
  157|      1|  // Initiate registration process on success if needed, but return the installation without waiting
  158|      1|  // for it.
  159|      1|  installationItemPromise.then(^id(FIRInstallationsItem *installation) {
  160|      1|    [self getAuthTokenForcingRefresh:NO];
  161|      1|    return nil;
  162|      1|  });
  163|      1|
  164|      1|  return installationItemPromise;
  165|      1|}
  166|       |
  167|      1|- (FBLPromise<FIRInstallationsItem *> *)getStoredInstallation {
  168|      1|  return [self.installationsStore installationForAppID:self.appID appName:self.appName].validate(
  169|      1|      ^BOOL(FIRInstallationsItem *installation) {
  170|      1|        BOOL isValid = NO;
  171|      1|        switch (installation.registrationStatus) {
  172|      1|          case FIRInstallationStatusUnregistered:
  173|      1|          case FIRInstallationStatusRegistered:
  174|      1|            isValid = YES;
  175|      1|            break;
  176|      1|
  177|      1|          case FIRInstallationStatusUnknown:
  178|      0|            isValid = NO;
  179|      0|            break;
  180|      1|        }
  181|      1|
  182|      1|        return isValid;
  183|      1|      });
  184|      1|}
  185|       |
  186|      0|- (FBLPromise<FIRInstallationsItem *> *)createAndSaveFID {
  187|      0|  return [self migrateOrGenerateInstallation]
  188|      0|      .then(^FBLPromise<FIRInstallationsItem *> *(FIRInstallationsItem *installation) {
  189|      0|        return [self saveInstallation:installation];
  190|      0|      })
  191|      0|      .then(^FIRInstallationsItem *(FIRInstallationsItem *installation) {
  192|      0|        [self postFIDDidChangeNotification];
  193|      0|        return installation;
  194|      0|      });
  195|      0|}
  196|       |
  197|      0|- (FBLPromise<FIRInstallationsItem *> *)saveInstallation:(FIRInstallationsItem *)installation {
  198|      0|  return [self.installationsStore saveInstallation:installation].then(
  199|      0|      ^FIRInstallationsItem *(NSNull *result) {
  200|      0|        return installation;
  201|      0|      });
  202|      0|}
  203|       |
  204|       |/**
  205|       | * Tries to migrate IID data stored by FirebaseInstanceID SDK or generates a new Installation ID if
  206|       | * not found.
  207|       | */
  208|      0|- (FBLPromise<FIRInstallationsItem *> *)migrateOrGenerateInstallation {
  209|      0|  if (![self isDefaultApp]) {
  210|      0|    // Existing IID should be used only for default FirebaseApp.
  211|      0|    FIRInstallationsItem *installation =
  212|      0|        [self createInstallationWithFID:[FIRInstallationsItem generateFID] IIDDefaultToken:nil];
  213|      0|    return [FBLPromise resolvedWith:installation];
  214|      0|  }
  215|      0|
  216|      0|  return [[[FBLPromise
  217|      0|      all:@[ [self.IIDStore existingIID], [self.IIDTokenStore existingIIDDefaultToken] ]]
  218|      0|      then:^id _Nullable(NSArray *_Nullable results) {
  219|      0|        NSString *existingIID = results[0];
  220|      0|        NSString *IIDDefaultToken = results[1];
  221|      0|
  222|      0|        return [self createInstallationWithFID:existingIID IIDDefaultToken:IIDDefaultToken];
  223|      0|      }] recover:^id _Nullable(NSError *_Nonnull error) {
  224|      0|    return [self createInstallationWithFID:[FIRInstallationsItem generateFID] IIDDefaultToken:nil];
  225|      0|  }];
  226|      0|}
  227|       |
  228|       |- (FIRInstallationsItem *)createInstallationWithFID:(NSString *)FID
  229|      0|                                    IIDDefaultToken:(nullable NSString *)IIDDefaultToken {
  230|      0|  FIRInstallationsItem *installation = [[FIRInstallationsItem alloc] initWithAppID:self.appID
  231|      0|                                                                   firebaseAppName:self.appName];
  232|      0|  installation.firebaseInstallationID = FID;
  233|      0|  installation.IIDDefaultToken = IIDDefaultToken;
  234|      0|  installation.registrationStatus = FIRInstallationStatusUnregistered;
  235|      0|  return installation;
  236|      0|}
  237|       |
  238|       |#pragma mark - FID registration
  239|       |
  240|       |- (FBLPromise<FIRInstallationsItem *> *)registerInstallationIfNeeded:
  241|      1|    (FIRInstallationsItem *)installation {
  242|      1|  switch (installation.registrationStatus) {
  243|      1|    case FIRInstallationStatusRegistered:
  244|      0|      // Already registered. Do nothing.
  245|      0|      return [FBLPromise resolvedWith:installation];
  246|      1|
  247|      1|    case FIRInstallationStatusUnknown:
  248|      1|    case FIRInstallationStatusUnregistered:
  249|      1|      // Registration required. Proceed.
  250|      1|      break;
  251|      1|  }
  252|      1|
  253|      1|  return [self.APIService registerInstallation:installation]
  254|      1|      .catch(^(NSError *_Nonnull error) {
  255|      0|        if ([self doesRegistrationErrorRequireConfigChange:error]) {
  256|      0|          FIRLogError(kFIRLoggerInstallations,
  257|      0|                      kFIRInstallationsMessageCodeInvalidFirebaseConfiguration,
  258|      0|                      @"Firebase Installation registration failed for app with name: %@, error: "
  259|      0|                      @"%@\nPlease make sure you use valid GoogleService-Info.plist",
  260|      0|                      self.appName, error);
  261|      0|        }
  262|      0|      })
  263|      1|      .then(^id(FIRInstallationsItem *registeredInstallation) {
  264|      0|        return [self saveInstallation:registeredInstallation];
  265|      0|      })
  266|      1|      .then(^FIRInstallationsItem *(FIRInstallationsItem *registeredInstallation) {
  267|      0|        // Server may respond with a different FID if the sent one cannot be accepted.
  268|      0|        if (![registeredInstallation.firebaseInstallationID
  269|      0|                isEqualToString:installation.firebaseInstallationID]) {
  270|      0|          [self postFIDDidChangeNotification];
  271|      0|        }
  272|      0|        return registeredInstallation;
  273|      0|      });
  274|      1|}
  275|       |
  276|      0|- (BOOL)doesRegistrationErrorRequireConfigChange:(NSError *)error {
  277|      0|  FIRInstallationsHTTPError *HTTPError = (FIRInstallationsHTTPError *)error;
  278|      0|  if (![HTTPError isKindOfClass:[FIRInstallationsHTTPError class]]) {
  279|      0|    return NO;
  280|      0|  }
  281|      0|
  282|      0|  switch (HTTPError.HTTPResponse.statusCode) {
  283|      0|    // These are the errors that require Firebase configuration change.
  284|      0|    case FIRInstallationsRegistrationHTTPCodeInvalidArgument:
  285|      0|    case FIRInstallationsRegistrationHTTPCodeInvalidAPIKey:
  286|      0|    case FIRInstallationsRegistrationHTTPCodeAPIKeyToProjectIDMismatch:
  287|      0|    case FIRInstallationsRegistrationHTTPCodeProjectNotFound:
  288|      0|      return YES;
  289|      0|
  290|      0|    default:
  291|      0|      return NO;
  292|      0|  }
  293|      0|}
  294|       |
  295|       |#pragma mark - Auth Token
  296|       |
  297|      2|- (FBLPromise<FIRInstallationsItem *> *)getAuthTokenForcingRefresh:(BOOL)forceRefresh {
  298|      2|  if (forceRefresh || [self.authTokenForcingRefreshPromiseCache getExistingPendingPromise] != nil) {
  299|      0|    return [self.authTokenForcingRefreshPromiseCache getExistingPendingOrCreateNewPromise];
  300|      2|  } else {
  301|      2|    return [self.authTokenPromiseCache getExistingPendingOrCreateNewPromise];
  302|      2|  }
  303|      2|}
  304|       |
  305|       |- (FBLPromise<FIRInstallationsItem *> *)installationWithValidAuthTokenForcingRefresh:
  306|      1|    (BOOL)forceRefresh {
  307|      1|  FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeNewGetAuthTokenOperationCreated,
  308|      1|              @"-[FIRInstallationsIDController installationWithValidAuthTokenForcingRefresh:%@], "
  309|      1|              @"appName: %@",
  310|      1|              @(forceRefresh), self.appName);
  311|      1|
  312|      1|  return [self getInstallationItem]
  313|      1|      .then(^FBLPromise<FIRInstallationsItem *> *(FIRInstallationsItem *installation) {
  314|      1|        return [self registerInstallationIfNeeded:installation];
  315|      1|      })
  316|      1|      .then(^id(FIRInstallationsItem *registeredInstallation) {
  317|      0|        BOOL isTokenExpiredOrExpiresSoon =
  318|      0|            [registeredInstallation.authToken.expirationDate timeIntervalSinceDate:[NSDate date]] <
  319|      0|            kFIRInstallationsTokenExpirationThreshold;
  320|      0|        if (forceRefresh || isTokenExpiredOrExpiresSoon) {
  321|      0|          return [self refreshAuthTokenForInstallation:registeredInstallation];
  322|      0|        } else {
  323|      0|          return registeredInstallation;
  324|      0|        }
  325|      0|      })
  326|      1|      .recover(^id(NSError *error) {
  327|      0|        return [self regenerateFIDOnRefreshTokenErrorIfNeeded:error];
  328|      0|      });
  329|      1|}
  330|       |
  331|       |- (FBLPromise<FIRInstallationsItem *> *)refreshAuthTokenForInstallation:
  332|      0|    (FIRInstallationsItem *)installation {
  333|      0|  return [[self.APIService refreshAuthTokenForInstallation:installation]
  334|      0|      then:^id _Nullable(FIRInstallationsItem *_Nullable refreshedInstallation) {
  335|      0|        return [self saveInstallation:refreshedInstallation];
  336|      0|      }];
  337|      0|}
  338|       |
  339|      0|- (id)regenerateFIDOnRefreshTokenErrorIfNeeded:(NSError *)error {
  340|      0|  if (![error isKindOfClass:[FIRInstallationsHTTPError class]]) {
  341|      0|    // No recovery possible. Return the same error.
  342|      0|    return error;
  343|      0|  }
  344|      0|
  345|      0|  FIRInstallationsHTTPError *HTTPError = (FIRInstallationsHTTPError *)error;
  346|      0|  switch (HTTPError.HTTPResponse.statusCode) {
  347|      0|    case FIRInstallationsAuthTokenHTTPCodeInvalidAuthentication:
  348|      0|    case FIRInstallationsAuthTokenHTTPCodeFIDNotFound:
  349|      0|      // The stored installation was damaged or blocked by the server.
  350|      0|      // Delete the stored installation then generate and register a new one.
  351|      0|      return [self getInstallationItem]
  352|      0|          .then(^FBLPromise<NSNull *> *(FIRInstallationsItem *installation) {
  353|      0|            return [self deleteInstallationLocally:installation];
  354|      0|          })
  355|      0|          .then(^FBLPromise<FIRInstallationsItem *> *(id result) {
  356|      0|            return [self installationWithValidAuthTokenForcingRefresh:NO];
  357|      0|          });
  358|      0|
  359|      0|    default:
  360|      0|      // No recovery possible. Return the same error.
  361|      0|      return error;
  362|      0|  }
  363|      0|}
  364|       |
  365|       |#pragma mark - Delete FID
  366|       |
  367|      0|- (FBLPromise<NSNull *> *)deleteInstallation {
  368|      0|  return [self.deleteInstallationPromiseCache getExistingPendingOrCreateNewPromise];
  369|      0|}
  370|       |
  371|      0|- (FBLPromise<NSNull *> *)createDeleteInstallationPromise {
  372|      0|  FIRLogDebug(kFIRLoggerInstallations,
  373|      0|              kFIRInstallationsMessageCodeNewDeleteInstallationOperationCreated, @"%s, appName: %@",
  374|      0|              __PRETTY_FUNCTION__, self.appName);
  375|      0|
  376|      0|  // Check for ongoing requests first, if there is no a request, then check local storage for
  377|      0|  // existing installation.
  378|      0|  FBLPromise<FIRInstallationsItem *> *currentInstallationPromise =
  379|      0|      [self mostRecentInstallationOperation] ?: [self getStoredInstallation];
  380|      0|
  381|      0|  return currentInstallationPromise
  382|      0|      .then(^id(FIRInstallationsItem *installation) {
  383|      0|        return [self sendDeleteInstallationRequestIfNeeded:installation];
  384|      0|      })
  385|      0|      .then(^id(FIRInstallationsItem *installation) {
  386|      0|        // Remove the installation from the local storage.
  387|      0|        return [self deleteInstallationLocally:installation];
  388|      0|      });
  389|      0|}
  390|       |
  391|      0|- (FBLPromise<NSNull *> *)deleteInstallationLocally:(FIRInstallationsItem *)installation {
  392|      0|  return [self.installationsStore removeInstallationForAppID:installation.appID
  393|      0|                                                     appName:installation.firebaseAppName]
  394|      0|      .then(^FBLPromise<NSNull *> *(NSNull *result) {
  395|      0|        return [self deleteExistingIIDIfNeeded];
  396|      0|      })
  397|      0|      .then(^NSNull *(NSNull *result) {
  398|      0|        [self postFIDDidChangeNotification];
  399|      0|        return result;
  400|      0|      });
  401|      0|}
  402|       |
  403|       |- (FBLPromise<FIRInstallationsItem *> *)sendDeleteInstallationRequestIfNeeded:
  404|      0|    (FIRInstallationsItem *)installation {
  405|      0|  switch (installation.registrationStatus) {
  406|      0|    case FIRInstallationStatusUnknown:
  407|      0|    case FIRInstallationStatusUnregistered:
  408|      0|      // The installation is not registered, so it is safe to be deleted as is, so return early.
  409|      0|      return [FBLPromise resolvedWith:installation];
  410|      0|      break;
  411|      0|
  412|      0|    case FIRInstallationStatusRegistered:
  413|      0|      // Proceed to de-register the installation on the server.
  414|      0|      break;
  415|      0|  }
  416|      0|
  417|      0|  return [self.APIService deleteInstallation:installation].recover(^id(NSError *APIError) {
  418|      0|    if ([FIRInstallationsErrorUtil isAPIError:APIError withHTTPCode:404]) {
  419|      0|      // The installation was not found on the server.
  420|      0|      // Return success.
  421|      0|      return installation;
  422|      0|    } else {
  423|      0|      // Re-throw the error otherwise.
  424|      0|      return APIError;
  425|      0|    }
  426|      0|  });
  427|      0|}
  428|       |
  429|      0|- (FBLPromise<NSNull *> *)deleteExistingIIDIfNeeded {
  430|      0|  if ([self isDefaultApp]) {
  431|      0|    return [self.IIDStore deleteExistingIID];
  432|      0|  } else {
  433|      0|    return [FBLPromise resolvedWith:[NSNull null]];
  434|      0|  }
  435|      0|}
  436|       |
  437|      0|- (nullable FBLPromise<FIRInstallationsItem *> *)mostRecentInstallationOperation {
  438|      0|  return [self.authTokenForcingRefreshPromiseCache getExistingPendingPromise]
  439|      0|             ?: [self.authTokenPromiseCache getExistingPendingPromise]
  440|      0|                    ?: [self.getInstallationPromiseCache getExistingPendingPromise];
  441|      0|}
  442|       |
  443|       |#pragma mark - Notifications
  444|       |
  445|      0|- (void)postFIDDidChangeNotification {
  446|      0|  [[NSNotificationCenter defaultCenter]
  447|      0|      postNotificationName:FIRInstallationIDDidChangeNotification
  448|      0|                    object:nil
  449|      0|                  userInfo:@{kFIRInstallationIDDidChangeNotificationAppNameKey : self.appName}];
  450|      0|}
  451|       |
  452|       |#pragma mark - Default App
  453|       |
  454|      0|- (BOOL)isDefaultApp {
  455|      0|  return [self.appName isEqualToString:kFIRDefaultAppName];
  456|      0|}
  457|       |
  458|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsSingleOperationPromiseCache.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsSingleOperationPromiseCache.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |@interface FIRInstallationsSingleOperationPromiseCache <ResultType>()
   26|       |@property(nonatomic, readonly) FBLPromise *_Nonnull (^newOperationHandler)(void);
   27|       |@property(nonatomic, nullable) FBLPromise *pendingPromise;
   28|       |@end
   29|       |
   30|       |@implementation FIRInstallationsSingleOperationPromiseCache
   31|       |
   32|       |- (instancetype)initWithNewOperationHandler:
   33|      4|    (FBLPromise<id> *_Nonnull (^)(void))newOperationHandler {
   34|      4|  if (newOperationHandler == nil) {
   35|      0|    [NSException raise:NSInvalidArgumentException
   36|      0|                format:@"`newOperationHandler` must not be `nil`."];
   37|      0|  }
   38|      4|
   39|      4|  self = [super init];
   40|      4|  if (self) {
   41|      4|    _newOperationHandler = [newOperationHandler copy];
   42|      4|  }
   43|      4|  return self;
   44|      4|}
   45|       |
   46|      4|- (FBLPromise *)getExistingPendingOrCreateNewPromise {
   47|      4|  @synchronized(self) {
   48|      4|    if (!self.pendingPromise) {
   49|      2|      self.pendingPromise = self.newOperationHandler();
   50|      2|
   51|      2|      self.pendingPromise
   52|      2|          .then(^id(id result) {
   53|      1|            @synchronized(self) {
   54|      1|              self.pendingPromise = nil;
   55|      1|              return nil;
   56|      1|            }
   57|      1|          })
   58|      2|          .catch(^void(NSError *error) {
   59|      0|            @synchronized(self) {
   60|      0|              self.pendingPromise = nil;
   61|      0|            }
   62|      0|          });
   63|      2|    }
   64|      4|
   65|      4|    return self.pendingPromise;
   66|      4|  }
   67|      4|}
   68|       |
   69|      2|- (nullable FBLPromise *)getExistingPendingPromise {
   70|      2|  @synchronized(self) {
   71|      2|    return self.pendingPromise;
   72|      2|  }
   73|      2|}
   74|       |
   75|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsStore.h"
   18|       |
   19|       |#import <GoogleUtilities/GULUserDefaults.h>
   20|       |
   21|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   22|       |#import <FBLPromises/FBLPromises.h>
   23|       |#else
   24|       |#import "FBLPromises.h"
   25|       |#endif
   26|       |
   27|       |#import "FIRInstallationsErrorUtil.h"
   28|       |#import "FIRInstallationsItem.h"
   29|       |#import "FIRInstallationsStoredItem.h"
   30|       |#import "FIRSecureStorage.h"
   31|       |
   32|       |NSString *const kFIRInstallationsStoreUserDefaultsID = @"com.firebase.FIRInstallations";
   33|       |
   34|       |@interface FIRInstallationsStore ()
   35|       |@property(nonatomic, readonly) FIRSecureStorage *secureStorage;
   36|       |@property(nonatomic, readonly, nullable) NSString *accessGroup;
   37|       |@property(nonatomic, readonly) dispatch_queue_t queue;
   38|       |@property(nonatomic, readonly) GULUserDefaults *userDefaults;
   39|       |@end
   40|       |
   41|       |@implementation FIRInstallationsStore
   42|       |
   43|       |- (instancetype)initWithSecureStorage:(FIRSecureStorage *)storage
   44|      1|                          accessGroup:(NSString *)accessGroup {
   45|      1|  self = [super init];
   46|      1|  if (self) {
   47|      1|    _secureStorage = storage;
   48|      1|    _accessGroup = [accessGroup copy];
   49|      1|    _queue = dispatch_queue_create("com.firebase.FIRInstallationsStore", DISPATCH_QUEUE_SERIAL);
   50|      1|
   51|      1|    NSString *userDefaultsSuiteName = _accessGroup ?: kFIRInstallationsStoreUserDefaultsID;
   52|      1|    _userDefaults = [[GULUserDefaults alloc] initWithSuiteName:userDefaultsSuiteName];
   53|      1|  }
   54|      1|  return self;
   55|      1|}
   56|       |
   57|       |- (FBLPromise<FIRInstallationsItem *> *)installationForAppID:(NSString *)appID
   58|      1|                                                     appName:(NSString *)appName {
   59|      1|  NSString *itemID = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
   60|      1|  return [self installationExistsForAppID:appID appName:appName]
   61|      1|      .then(^id(id result) {
   62|      1|        return [self.secureStorage getObjectForKey:itemID
   63|      1|                                       objectClass:[FIRInstallationsStoredItem class]
   64|      1|                                       accessGroup:self.accessGroup];
   65|      1|      })
   66|      1|      .then(^id(FIRInstallationsStoredItem *_Nullable storedItem) {
   67|      1|        if (storedItem == nil) {
   68|      0|          return [FIRInstallationsErrorUtil installationItemNotFoundForAppID:appID appName:appName];
   69|      0|        }
   70|      1|
   71|      1|        FIRInstallationsItem *item = [[FIRInstallationsItem alloc] initWithAppID:appID
   72|      1|                                                                 firebaseAppName:appName];
   73|      1|        [item updateWithStoredItem:storedItem];
   74|      1|        return item;
   75|      1|      });
   76|      1|}
   77|       |
   78|      0|- (FBLPromise<NSNull *> *)saveInstallation:(FIRInstallationsItem *)installationItem {
   79|      0|  FIRInstallationsStoredItem *storedItem = [installationItem storedItem];
   80|      0|  NSString *identifier = [installationItem identifier];
   81|      0|
   82|      0|  return
   83|      0|      [self.secureStorage setObject:storedItem forKey:identifier accessGroup:self.accessGroup].then(
   84|      0|          ^id(id result) {
   85|      0|            return [self setInstallationExists:YES forItemWithIdentifier:identifier];
   86|      0|          });
   87|      0|}
   88|       |
   89|      0|- (FBLPromise<NSNull *> *)removeInstallationForAppID:(NSString *)appID appName:(NSString *)appName {
   90|      0|  NSString *identifier = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
   91|      0|  return [self.secureStorage removeObjectForKey:identifier accessGroup:self.accessGroup].then(
   92|      0|      ^id(id result) {
   93|      0|        return [self setInstallationExists:NO forItemWithIdentifier:identifier];
   94|      0|      });
   95|      0|}
   96|       |
   97|       |#pragma mark - User defaults
   98|       |
   99|      1|- (FBLPromise<NSNull *> *)installationExistsForAppID:(NSString *)appID appName:(NSString *)appName {
  100|      1|  NSString *identifier = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
  101|      1|  return [FBLPromise onQueue:self.queue
  102|      1|                          do:^id _Nullable {
  103|      1|                            return [[self userDefaults] objectForKey:identifier] != nil
  104|      1|                                       ? [NSNull null]
  105|      1|                                       : [FIRInstallationsErrorUtil
  106|      0|                                             installationItemNotFoundForAppID:appID
  107|      0|                                                                      appName:appName];
  108|      1|                          }];
  109|      1|}
  110|       |
  111|       |- (FBLPromise<NSNull *> *)setInstallationExists:(BOOL)exists
  112|      0|                          forItemWithIdentifier:(NSString *)identifier {
  113|      0|  return [FBLPromise onQueue:self.queue
  114|      0|                          do:^id _Nullable {
  115|      0|                            if (exists) {
  116|      0|                              [[self userDefaults] setBool:YES forKey:identifier];
  117|      0|                            } else {
  118|      0|                              [[self userDefaults] removeObjectForKey:identifier];
  119|      0|                            }
  120|      0|
  121|      0|                            return [NSNull null];
  122|      0|                          }];
  123|      0|}
  124|       |
  125|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsStoredAuthToken.h"
   18|       |
   19|       |#import "FIRInstallationsLogger.h"
   20|       |
   21|       |NSString *const kFIRInstallationsStoredAuthTokenStatusKey = @"status";
   22|       |NSString *const kFIRInstallationsStoredAuthTokenTokenKey = @"token";
   23|       |NSString *const kFIRInstallationsStoredAuthTokenExpirationDateKey = @"expirationDate";
   24|       |NSString *const kFIRInstallationsStoredAuthTokenStorageVersionKey = @"storageVersion";
   25|       |
   26|       |NSInteger const kFIRInstallationsStoredAuthTokenStorageVersion = 1;
   27|       |
   28|       |@implementation FIRInstallationsStoredAuthToken
   29|       |
   30|      0|- (NSInteger)storageVersion {
   31|      0|  return kFIRInstallationsStoredAuthTokenStorageVersion;
   32|      0|}
   33|       |
   34|      0|- (nonnull id)copyWithZone:(nullable NSZone *)zone {
   35|      0|  FIRInstallationsStoredAuthToken *clone = [[FIRInstallationsStoredAuthToken alloc] init];
   36|      0|  clone.status = self.status;
   37|      0|  clone.token = [self.token copy];
   38|      0|  clone.expirationDate = self.expirationDate;
   39|      0|  return clone;
   40|      0|}
   41|       |
   42|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   43|      0|  [aCoder encodeInteger:self.status forKey:kFIRInstallationsStoredAuthTokenStatusKey];
   44|      0|  [aCoder encodeObject:self.token forKey:kFIRInstallationsStoredAuthTokenTokenKey];
   45|      0|  [aCoder encodeObject:self.expirationDate
   46|      0|                forKey:kFIRInstallationsStoredAuthTokenExpirationDateKey];
   47|      0|  [aCoder encodeInteger:self.storageVersion
   48|      0|                 forKey:kFIRInstallationsStoredAuthTokenStorageVersionKey];
   49|      0|}
   50|       |
   51|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   52|      0|  NSInteger storageVersion =
   53|      0|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredAuthTokenStorageVersionKey];
   54|      0|  if (storageVersion > kFIRInstallationsStoredAuthTokenStorageVersion) {
   55|      0|    FIRLogWarning(kFIRLoggerInstallations,
   56|      0|                  kFIRInstallationsMessageCodeAuthTokenCoderVersionMismatch,
   57|      0|                  @"FIRInstallationsStoredAuthToken was encoded by a newer coder version %ld. "
   58|      0|                  @"Current coder version is %ld. Some auth token data may be lost.",
   59|      0|                  (long)storageVersion, (long)kFIRInstallationsStoredAuthTokenStorageVersion);
   60|      0|  }
   61|      0|
   62|      0|  FIRInstallationsStoredAuthToken *object = [[FIRInstallationsStoredAuthToken alloc] init];
   63|      0|  object.status = [aDecoder decodeIntegerForKey:kFIRInstallationsStoredAuthTokenStatusKey];
   64|      0|  object.token = [aDecoder decodeObjectOfClass:[NSString class]
   65|      0|                                        forKey:kFIRInstallationsStoredAuthTokenTokenKey];
   66|      0|  object.expirationDate =
   67|      0|      [aDecoder decodeObjectOfClass:[NSDate class]
   68|      0|                             forKey:kFIRInstallationsStoredAuthTokenExpirationDateKey];
   69|      0|
   70|      0|  return object;
   71|      0|}
   72|       |
   73|      0|+ (BOOL)supportsSecureCoding {
   74|      0|  return YES;
   75|      0|}
   76|       |
   77|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsStoredItem.h"
   18|       |
   19|       |#import "FIRInstallationsLogger.h"
   20|       |#import "FIRInstallationsStoredAuthToken.h"
   21|       |
   22|       |NSString *const kFIRInstallationsStoredItemFirebaseInstallationIDKey = @"firebaseInstallationID";
   23|       |NSString *const kFIRInstallationsStoredItemRefreshTokenKey = @"refreshToken";
   24|       |NSString *const kFIRInstallationsStoredItemAuthTokenKey = @"authToken";
   25|       |NSString *const kFIRInstallationsStoredItemRegistrationStatusKey = @"registrationStatus";
   26|       |NSString *const kFIRInstallationsStoredItemIIDDefaultTokenKey = @"IIDDefaultToken";
   27|       |NSString *const kFIRInstallationsStoredItemStorageVersionKey = @"storageVersion";
   28|       |
   29|       |NSInteger const kFIRInstallationsStoredItemStorageVersion = 1;
   30|       |
   31|       |@implementation FIRInstallationsStoredItem
   32|       |
   33|      1|- (NSInteger)storageVersion {
   34|      1|  return kFIRInstallationsStoredItemStorageVersion;
   35|      1|}
   36|       |
   37|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   38|      0|  [aCoder encodeObject:self.firebaseInstallationID
   39|      0|                forKey:kFIRInstallationsStoredItemFirebaseInstallationIDKey];
   40|      0|  [aCoder encodeObject:self.refreshToken forKey:kFIRInstallationsStoredItemRefreshTokenKey];
   41|      0|  [aCoder encodeObject:self.authToken forKey:kFIRInstallationsStoredItemAuthTokenKey];
   42|      0|  [aCoder encodeInteger:self.registrationStatus
   43|      0|                 forKey:kFIRInstallationsStoredItemRegistrationStatusKey];
   44|      0|  [aCoder encodeObject:self.IIDDefaultToken forKey:kFIRInstallationsStoredItemIIDDefaultTokenKey];
   45|      0|  [aCoder encodeInteger:self.storageVersion forKey:kFIRInstallationsStoredItemStorageVersionKey];
   46|      0|}
   47|       |
   48|      1|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   49|      1|  NSInteger storageVersion =
   50|      1|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredItemStorageVersionKey];
   51|      1|  if (storageVersion > self.storageVersion) {
   52|      0|    FIRLogWarning(kFIRLoggerInstallations,
   53|      0|                  kFIRInstallationsMessageCodeInstallationCoderVersionMismatch,
   54|      0|                  @"FIRInstallationsStoredItem was encoded by a newer coder version %ld. Current "
   55|      0|                  @"coder version is %ld. Some installation data may be lost.",
   56|      0|                  (long)storageVersion, (long)kFIRInstallationsStoredItemStorageVersion);
   57|      0|  }
   58|      1|
   59|      1|  FIRInstallationsStoredItem *item = [[FIRInstallationsStoredItem alloc] init];
   60|      1|  item.firebaseInstallationID =
   61|      1|      [aDecoder decodeObjectOfClass:[NSString class]
   62|      1|                             forKey:kFIRInstallationsStoredItemFirebaseInstallationIDKey];
   63|      1|  item.refreshToken = [aDecoder decodeObjectOfClass:[NSString class]
   64|      1|                                             forKey:kFIRInstallationsStoredItemRefreshTokenKey];
   65|      1|  item.authToken = [aDecoder decodeObjectOfClass:[FIRInstallationsStoredAuthToken class]
   66|      1|                                          forKey:kFIRInstallationsStoredItemAuthTokenKey];
   67|      1|  item.registrationStatus =
   68|      1|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredItemRegistrationStatusKey];
   69|      1|  item.IIDDefaultToken =
   70|      1|      [aDecoder decodeObjectOfClass:[NSString class]
   71|      1|                             forKey:kFIRInstallationsStoredItemIIDDefaultTokenKey];
   72|      1|
   73|      1|  return item;
   74|      1|}
   75|       |
   76|      1|+ (BOOL)supportsSecureCoding {
   77|      1|  return YES;
   78|      1|}
   79|       |
   80|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/SecureStorage/FIRInstallationsKeychainUtils.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsKeychainUtils.h"
   18|       |
   19|       |#import "FIRInstallationsErrorUtil.h"
   20|       |
   21|       |@implementation FIRInstallationsKeychainUtils
   22|       |
   23|       |+ (nullable NSData *)getItemWithQuery:(NSDictionary *)query
   24|      1|                                error:(NSError *_Nullable *_Nullable)outError {
   25|      1|  NSMutableDictionary *mutableQuery = [query mutableCopy];
   26|      1|
   27|      1|  mutableQuery[(__bridge id)kSecReturnData] = @YES;
   28|      1|  mutableQuery[(__bridge id)kSecMatchLimit] = (__bridge id)kSecMatchLimitOne;
   29|      1|
   30|      1|  CFDataRef result = NULL;
   31|      1|  OSStatus status =
   32|      1|      SecItemCopyMatching((__bridge CFDictionaryRef)mutableQuery, (CFTypeRef *)&result);
   33|      1|
   34|      1|  if (status == errSecSuccess && result != NULL) {
   35|      1|    if (outError) {
   36|      1|      *outError = nil;
   37|      1|    }
   38|      1|
   39|      1|    return (__bridge_transfer NSData *)result;
   40|      1|  }
   41|      0|
   42|      0|  if (status == errSecItemNotFound) {
   43|      0|    if (outError) {
   44|      0|      *outError = nil;
   45|      0|    }
   46|      0|  } else {
   47|      0|    if (outError) {
   48|      0|      *outError = [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemCopyMatching"
   49|      0|                                                                status:status];
   50|      0|    }
   51|      0|  }
   52|      0|  return nil;
   53|      0|}
   54|       |
   55|       |+ (BOOL)setItem:(NSData *)item
   56|       |      withQuery:(NSDictionary *)query
   57|      0|          error:(NSError *_Nullable *_Nullable)outError {
   58|      0|  NSData *existingItem = [self getItemWithQuery:query error:outError];
   59|      0|  if (outError && *outError) {
   60|      0|    return NO;
   61|      0|  }
   62|      0|
   63|      0|  NSMutableDictionary *mutableQuery = [query mutableCopy];
   64|      0|  mutableQuery[(__bridge id)kSecAttrAccessible] =
   65|      0|      (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
   66|      0|
   67|      0|  OSStatus status;
   68|      0|  if (!existingItem) {
   69|      0|    mutableQuery[(__bridge id)kSecValueData] = item;
   70|      0|    status = SecItemAdd((__bridge CFDictionaryRef)mutableQuery, NULL);
   71|      0|  } else {
   72|      0|    NSDictionary *attributes = @{(__bridge id)kSecValueData : item};
   73|      0|    status = SecItemUpdate((__bridge CFDictionaryRef)query, (__bridge CFDictionaryRef)attributes);
   74|      0|  }
   75|      0|
   76|      0|  if (status == noErr) {
   77|      0|    if (outError) {
   78|      0|      *outError = nil;
   79|      0|    }
   80|      0|    return YES;
   81|      0|  }
   82|      0|
   83|      0|  NSString *function = existingItem ? @"SecItemUpdate" : @"SecItemAdd";
   84|      0|  if (outError) {
   85|      0|    *outError = [FIRInstallationsErrorUtil keychainErrorWithFunction:function status:status];
   86|      0|  }
   87|      0|  return NO;
   88|      0|}
   89|       |
   90|      0|+ (BOOL)removeItemWithQuery:(NSDictionary *)query error:(NSError *_Nullable *_Nullable)outError {
   91|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)query);
   92|      0|
   93|      0|  if (status == noErr || status == errSecItemNotFound) {
   94|      0|    if (outError) {
   95|      0|      *outError = nil;
   96|      0|    }
   97|      0|    return YES;
   98|      0|  }
   99|      0|
  100|      0|  if (outError) {
  101|      0|    *outError = [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemDelete"
  102|      0|                                                              status:status];
  103|      0|  }
  104|      0|  return NO;
  105|      0|}
  106|       |
  107|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/SecureStorage/FIRSecureStorage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureStorage.h"
   18|       |#import <Security/Security.h>
   19|       |
   20|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   21|       |#import <FBLPromises/FBLPromises.h>
   22|       |#else
   23|       |#import "FBLPromises.h"
   24|       |#endif
   25|       |
   26|       |#import "FIRInstallationsErrorUtil.h"
   27|       |#import "FIRInstallationsKeychainUtils.h"
   28|       |
   29|       |@interface FIRSecureStorage ()
   30|       |@property(nonatomic, readonly) dispatch_queue_t keychainQueue;
   31|       |@property(nonatomic, readonly) dispatch_queue_t inMemoryCacheQueue;
   32|       |@property(nonatomic, readonly) NSString *service;
   33|       |@property(nonatomic, readonly) NSCache<NSString *, id<NSSecureCoding>> *inMemoryCache;
   34|       |@end
   35|       |
   36|       |@implementation FIRSecureStorage
   37|       |
   38|      1|- (instancetype)init {
   39|      1|  NSCache *cache = [[NSCache alloc] init];
   40|      1|  // Cache up to 5 installations.
   41|      1|  cache.countLimit = 5;
   42|      1|  return [self initWithService:@"com.firebase.FIRInstallations.installations" cache:cache];
   43|      1|}
   44|       |
   45|      1|- (instancetype)initWithService:(NSString *)service cache:(NSCache *)cache {
   46|      1|  self = [super init];
   47|      1|  if (self) {
   48|      1|    _keychainQueue = dispatch_queue_create(
   49|      1|        "com.firebase.FIRInstallations.FIRSecureStorage.Keychain", DISPATCH_QUEUE_SERIAL);
   50|      1|    _inMemoryCacheQueue = dispatch_queue_create(
   51|      1|        "com.firebase.FIRInstallations.FIRSecureStorage.InMemoryCache", DISPATCH_QUEUE_SERIAL);
   52|      1|    _service = [service copy];
   53|      1|    _inMemoryCache = cache;
   54|      1|  }
   55|      1|  return self;
   56|      1|}
   57|       |
   58|       |#pragma mark - Public
   59|       |
   60|       |- (FBLPromise<id<NSSecureCoding>> *)getObjectForKey:(NSString *)key
   61|       |                                        objectClass:(Class)objectClass
   62|      1|                                        accessGroup:(nullable NSString *)accessGroup {
   63|      1|  return [FBLPromise onQueue:self.inMemoryCacheQueue
   64|      1|                          do:^id _Nullable {
   65|      1|                            // Return cached object or fail otherwise.
   66|      1|                            id object = [self.inMemoryCache objectForKey:key];
   67|      1|                            return object
   68|      1|                                       ?: [[NSError alloc]
   69|      1|                                              initWithDomain:FBLPromiseErrorDomain
   70|      1|                                                        code:FBLPromiseErrorCodeValidationFailure
   71|      1|                                                    userInfo:nil];
   72|      1|                          }]
   73|      1|      .recover(^id _Nullable(NSError *error) {
   74|      1|        // Look for the object in the keychain.
   75|      1|        return [self getObjectFromKeychainForKey:key
   76|      1|                                     objectClass:objectClass
   77|      1|                                     accessGroup:accessGroup];
   78|      1|      });
   79|      1|}
   80|       |
   81|       |- (FBLPromise<NSNull *> *)setObject:(id<NSSecureCoding>)object
   82|       |                             forKey:(NSString *)key
   83|      0|                        accessGroup:(nullable NSString *)accessGroup {
   84|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
   85|      0|                          do:^id _Nullable {
   86|      0|                            // Save to the in-memory cache first.
   87|      0|                            [self.inMemoryCache setObject:object forKey:[key copy]];
   88|      0|                            return [NSNull null];
   89|      0|                          }]
   90|      0|      .thenOn(self.keychainQueue, ^id(id result) {
   91|      0|        // Then store the object to the keychain.
   92|      0|        NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
   93|      0|        NSError *error;
   94|      0|        NSData *encodedObject = [self archiveDataForObject:object error:&error];
   95|      0|        if (!encodedObject) {
   96|      0|          return error;
   97|      0|        }
   98|      0|
   99|      0|        if (![FIRInstallationsKeychainUtils setItem:encodedObject withQuery:query error:&error]) {
  100|      0|          return error;
  101|      0|        }
  102|      0|
  103|      0|        return [NSNull null];
  104|      0|      });
  105|      0|}
  106|       |
  107|       |- (FBLPromise<NSNull *> *)removeObjectForKey:(NSString *)key
  108|      0|                                 accessGroup:(nullable NSString *)accessGroup {
  109|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
  110|      0|                          do:^id _Nullable {
  111|      0|                            [self.inMemoryCache removeObjectForKey:key];
  112|      0|                            return nil;
  113|      0|                          }]
  114|      0|      .thenOn(self.keychainQueue, ^id(id result) {
  115|      0|        NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
  116|      0|
  117|      0|        NSError *error;
  118|      0|        if (![FIRInstallationsKeychainUtils removeItemWithQuery:query error:&error]) {
  119|      0|          return error;
  120|      0|        }
  121|      0|
  122|      0|        return [NSNull null];
  123|      0|      });
  124|      0|}
  125|       |
  126|       |#pragma mark - Private
  127|       |
  128|       |- (FBLPromise<id<NSSecureCoding>> *)getObjectFromKeychainForKey:(NSString *)key
  129|       |                                                    objectClass:(Class)objectClass
  130|      1|                                                    accessGroup:(nullable NSString *)accessGroup {
  131|      1|  // Look for the object in the keychain.
  132|      1|  return [FBLPromise onQueue:self.keychainQueue
  133|      1|                          do:^id {
  134|      1|                            NSDictionary *query = [self keychainQueryWithKey:key
  135|      1|                                                                 accessGroup:accessGroup];
  136|      1|                            NSError *error;
  137|      1|                            NSData *encodedObject =
  138|      1|                                [FIRInstallationsKeychainUtils getItemWithQuery:query error:&error];
  139|      1|
  140|      1|                            if (error) {
  141|      0|                              return error;
  142|      0|                            }
  143|      1|                            if (!encodedObject) {
  144|      0|                              return nil;
  145|      0|                            }
  146|      1|                            id object = [self unarchivedObjectOfClass:objectClass
  147|      1|                                                             fromData:encodedObject
  148|      1|                                                                error:&error];
  149|      1|                            if (error) {
  150|      0|                              return error;
  151|      0|                            }
  152|      1|
  153|      1|                            return object;
  154|      1|                          }]
  155|      1|      .thenOn(self.inMemoryCacheQueue,
  156|      1|              ^id<NSSecureCoding> _Nullable(id<NSSecureCoding> _Nullable object) {
  157|      1|                // Save object to the in-memory cache if exists and return the object.
  158|      1|                if (object) {
  159|      1|                  [self.inMemoryCache setObject:object forKey:[key copy]];
  160|      1|                }
  161|      1|                return object;
  162|      1|              });
  163|      1|}
  164|       |
  165|      0|- (void)resetInMemoryCache {
  166|      0|  [self.inMemoryCache removeAllObjects];
  167|      0|}
  168|       |
  169|       |#pragma mark - Keychain
  170|       |
  171|       |- (NSMutableDictionary<NSString *, id> *)keychainQueryWithKey:(NSString *)key
  172|      1|                                                  accessGroup:(nullable NSString *)accessGroup {
  173|      1|  NSMutableDictionary<NSString *, id> *query = [NSMutableDictionary dictionary];
  174|      1|
  175|      1|  query[(__bridge NSString *)kSecClass] = (__bridge NSString *)kSecClassGenericPassword;
  176|      1|  query[(__bridge NSString *)kSecAttrService] = self.service;
  177|      1|  query[(__bridge NSString *)kSecAttrAccount] = key;
  178|      1|
  179|      1|  if (accessGroup) {
  180|      0|    query[(__bridge NSString *)kSecAttrAccessGroup] = accessGroup;
  181|      0|  }
  182|      1|
  183|       |#if TARGET_OS_OSX
  184|       |  if (self.keychainRef) {
  185|       |    query[(__bridge NSString *)kSecUseKeychain] = (__bridge id)(self.keychainRef);
  186|       |    query[(__bridge NSString *)kSecMatchSearchList] = @[ (__bridge id)(self.keychainRef) ];
  187|       |  }
  188|       |#endif  // TARGET_OSX
  189|       |
  190|      1|  return query;
  191|      1|}
  192|       |
  193|      0|- (nullable NSData *)archiveDataForObject:(id<NSSecureCoding>)object error:(NSError **)outError {
  194|      0|  NSData *archiveData;
  195|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  196|      0|    NSError *error;
  197|      0|    archiveData = [NSKeyedArchiver archivedDataWithRootObject:object
  198|      0|                                        requiringSecureCoding:YES
  199|      0|                                                        error:&error];
  200|      0|    if (error && outError) {
  201|      0|      *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithError:error];
  202|      0|    }
  203|      0|  } else {
  204|      0|    @try {
  205|      0|      NSMutableData *data = [NSMutableData data];
  206|      0|#pragma clang diagnostic push
  207|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  208|      0|      NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
  209|      0|#pragma clang diagnostic pop
  210|      0|      archiver.requiresSecureCoding = YES;
  211|      0|
  212|      0|      [archiver encodeObject:object forKey:NSKeyedArchiveRootObjectKey];
  213|      0|      [archiver finishEncoding];
  214|      0|
  215|      0|      archiveData = [data copy];
  216|      0|    } @catch (NSException *exception) {
  217|      0|      if (outError) {
  218|      0|        *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
  219|      0|      }
  220|      0|    }
  221|      0|  }
  222|      0|
  223|      0|  return archiveData;
  224|      0|}
  225|       |
  226|       |- (nullable id)unarchivedObjectOfClass:(Class)class
  227|       |                              fromData:(NSData *)data
  228|      1|                                 error:(NSError **)outError {
  229|      1|  id object;
  230|      1|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  231|      1|    NSError *error;
  232|      1|    object = [NSKeyedUnarchiver unarchivedObjectOfClass:class fromData:data error:&error];
  233|      1|    if (error && outError) {
  234|      0|      *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithError:error];
  235|      0|    }
  236|      1|  } else {
  237|      0|    @try {
  238|      0|#pragma clang diagnostic push
  239|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  240|      0|      NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
  241|      0|#pragma clang diagnostic pop
  242|      0|      unarchiver.requiresSecureCoding = YES;
  243|      0|
  244|      0|      object = [unarchiver decodeObjectOfClass:class forKey:NSKeyedArchiveRootObjectKey];
  245|      0|    } @catch (NSException *exception) {
  246|      0|      if (outError) {
  247|      0|        *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
  248|      0|      }
  249|      0|    }
  250|      0|  }
  251|      1|
  252|      1|  return object;
  253|      1|}
  254|       |
  255|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GTMSessionFetcher/Source/GTMSessionFetcher.h:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |// GTMSessionFetcher is a wrapper around NSURLSession for http operations.
   17|       |//
   18|       |// What does this offer on top of of NSURLSession?
   19|       |//
   20|       |// - Block-style callbacks for useful functionality like progress rather
   21|       |//   than delegate methods.
   22|       |// - Out-of-process uploads and downloads using NSURLSession, including
   23|       |//   management of fetches after relaunch.
   24|       |// - Integration with GTMAppAuth for invisible management and refresh of
   25|       |//   authorization tokens.
   26|       |// - Pretty-printed http logging.
   27|       |// - Cookies handling that does not interfere with or get interfered with
   28|       |//   by WebKit cookies or on Mac by Safari and other apps.
   29|       |// - Credentials handling for the http operation.
   30|       |// - Rate-limiting and cookie grouping when fetchers are created with
   31|       |//   GTMSessionFetcherService.
   32|       |//
   33|       |// If the bodyData or bodyFileURL property is set, then a POST request is assumed.
   34|       |//
   35|       |// Each fetcher is assumed to be for a one-shot fetch request; don't reuse the object
   36|       |// for a second fetch.
   37|       |//
   38|       |// The fetcher will be self-retained as long as a connection is pending.
   39|       |//
   40|       |// To keep user activity private, URLs must have an https scheme (unless the property
   41|       |// allowedInsecureSchemes is set to permit the scheme.)
   42|       |//
   43|       |// Callbacks will be released when the fetch completes or is stopped, so there is no need
   44|       |// to use weak self references in the callback blocks.
   45|       |//
   46|       |// Sample usage:
   47|       |//
   48|       |//  _fetcherService = [[GTMSessionFetcherService alloc] init];
   49|       |//
   50|       |//  GTMSessionFetcher *myFetcher = [_fetcherService fetcherWithURLString:myURLString];
   51|       |//  myFetcher.retryEnabled = YES;
   52|       |//  myFetcher.comment = @"First profile image";
   53|       |//
   54|       |//  // Optionally specify a file URL or NSData for the request body to upload.
   55|       |//  myFetcher.bodyData = [postString dataUsingEncoding:NSUTF8StringEncoding];
   56|       |//
   57|       |//  [myFetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
   58|       |//    if (error != nil) {
   59|       |//      // Server status code or network error.
   60|       |//      //
   61|       |//      // If the domain is kGTMSessionFetcherStatusDomain then the error code
   62|       |//      // is a failure status from the server.
   63|       |//    } else {
   64|       |//      // Fetch succeeded.
   65|       |//    }
   66|       |//  }];
   67|       |//
   68|       |// There is also a beginFetch call that takes a pointer and selector for the completion handler;
   69|       |// a pointer and selector is a better style when the callback is a substantial, separate method.
   70|       |//
   71|       |// NOTE:  Fetches may retrieve data from the server even though the server
   72|       |//        returned an error, so the criteria for success is a non-nil error.
   73|       |//        The completion handler is called when the server status is >= 300 with an NSError
   74|       |//        having domain kGTMSessionFetcherStatusDomain and code set to the server status.
   75|       |//
   76|       |//        Status codes are at <http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html>
   77|       |//
   78|       |//
   79|       |// Background session support:
   80|       |//
   81|       |// Out-of-process uploads and downloads may be created by setting the fetcher's
   82|       |// useBackgroundSession property. Data to be uploaded should be provided via
   83|       |// the uploadFileURL property; the download destination should be specified with
   84|       |// the destinationFileURL.  NOTE: Background upload files should be in a location
   85|       |// that will be valid even after the device is restarted, so the file should not
   86|       |// be uploaded from a system temporary or cache directory.
   87|       |//
   88|       |// Background session transfers are slower, and should typically be used only
   89|       |// for very large downloads or uploads (hundreds of megabytes).
   90|       |//
   91|       |// When background sessions are used in iOS apps, the application delegate must
   92|       |// pass through the parameters from UIApplicationDelegate's
   93|       |// application:handleEventsForBackgroundURLSession:completionHandler: to the
   94|       |// fetcher class.
   95|       |//
   96|       |// When the application has been relaunched, it may also create a new fetcher
   97|       |// instance to handle completion of the transfers.
   98|       |//
   99|       |//  - (void)application:(UIApplication *)application
  100|       |//      handleEventsForBackgroundURLSession:(NSString *)identifier
  101|       |//                        completionHandler:(void (^)())completionHandler {
  102|       |//    // Application was re-launched on completing an out-of-process download.
  103|       |//
  104|       |//    // Pass the URLSession info related to this re-launch to the fetcher class.
  105|       |//    [GTMSessionFetcher application:application
  106|       |//        handleEventsForBackgroundURLSession:identifier
  107|       |//                          completionHandler:completionHandler];
  108|       |//
  109|       |//    // Get a fetcher related to this re-launch and re-hook up a completionHandler to it.
  110|       |//    GTMSessionFetcher *fetcher = [GTMSessionFetcher fetcherWithSessionIdentifier:identifier];
  111|       |//    NSURL *destinationFileURL = fetcher.destinationFileURL;
  112|       |//    fetcher.completionHandler = ^(NSData *data, NSError *error) {
  113|       |//      [self downloadCompletedToFile:destinationFileURL error:error];
  114|       |//    };
  115|       |//  }
  116|       |//
  117|       |//
  118|       |// Threading and queue support:
  119|       |//
  120|       |// Networking always happens on a background thread; there is no advantage to
  121|       |// changing thread or queue to create or start a fetcher.
  122|       |//
  123|       |// Callbacks are run on the main thread; alternatively, the app may set the
  124|       |// fetcher's callbackQueue to a dispatch queue.
  125|       |//
  126|       |// Once the fetcher's beginFetch method has been called, the fetcher's methods and
  127|       |// properties may be accessed from any thread.
  128|       |//
  129|       |// Downloading to disk:
  130|       |//
  131|       |// To have downloaded data saved directly to disk, specify a file URL for the
  132|       |// destinationFileURL property.
  133|       |//
  134|       |// HTTP methods and headers:
  135|       |//
  136|       |// Alternative HTTP methods, like PUT, and custom headers can be specified by
  137|       |// creating the fetcher with an appropriate NSMutableURLRequest.
  138|       |//
  139|       |//
  140|       |// Caching:
  141|       |//
  142|       |// The fetcher avoids caching. That is best for API requests, but may hurt
  143|       |// repeat fetches of static data. Apps may enable a persistent disk cache by
  144|       |// customizing the config:
  145|       |//
  146|       |//  fetcher.configurationBlock = ^(GTMSessionFetcher *configFetcher,
  147|       |//                                 NSURLSessionConfiguration *config) {
  148|       |//    config.URLCache = [NSURLCache sharedURLCache];
  149|       |//  };
  150|       |//
  151|       |// Or use the standard system config to share cookie storage with web views
  152|       |// and to enable disk caching:
  153|       |//
  154|       |//  fetcher.configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
  155|       |//
  156|       |//
  157|       |// Cookies:
  158|       |//
  159|       |// There are three supported mechanisms for remembering cookies between fetches.
  160|       |//
  161|       |// By default, a standalone GTMSessionFetcher uses a mutable array held
  162|       |// statically to track cookies for all instantiated fetchers.  This avoids
  163|       |// cookies being set by servers for the application from interfering with
  164|       |// Safari and WebKit cookie settings, and vice versa.
  165|       |// The fetcher cookies are lost when the application quits.
  166|       |//
  167|       |// To rely instead on WebKit's global NSHTTPCookieStorage, set the fetcher's
  168|       |// cookieStorage property:
  169|       |//   myFetcher.cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
  170|       |//
  171|       |// To share cookies with other apps, use the method introduced in iOS 9/OS X 10.11:
  172|       |//   myFetcher.cookieStorage =
  173|       |//     [NSHTTPCookieStorage sharedCookieStorageForGroupContainerIdentifier:kMyCompanyContainedID];
  174|       |//
  175|       |// To ignore existing cookies and only have cookies related to the single fetch
  176|       |// be applied, make a temporary cookie storage object:
  177|       |//   myFetcher.cookieStorage = [[GTMSessionCookieStorage alloc] init];
  178|       |//
  179|       |// Note: cookies set while following redirects will be sent to the server, as
  180|       |// the redirects are followed by the fetcher.
  181|       |//
  182|       |// To completely disable cookies, similar to setting cookieStorageMethod to
  183|       |// kGTMHTTPFetcherCookieStorageMethodNone, adjust the session configuration
  184|       |// appropriately in the fetcher or fetcher service:
  185|       |//  fetcher.configurationBlock = ^(GTMSessionFetcher *configFetcher,
  186|       |//                                 NSURLSessionConfiguration *config) {
  187|       |//    config.HTTPCookieAcceptPolicy = NSHTTPCookieAcceptPolicyNever;
  188|       |//    config.HTTPShouldSetCookies = NO;
  189|       |//  };
  190|       |//
  191|       |// If the fetcher is created from a GTMSessionFetcherService object
  192|       |// then the cookie storage mechanism is set to use the cookie storage in the
  193|       |// service object rather than the static storage. Disabling cookies in the
  194|       |// session configuration set on a service object will disable cookies for all
  195|       |// fetchers created from that GTMSessionFetcherService object, since the session
  196|       |// configuration is propagated to the fetcher.
  197|       |//
  198|       |//
  199|       |// Monitoring data transfers.
  200|       |//
  201|       |// The fetcher supports a variety of properties for progress monitoring
  202|       |// progress with callback blocks.
  203|       |//  GTMSessionFetcherSendProgressBlock sendProgressBlock
  204|       |//  GTMSessionFetcherReceivedProgressBlock receivedProgressBlock
  205|       |//  GTMSessionFetcherDownloadProgressBlock downloadProgressBlock
  206|       |//
  207|       |// If supplied by the server, the anticipated total download size is available
  208|       |// as [[myFetcher response] expectedContentLength] (and may be -1 for unknown
  209|       |// download sizes.)
  210|       |//
  211|       |//
  212|       |// Automatic retrying of fetches
  213|       |//
  214|       |// The fetcher can optionally create a timer and reattempt certain kinds of
  215|       |// fetch failures (status codes 408, request timeout; 502, gateway failure;
  216|       |// 503, service unavailable; 504, gateway timeout; networking errors
  217|       |// NSURLErrorTimedOut and NSURLErrorNetworkConnectionLost.)  The user may
  218|       |// set a retry selector to customize the type of errors which will be retried.
  219|       |//
  220|       |// Retries are done in an exponential-backoff fashion (that is, after 1 second,
  221|       |// 2, 4, 8, and so on.)
  222|       |//
  223|       |// Enabling automatic retries looks like this:
  224|       |//  myFetcher.retryEnabled = YES;
  225|       |//
  226|       |// With retries enabled, the completion callbacks are called only
  227|       |// when no more retries will be attempted. Calling the fetcher's stopFetching
  228|       |// method will terminate the retry timer, without the finished or failure
  229|       |// selectors being invoked.
  230|       |//
  231|       |// Optionally, the client may set the maximum retry interval:
  232|       |//  myFetcher.maxRetryInterval = 60.0; // in seconds; default is 60 seconds
  233|       |//                                     // for downloads, 600 for uploads
  234|       |//
  235|       |// Servers should never send a 400 or 500 status for errors that are retryable
  236|       |// by clients, as those values indicate permanent failures. In nearly all
  237|       |// cases, the default standard retry behavior is correct for clients, and no
  238|       |// custom client retry behavior is needed or appropriate. Servers that send
  239|       |// non-retryable status codes and expect the client to retry the request are
  240|       |// faulty.
  241|       |//
  242|       |// Still, the client may provide a block to determine if a status code or other
  243|       |// error should be retried. The block returns YES to set the retry timer or NO
  244|       |// to fail without additional fetch attempts.
  245|       |//
  246|       |// The retry method may return the |suggestedWillRetry| argument to get the
  247|       |// default retry behavior.  Server status codes are present in the
  248|       |// error argument, and have the domain kGTMSessionFetcherStatusDomain. The
  249|       |// user's method may look something like this:
  250|       |//
  251|       |//  myFetcher.retryBlock = ^(BOOL suggestedWillRetry, NSError *error,
  252|       |//                           GTMSessionFetcherRetryResponse response) {
  253|       |//    // Perhaps examine error.domain and error.code, or fetcher.retryCount
  254|       |//    //
  255|       |//    // Respond with YES to start the retry timer, NO to proceed to the failure
  256|       |//    // callback, or suggestedWillRetry to get default behavior for the
  257|       |//    // current error domain and code values.
  258|       |//    response(suggestedWillRetry);
  259|       |//  };
  260|       |
  261|       |
  262|       |#import <Foundation/Foundation.h>
  263|       |
  264|       |#if TARGET_OS_IPHONE
  265|       |#import <UIKit/UIKit.h>
  266|       |#endif
  267|       |#if TARGET_OS_WATCH
  268|       |#import <WatchKit/WatchKit.h>
  269|       |#endif
  270|       |
  271|       |// By default it is stripped from non DEBUG builds. Developers can override
  272|       |// this in their project settings.
  273|       |#ifndef STRIP_GTM_FETCH_LOGGING
  274|       |  #if !DEBUG
  275|       |    #define STRIP_GTM_FETCH_LOGGING 1
  276|       |  #else
  277|       |    #define STRIP_GTM_FETCH_LOGGING 0
  278|       |  #endif
  279|       |#endif
  280|       |
  281|       |// Logs in debug builds.
  282|       |#ifndef GTMSESSION_LOG_DEBUG
  283|       |  #if DEBUG
  284|      0|    #define GTMSESSION_LOG_DEBUG(...) NSLog(__VA_ARGS__)
  285|       |  #else
  286|       |    #define GTMSESSION_LOG_DEBUG(...) do { } while (0)
  287|       |  #endif
  288|       |#endif
  289|       |
  290|       |// Asserts in debug builds (or logs in debug builds if GTMSESSION_ASSERT_AS_LOG
  291|       |// or NS_BLOCK_ASSERTIONS are defined.)
  292|       |#ifndef GTMSESSION_ASSERT_DEBUG
  293|       |  #if DEBUG && !defined(NS_BLOCK_ASSERTIONS) && !GTMSESSION_ASSERT_AS_LOG
  294|       |    #undef GTMSESSION_ASSERT_AS_LOG
  295|       |    #define GTMSESSION_ASSERT_AS_LOG 1
  296|       |  #endif
  297|       |
  298|       |  #if DEBUG && !GTMSESSION_ASSERT_AS_LOG
  299|       |    #define GTMSESSION_ASSERT_DEBUG(...) NSAssert(__VA_ARGS__)
  300|       |  #elif DEBUG
  301|      0|    #define GTMSESSION_ASSERT_DEBUG(pred, ...) if (!(pred)) { NSLog(__VA_ARGS__); }
  302|       |  #else
  303|       |    #define GTMSESSION_ASSERT_DEBUG(pred, ...) do { } while (0)
  304|       |  #endif
  305|       |#endif
  306|       |
  307|       |// Asserts in debug builds, logs in release builds (or logs in debug builds if
  308|       |// GTMSESSION_ASSERT_AS_LOG is defined.)
  309|       |#ifndef GTMSESSION_ASSERT_DEBUG_OR_LOG
  310|       |  #if DEBUG && !GTMSESSION_ASSERT_AS_LOG
  311|       |    #define GTMSESSION_ASSERT_DEBUG_OR_LOG(...) NSAssert(__VA_ARGS__)
  312|       |  #else
  313|      0|    #define GTMSESSION_ASSERT_DEBUG_OR_LOG(pred, ...) if (!(pred)) { NSLog(__VA_ARGS__); }
  314|       |  #endif
  315|       |#endif
  316|       |
  317|       |// Macro useful for examining messages from NSURLSession during debugging.
  318|       |#if 0
  319|       |#define GTM_LOG_SESSION_DELEGATE(...) GTMSESSION_LOG_DEBUG(__VA_ARGS__)
  320|       |#else
  321|       |#define GTM_LOG_SESSION_DELEGATE(...)
  322|       |#endif
  323|       |
  324|       |#ifndef GTM_NULLABLE
  325|       |  #if __has_feature(nullability)  // Available starting in Xcode 6.3
  326|       |    #define GTM_NULLABLE_TYPE __nullable
  327|       |    #define GTM_NONNULL_TYPE __nonnull
  328|       |    #define GTM_NULLABLE nullable
  329|       |    #define GTM_NONNULL_DECL nonnull  // GTM_NONNULL is used by GTMDefines.h
  330|       |    #define GTM_NULL_RESETTABLE null_resettable
  331|       |
  332|       |    #define GTM_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_BEGIN
  333|       |    #define GTM_ASSUME_NONNULL_END NS_ASSUME_NONNULL_END
  334|       |  #else
  335|       |    #define GTM_NULLABLE_TYPE
  336|       |    #define GTM_NONNULL_TYPE
  337|       |    #define GTM_NULLABLE
  338|       |    #define GTM_NONNULL_DECL
  339|       |    #define GTM_NULL_RESETTABLE
  340|       |    #define GTM_ASSUME_NONNULL_BEGIN
  341|       |    #define GTM_ASSUME_NONNULL_END
  342|       |  #endif  // __has_feature(nullability)
  343|       |#endif  // GTM_NULLABLE
  344|       |
  345|       |#ifndef GTM_DECLARE_GENERICS
  346|       |  #if __has_feature(objc_generics)
  347|       |    #define GTM_DECLARE_GENERICS 1
  348|       |  #else
  349|       |    #define GTM_DECLARE_GENERICS 0
  350|       |  #endif
  351|       |#endif
  352|       |
  353|       |#ifndef GTM_NSArrayOf
  354|       |  #if GTM_DECLARE_GENERICS
  355|       |    #define GTM_NSArrayOf(value) NSArray<value>
  356|       |    #define GTM_NSDictionaryOf(key, value) NSDictionary<key, value>
  357|       |  #else
  358|       |    #define GTM_NSArrayOf(value) NSArray
  359|       |    #define GTM_NSDictionaryOf(key, value) NSDictionary
  360|       |  #endif // __has_feature(objc_generics)
  361|       |#endif  // GTM_NSArrayOf
  362|       |
  363|       |// For iOS, the fetcher can declare itself a background task to allow fetches
  364|       |// to finish when the app leaves the foreground.
  365|       |//
  366|       |// (This is unrelated to providing a background configuration, which allows
  367|       |// out-of-process uploads and downloads.)
  368|       |//
  369|       |// To disallow use of background tasks during fetches, the target should define
  370|       |// GTM_BACKGROUND_TASK_FETCHING to 0, or alternatively may set the
  371|       |// skipBackgroundTask property to YES.
  372|       |#if TARGET_OS_IPHONE && !TARGET_OS_WATCH && !defined(GTM_BACKGROUND_TASK_FETCHING)
  373|       |  #define GTM_BACKGROUND_TASK_FETCHING 1
  374|       |#endif
  375|       |
  376|       |#ifdef __cplusplus
  377|       |extern "C" {
  378|       |#endif
  379|       |
  380|       |#if (TARGET_OS_TV \
  381|       |     || TARGET_OS_WATCH \
  382|       |     || (!TARGET_OS_IPHONE && defined(MAC_OS_X_VERSION_10_11) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11) \
  383|       |     || (TARGET_OS_IPHONE && defined(__IPHONE_9_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_9_0))
  384|       |  #ifndef GTM_USE_SESSION_FETCHER
  385|       |    #define GTM_USE_SESSION_FETCHER 1
  386|       |  #endif
  387|       |#endif
  388|       |
  389|       |#if !defined(GTMBridgeFetcher)
  390|       |  // These bridge macros should be identical in GTMHTTPFetcher.h and GTMSessionFetcher.h
  391|       |  #if GTM_USE_SESSION_FETCHER
  392|       |  // Macros to new fetcher class.
  393|       |    #define GTMBridgeFetcher GTMSessionFetcher
  394|       |    #define GTMBridgeFetcherService GTMSessionFetcherService
  395|       |    #define GTMBridgeFetcherServiceProtocol GTMSessionFetcherServiceProtocol
  396|       |    #define GTMBridgeAssertValidSelector GTMSessionFetcherAssertValidSelector
  397|       |    #define GTMBridgeCookieStorage GTMSessionCookieStorage
  398|       |    #define GTMBridgeCleanedUserAgentString GTMFetcherCleanedUserAgentString
  399|       |    #define GTMBridgeSystemVersionString GTMFetcherSystemVersionString
  400|       |    #define GTMBridgeApplicationIdentifier GTMFetcherApplicationIdentifier
  401|       |    #define kGTMBridgeFetcherStatusDomain kGTMSessionFetcherStatusDomain
  402|       |    #define kGTMBridgeFetcherStatusBadRequest GTMSessionFetcherStatusBadRequest
  403|       |  #else
  404|       |    // Macros to old fetcher class.
  405|       |    #define GTMBridgeFetcher GTMHTTPFetcher
  406|       |    #define GTMBridgeFetcherService GTMHTTPFetcherService
  407|       |    #define GTMBridgeFetcherServiceProtocol GTMHTTPFetcherServiceProtocol
  408|       |    #define GTMBridgeAssertValidSelector GTMAssertSelectorNilOrImplementedWithArgs
  409|       |    #define GTMBridgeCookieStorage GTMCookieStorage
  410|       |    #define GTMBridgeCleanedUserAgentString GTMCleanedUserAgentString
  411|       |    #define GTMBridgeSystemVersionString GTMSystemVersionString
  412|       |    #define GTMBridgeApplicationIdentifier GTMApplicationIdentifier
  413|       |    #define kGTMBridgeFetcherStatusDomain kGTMHTTPFetcherStatusDomain
  414|       |    #define kGTMBridgeFetcherStatusBadRequest kGTMHTTPFetcherStatusBadRequest
  415|       |  #endif  // GTM_USE_SESSION_FETCHER
  416|       |#endif
  417|       |
  418|       |// When creating background sessions to perform out-of-process uploads and
  419|       |// downloads, on app launch any background sessions must be reconnected in
  420|       |// order to receive events that occurred while the app was not running.
  421|       |//
  422|       |// The fetcher will automatically attempt to recreate the sessions on app
  423|       |// start, but doing so reads from NSUserDefaults. This may have launch-time
  424|       |// performance impacts.
  425|       |//
  426|       |// To avoid launch performance impacts, on iPhone/iPad with iOS 13+ the
  427|       |// GTMSessionFetcher class will register for the app launch notification and
  428|       |// perform the reconnect then.
  429|       |//
  430|       |// Apps targeting Mac or older iOS SDKs can opt into the new behavior by defining
  431|       |// GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH=1.
  432|       |//
  433|       |// Apps targeting new SDKs can force the old behavior by defining
  434|       |// GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH = 0.
  435|       |#ifndef GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH
  436|       |  // Default to the on-launch behavior for iOS 13+.
  437|       |  #if TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0
  438|       |    #define GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH 1
  439|       |  #else
  440|       |    #define GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH 0
  441|       |  #endif
  442|       |#endif
  443|       |
  444|       |GTM_ASSUME_NONNULL_BEGIN
  445|       |
  446|       |// Notifications
  447|       |//
  448|       |// Fetch started and stopped, and fetch retry delay started and stopped.
  449|       |extern NSString *const kGTMSessionFetcherStartedNotification;
  450|       |extern NSString *const kGTMSessionFetcherStoppedNotification;
  451|       |extern NSString *const kGTMSessionFetcherRetryDelayStartedNotification;
  452|       |extern NSString *const kGTMSessionFetcherRetryDelayStoppedNotification;
  453|       |
  454|       |// Completion handler notification. This is intended for use by code capturing
  455|       |// and replaying fetch requests and results for testing. For fetches where
  456|       |// destinationFileURL or accumulateDataBlock is set for the fetcher, the data
  457|       |// will be nil for successful fetches.
  458|       |//
  459|       |// This notification is posted on the main thread.
  460|       |extern NSString *const kGTMSessionFetcherCompletionInvokedNotification;
  461|       |extern NSString *const kGTMSessionFetcherCompletionDataKey;
  462|       |extern NSString *const kGTMSessionFetcherCompletionErrorKey;
  463|       |
  464|       |// Constants for NSErrors created by the fetcher (excluding server status errors,
  465|       |// and error objects originating in the OS.)
  466|       |extern NSString *const kGTMSessionFetcherErrorDomain;
  467|       |
  468|       |// The fetcher turns server error status values (3XX, 4XX, 5XX) into NSErrors
  469|       |// with domain kGTMSessionFetcherStatusDomain.
  470|       |//
  471|       |// Any server response body data accompanying the status error is added to the
  472|       |// userInfo dictionary with key kGTMSessionFetcherStatusDataKey.
  473|       |extern NSString *const kGTMSessionFetcherStatusDomain;
  474|       |extern NSString *const kGTMSessionFetcherStatusDataKey;
  475|       |extern NSString *const kGTMSessionFetcherStatusDataContentTypeKey;
  476|       |
  477|       |// When a fetch fails with an error, these keys are included in the error userInfo
  478|       |// dictionary if retries were attempted.
  479|       |extern NSString *const kGTMSessionFetcherNumberOfRetriesDoneKey;
  480|       |extern NSString *const kGTMSessionFetcherElapsedIntervalWithRetriesKey;
  481|       |
  482|       |// Background session support requires access to NSUserDefaults.
  483|       |// If [NSUserDefaults standardUserDefaults] doesn't yield the correct NSUserDefaults for your usage,
  484|       |// ie for an App Extension, then implement this class/method to return the correct NSUserDefaults.
  485|       |// https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6
  486|       |@interface GTMSessionFetcherUserDefaultsFactory : NSObject
  487|       |
  488|       |+ (NSUserDefaults *)fetcherUserDefaults;
  489|       |
  490|       |@end
  491|       |
  492|       |#ifdef __cplusplus
  493|       |}
  494|       |#endif
  495|       |
  496|       |typedef NS_ENUM(NSInteger, GTMSessionFetcherError) {
  497|       |  GTMSessionFetcherErrorDownloadFailed = -1,
  498|       |  GTMSessionFetcherErrorUploadChunkUnavailable = -2,
  499|       |  GTMSessionFetcherErrorBackgroundExpiration = -3,
  500|       |  GTMSessionFetcherErrorBackgroundFetchFailed = -4,
  501|       |  GTMSessionFetcherErrorInsecureRequest = -5,
  502|       |  GTMSessionFetcherErrorTaskCreationFailed = -6,
  503|       |};
  504|       |
  505|       |typedef NS_ENUM(NSInteger, GTMSessionFetcherStatus) {
  506|       |  // Standard http status codes.
  507|       |  GTMSessionFetcherStatusNotModified = 304,
  508|       |  GTMSessionFetcherStatusBadRequest = 400,
  509|       |  GTMSessionFetcherStatusUnauthorized = 401,
  510|       |  GTMSessionFetcherStatusForbidden = 403,
  511|       |  GTMSessionFetcherStatusPreconditionFailed = 412
  512|       |};
  513|       |
  514|       |#ifdef __cplusplus
  515|       |extern "C" {
  516|       |#endif
  517|       |
  518|       |@class GTMSessionCookieStorage;
  519|       |@class GTMSessionFetcher;
  520|       |
  521|       |// The configuration block is for modifying the NSURLSessionConfiguration only.
  522|       |// DO NOT change any fetcher properties in the configuration block.
  523|       |typedef void (^GTMSessionFetcherConfigurationBlock)(GTMSessionFetcher *fetcher,
  524|       |                                                    NSURLSessionConfiguration *configuration);
  525|       |typedef void (^GTMSessionFetcherSystemCompletionHandler)(void);
  526|       |typedef void (^GTMSessionFetcherCompletionHandler)(NSData * GTM_NULLABLE_TYPE data,
  527|       |                                                   NSError * GTM_NULLABLE_TYPE error);
  528|       |typedef void (^GTMSessionFetcherBodyStreamProviderResponse)(NSInputStream *bodyStream);
  529|       |typedef void (^GTMSessionFetcherBodyStreamProvider)(GTMSessionFetcherBodyStreamProviderResponse response);
  530|       |typedef void (^GTMSessionFetcherDidReceiveResponseDispositionBlock)(NSURLSessionResponseDisposition disposition);
  531|       |typedef void (^GTMSessionFetcherDidReceiveResponseBlock)(NSURLResponse *response,
  532|       |                                                         GTMSessionFetcherDidReceiveResponseDispositionBlock dispositionBlock);
  533|       |typedef void (^GTMSessionFetcherChallengeDispositionBlock)(NSURLSessionAuthChallengeDisposition disposition,
  534|       |                                                           NSURLCredential * GTM_NULLABLE_TYPE credential);
  535|       |typedef void (^GTMSessionFetcherChallengeBlock)(GTMSessionFetcher *fetcher,
  536|       |                                                NSURLAuthenticationChallenge *challenge,
  537|       |                                                GTMSessionFetcherChallengeDispositionBlock dispositionBlock);
  538|       |typedef void (^GTMSessionFetcherWillRedirectResponse)(NSURLRequest * GTM_NULLABLE_TYPE redirectedRequest);
  539|       |typedef void (^GTMSessionFetcherWillRedirectBlock)(NSHTTPURLResponse *redirectResponse,
  540|       |                                                   NSURLRequest *redirectRequest,
  541|       |                                                   GTMSessionFetcherWillRedirectResponse response);
  542|       |typedef void (^GTMSessionFetcherAccumulateDataBlock)(NSData * GTM_NULLABLE_TYPE buffer);
  543|       |typedef void (^GTMSessionFetcherSimulateByteTransferBlock)(NSData * GTM_NULLABLE_TYPE buffer,
  544|       |                                                           int64_t bytesWritten,
  545|       |                                                           int64_t totalBytesWritten,
  546|       |                                                           int64_t totalBytesExpectedToWrite);
  547|       |typedef void (^GTMSessionFetcherReceivedProgressBlock)(int64_t bytesWritten,
  548|       |                                                       int64_t totalBytesWritten);
  549|       |typedef void (^GTMSessionFetcherDownloadProgressBlock)(int64_t bytesWritten,
  550|       |                                                       int64_t totalBytesWritten,
  551|       |                                                       int64_t totalBytesExpectedToWrite);
  552|       |typedef void (^GTMSessionFetcherSendProgressBlock)(int64_t bytesSent,
  553|       |                                                   int64_t totalBytesSent,
  554|       |                                                   int64_t totalBytesExpectedToSend);
  555|       |typedef void (^GTMSessionFetcherWillCacheURLResponseResponse)(NSCachedURLResponse * GTM_NULLABLE_TYPE cachedResponse);
  556|       |typedef void (^GTMSessionFetcherWillCacheURLResponseBlock)(NSCachedURLResponse *proposedResponse,
  557|       |                                                           GTMSessionFetcherWillCacheURLResponseResponse responseBlock);
  558|       |typedef void (^GTMSessionFetcherRetryResponse)(BOOL shouldRetry);
  559|       |typedef void (^GTMSessionFetcherRetryBlock)(BOOL suggestedWillRetry,
  560|       |                                            NSError * GTM_NULLABLE_TYPE error,
  561|       |                                            GTMSessionFetcherRetryResponse response);
  562|       |
  563|       |typedef void (^GTMSessionFetcherTestResponse)(NSHTTPURLResponse * GTM_NULLABLE_TYPE response,
  564|       |                                              NSData * GTM_NULLABLE_TYPE data,
  565|       |                                              NSError * GTM_NULLABLE_TYPE error);
  566|       |typedef void (^GTMSessionFetcherTestBlock)(GTMSessionFetcher *fetcherToTest,
  567|       |                                           GTMSessionFetcherTestResponse testResponse);
  568|       |
  569|       |void GTMSessionFetcherAssertValidSelector(id GTM_NULLABLE_TYPE obj, SEL GTM_NULLABLE_TYPE sel, ...);
  570|       |
  571|       |// Utility functions for applications self-identifying to servers via a
  572|       |// user-agent header
  573|       |
  574|       |// The "standard" user agent includes the application identifier, taken from the bundle,
  575|       |// followed by a space and the system version string. Pass nil to use +mainBundle as the source
  576|       |// of the bundle identifier.
  577|       |//
  578|       |// Applications may use this as a starting point for their own user agent strings, perhaps
  579|       |// with additional sections appended.  Use GTMFetcherCleanedUserAgentString() below to
  580|       |// clean up any string being added to the user agent.
  581|       |NSString *GTMFetcherStandardUserAgentString(NSBundle * GTM_NULLABLE_TYPE bundle);
  582|       |
  583|       |// Make a generic name and version for the current application, like
  584|       |// com.example.MyApp/1.2.3 relying on the bundle identifier and the
  585|       |// CFBundleShortVersionString or CFBundleVersion.
  586|       |//
  587|       |// The bundle ID may be overridden as the base identifier string by
  588|       |// adding to the bundle's Info.plist a "GTMUserAgentID" key.
  589|       |//
  590|       |// If no bundle ID or override is available, the process name preceded
  591|       |// by "proc_" is used.
  592|       |NSString *GTMFetcherApplicationIdentifier(NSBundle * GTM_NULLABLE_TYPE bundle);
  593|       |
  594|       |// Make an identifier like "MacOSX/10.7.1" or "iPod_Touch/4.1 hw/iPod1_1"
  595|       |NSString *GTMFetcherSystemVersionString(void);
  596|       |
  597|       |// Make a parseable user-agent identifier from the given string, replacing whitespace
  598|       |// and commas with underscores, and removing other characters that may interfere
  599|       |// with parsing of the full user-agent string.
  600|       |//
  601|       |// For example, @"[My App]" would become @"My_App"
  602|       |NSString *GTMFetcherCleanedUserAgentString(NSString *str);
  603|       |
  604|       |// Grab the data from an input stream. Since streams cannot be assumed to be rewindable,
  605|       |// this may be destructive; the caller can try to rewind the stream (by setting the
  606|       |// NSStreamFileCurrentOffsetKey property) or can just use the NSData to make a new
  607|       |// NSInputStream. This function is intended to facilitate testing rather than be used in
  608|       |// production.
  609|       |//
  610|       |// This function operates synchronously on the current thread. Depending on how the
  611|       |// input stream is implemented, it may be appropriate to dispatch to a different
  612|       |// queue before calling this function.
  613|       |//
  614|       |// Failure is indicated by a returned data value of nil.
  615|       |NSData * GTM_NULLABLE_TYPE GTMDataFromInputStream(NSInputStream *inputStream, NSError **outError);
  616|       |
  617|       |#ifdef __cplusplus
  618|       |}  // extern "C"
  619|       |#endif
  620|       |
  621|       |
  622|       |#if !GTM_USE_SESSION_FETCHER
  623|       |@protocol GTMHTTPFetcherServiceProtocol;
  624|       |#endif
  625|       |
  626|       |// This protocol allows abstract references to the fetcher service, primarily for
  627|       |// fetchers (which may be compiled without the fetcher service class present.)
  628|       |//
  629|       |// Apps should not need to use this protocol.
  630|       |@protocol GTMSessionFetcherServiceProtocol <NSObject>
  631|       |// This protocol allows us to call into the service without requiring
  632|       |// GTMSessionFetcherService sources in this project
  633|       |
  634|       |@property(atomic, strong) dispatch_queue_t callbackQueue;
  635|       |
  636|       |- (BOOL)fetcherShouldBeginFetching:(GTMSessionFetcher *)fetcher;
  637|       |- (void)fetcherDidCreateSession:(GTMSessionFetcher *)fetcher;
  638|       |- (void)fetcherDidBeginFetching:(GTMSessionFetcher *)fetcher;
  639|       |- (void)fetcherDidStop:(GTMSessionFetcher *)fetcher;
  640|       |
  641|       |- (GTMSessionFetcher *)fetcherWithRequest:(NSURLRequest *)request;
  642|       |- (BOOL)isDelayingFetcher:(GTMSessionFetcher *)fetcher;
  643|       |
  644|       |@property(atomic, assign) BOOL reuseSession;
  645|       |- (GTM_NULLABLE NSURLSession *)session;
  646|       |- (GTM_NULLABLE NSURLSession *)sessionForFetcherCreation;
  647|       |- (GTM_NULLABLE id<NSURLSessionDelegate>)sessionDelegate;
  648|       |- (GTM_NULLABLE NSDate *)stoppedAllFetchersDate;
  649|       |
  650|       |// Methods for compatibility with the old GTMHTTPFetcher.
  651|       |@property(atomic, readonly, strong, GTM_NULLABLE) NSOperationQueue *delegateQueue;
  652|       |
  653|       |@end  // @protocol GTMSessionFetcherServiceProtocol
  654|       |
  655|       |#ifndef GTM_FETCHER_AUTHORIZATION_PROTOCOL
  656|       |#define GTM_FETCHER_AUTHORIZATION_PROTOCOL 1
  657|       |@protocol GTMFetcherAuthorizationProtocol <NSObject>
  658|       |@required
  659|       |// This protocol allows us to call the authorizer without requiring its sources
  660|       |// in this project.
  661|       |- (void)authorizeRequest:(GTM_NULLABLE NSMutableURLRequest *)request
  662|       |                delegate:(id)delegate
  663|       |       didFinishSelector:(SEL)sel;
  664|       |
  665|       |- (void)stopAuthorization;
  666|       |
  667|       |- (void)stopAuthorizationForRequest:(NSURLRequest *)request;
  668|       |
  669|       |- (BOOL)isAuthorizingRequest:(NSURLRequest *)request;
  670|       |
  671|       |- (BOOL)isAuthorizedRequest:(NSURLRequest *)request;
  672|       |
  673|       |@property(atomic, strong, readonly, GTM_NULLABLE) NSString *userEmail;
  674|       |
  675|       |@optional
  676|       |
  677|       |// Indicate if authorization may be attempted. Even if this succeeds,
  678|       |// authorization may fail if the user's permissions have been revoked.
  679|       |@property(atomic, readonly) BOOL canAuthorize;
  680|       |
  681|       |// For development only, allow authorization of non-SSL requests, allowing
  682|       |// transmission of the bearer token unencrypted.
  683|       |@property(atomic, assign) BOOL shouldAuthorizeAllRequests;
  684|       |
  685|       |- (void)authorizeRequest:(GTM_NULLABLE NSMutableURLRequest *)request
  686|       |       completionHandler:(void (^)(NSError * GTM_NULLABLE_TYPE error))handler;
  687|       |
  688|       |#if GTM_USE_SESSION_FETCHER
  689|       |@property(atomic, weak, GTM_NULLABLE) id<GTMSessionFetcherServiceProtocol> fetcherService;
  690|       |#else
  691|       |@property(atomic, weak, GTM_NULLABLE) id<GTMHTTPFetcherServiceProtocol> fetcherService;
  692|       |#endif
  693|       |
  694|       |- (BOOL)primeForRefresh;
  695|       |
  696|       |@end
  697|       |#endif  // GTM_FETCHER_AUTHORIZATION_PROTOCOL
  698|       |
  699|       |#if GTM_BACKGROUND_TASK_FETCHING
  700|       |// A protocol for an alternative target for messages from GTMSessionFetcher to UIApplication.
  701|       |// Set the target using +[GTMSessionFetcher setSubstituteUIApplication:]
  702|       |@protocol GTMUIApplicationProtocol <NSObject>
  703|       |- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithName:(nullable NSString *)taskName
  704|       |                                        expirationHandler:(void(^ __nullable)(void))handler;
  705|       |- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier;
  706|       |@end
  707|       |#endif
  708|       |
  709|       |#pragma mark -
  710|       |
  711|       |// GTMSessionFetcher objects are used for async retrieval of an http get or post
  712|       |//
  713|       |// See additional comments at the beginning of this file
  714|       |@interface GTMSessionFetcher : NSObject <NSURLSessionDelegate>
  715|       |
  716|       |// Create a fetcher
  717|       |//
  718|       |// fetcherWithRequest will return an autoreleased fetcher, but if
  719|       |// the connection is successfully created, the connection should retain the
  720|       |// fetcher for the life of the connection as well. So the caller doesn't have
  721|       |// to retain the fetcher explicitly unless they want to be able to cancel it.
  722|       |+ (instancetype)fetcherWithRequest:(GTM_NULLABLE NSURLRequest *)request;
  723|       |
  724|       |// Convenience methods that make a request, like +fetcherWithRequest
  725|       |+ (instancetype)fetcherWithURL:(NSURL *)requestURL;
  726|       |+ (instancetype)fetcherWithURLString:(NSString *)requestURLString;
  727|       |
  728|       |// Methods for creating fetchers to continue previous fetches.
  729|       |+ (instancetype)fetcherWithDownloadResumeData:(NSData *)resumeData;
  730|       |+ (GTM_NULLABLE instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier;
  731|       |
  732|       |// Returns an array of currently active fetchers for background sessions,
  733|       |// both restarted and newly created ones.
  734|       |+ (GTM_NSArrayOf(GTMSessionFetcher *) *)fetchersForBackgroundSessions;
  735|       |
  736|       |// Designated initializer.
  737|       |//
  738|       |// Applications should create fetchers with a "fetcherWith..." method on a fetcher
  739|       |// service or a class method, not with this initializer.
  740|       |//
  741|       |// The configuration should typically be nil. Applications needing to customize
  742|       |// the configuration may do so by setting the configurationBlock property.
  743|       |- (instancetype)initWithRequest:(GTM_NULLABLE NSURLRequest *)request
  744|       |                  configuration:(GTM_NULLABLE NSURLSessionConfiguration *)configuration;
  745|       |
  746|       |// The fetcher's request.  This may not be set after beginFetch has been invoked. The request
  747|       |// may change due to redirects.
  748|       |@property(atomic, strong, GTM_NULLABLE) NSURLRequest *request;
  749|       |
  750|       |// Set a header field value on the request. Header field value changes will not
  751|       |// affect a fetch after the fetch has begun.
  752|       |- (void)setRequestValue:(GTM_NULLABLE NSString *)value forHTTPHeaderField:(NSString *)field;
  753|       |
  754|       |// Data used for resuming a download task.
  755|       |@property(atomic, readonly, GTM_NULLABLE) NSData *downloadResumeData;
  756|       |
  757|       |// The configuration; this must be set before the fetch begins. If no configuration is
  758|       |// set or inherited from the fetcher service, then the fetcher uses an ephemeral config.
  759|       |//
  760|       |// NOTE: This property should typically be nil. Applications needing to customize
  761|       |// the configuration should do so by setting the configurationBlock property.
  762|       |// That allows the fetcher to pick an appropriate base configuration, with the
  763|       |// application setting only the configuration properties it needs to customize.
  764|       |@property(atomic, strong, GTM_NULLABLE) NSURLSessionConfiguration *configuration;
  765|       |
  766|       |// A block the client may use to customize the configuration used to create the session.
  767|       |//
  768|       |// This is called synchronously, either on the thread that begins the fetch or, during a retry,
  769|       |// on the main thread. The configuration block may be called repeatedly if multiple fetchers are
  770|       |// created.
  771|       |//
  772|       |// The configuration block is for modifying the NSURLSessionConfiguration only.
  773|       |// DO NOT change any fetcher properties in the configuration block. Fetcher properties
  774|       |// may be set in the fetcher service prior to fetcher creation, or on the fetcher prior
  775|       |// to invoking beginFetch.
  776|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherConfigurationBlock configurationBlock;
  777|       |
  778|       |// A session is created as needed by the fetcher.  A fetcher service object
  779|       |// may maintain sessions for multiple fetches to the same host.
  780|       |@property(atomic, strong, GTM_NULLABLE) NSURLSession *session;
  781|       |
  782|       |// The task in flight.
  783|       |@property(atomic, readonly, GTM_NULLABLE) NSURLSessionTask *sessionTask;
  784|       |
  785|       |// The background session identifier.
  786|       |@property(atomic, readonly, GTM_NULLABLE) NSString *sessionIdentifier;
  787|       |
  788|       |// Indicates a fetcher created to finish a background session task.
  789|       |@property(atomic, readonly) BOOL wasCreatedFromBackgroundSession;
  790|       |
  791|       |// Additional user-supplied data to encode into the session identifier. Since session identifier
  792|       |// length limits are unspecified, this should be kept small. Key names beginning with an underscore
  793|       |// are reserved for use by the fetcher.
  794|       |@property(atomic, strong, GTM_NULLABLE) GTM_NSDictionaryOf(NSString *, NSString *) *sessionUserInfo;
  795|       |
  796|       |// The human-readable description to be assigned to the task.
  797|       |@property(atomic, copy, GTM_NULLABLE) NSString *taskDescription;
  798|       |
  799|       |// The priority assigned to the task, if any.  Use NSURLSessionTaskPriorityLow,
  800|       |// NSURLSessionTaskPriorityDefault, or NSURLSessionTaskPriorityHigh.
  801|       |@property(atomic, assign) float taskPriority;
  802|       |
  803|       |// The fetcher encodes information used to resume a session in the session identifier.
  804|       |// This method, intended for internal use returns the encoded information.  The sessionUserInfo
  805|       |// dictionary is stored as identifier metadata.
  806|       |- (GTM_NULLABLE GTM_NSDictionaryOf(NSString *, NSString *) *)sessionIdentifierMetadata;
  807|       |
  808|       |#if TARGET_OS_IPHONE && !TARGET_OS_WATCH
  809|       |// The app should pass to this method the completion handler passed in the app delegate method
  810|       |// application:handleEventsForBackgroundURLSession:completionHandler:
  811|       |+ (void)application:(UIApplication *)application
  812|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
  813|       |                      completionHandler:(GTMSessionFetcherSystemCompletionHandler)completionHandler;
  814|       |#endif
  815|       |
  816|       |// Indicate that a newly created session should be a background session.
  817|       |// A new session identifier will be created by the fetcher.
  818|       |//
  819|       |// Warning:  The only thing background sessions are for is rare download
  820|       |// of huge, batched files of data. And even just for those, there's a lot
  821|       |// of pain and hackery needed to get transfers to actually happen reliably
  822|       |// with background sessions.
  823|       |//
  824|       |// Don't try to upload or download in many background sessions, since the system
  825|       |// will impose an exponentially increasing time penalty to prevent the app from
  826|       |// getting too much background execution time.
  827|       |//
  828|       |// References:
  829|       |//
  830|       |//   "Moving to Fewer, Larger Transfers"
  831|       |//   https://forums.developer.apple.com/thread/14853
  832|       |//
  833|       |//   "NSURLSession’s Resume Rate Limiter"
  834|       |//   https://forums.developer.apple.com/thread/14854
  835|       |//
  836|       |//   "Background Session Task state persistence"
  837|       |//   https://forums.developer.apple.com/thread/11554
  838|       |//
  839|       |@property(atomic, assign) BOOL useBackgroundSession;
  840|       |
  841|       |// Indicates if the fetcher was started using a background session.
  842|       |@property(atomic, readonly, getter=isUsingBackgroundSession) BOOL usingBackgroundSession;
  843|       |
  844|       |// Indicates if uploads should use an upload task.  This is always set for file or stream-provider
  845|       |// bodies, but may be set explicitly for NSData bodies.
  846|       |@property(atomic, assign) BOOL useUploadTask;
  847|       |
  848|       |// Indicates that the fetcher is using a session that may be shared with other fetchers.
  849|       |@property(atomic, readonly) BOOL canShareSession;
  850|       |
  851|       |// By default, the fetcher allows only secure (https) schemes unless this
  852|       |// property is set, or the GTM_ALLOW_INSECURE_REQUESTS build flag is set.
  853|       |//
  854|       |// For example, during debugging when fetching from a development server that lacks SSL support,
  855|       |// this may be set to @[ @"http" ], or when the fetcher is used to retrieve local files,
  856|       |// this may be set to @[ @"file" ].
  857|       |//
  858|       |// This should be left as nil for release builds to avoid creating the opportunity for
  859|       |// leaking private user behavior and data.  If a server is providing insecure URLs
  860|       |// for fetching by the client app, report the problem as server security & privacy bug.
  861|       |//
  862|       |// For builds with the iOS 9/OS X 10.11 and later SDKs, this property is required only when
  863|       |// the app specifies NSAppTransportSecurity/NSAllowsArbitraryLoads in the main bundle's Info.plist.
  864|       |@property(atomic, copy, GTM_NULLABLE) GTM_NSArrayOf(NSString *) *allowedInsecureSchemes;
  865|       |
  866|       |// By default, the fetcher prohibits localhost requests unless this property is set,
  867|       |// or the GTM_ALLOW_INSECURE_REQUESTS build flag is set.
  868|       |//
  869|       |// For localhost requests, the URL scheme is not checked  when this property is set.
  870|       |//
  871|       |// For builds with the iOS 9/OS X 10.11 and later SDKs, this property is required only when
  872|       |// the app specifies NSAppTransportSecurity/NSAllowsArbitraryLoads in the main bundle's Info.plist.
  873|       |@property(atomic, assign) BOOL allowLocalhostRequest;
  874|       |
  875|       |// By default, the fetcher requires valid server certs.  This may be bypassed
  876|       |// temporarily for development against a test server with an invalid cert.
  877|       |@property(atomic, assign) BOOL allowInvalidServerCertificates;
  878|       |
  879|       |// Cookie storage object for this fetcher. If nil, the fetcher will use a static cookie
  880|       |// storage instance shared among fetchers. If this fetcher was created by a fetcher service
  881|       |// object, it will be set to use the service object's cookie storage. See Cookies section above for
  882|       |// the full discussion.
  883|       |//
  884|       |// Because as of Jan 2014 standalone instances of NSHTTPCookieStorage do not actually
  885|       |// store any cookies (Radar 15735276) we use our own subclass, GTMSessionCookieStorage,
  886|       |// to hold cookies in memory.
  887|       |@property(atomic, strong, GTM_NULLABLE) NSHTTPCookieStorage *cookieStorage;
  888|       |
  889|       |// Setting the credential is optional; it is used if the connection receives
  890|       |// an authentication challenge.
  891|       |@property(atomic, strong, GTM_NULLABLE) NSURLCredential *credential;
  892|       |
  893|       |// Setting the proxy credential is optional; it is used if the connection
  894|       |// receives an authentication challenge from a proxy.
  895|       |@property(atomic, strong, GTM_NULLABLE) NSURLCredential *proxyCredential;
  896|       |
  897|       |// If body data, body file URL, or body stream provider is not set, then a GET request
  898|       |// method is assumed.
  899|       |@property(atomic, strong, GTM_NULLABLE) NSData *bodyData;
  900|       |
  901|       |// File to use as the request body. This forces use of an upload task.
  902|       |@property(atomic, strong, GTM_NULLABLE) NSURL *bodyFileURL;
  903|       |
  904|       |// Length of body to send, expected or actual.
  905|       |@property(atomic, readonly) int64_t bodyLength;
  906|       |
  907|       |// The body stream provider may be called repeatedly to provide a body.
  908|       |// Setting a body stream provider forces use of an upload task.
  909|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherBodyStreamProvider bodyStreamProvider;
  910|       |
  911|       |// Object to add authorization to the request, if needed.
  912|       |//
  913|       |// This may not be changed once beginFetch has been invoked.
  914|       |@property(atomic, strong, GTM_NULLABLE) id<GTMFetcherAuthorizationProtocol> authorizer;
  915|       |
  916|       |// The service object that created and monitors this fetcher, if any.
  917|       |@property(atomic, strong) id<GTMSessionFetcherServiceProtocol> service;
  918|       |
  919|       |// The host, if any, used to classify this fetcher in the fetcher service.
  920|       |@property(atomic, copy, GTM_NULLABLE) NSString *serviceHost;
  921|       |
  922|       |// The priority, if any, used for starting fetchers in the fetcher service.
  923|       |//
  924|       |// Lower values are higher priority; the default is 0, and values may
  925|       |// be negative or positive. This priority affects only the start order of
  926|       |// fetchers that are being delayed by a fetcher service when the running fetchers
  927|       |// exceeds the service's maxRunningFetchersPerHost.  A priority of NSIntegerMin will
  928|       |// exempt this fetcher from delay.
  929|       |@property(atomic, assign) NSInteger servicePriority;
  930|       |
  931|       |// The delegate's optional didReceiveResponse block may be used to inspect or alter
  932|       |// the session task response.
  933|       |//
  934|       |// This is called on the callback queue.
  935|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherDidReceiveResponseBlock didReceiveResponseBlock;
  936|       |
  937|       |// The delegate's optional challenge block may be used to inspect or alter
  938|       |// the session task challenge.
  939|       |//
  940|       |// If this block is not set, the fetcher's default behavior for the NSURLSessionTask
  941|       |// didReceiveChallenge: delegate method is to use the fetcher's respondToChallenge: method
  942|       |// which relies on the fetcher's credential and proxyCredential properties.
  943|       |//
  944|       |// Warning: This may be called repeatedly if the challenge fails. Check
  945|       |// challenge.previousFailureCount to identify repeated invocations.
  946|       |//
  947|       |// This is called on the callback queue.
  948|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherChallengeBlock challengeBlock;
  949|       |
  950|       |// The delegate's optional willRedirect block may be used to inspect or alter
  951|       |// the redirection.
  952|       |//
  953|       |// This is called on the callback queue.
  954|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherWillRedirectBlock willRedirectBlock;
  955|       |
  956|       |// The optional send progress block reports body bytes uploaded.
  957|       |//
  958|       |// This is called on the callback queue.
  959|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherSendProgressBlock sendProgressBlock;
  960|       |
  961|       |// The optional accumulate block may be set by clients wishing to accumulate data
  962|       |// themselves rather than let the fetcher append each buffer to an NSData.
  963|       |//
  964|       |// When this is called with nil data (such as on redirect) the client
  965|       |// should empty its accumulation buffer.
  966|       |//
  967|       |// This is called on the callback queue.
  968|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherAccumulateDataBlock accumulateDataBlock;
  969|       |
  970|       |// The optional received progress block may be used to monitor data
  971|       |// received from a data task.
  972|       |//
  973|       |// This is called on the callback queue.
  974|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherReceivedProgressBlock receivedProgressBlock;
  975|       |
  976|       |// The delegate's optional downloadProgress block may be used to monitor download
  977|       |// progress in writing to disk.
  978|       |//
  979|       |// This is called on the callback queue.
  980|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherDownloadProgressBlock downloadProgressBlock;
  981|       |
  982|       |// The delegate's optional willCacheURLResponse block may be used to alter the cached
  983|       |// NSURLResponse. The user may prevent caching by passing nil to the block's response.
  984|       |//
  985|       |// This is called on the callback queue.
  986|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherWillCacheURLResponseBlock willCacheURLResponseBlock;
  987|       |
  988|       |// Enable retrying; see comments at the top of this file.  Setting
  989|       |// retryEnabled=YES resets the min and max retry intervals.
  990|       |@property(atomic, assign, getter=isRetryEnabled) BOOL retryEnabled;
  991|       |
  992|       |// Retry block is optional for retries.
  993|       |//
  994|       |// If present, this block should call the response block with YES to cause a retry or NO to end the
  995|       |// fetch.
  996|       |// See comments at the top of this file.
  997|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherRetryBlock retryBlock;
  998|       |
  999|       |// Retry intervals must be strictly less than maxRetryInterval, else
 1000|       |// they will be limited to maxRetryInterval and no further retries will
 1001|       |// be attempted.  Setting maxRetryInterval to 0.0 will reset it to the
 1002|       |// default value, 60 seconds for downloads and 600 seconds for uploads.
 1003|       |@property(atomic, assign) NSTimeInterval maxRetryInterval;
 1004|       |
 1005|       |// Starting retry interval.  Setting minRetryInterval to 0.0 will reset it
 1006|       |// to a random value between 1.0 and 2.0 seconds.  Clients should normally not
 1007|       |// set this except for unit testing.
 1008|       |@property(atomic, assign) NSTimeInterval minRetryInterval;
 1009|       |
 1010|       |// Multiplier used to increase the interval between retries, typically 2.0.
 1011|       |// Clients should not need to set this.
 1012|       |@property(atomic, assign) double retryFactor;
 1013|       |
 1014|       |// Number of retries attempted.
 1015|       |@property(atomic, readonly) NSUInteger retryCount;
 1016|       |
 1017|       |// Interval delay to precede next retry.
 1018|       |@property(atomic, readonly) NSTimeInterval nextRetryInterval;
 1019|       |
 1020|       |#if GTM_BACKGROUND_TASK_FETCHING
 1021|       |// Skip use of a UIBackgroundTask, thus requiring fetches to complete when the app is in the
 1022|       |// foreground.
 1023|       |//
 1024|       |// Targets should define GTM_BACKGROUND_TASK_FETCHING to 0 to avoid use of a UIBackgroundTask
 1025|       |// on iOS to allow fetches to complete in the background.  This property is available when
 1026|       |// it's not practical to set the preprocessor define.
 1027|       |@property(atomic, assign) BOOL skipBackgroundTask;
 1028|       |#endif  // GTM_BACKGROUND_TASK_FETCHING
 1029|       |
 1030|       |// Begin fetching the request
 1031|       |//
 1032|       |// The delegate may optionally implement the callback or pass nil for the selector or handler.
 1033|       |//
 1034|       |// The delegate and all callback blocks are retained between the beginFetch call until after the
 1035|       |// finish callback, or until the fetch is stopped.
 1036|       |//
 1037|       |// An error is passed to the callback for server statuses 300 or
 1038|       |// higher, with the status stored as the error object's code.
 1039|       |//
 1040|       |// finishedSEL has a signature like:
 1041|       |//   - (void)fetcher:(GTMSessionFetcher *)fetcher
 1042|       |//  finishedWithData:(NSData *)data
 1043|       |//             error:(NSError *)error;
 1044|       |//
 1045|       |// If the application has specified a destinationFileURL or an accumulateDataBlock
 1046|       |// for the fetcher, the data parameter passed to the callback will be nil.
 1047|       |
 1048|       |- (void)beginFetchWithDelegate:(GTM_NULLABLE id)delegate
 1049|       |             didFinishSelector:(GTM_NULLABLE SEL)finishedSEL;
 1050|       |
 1051|       |- (void)beginFetchWithCompletionHandler:(GTM_NULLABLE GTMSessionFetcherCompletionHandler)handler;
 1052|       |
 1053|       |// Returns YES if this fetcher is in the process of fetching a URL.
 1054|       |@property(atomic, readonly, getter=isFetching) BOOL fetching;
 1055|       |
 1056|       |// Cancel the fetch of the request that's currently in progress.  The completion handler
 1057|       |// will not be called.
 1058|       |- (void)stopFetching;
 1059|       |
 1060|       |// A block to be called when the fetch completes.
 1061|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherCompletionHandler completionHandler;
 1062|       |
 1063|       |// A block to be called if download resume data becomes available.
 1064|       |@property(atomic, strong, GTM_NULLABLE) void (^resumeDataBlock)(NSData *);
 1065|       |
 1066|       |// Return the status code from the server response.
 1067|       |@property(atomic, readonly) NSInteger statusCode;
 1068|       |
 1069|       |// Return the http headers from the response.
 1070|       |@property(atomic, strong, readonly, GTM_NULLABLE) GTM_NSDictionaryOf(NSString *, NSString *) *responseHeaders;
 1071|       |
 1072|       |// The response, once it's been received.
 1073|       |@property(atomic, strong, readonly, GTM_NULLABLE) NSURLResponse *response;
 1074|       |
 1075|       |// Bytes downloaded so far.
 1076|       |@property(atomic, readonly) int64_t downloadedLength;
 1077|       |
 1078|       |// Buffer of currently-downloaded data, if available.
 1079|       |@property(atomic, readonly, strong, GTM_NULLABLE) NSData *downloadedData;
 1080|       |
 1081|       |// Local path to which the downloaded file will be moved.
 1082|       |//
 1083|       |// If a file already exists at the path, it will be overwritten.
 1084|       |// Will create the enclosing folders if they are not present.
 1085|       |@property(atomic, strong, GTM_NULLABLE) NSURL *destinationFileURL;
 1086|       |
 1087|       |// The time this fetcher originally began fetching. This is useful as a time
 1088|       |// barrier for ignoring irrelevant fetch notifications or callbacks.
 1089|       |@property(atomic, strong, readonly, GTM_NULLABLE) NSDate *initialBeginFetchDate;
 1090|       |
 1091|       |// userData is retained solely for the convenience of the client.
 1092|       |@property(atomic, strong, GTM_NULLABLE) id userData;
 1093|       |
 1094|       |// Stored property values are retained solely for the convenience of the client.
 1095|       |@property(atomic, copy, GTM_NULLABLE) GTM_NSDictionaryOf(NSString *, id) *properties;
 1096|       |
 1097|       |- (void)setProperty:(GTM_NULLABLE id)obj forKey:(NSString *)key;  // Pass nil for obj to remove the property.
 1098|       |- (GTM_NULLABLE id)propertyForKey:(NSString *)key;
 1099|       |
 1100|       |- (void)addPropertiesFromDictionary:(GTM_NSDictionaryOf(NSString *, id) *)dict;
 1101|       |
 1102|       |// Comments are useful for logging, so are strongly recommended for each fetcher.
 1103|       |@property(atomic, copy, GTM_NULLABLE) NSString *comment;
 1104|       |
 1105|       |- (void)setCommentWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1, 2);
 1106|       |
 1107|       |// Log of request and response, if logging is enabled
 1108|       |@property(atomic, copy, GTM_NULLABLE) NSString *log;
 1109|       |
 1110|       |// Callbacks are run on this queue.  If none is supplied, the main queue is used.
 1111|       |@property(atomic, strong, GTM_NULL_RESETTABLE) dispatch_queue_t callbackQueue;
 1112|       |
 1113|       |// The queue used internally by the session to invoke its delegate methods in the fetcher.
 1114|       |//
 1115|       |// Application callbacks are always called by the fetcher on the callbackQueue above,
 1116|       |// not on this queue. Apps should generally not change this queue.
 1117|       |//
 1118|       |// The default delegate queue is the main queue.
 1119|       |//
 1120|       |// This value is ignored after the session has been created, so this
 1121|       |// property should be set in the fetcher service rather in the fetcher as it applies
 1122|       |// to a shared session.
 1123|       |@property(atomic, strong, GTM_NULL_RESETTABLE) NSOperationQueue *sessionDelegateQueue;
 1124|       |
 1125|       |// Spin the run loop or sleep the thread, discarding events, until the fetch has completed.
 1126|       |//
 1127|       |// This is only for use in testing or in tools without a user interface.
 1128|       |//
 1129|       |// Note:  Synchronous fetches should never be used by shipping apps; they are
 1130|       |// sufficient reason for rejection from the app store.
 1131|       |//
 1132|       |// Returns NO if timed out.
 1133|       |- (BOOL)waitForCompletionWithTimeout:(NSTimeInterval)timeoutInSeconds;
 1134|       |
 1135|       |// Test block is optional for testing.
 1136|       |//
 1137|       |// If present, this block will cause the fetcher to skip starting the session, and instead
 1138|       |// use the test block response values when calling the completion handler and delegate code.
 1139|       |//
 1140|       |// Test code can set this on the fetcher or on the fetcher service.  For testing libraries
 1141|       |// that use a fetcher without exposing either the fetcher or the fetcher service, the global
 1142|       |// method setGlobalTestBlock: will set the block for all fetchers that do not have a test
 1143|       |// block set.
 1144|       |//
 1145|       |// The test code can pass nil for all response parameters to indicate that the fetch
 1146|       |// should proceed.
 1147|       |//
 1148|       |// Applications can exclude test block support by setting GTM_DISABLE_FETCHER_TEST_BLOCK.
 1149|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherTestBlock testBlock;
 1150|       |
 1151|       |+ (void)setGlobalTestBlock:(GTM_NULLABLE GTMSessionFetcherTestBlock)block;
 1152|       |
 1153|       |// When using the testBlock, |testBlockAccumulateDataChunkCount| is the desired number of chunks to
 1154|       |// divide the response data into if the client has streaming enabled. The data will be divided up to
 1155|       |// |testBlockAccumulateDataChunkCount| chunks; however, the exact amount may vary depending on the
 1156|       |// size of the response data (e.g. a 1-byte response can only be divided into one chunk).
 1157|       |@property(atomic, readwrite) NSUInteger testBlockAccumulateDataChunkCount;
 1158|       |
 1159|       |#if GTM_BACKGROUND_TASK_FETCHING
 1160|       |// For testing or to override UIApplication invocations, apps may specify an alternative
 1161|       |// target for messages to UIApplication.
 1162|       |+ (void)setSubstituteUIApplication:(nullable id<GTMUIApplicationProtocol>)substituteUIApplication;
 1163|       |+ (nullable id<GTMUIApplicationProtocol>)substituteUIApplication;
 1164|       |#endif  // GTM_BACKGROUND_TASK_FETCHING
 1165|       |
 1166|       |// Exposed for testing.
 1167|       |+ (GTMSessionCookieStorage *)staticCookieStorage;
 1168|       |+ (BOOL)appAllowsInsecureRequests;
 1169|       |
 1170|       |#if STRIP_GTM_FETCH_LOGGING
 1171|       |// If logging is stripped, provide a stub for the main method
 1172|       |// for controlling logging.
 1173|       |+ (void)setLoggingEnabled:(BOOL)flag;
 1174|       |+ (BOOL)isLoggingEnabled;
 1175|       |
 1176|       |#else
 1177|       |
 1178|       |// These methods let an application log specific body text, such as the text description of a binary
 1179|       |// request or response. The application should set the fetcher to defer response body logging until
 1180|       |// the response has been received and the log response body has been set by the app. For example:
 1181|       |//
 1182|       |//   fetcher.logRequestBody = [binaryObject stringDescription];
 1183|       |//   fetcher.deferResponseBodyLogging = YES;
 1184|       |//   [fetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
 1185|       |//      if (error == nil) {
 1186|       |//        fetcher.logResponseBody = [[[MyThing alloc] initWithData:data] stringDescription];
 1187|       |//      }
 1188|       |//      fetcher.deferResponseBodyLogging = NO;
 1189|       |//   }];
 1190|       |
 1191|       |@property(atomic, copy, GTM_NULLABLE) NSString *logRequestBody;
 1192|       |@property(atomic, assign) BOOL deferResponseBodyLogging;
 1193|       |@property(atomic, copy, GTM_NULLABLE) NSString *logResponseBody;
 1194|       |
 1195|       |// Internal logging support.
 1196|       |@property(atomic, readonly) NSData *loggedStreamData;
 1197|       |@property(atomic, assign) BOOL hasLoggedError;
 1198|       |@property(atomic, strong, GTM_NULLABLE) NSURL *redirectedFromURL;
 1199|       |- (void)appendLoggedStreamData:(NSData *)dataToAdd;
 1200|       |- (void)clearLoggedStreamData;
 1201|       |
 1202|       |#endif // STRIP_GTM_FETCH_LOGGING
 1203|       |
 1204|       |@end
 1205|       |
 1206|       |@interface GTMSessionFetcher (BackwardsCompatibilityOnly)
 1207|       |// Clients using GTMSessionFetcher should set the cookie storage explicitly themselves.
 1208|       |// This method is just for compatibility with the old GTMHTTPFetcher class.
 1209|       |- (void)setCookieStorageMethod:(NSInteger)method;
 1210|       |@end
 1211|       |
 1212|       |// Until we can just instantiate NSHTTPCookieStorage for local use, we'll
 1213|       |// implement all the public methods ourselves.  This stores cookies only in
 1214|       |// memory.  Additional methods are provided for testing.
 1215|       |//
 1216|       |// iOS 9/OS X 10.11 added +[NSHTTPCookieStorage sharedCookieStorageForGroupContainerIdentifier:]
 1217|       |// which may also be used to create cookie storage.
 1218|       |@interface GTMSessionCookieStorage : NSHTTPCookieStorage
 1219|       |
 1220|       |// Add the array off cookies to the storage, replacing duplicates.
 1221|       |// Also removes expired cookies from the storage.
 1222|       |- (void)setCookies:(GTM_NULLABLE GTM_NSArrayOf(NSHTTPCookie *) *)cookies;
 1223|       |
 1224|       |- (void)removeAllCookies;
 1225|       |
 1226|       |@end
 1227|       |
 1228|       |// Macros to monitor synchronization blocks in debug builds.
 1229|       |// These report problems using GTMSessionCheckDebug.
 1230|       |//
 1231|       |// GTMSessionMonitorSynchronized           Start monitoring a top-level-only
 1232|       |//                                         @sync scope.
 1233|       |// GTMSessionMonitorRecursiveSynchronized  Start monitoring a top-level or
 1234|       |//                                         recursive @sync scope.
 1235|       |// GTMSessionCheckSynchronized             Verify that the current execution
 1236|       |//                                         is inside a @sync scope.
 1237|       |// GTMSessionCheckNotSynchronized          Verify that the current execution
 1238|       |//                                         is not inside a @sync scope.
 1239|       |//
 1240|       |// Example usage:
 1241|       |//
 1242|       |// - (void)myExternalMethod {
 1243|       |//   @synchronized(self) {
 1244|       |//     GTMSessionMonitorSynchronized(self)
 1245|       |//
 1246|       |// - (void)myInternalMethod {
 1247|       |//   GTMSessionCheckSynchronized(self);
 1248|       |//
 1249|       |// - (void)callMyCallbacks {
 1250|       |//   GTMSessionCheckNotSynchronized(self);
 1251|       |//
 1252|       |// GTMSessionCheckNotSynchronized is available for verifying the code isn't
 1253|       |// in a deadlockable @sync state when posting notifications and invoking
 1254|       |// callbacks. Don't use GTMSessionCheckNotSynchronized immediately before a
 1255|       |// @sync scope; the normal recursiveness check of GTMSessionMonitorSynchronized
 1256|       |// can catch those.
 1257|       |
 1258|       |#ifdef __OBJC__
 1259|       |// If asserts are entirely no-ops, the synchronization monitor is just a bunch
 1260|       |// of counting code that doesn't report exceptional circumstances in any way.
 1261|       |// Only build the synchronization monitor code if NS_BLOCK_ASSERTIONS is not
 1262|       |// defined or asserts are being logged instead.
 1263|       |#if DEBUG && (!defined(NS_BLOCK_ASSERTIONS) || GTMSESSION_ASSERT_AS_LOG)
 1264|       |  #define __GTMSessionMonitorSynchronizedVariableInner(varname, counter) \
 1265|       |      varname ## counter
 1266|       |  #define __GTMSessionMonitorSynchronizedVariable(varname, counter)  \
 1267|       |      __GTMSessionMonitorSynchronizedVariableInner(varname, counter)
 1268|       |
 1269|       |  #define GTMSessionMonitorSynchronized(obj)                                     \
 1270|      0|      NS_VALID_UNTIL_END_OF_SCOPE id                                             \
 1271|      0|        __GTMSessionMonitorSynchronizedVariable(__monitor, __COUNTER__) =        \
 1272|      0|        [[GTMSessionSyncMonitorInternal alloc] initWithSynchronizationObject:obj \
 1273|      0|                                                    allowRecursive:NO            \
 1274|      0|                                                     functionName:__func__]
 1275|       |
 1276|       |  #define GTMSessionMonitorRecursiveSynchronized(obj)                            \
 1277|       |      NS_VALID_UNTIL_END_OF_SCOPE id                                             \
 1278|       |        __GTMSessionMonitorSynchronizedVariable(__monitor, __COUNTER__) =        \
 1279|       |        [[GTMSessionSyncMonitorInternal alloc] initWithSynchronizationObject:obj \
 1280|       |                                                    allowRecursive:YES           \
 1281|       |                                                     functionName:__func__]
 1282|       |
 1283|      0|  #define GTMSessionCheckSynchronized(obj) {                                           \
 1284|      0|      GTMSESSION_ASSERT_DEBUG(                                                         \
 1285|      0|          [GTMSessionSyncMonitorInternal functionsHoldingSynchronizationOnObject:obj], \
 1286|      0|          @"GTMSessionCheckSynchronized(" #obj ") failed: not sync'd"                  \
 1287|      0|          @" on " #obj " in %s. Call stack:\n%@",                                      \
 1288|      0|          __func__, [NSThread callStackSymbols]);                                      \
 1289|      0|      }
 1290|       |
 1291|      0|  #define GTMSessionCheckNotSynchronized(obj) {                                       \
 1292|      0|      GTMSESSION_ASSERT_DEBUG(                                                        \
 1293|      0|        ![GTMSessionSyncMonitorInternal functionsHoldingSynchronizationOnObject:obj], \
 1294|      0|        @"GTMSessionCheckNotSynchronized(" #obj ") failed: was sync'd"                \
 1295|      0|        @" on " #obj " in %s by %@. Call stack:\n%@", __func__,                       \
 1296|      0|        [GTMSessionSyncMonitorInternal functionsHoldingSynchronizationOnObject:obj],  \
 1297|      0|        [NSThread callStackSymbols]);                                                 \
 1298|      0|      }
 1299|       |
 1300|       |// GTMSessionSyncMonitorInternal is a private class that keeps track of the
 1301|       |// beginning and end of synchronized scopes.
 1302|       |//
 1303|       |// This class should not be used directly, but only via the
 1304|       |// GTMSessionMonitorSynchronized macro.
 1305|       |@interface GTMSessionSyncMonitorInternal : NSObject
 1306|       |- (instancetype)initWithSynchronizationObject:(id)object
 1307|       |                               allowRecursive:(BOOL)allowRecursive
 1308|       |                                 functionName:(const char *)functionName;
 1309|       |// Return the names of the functions that hold sync on the object, or nil if none.
 1310|       |+ (NSArray *)functionsHoldingSynchronizationOnObject:(id)object;
 1311|       |@end
 1312|       |
 1313|       |#else
 1314|       |  #define GTMSessionMonitorSynchronized(obj) do { } while (0)
 1315|       |  #define GTMSessionMonitorRecursiveSynchronized(obj) do { } while (0)
 1316|       |  #define GTMSessionCheckSynchronized(obj) do { } while (0)
 1317|       |  #define GTMSessionCheckNotSynchronized(obj) do { } while (0)
 1318|       |#endif  // !DEBUG
 1319|       |#endif  // __OBJC__
 1320|       |
 1321|       |
 1322|       |GTM_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GTMSessionFetcher/Source/GTMSessionFetcher.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#import "GTMSessionFetcher.h"
   21|       |#if TARGET_OS_OSX && GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH
   22|       |// To reconnect background sessions on Mac outside +load requires importing and linking
   23|       |// AppKit to access the NSApplicationDidFinishLaunching symbol.
   24|       |#import <AppKit/AppKit.h>
   25|       |#endif
   26|       |
   27|       |#import <sys/utsname.h>
   28|       |
   29|       |#ifndef STRIP_GTM_FETCH_LOGGING
   30|       |  #error GTMSessionFetcher headers should have defaulted this if it wasn't already defined.
   31|       |#endif
   32|       |
   33|       |GTM_ASSUME_NONNULL_BEGIN
   34|       |
   35|       |NSString *const kGTMSessionFetcherStartedNotification           = @"kGTMSessionFetcherStartedNotification";
   36|       |NSString *const kGTMSessionFetcherStoppedNotification           = @"kGTMSessionFetcherStoppedNotification";
   37|       |NSString *const kGTMSessionFetcherRetryDelayStartedNotification = @"kGTMSessionFetcherRetryDelayStartedNotification";
   38|       |NSString *const kGTMSessionFetcherRetryDelayStoppedNotification = @"kGTMSessionFetcherRetryDelayStoppedNotification";
   39|       |
   40|       |NSString *const kGTMSessionFetcherCompletionInvokedNotification = @"kGTMSessionFetcherCompletionInvokedNotification";
   41|       |NSString *const kGTMSessionFetcherCompletionDataKey = @"data";
   42|       |NSString *const kGTMSessionFetcherCompletionErrorKey = @"error";
   43|       |
   44|       |NSString *const kGTMSessionFetcherErrorDomain       = @"com.google.GTMSessionFetcher";
   45|       |NSString *const kGTMSessionFetcherStatusDomain      = @"com.google.HTTPStatus";
   46|       |NSString *const kGTMSessionFetcherStatusDataKey     = @"data";  // data returned with a kGTMSessionFetcherStatusDomain error
   47|       |NSString *const kGTMSessionFetcherStatusDataContentTypeKey = @"data_content_type";
   48|       |
   49|       |NSString *const kGTMSessionFetcherNumberOfRetriesDoneKey        = @"kGTMSessionFetcherNumberOfRetriesDoneKey";
   50|       |NSString *const kGTMSessionFetcherElapsedIntervalWithRetriesKey = @"kGTMSessionFetcherElapsedIntervalWithRetriesKey";
   51|       |
   52|       |static NSString *const kGTMSessionIdentifierPrefix = @"com.google.GTMSessionFetcher";
   53|       |static NSString *const kGTMSessionIdentifierDestinationFileURLMetadataKey = @"_destURL";
   54|       |static NSString *const kGTMSessionIdentifierBodyFileURLMetadataKey        = @"_bodyURL";
   55|       |
   56|       |// The default max retry interview is 10 minutes for uploads (POST/PUT/PATCH),
   57|       |// 1 minute for downloads.
   58|       |static const NSTimeInterval kUnsetMaxRetryInterval = -1.0;
   59|       |static const NSTimeInterval kDefaultMaxDownloadRetryInterval = 60.0;
   60|       |static const NSTimeInterval kDefaultMaxUploadRetryInterval = 60.0 * 10.;
   61|       |
   62|       |// The maximum data length that can be loaded to the error userInfo
   63|       |static const int64_t kMaximumDownloadErrorDataLength = 20000;
   64|       |
   65|       |#ifdef GTMSESSION_PERSISTED_DESTINATION_KEY
   66|       |// Projects using unique class names should also define a unique persisted destination key.
   67|       |static NSString * const kGTMSessionFetcherPersistedDestinationKey =
   68|       |    GTMSESSION_PERSISTED_DESTINATION_KEY;
   69|       |#else
   70|       |static NSString * const kGTMSessionFetcherPersistedDestinationKey =
   71|       |    @"com.google.GTMSessionFetcher.downloads";
   72|       |#endif
   73|       |
   74|       |GTM_ASSUME_NONNULL_END
   75|       |
   76|       |//
   77|       |// GTMSessionFetcher
   78|       |//
   79|       |
   80|       |#if 0
   81|       |#define GTM_LOG_BACKGROUND_SESSION(...) GTMSESSION_LOG_DEBUG(__VA_ARGS__)
   82|       |#else
   83|       |#define GTM_LOG_BACKGROUND_SESSION(...)
   84|       |#endif
   85|       |
   86|       |#ifndef GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY
   87|       |  #if (TARGET_OS_TV \
   88|       |       || TARGET_OS_WATCH \
   89|       |       || (!TARGET_OS_IPHONE && defined(MAC_OS_X_VERSION_10_11) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11) \
   90|       |       || (TARGET_OS_IPHONE && defined(__IPHONE_9_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_9_0))
   91|       |    #define GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY 1
   92|       |  #endif
   93|       |#endif
   94|       |
   95|       |#if ((defined(TARGET_OS_MACCATALYST) && TARGET_OS_MACCATALYST) || \
   96|       |     (TARGET_OS_OSX && defined(__MAC_10_15) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_15) || \
   97|       |     (TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_13_0) || \
   98|       |     (TARGET_OS_WATCH && defined(__WATCHOS_6_0) && __WATCHOS_VERSION_MIN_REQUIRED >= __WATCHOS_6_0) || \
   99|       |     (TARGET_OS_TV && defined(__TVOS_13_0) && __TVOS_VERSION_MIN_REQUIRED >= __TVOS_13_0))
  100|       |#define GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 1
  101|       |#define GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 1
  102|       |#elif ((TARGET_OS_OSX && defined(__MAC_10_15) && __MAC_OS_X_VERSION_MAX_ALLOWED >= __MAC_10_15) || \
  103|       |       (TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0) || \
  104|       |       (TARGET_OS_WATCH && defined(__WATCHOS_6_0) && __WATCHOS_VERSION_MAX_ALLOWED >= __WATCHOS_6_0) || \
  105|       |       (TARGET_OS_TV && defined(__TVOS_13_0) && __TVOS_VERSION_MAX_ALLOWED >= __TVOS_13_0))
  106|       |#define GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 0
  107|       |#define GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 1
  108|       |#else
  109|       |#define GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 0
  110|       |#define GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 0
  111|       |#endif
  112|       |
  113|       |#if ((defined(TARGET_OS_MACCATALYST) && TARGET_OS_MACCATALYST) || \
  114|       |     (TARGET_OS_OSX && defined(__MAC_10_15) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_15) || \
  115|       |     (TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_13_0) || \
  116|       |     (TARGET_OS_WATCH && defined(__WATCHOS_6_0) && __WATCHOS_VERSION_MIN_REQUIRED >= __WATCHOS_6_0) || \
  117|       |     (TARGET_OS_TV && defined(__TVOS_13_0) && __TVOS_VERSION_MIN_REQUIRED >= __TVOS_13_0))
  118|       |#define GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR 1
  119|       |#else
  120|       |#define GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR 0
  121|       |#endif
  122|       |
  123|       |@interface GTMSessionFetcher ()
  124|       |
  125|       |@property(atomic, strong, readwrite, GTM_NULLABLE) NSData *downloadedData;
  126|       |@property(atomic, strong, readwrite, GTM_NULLABLE) NSData *downloadResumeData;
  127|       |
  128|       |#if GTM_BACKGROUND_TASK_FETCHING
  129|       |// Should always be accessed within an @synchronized(self).
  130|       |@property(assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskIdentifier;
  131|       |#endif
  132|       |
  133|       |@property(atomic, readwrite, getter=isUsingBackgroundSession) BOOL usingBackgroundSession;
  134|       |
  135|       |@end
  136|       |
  137|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
  138|       |@interface GTMSessionFetcher (GTMSessionFetcherLoggingInternal)
  139|       |- (void)logFetchWithError:(NSError *)error;
  140|       |- (void)logNowWithError:(GTM_NULLABLE NSError *)error;
  141|       |- (NSInputStream *)loggedInputStreamForInputStream:(NSInputStream *)inputStream;
  142|       |- (GTMSessionFetcherBodyStreamProvider)loggedStreamProviderForStreamProvider:
  143|       |    (GTMSessionFetcherBodyStreamProvider)streamProvider;
  144|       |@end
  145|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
  146|       |
  147|       |GTM_ASSUME_NONNULL_BEGIN
  148|       |
  149|      0|static NSTimeInterval InitialMinRetryInterval(void) {
  150|      0|  return 1.0 + ((double)(arc4random_uniform(0x0FFFF)) / (double) 0x0FFFF);
  151|      0|}
  152|       |
  153|      0|static BOOL IsLocalhost(NSString * GTM_NULLABLE_TYPE host) {
  154|      0|  // We check if there's host, and then make the comparisons.
  155|      0|  if (host == nil) return NO;
  156|      0|  return ([host caseInsensitiveCompare:@"localhost"] == NSOrderedSame
  157|      0|          || [host isEqual:@"::1"]
  158|      0|          || [host isEqual:@"127.0.0.1"]);
  159|      0|}
  160|       |
  161|       |static NSDictionary *GTM_NULLABLE_TYPE GTMErrorUserInfoForData(
  162|      0|    NSData *GTM_NULLABLE_TYPE data, NSDictionary *GTM_NULLABLE_TYPE responseHeaders) {
  163|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  164|      0|
  165|      0|  if (data.length > 0) {
  166|      0|    userInfo[kGTMSessionFetcherStatusDataKey] = data;
  167|      0|
  168|      0|    NSString *contentType = responseHeaders[@"Content-Type"];
  169|      0|    if (contentType) {
  170|      0|      userInfo[kGTMSessionFetcherStatusDataContentTypeKey] = contentType;
  171|      0|    }
  172|      0|  }
  173|      0|
  174|      0|  return userInfo.count > 0 ? userInfo : nil;
  175|      0|}
  176|       |
  177|       |static GTMSessionFetcherTestBlock GTM_NULLABLE_TYPE gGlobalTestBlock;
  178|       |
  179|       |@implementation GTMSessionFetcher {
  180|       |  NSMutableURLRequest *_request; // after beginFetch, changed only in delegate callbacks
  181|       |  BOOL _useUploadTask;           // immutable after beginFetch
  182|       |  NSURL *_bodyFileURL;           // immutable after beginFetch
  183|       |  GTMSessionFetcherBodyStreamProvider _bodyStreamProvider;  // immutable after beginFetch
  184|       |  NSURLSession *_session;
  185|       |  BOOL _shouldInvalidateSession;  // immutable after beginFetch
  186|       |  NSURLSession *_sessionNeedingInvalidation;
  187|       |  NSURLSessionConfiguration *_configuration;
  188|       |  NSURLSessionTask *_sessionTask;
  189|       |  NSString *_taskDescription;
  190|       |  float _taskPriority;
  191|       |  NSURLResponse *_response;
  192|       |  NSString *_sessionIdentifier;
  193|       |  BOOL _wasCreatedFromBackgroundSession;
  194|       |  BOOL _didCreateSessionIdentifier;
  195|       |  NSString *_sessionIdentifierUUID;
  196|       |  BOOL _userRequestedBackgroundSession;
  197|       |  BOOL _usingBackgroundSession;
  198|       |  NSMutableData * GTM_NULLABLE_TYPE _downloadedData;
  199|       |  NSError *_downloadFinishedError;
  200|       |  NSData *_downloadResumeData;  // immutable after construction
  201|       |  NSData * GTM_NULLABLE_TYPE _downloadTaskErrorData; // Data for when download task fails
  202|       |  NSURL *_destinationFileURL;
  203|       |  int64_t _downloadedLength;
  204|       |  NSURLCredential *_credential;     // username & password
  205|       |  NSURLCredential *_proxyCredential; // credential supplied to proxy servers
  206|       |  BOOL _isStopNotificationNeeded;   // set when start notification has been sent
  207|       |  BOOL _isUsingTestBlock;  // set when a test block was provided (remains set when the block is released)
  208|       |  id _userData;                      // retained, if set by caller
  209|       |  NSMutableDictionary *_properties;  // more data retained for caller
  210|       |  dispatch_queue_t _callbackQueue;
  211|       |  dispatch_group_t _callbackGroup;   // read-only after creation
  212|       |  NSOperationQueue *_delegateQueue;  // immutable after beginFetch
  213|       |
  214|       |  id<GTMFetcherAuthorizationProtocol> _authorizer;  // immutable after beginFetch
  215|       |
  216|       |  // The service object that created and monitors this fetcher, if any.
  217|       |  id<GTMSessionFetcherServiceProtocol> _service;  // immutable; set by the fetcher service upon creation
  218|       |  NSString *_serviceHost;
  219|       |  NSInteger _servicePriority;       // immutable after beginFetch
  220|       |  BOOL _hasStoppedFetching;         // counterpart to _initialBeginFetchDate
  221|       |  BOOL _userStoppedFetching;
  222|       |
  223|       |  BOOL _isRetryEnabled;             // user wants auto-retry
  224|       |  NSTimer *_retryTimer;
  225|       |  NSUInteger _retryCount;
  226|       |  NSTimeInterval _maxRetryInterval; // default 60 (download) or 600 (upload) seconds
  227|       |  NSTimeInterval _minRetryInterval; // random between 1 and 2 seconds
  228|       |  NSTimeInterval _retryFactor;      // default interval multiplier is 2
  229|       |  NSTimeInterval _lastRetryInterval;
  230|       |  NSDate *_initialBeginFetchDate;   // date that beginFetch was first invoked; immutable after initial beginFetch
  231|       |  NSDate *_initialRequestDate;      // date of first request to the target server (ignoring auth)
  232|       |  BOOL _hasAttemptedAuthRefresh;    // accessed only in shouldRetryNowForStatus:
  233|       |
  234|       |  NSString *_comment;               // comment for log
  235|       |  NSString *_log;
  236|       |#if !STRIP_GTM_FETCH_LOGGING
  237|       |  NSMutableData *_loggedStreamData;
  238|       |  NSURL *_redirectedFromURL;
  239|       |  NSString *_logRequestBody;
  240|       |  NSString *_logResponseBody;
  241|       |  BOOL _hasLoggedError;
  242|       |  BOOL _deferResponseBodyLogging;
  243|       |#endif
  244|       |}
  245|       |
  246|       |#if !GTMSESSION_UNIT_TESTING
  247|      1|+ (void)load {
  248|      1|#if GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH && TARGET_OS_IPHONE
  249|      1|  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
  250|      1|  [nc addObserver:self
  251|      1|         selector:@selector(reconnectFetchersForBackgroundSessionsOnAppLaunch:)
  252|      1|             name:UIApplicationDidFinishLaunchingNotification
  253|      1|           object:nil];
  254|       |#elif GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH && TARGET_OS_OSX
  255|       |  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
  256|       |  [nc addObserver:self
  257|       |         selector:@selector(reconnectFetchersForBackgroundSessionsOnAppLaunch:)
  258|       |             name:NSApplicationDidFinishLaunchingNotification
  259|       |           object:nil];
  260|       |#else
  261|       |  [self fetchersForBackgroundSessions];
  262|       |#endif
  263|       |}
  264|       |
  265|      1|+ (void)reconnectFetchersForBackgroundSessionsOnAppLaunch:(NSNotification *)notification {
  266|      1|  // Give all other app-did-launch handlers a chance to complete before
  267|      1|  // reconnecting the fetchers. Not doing this may lead to reconnecting
  268|      1|  // before the app delegate has a chance to run.
  269|      1|  dispatch_async(dispatch_get_main_queue(), ^{
  270|      1|    [self fetchersForBackgroundSessions];
  271|      1|  });
  272|      1|}
  273|       |#endif  // !GTMSESSION_UNIT_TESTING
  274|       |
  275|      0|+ (instancetype)fetcherWithRequest:(GTM_NULLABLE NSURLRequest *)request {
  276|      0|  return [[self alloc] initWithRequest:request configuration:nil];
  277|      0|}
  278|       |
  279|      0|+ (instancetype)fetcherWithURL:(NSURL *)requestURL {
  280|      0|  return [self fetcherWithRequest:[NSURLRequest requestWithURL:requestURL]];
  281|      0|}
  282|       |
  283|      0|+ (instancetype)fetcherWithURLString:(NSString *)requestURLString {
  284|      0|  return [self fetcherWithURL:(NSURL *)[NSURL URLWithString:requestURLString]];
  285|      0|}
  286|       |
  287|      0|+ (instancetype)fetcherWithDownloadResumeData:(NSData *)resumeData {
  288|      0|  GTMSessionFetcher *fetcher = [self fetcherWithRequest:nil];
  289|      0|  fetcher.comment = @"Resuming download";
  290|      0|  fetcher.downloadResumeData = resumeData;
  291|      0|  return fetcher;
  292|      0|}
  293|       |
  294|      0|+ (GTM_NULLABLE instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier {
  295|      0|  GTMSESSION_ASSERT_DEBUG(sessionIdentifier != nil, @"Invalid session identifier");
  296|      0|  NSMapTable *sessionIdentifierToFetcherMap = [self sessionIdentifierToFetcherMap];
  297|      0|  GTMSessionFetcher *fetcher = [sessionIdentifierToFetcherMap objectForKey:sessionIdentifier];
  298|      0|  if (!fetcher && [sessionIdentifier hasPrefix:kGTMSessionIdentifierPrefix]) {
  299|      0|    fetcher = [self fetcherWithRequest:nil];
  300|      0|    [fetcher setSessionIdentifier:sessionIdentifier];
  301|      0|    [sessionIdentifierToFetcherMap setObject:fetcher forKey:sessionIdentifier];
  302|      0|    fetcher->_wasCreatedFromBackgroundSession = YES;
  303|      0|    [fetcher setCommentWithFormat:@"Resuming %@",
  304|      0|     fetcher && fetcher->_sessionIdentifierUUID ? fetcher->_sessionIdentifierUUID : @"?"];
  305|      0|  }
  306|      0|  return fetcher;
  307|      0|}
  308|       |
  309|      2|+ (NSMapTable *)sessionIdentifierToFetcherMap {
  310|      2|  // TODO: What if a service is involved in creating the fetcher? Currently, when re-creating
  311|      2|  // fetchers, if a service was involved, it is not re-created. Should the service maintain a map?
  312|      2|  static NSMapTable *gSessionIdentifierToFetcherMap = nil;
  313|      2|
  314|      2|  static dispatch_once_t onceToken;
  315|      2|  dispatch_once(&onceToken, ^{
  316|      1|    gSessionIdentifierToFetcherMap = [NSMapTable strongToWeakObjectsMapTable];
  317|      1|  });
  318|      2|  return gSessionIdentifierToFetcherMap;
  319|      2|}
  320|       |
  321|       |#if !GTM_ALLOW_INSECURE_REQUESTS
  322|      0|+ (BOOL)appAllowsInsecureRequests {
  323|      0|  // If the main bundle Info.plist key NSAppTransportSecurity is present, and it specifies
  324|      0|  // NSAllowsArbitraryLoads, then we need to explicitly enforce secure schemes.
  325|      0|#if GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY
  326|      0|  static BOOL allowsInsecureRequests;
  327|      0|  static dispatch_once_t onceToken;
  328|      0|  dispatch_once(&onceToken, ^{
  329|      0|    NSBundle *mainBundle = [NSBundle mainBundle];
  330|      0|    NSDictionary *appTransportSecurity =
  331|      0|        [mainBundle objectForInfoDictionaryKey:@"NSAppTransportSecurity"];
  332|      0|    allowsInsecureRequests =
  333|      0|        [[appTransportSecurity objectForKey:@"NSAllowsArbitraryLoads"] boolValue];
  334|      0|  });
  335|      0|  return allowsInsecureRequests;
  336|       |#else
  337|       |  // For builds targeting iOS 8 or 10.10 and earlier, we want to require fetcher
  338|       |  // security checks.
  339|       |  return YES;
  340|       |#endif  // GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY
  341|       |}
  342|       |#else  // GTM_ALLOW_INSECURE_REQUESTS
  343|       |+ (BOOL)appAllowsInsecureRequests {
  344|       |  return YES;
  345|       |}
  346|       |#endif  // !GTM_ALLOW_INSECURE_REQUESTS
  347|       |
  348|       |
  349|      0|- (instancetype)init {
  350|      0|  return [self initWithRequest:nil configuration:nil];
  351|      0|}
  352|       |
  353|      0|- (instancetype)initWithRequest:(NSURLRequest *)request  {
  354|      0|  return [self initWithRequest:request configuration:nil];
  355|      0|}
  356|       |
  357|       |- (instancetype)initWithRequest:(GTM_NULLABLE NSURLRequest *)request
  358|      0|                  configuration:(GTM_NULLABLE NSURLSessionConfiguration *)configuration {
  359|      0|  self = [super init];
  360|      0|  if (self) {
  361|      0|#if GTM_BACKGROUND_TASK_FETCHING
  362|      0|    _backgroundTaskIdentifier = UIBackgroundTaskInvalid;
  363|      0|#endif
  364|      0|    _request = [request mutableCopy];
  365|      0|    _configuration = configuration;
  366|      0|
  367|      0|    NSData *bodyData = request.HTTPBody;
  368|      0|    if (bodyData) {
  369|      0|      _bodyLength = (int64_t)bodyData.length;
  370|      0|    } else {
  371|      0|      _bodyLength = NSURLSessionTransferSizeUnknown;
  372|      0|    }
  373|      0|
  374|      0|    _callbackQueue = dispatch_get_main_queue();
  375|      0|    _callbackGroup = dispatch_group_create();
  376|      0|    _delegateQueue = [NSOperationQueue mainQueue];
  377|      0|
  378|      0|    _minRetryInterval = InitialMinRetryInterval();
  379|      0|    _maxRetryInterval = kUnsetMaxRetryInterval;
  380|      0|
  381|      0|    _taskPriority = -1.0f;  // Valid values if set are 0.0...1.0.
  382|      0|
  383|      0|    _testBlockAccumulateDataChunkCount = 1;
  384|      0|
  385|      0|#if !STRIP_GTM_FETCH_LOGGING
  386|      0|    // Encourage developers to set the comment property or use
  387|      0|    // setCommentWithFormat: by providing a default string.
  388|      0|    _comment = @"(No fetcher comment set)";
  389|      0|#endif
  390|      0|  }
  391|      0|  return self;
  392|      0|}
  393|       |
  394|      0|- (id)copyWithZone:(NSZone *)zone {
  395|      0|  // disallow use of fetchers in a copy property
  396|      0|  [self doesNotRecognizeSelector:_cmd];
  397|      0|  return nil;
  398|      0|}
  399|       |
  400|      0|- (NSString *)description {
  401|      0|  NSString *requestStr = self.request.URL.description;
  402|      0|  if (requestStr.length == 0) {
  403|      0|    if (self.downloadResumeData.length > 0) {
  404|      0|      requestStr = @"<download resume data>";
  405|      0|    } else if (_wasCreatedFromBackgroundSession) {
  406|      0|      requestStr = @"<from bg session>";
  407|      0|    } else {
  408|      0|      requestStr = @"<no request>";
  409|      0|    }
  410|      0|  }
  411|      0|  return [NSString stringWithFormat:@"%@ %p (%@)", [self class], self, requestStr];
  412|      0|}
  413|       |
  414|      0|- (void)dealloc {
  415|      0|  GTMSESSION_ASSERT_DEBUG(!_isStopNotificationNeeded,
  416|      0|                          @"unbalanced fetcher notification for %@", _request.URL);
  417|      0|  [self forgetSessionIdentifierForFetcherWithoutSyncCheck];
  418|      0|
  419|      0|  // Note: if a session task or a retry timer was pending, then this instance
  420|      0|  // would be retained by those so it wouldn't be getting dealloc'd,
  421|      0|  // hence we don't need to stopFetch here
  422|      0|}
  423|       |
  424|       |#pragma mark -
  425|       |
  426|       |// Begin fetching the URL (or begin a retry fetch).  The delegate is retained
  427|       |// for the duration of the fetch connection.
  428|       |
  429|      0|- (void)beginFetchWithCompletionHandler:(GTM_NULLABLE GTMSessionFetcherCompletionHandler)handler {
  430|      0|  GTMSessionCheckNotSynchronized(self);
  431|      0|
  432|      0|  _completionHandler = [handler copy];
  433|      0|
  434|      0|  // The user may have called setDelegate: earlier if they want to use other
  435|      0|  // delegate-style callbacks during the fetch; otherwise, the delegate is nil,
  436|      0|  // which is fine.
  437|      0|  [self beginFetchMayDelay:YES mayAuthorize:YES];
  438|      0|}
  439|       |
  440|       |// Begin fetching the URL for a retry fetch. The delegate and completion handler
  441|       |// are already provided, and do not need to be copied.
  442|      0|- (void)beginFetchForRetry {
  443|      0|  GTMSessionCheckNotSynchronized(self);
  444|      0|
  445|      0|  [self beginFetchMayDelay:YES mayAuthorize:YES];
  446|      0|}
  447|       |
  448|       |- (GTMSessionFetcherCompletionHandler)completionHandlerWithTarget:(GTM_NULLABLE_TYPE id)target
  449|      0|                                                didFinishSelector:(GTM_NULLABLE_TYPE SEL)finishedSelector {
  450|      0|  GTMSessionFetcherAssertValidSelector(target, finishedSelector, @encode(GTMSessionFetcher *),
  451|      0|                                       @encode(NSData *), @encode(NSError *), 0);
  452|      0|  GTMSessionFetcherCompletionHandler completionHandler = ^(NSData *data, NSError *error) {
  453|      0|      if (target && finishedSelector) {
  454|      0|        id selfArg = self;  // Placate ARC.
  455|      0|        NSMethodSignature *sig = [target methodSignatureForSelector:finishedSelector];
  456|      0|        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];
  457|      0|        [invocation setSelector:(SEL)finishedSelector];
  458|      0|        [invocation setTarget:target];
  459|      0|        [invocation setArgument:&selfArg atIndex:2];
  460|      0|        [invocation setArgument:&data atIndex:3];
  461|      0|        [invocation setArgument:&error atIndex:4];
  462|      0|        [invocation invoke];
  463|      0|      }
  464|      0|  };
  465|      0|  return completionHandler;
  466|      0|}
  467|       |
  468|       |- (void)beginFetchWithDelegate:(GTM_NULLABLE_TYPE id)target
  469|      0|             didFinishSelector:(GTM_NULLABLE_TYPE SEL)finishedSelector {
  470|      0|  GTMSessionCheckNotSynchronized(self);
  471|      0|
  472|      0|  GTMSessionFetcherCompletionHandler handler =  [self completionHandlerWithTarget:target
  473|      0|                                                                didFinishSelector:finishedSelector];
  474|      0|  [self beginFetchWithCompletionHandler:handler];
  475|      0|}
  476|       |
  477|       |- (void)beginFetchMayDelay:(BOOL)mayDelay
  478|      0|              mayAuthorize:(BOOL)mayAuthorize {
  479|      0|  // This is the internal entry point for re-starting fetches.
  480|      0|  GTMSessionCheckNotSynchronized(self);
  481|      0|
  482|      0|  NSMutableURLRequest *fetchRequest = _request;  // The request property is now externally immutable.
  483|      0|  NSURL *fetchRequestURL = fetchRequest.URL;
  484|      0|  NSString *priorSessionIdentifier = self.sessionIdentifier;
  485|      0|
  486|      0|  // A utility block for creating error objects when we fail to start the fetch.
  487|      0|  NSError *(^beginFailureError)(NSInteger) = ^(NSInteger code){
  488|      0|    NSString *urlString = fetchRequestURL.absoluteString;
  489|      0|    NSDictionary *userInfo = @{
  490|      0|      NSURLErrorFailingURLStringErrorKey : (urlString ? urlString : @"(missing URL)")
  491|      0|    };
  492|      0|    return [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
  493|      0|                               code:code
  494|      0|                           userInfo:userInfo];
  495|      0|  };
  496|      0|
  497|      0|  // Catch delegate queue maxConcurrentOperationCount values other than 1, particularly
  498|      0|  // NSOperationQueueDefaultMaxConcurrentOperationCount (-1), to avoid the additional complexity
  499|      0|  // of simultaneous or out-of-order delegate callbacks.
  500|      0|  GTMSESSION_ASSERT_DEBUG(_delegateQueue.maxConcurrentOperationCount == 1,
  501|      0|                          @"delegate queue %@ should support one concurrent operation, not %ld",
  502|      0|                          _delegateQueue.name,
  503|      0|                          (long)_delegateQueue.maxConcurrentOperationCount);
  504|      0|
  505|      0|  if (!_initialBeginFetchDate) {
  506|      0|    // This ivar is set only here on the initial beginFetch so need not be synchronized.
  507|      0|    _initialBeginFetchDate = [[NSDate alloc] init];
  508|      0|  }
  509|      0|
  510|      0|  if (self.sessionTask != nil) {
  511|      0|    // If cached fetcher returned through fetcherWithSessionIdentifier:, then it's
  512|      0|    // already begun, but don't consider this a failure, since the user need not know this.
  513|      0|    if (self.sessionIdentifier != nil) {
  514|      0|      return;
  515|      0|    }
  516|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"Fetch object %@ being reused; this should never happen", self);
  517|      0|    [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorDownloadFailed)];
  518|      0|    return;
  519|      0|  }
  520|      0|
  521|      0|  if (fetchRequestURL == nil && !_downloadResumeData && !priorSessionIdentifier) {
  522|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"Beginning a fetch requires a request with a URL");
  523|      0|    [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorDownloadFailed)];
  524|      0|    return;
  525|      0|  }
  526|      0|
  527|      0|  // We'll respect the user's request for a background session (unless this is
  528|      0|  // an upload fetcher, which does its initial request foreground.)
  529|      0|  self.usingBackgroundSession = self.useBackgroundSession && [self canFetchWithBackgroundSession];
  530|      0|
  531|      0|  NSURL *bodyFileURL = self.bodyFileURL;
  532|      0|  if (bodyFileURL) {
  533|      0|    NSError *fileCheckError;
  534|      0|    if (![bodyFileURL checkResourceIsReachableAndReturnError:&fileCheckError]) {
  535|      0|      // This assert fires when the file being uploaded no longer exists once
  536|      0|      // the fetcher is ready to start the upload.
  537|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(0, @"Body file is unreachable: %@\n  %@",
  538|      0|                                     bodyFileURL.path, fileCheckError);
  539|      0|      [self failToBeginFetchWithError:fileCheckError];
  540|      0|      return;
  541|      0|    }
  542|      0|  }
  543|      0|
  544|      0|  NSString *requestScheme = fetchRequestURL.scheme;
  545|      0|  BOOL isDataRequest = [requestScheme isEqual:@"data"];
  546|      0|  if (isDataRequest) {
  547|      0|    // NSURLSession does not support data URLs in background sessions.
  548|      0|#if DEBUG
  549|      0|    if (priorSessionIdentifier || self.sessionIdentifier) {
  550|      0|      GTMSESSION_LOG_DEBUG(@"Converting background to foreground session for %@",
  551|      0|                           fetchRequest);
  552|      0|    }
  553|      0|#endif
  554|      0|    [self setSessionIdentifierInternal:nil];
  555|      0|    self.useBackgroundSession = NO;
  556|      0|  }
  557|      0|
  558|       |#if GTM_ALLOW_INSECURE_REQUESTS
  559|       |  BOOL shouldCheckSecurity = NO;
  560|       |#else
  561|      0|  BOOL shouldCheckSecurity = (fetchRequestURL != nil
  562|      0|                              && !isDataRequest
  563|      0|                              && [[self class] appAllowsInsecureRequests]);
  564|      0|#endif
  565|      0|
  566|      0|  if (shouldCheckSecurity) {
  567|      0|    // Allow https only for requests, unless overridden by the client.
  568|      0|    //
  569|      0|    // Non-https requests may too easily be snooped, so we disallow them by default.
  570|      0|    //
  571|      0|    // file: and data: schemes are usually safe if they are hardcoded in the client or provided
  572|      0|    // by a trusted source, but since it's fairly rare to need them, it's safest to make clients
  573|      0|    // explicitly whitelist them.
  574|      0|    BOOL isSecure =
  575|      0|        requestScheme != nil && [requestScheme caseInsensitiveCompare:@"https"] == NSOrderedSame;
  576|      0|    if (!isSecure) {
  577|      0|      BOOL allowRequest = NO;
  578|      0|      NSString *host = fetchRequestURL.host;
  579|      0|
  580|      0|      // Check schemes first.  A file scheme request may be allowed here, or as a localhost request.
  581|      0|      for (NSString *allowedScheme in _allowedInsecureSchemes) {
  582|      0|        if (requestScheme != nil &&
  583|      0|            [requestScheme caseInsensitiveCompare:allowedScheme] == NSOrderedSame) {
  584|      0|          allowRequest = YES;
  585|      0|          break;
  586|      0|        }
  587|      0|      }
  588|      0|      if (!allowRequest) {
  589|      0|        // Check for localhost requests.  Security checks only occur for non-https requests, so
  590|      0|        // this check won't happen for an https request to localhost.
  591|      0|        BOOL isLocalhostRequest = (host.length == 0 && [fetchRequestURL isFileURL]) || IsLocalhost(host);
  592|      0|        if (isLocalhostRequest) {
  593|      0|          if (self.allowLocalhostRequest) {
  594|      0|            allowRequest = YES;
  595|      0|          } else {
  596|      0|            GTMSESSION_ASSERT_DEBUG(NO, @"Fetch request for localhost but fetcher"
  597|      0|                                        @" allowLocalhostRequest is not set: %@", fetchRequestURL);
  598|      0|          }
  599|      0|        } else {
  600|      0|          GTMSESSION_ASSERT_DEBUG(NO, @"Insecure fetch request has a scheme (%@)"
  601|      0|                                      @" not found in fetcher allowedInsecureSchemes (%@): %@",
  602|      0|                                  requestScheme, _allowedInsecureSchemes ?: @" @[] ", fetchRequestURL);
  603|      0|        }
  604|      0|      }
  605|      0|
  606|      0|      if (!allowRequest) {
  607|       |#if !DEBUG
  608|       |        NSLog(@"Insecure fetch disallowed for %@", fetchRequestURL.description ?: @"nil request URL");
  609|       |#endif
  610|       |        [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorInsecureRequest)];
  611|      0|        return;
  612|      0|      }
  613|      0|    }  // !isSecure
  614|      0|  }  // (requestURL != nil) && !isDataRequest
  615|      0|
  616|      0|  if (self.cookieStorage == nil) {
  617|      0|    self.cookieStorage = [[self class] staticCookieStorage];
  618|      0|  }
  619|      0|
  620|      0|  BOOL isRecreatingSession = (self.sessionIdentifier != nil) && (fetchRequest == nil);
  621|      0|
  622|      0|  self.canShareSession = !isRecreatingSession && !self.usingBackgroundSession;
  623|      0|
  624|      0|  if (!self.session && self.canShareSession) {
  625|      0|    self.session = [_service sessionForFetcherCreation];
  626|      0|    // If _session is nil, then the service's session creation semaphore will block
  627|      0|    // until this fetcher invokes fetcherDidCreateSession: below, so this *must* invoke
  628|      0|    // that method, even if the session fails to be created.
  629|      0|  }
  630|      0|
  631|      0|  if (!self.session) {
  632|      0|    // Create a session.
  633|      0|    if (!_configuration) {
  634|      0|      if (priorSessionIdentifier || self.usingBackgroundSession) {
  635|      0|        NSString *sessionIdentifier = priorSessionIdentifier;
  636|      0|        if (!sessionIdentifier) {
  637|      0|          sessionIdentifier = [self createSessionIdentifierWithMetadata:nil];
  638|      0|        }
  639|      0|        NSMapTable *sessionIdentifierToFetcherMap = [[self class] sessionIdentifierToFetcherMap];
  640|      0|        [sessionIdentifierToFetcherMap setObject:self forKey:self.sessionIdentifier];
  641|      0|
  642|      0|        if (@available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)) {
  643|      0|          _configuration =
  644|      0|              [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionIdentifier];
  645|      0|        } else {
  646|      0|#if ((!TARGET_OS_IPHONE && MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10) \
  647|      0|     || (TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_0))
  648|      0|          // If building with support for iOS 7 or < macOS 10.10, allow using the older
  649|      0|          // -backgroundSessionConfiguration: method, otherwise leave it out to avoid deprecated
  650|      0|          // API warnings/errors.
  651|      0|          _configuration =
  652|      0|              [NSURLSessionConfiguration backgroundSessionConfiguration:sessionIdentifier];
  653|      0|#endif
  654|      0|        }
  655|      0|        self.usingBackgroundSession = YES;
  656|      0|        self.canShareSession = NO;
  657|      0|      } else {
  658|      0|        _configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
  659|      0|      }
  660|      0|#if !GTM_ALLOW_INSECURE_REQUESTS
  661|       |#if GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION
  662|       |      _configuration.TLSMinimumSupportedProtocolVersion = tls_protocol_version_TLSv12;
  663|       |#elif GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION
  664|      0|      if (@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)) {
  665|      0|#if TARGET_OS_IOS
  666|      0|        // Early seeds of iOS 13 don't actually support the selector and several
  667|      0|        // months later, those seeds are still in use, so validate if the selector
  668|      0|        // is supported.
  669|      0|        if ([_configuration respondsToSelector:@selector(setTLSMinimumSupportedProtocolVersion:)]) {
  670|      0|          _configuration.TLSMinimumSupportedProtocolVersion = tls_protocol_version_TLSv12;
  671|      0|        } else {
  672|      0|          _configuration.TLSMinimumSupportedProtocol = kTLSProtocol12;
  673|      0|        }
  674|       |#else
  675|       |        _configuration.TLSMinimumSupportedProtocolVersion = tls_protocol_version_TLSv12;
  676|       |#endif  // TARGET_OS_IOS
  677|      0|      } else {
  678|      0|        _configuration.TLSMinimumSupportedProtocol = kTLSProtocol12;
  679|      0|      }
  680|       |#else
  681|       |      _configuration.TLSMinimumSupportedProtocol = kTLSProtocol12;
  682|       |#endif  // GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION
  683|       |#endif
  684|      0|    }  // !_configuration
  685|      0|    _configuration.HTTPCookieStorage = self.cookieStorage;
  686|      0|
  687|      0|    if (_configurationBlock) {
  688|      0|      _configurationBlock(self, _configuration);
  689|      0|    }
  690|      0|
  691|      0|    id<NSURLSessionDelegate> delegate = [_service sessionDelegate];
  692|      0|    if (!delegate || !self.canShareSession) {
  693|      0|      delegate = self;
  694|      0|    }
  695|      0|    self.session = [NSURLSession sessionWithConfiguration:_configuration
  696|      0|                                                 delegate:delegate
  697|      0|                                            delegateQueue:self.sessionDelegateQueue];
  698|      0|    GTMSESSION_ASSERT_DEBUG(self.session, @"Couldn't create session");
  699|      0|
  700|      0|    // Tell the service about the session created by this fetcher.  This also signals the
  701|      0|    // service's semaphore to allow other fetchers to request this session.
  702|      0|    [_service fetcherDidCreateSession:self];
  703|      0|
  704|      0|    // If this assertion fires, the client probably tried to use a session identifier that was
  705|      0|    // already used. The solution is to make the client use a unique identifier (or better yet let
  706|      0|    // the session fetcher assign the identifier).
  707|      0|    GTMSESSION_ASSERT_DEBUG(self.session.delegate == delegate, @"Couldn't assign delegate.");
  708|      0|
  709|      0|    if (self.session) {
  710|      0|      BOOL isUsingSharedDelegate = (delegate != self);
  711|      0|      if (!isUsingSharedDelegate) {
  712|      0|        _shouldInvalidateSession = YES;
  713|      0|      }
  714|      0|    }
  715|      0|  }
  716|      0|
  717|      0|  if (isRecreatingSession) {
  718|      0|    _shouldInvalidateSession = YES;
  719|      0|
  720|      0|    // Let's make sure there are tasks still running or if not that we get a callback from a
  721|      0|    // completed one; otherwise, we assume the tasks failed.
  722|      0|    // This is the observed behavior perhaps 25% of the time within the Simulator running 7.0.3 on
  723|      0|    // exiting the app after starting an upload and relaunching the app if we manage to relaunch
  724|      0|    // after the task has completed, but before the system relaunches us in the background.
  725|      0|    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks,
  726|      0|                                                  NSArray *downloadTasks) {
  727|      0|      if (dataTasks.count == 0 && uploadTasks.count == 0 && downloadTasks.count == 0) {
  728|      0|        double const kDelayInSeconds = 1.0;  // We should get progress indication or completion soon
  729|      0|        dispatch_time_t checkForFeedbackDelay =
  730|      0|            dispatch_time(DISPATCH_TIME_NOW, (int64_t)(kDelayInSeconds * NSEC_PER_SEC));
  731|      0|        dispatch_after(checkForFeedbackDelay, dispatch_get_main_queue(), ^{
  732|      0|          if (!self.sessionTask && !fetchRequest) {
  733|      0|            // If our task and/or request haven't been restored, then we assume task feedback lost.
  734|      0|            [self removePersistedBackgroundSessionFromDefaults];
  735|      0|            NSError *sessionError =
  736|      0|                [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
  737|      0|                                    code:GTMSessionFetcherErrorBackgroundFetchFailed
  738|      0|                                userInfo:nil];
  739|      0|            [self failToBeginFetchWithError:sessionError];
  740|      0|          }
  741|      0|        });
  742|      0|      }
  743|      0|    }];
  744|      0|    return;
  745|      0|  }
  746|      0|
  747|      0|  self.downloadedData = nil;
  748|      0|  self.downloadedLength = 0;
  749|      0|
  750|      0|  if (_servicePriority == NSIntegerMin) {
  751|      0|    mayDelay = NO;
  752|      0|  }
  753|      0|  if (mayDelay && _service) {
  754|      0|    BOOL shouldFetchNow = [_service fetcherShouldBeginFetching:self];
  755|      0|    if (!shouldFetchNow) {
  756|      0|      // The fetch is deferred, but will happen later.
  757|      0|      //
  758|      0|      // If this session is held by the fetcher service, clear the session now so that we don't
  759|      0|      // assume it's still valid after the fetcher is restarted.
  760|      0|      if (self.canShareSession) {
  761|      0|        self.session = nil;
  762|      0|      }
  763|      0|      return;
  764|      0|    }
  765|      0|  }
  766|      0|
  767|      0|  NSString *effectiveHTTPMethod = [fetchRequest valueForHTTPHeaderField:@"X-HTTP-Method-Override"];
  768|      0|  if (effectiveHTTPMethod == nil) {
  769|      0|    effectiveHTTPMethod = fetchRequest.HTTPMethod;
  770|      0|  }
  771|      0|  BOOL isEffectiveHTTPGet = (effectiveHTTPMethod == nil
  772|      0|                             || [effectiveHTTPMethod isEqual:@"GET"]);
  773|      0|
  774|      0|  BOOL needsUploadTask = (self.useUploadTask || self.bodyFileURL || self.bodyStreamProvider);
  775|      0|  if (_bodyData || self.bodyStreamProvider || fetchRequest.HTTPBodyStream) {
  776|      0|    if (isEffectiveHTTPGet) {
  777|      0|      fetchRequest.HTTPMethod = @"POST";
  778|      0|      isEffectiveHTTPGet = NO;
  779|      0|    }
  780|      0|
  781|      0|    if (_bodyData) {
  782|      0|      if (!needsUploadTask) {
  783|      0|        fetchRequest.HTTPBody = _bodyData;
  784|      0|      }
  785|      0|#if !STRIP_GTM_FETCH_LOGGING
  786|      0|    } else if (fetchRequest.HTTPBodyStream) {
  787|      0|      if ([self respondsToSelector:@selector(loggedInputStreamForInputStream:)]) {
  788|      0|        fetchRequest.HTTPBodyStream =
  789|      0|            [self performSelector:@selector(loggedInputStreamForInputStream:)
  790|      0|                       withObject:fetchRequest.HTTPBodyStream];
  791|      0|      }
  792|      0|#endif
  793|      0|    }
  794|      0|  }
  795|      0|
  796|      0|  // We authorize after setting up the http method and body in the request
  797|      0|  // because OAuth 1 may need to sign the request body
  798|      0|  if (mayAuthorize && _authorizer && !isDataRequest) {
  799|      0|    BOOL isAuthorized = [_authorizer isAuthorizedRequest:fetchRequest];
  800|      0|    if (!isAuthorized) {
  801|      0|      // Authorization needed.
  802|      0|      //
  803|      0|      // If this session is held by the fetcher service, clear the session now so that we don't
  804|      0|      // assume it's still valid after authorization completes.
  805|      0|      if (self.canShareSession) {
  806|      0|        self.session = nil;
  807|      0|      }
  808|      0|
  809|      0|      // Authorizing the request will recursively call this beginFetch:mayDelay:
  810|      0|      // or failToBeginFetchWithError:.
  811|      0|      [self authorizeRequest];
  812|      0|      return;
  813|      0|    }
  814|      0|  }
  815|      0|
  816|      0|  // set the default upload or download retry interval, if necessary
  817|      0|  if ([self isRetryEnabled] && self.maxRetryInterval <= 0) {
  818|      0|    if (isEffectiveHTTPGet || [effectiveHTTPMethod isEqual:@"HEAD"]) {
  819|      0|      [self setMaxRetryInterval:kDefaultMaxDownloadRetryInterval];
  820|      0|    } else {
  821|      0|      [self setMaxRetryInterval:kDefaultMaxUploadRetryInterval];
  822|      0|    }
  823|      0|  }
  824|      0|
  825|      0|  // finally, start the connection
  826|      0|  NSURLSessionTask *newSessionTask;
  827|      0|  BOOL needsDataAccumulator = NO;
  828|      0|  if (_downloadResumeData) {
  829|      0|    newSessionTask = [_session downloadTaskWithResumeData:_downloadResumeData];
  830|      0|    GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  831|      0|        @"Failed downloadTaskWithResumeData for %@, resume data %lu bytes",
  832|      0|        _session, (unsigned long)_downloadResumeData.length);
  833|      0|  } else if (_destinationFileURL && !isDataRequest) {
  834|      0|    newSessionTask = [_session downloadTaskWithRequest:fetchRequest];
  835|      0|    GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask, @"Failed downloadTaskWithRequest for %@, %@",
  836|      0|                                   _session, fetchRequest);
  837|      0|  } else if (needsUploadTask) {
  838|      0|    if (bodyFileURL) {
  839|      0|      newSessionTask = [_session uploadTaskWithRequest:fetchRequest
  840|      0|                                              fromFile:bodyFileURL];
  841|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  842|      0|                                     @"Failed uploadTaskWithRequest for %@, %@, file %@",
  843|      0|                                     _session, fetchRequest, bodyFileURL.path);
  844|      0|    } else if (self.bodyStreamProvider) {
  845|      0|      newSessionTask = [_session uploadTaskWithStreamedRequest:fetchRequest];
  846|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  847|      0|                                     @"Failed uploadTaskWithStreamedRequest for %@, %@",
  848|      0|                                     _session, fetchRequest);
  849|      0|    } else {
  850|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(_bodyData != nil,
  851|      0|                                     @"Upload task needs body data, %@", fetchRequest);
  852|      0|      newSessionTask = [_session uploadTaskWithRequest:fetchRequest
  853|      0|                                            fromData:(NSData * GTM_NONNULL_TYPE)_bodyData];
  854|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  855|      0|          @"Failed uploadTaskWithRequest for %@, %@, body data %lu bytes",
  856|      0|          _session, fetchRequest, (unsigned long)_bodyData.length);
  857|      0|    }
  858|      0|    needsDataAccumulator = YES;
  859|      0|  } else {
  860|      0|    newSessionTask = [_session dataTaskWithRequest:fetchRequest];
  861|      0|    needsDataAccumulator = YES;
  862|      0|    GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask, @"Failed dataTaskWithRequest for %@, %@",
  863|      0|                                   _session, fetchRequest);
  864|      0|  }
  865|      0|  self.sessionTask = newSessionTask;
  866|      0|
  867|      0|  if (!newSessionTask) {
  868|      0|    // We shouldn't get here; if we're here, an earlier assertion should have fired to explain
  869|      0|    // which session task creation failed.
  870|      0|    [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorTaskCreationFailed)];
  871|      0|    return;
  872|      0|  }
  873|      0|
  874|      0|  if (needsDataAccumulator && _accumulateDataBlock == nil) {
  875|      0|    self.downloadedData = [NSMutableData data];
  876|      0|  }
  877|      0|  if (_taskDescription) {
  878|      0|    newSessionTask.taskDescription = _taskDescription;
  879|      0|  }
  880|      0|  if (_taskPriority >= 0) {
  881|      0|    if (@available(iOS 8.0, macOS 10.10, *)) {
  882|      0|      newSessionTask.priority = _taskPriority;
  883|      0|    }
  884|      0|  }
  885|      0|
  886|       |#if GTM_DISABLE_FETCHER_TEST_BLOCK
  887|       |  GTMSESSION_ASSERT_DEBUG(_testBlock == nil && gGlobalTestBlock == nil, @"test blocks disabled");
  888|       |  _testBlock = nil;
  889|       |#else
  890|      0|  if (!_testBlock) {
  891|      0|    if (gGlobalTestBlock) {
  892|      0|      // Note that the test block may pass nil for all of its response parameters,
  893|      0|      // indicating that the fetch should actually proceed. This is useful when the
  894|      0|      // global test block has been set, and the app is only testing a specific
  895|      0|      // fetcher.  The block simulation code will then resume the task.
  896|      0|      _testBlock = gGlobalTestBlock;
  897|      0|    }
  898|      0|  }
  899|      0|  _isUsingTestBlock = (_testBlock != nil);
  900|      0|#endif  // GTM_DISABLE_FETCHER_TEST_BLOCK
  901|      0|
  902|      0|#if GTM_BACKGROUND_TASK_FETCHING
  903|      0|  id<GTMUIApplicationProtocol> app = [[self class] fetcherUIApplication];
  904|      0|  // Background tasks seem to interfere with out-of-process uploads and downloads.
  905|      0|  if (app && !self.skipBackgroundTask && !self.useBackgroundSession) {
  906|      0|    // Tell UIApplication that we want to continue even when the app is in the
  907|      0|    // background.
  908|      0|#if DEBUG
  909|      0|    NSString *bgTaskName = [NSString stringWithFormat:@"%@-%@",
  910|      0|                            [self class], fetchRequest.URL.host];
  911|       |#else
  912|       |    NSString *bgTaskName = @"GTMSessionFetcher";
  913|       |#endif
  914|       |    __block UIBackgroundTaskIdentifier bgTaskID = [app beginBackgroundTaskWithName:bgTaskName
  915|      0|                                                                 expirationHandler:^{
  916|      0|      // Background task expiration callback - this block is always invoked by
  917|      0|      // UIApplication on the main thread.
  918|      0|      if (bgTaskID != UIBackgroundTaskInvalid) {
  919|      0|        @synchronized(self) {
  920|      0|          if (bgTaskID == self.backgroundTaskIdentifier) {
  921|      0|            self.backgroundTaskIdentifier = UIBackgroundTaskInvalid;
  922|      0|          }
  923|      0|        }
  924|      0|        [app endBackgroundTask:bgTaskID];
  925|      0|      }
  926|      0|    }];
  927|      0|    @synchronized(self) {
  928|      0|      self.backgroundTaskIdentifier = bgTaskID;
  929|      0|    }
  930|      0|  }
  931|      0|#endif
  932|      0|
  933|      0|  if (!_initialRequestDate) {
  934|      0|    _initialRequestDate = [[NSDate alloc] init];
  935|      0|  }
  936|      0|
  937|      0|  // We don't expect to reach here even on retry or auth until a stop notification has been sent
  938|      0|  // for the previous task, but we should ensure that we don't unbalance that.
  939|      0|  GTMSESSION_ASSERT_DEBUG(!_isStopNotificationNeeded, @"Start notification without a prior stop");
  940|      0|  [self sendStopNotificationIfNeeded];
  941|      0|
  942|      0|  [self addPersistedBackgroundSessionToDefaults];
  943|      0|
  944|      0|  [self setStopNotificationNeeded:YES];
  945|      0|
  946|      0|  [self postNotificationOnMainThreadWithName:kGTMSessionFetcherStartedNotification
  947|      0|                                    userInfo:nil
  948|      0|                                requireAsync:NO];
  949|      0|
  950|      0|  // The service needs to know our task if it is serving as NSURLSession delegate.
  951|      0|  [_service fetcherDidBeginFetching:self];
  952|      0|
  953|      0|  if (_testBlock) {
  954|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  955|      0|    [self simulateFetchForTestBlock];
  956|      0|#endif
  957|      0|  } else {
  958|      0|    // We resume the session task after posting the notification since the
  959|      0|    // delegate callbacks may happen immediately if the fetch is started off
  960|      0|    // the main thread or the session delegate queue is on a background thread,
  961|      0|    // and we don't want to post a start notification after a premature finish
  962|      0|    // of the session task.
  963|      0|    [newSessionTask resume];
  964|      0|  }
  965|      0|}
  966|       |
  967|      0|NSData * GTM_NULLABLE_TYPE GTMDataFromInputStream(NSInputStream *inputStream, NSError **outError) {
  968|      0|  NSMutableData *data = [NSMutableData data];
  969|      0|
  970|      0|  [inputStream open];
  971|      0|  NSInteger numberOfBytesRead = 0;
  972|      0|  while ([inputStream hasBytesAvailable]) {
  973|      0|    uint8_t buffer[512];
  974|      0|    numberOfBytesRead = [inputStream read:buffer maxLength:sizeof(buffer)];
  975|      0|    if (numberOfBytesRead > 0) {
  976|      0|      [data appendBytes:buffer length:(NSUInteger)numberOfBytesRead];
  977|      0|    } else {
  978|      0|      break;
  979|      0|    }
  980|      0|  }
  981|      0|  [inputStream close];
  982|      0|  NSError *streamError = inputStream.streamError;
  983|      0|
  984|      0|  if (streamError) {
  985|      0|    data = nil;
  986|      0|  }
  987|      0|  if (outError) {
  988|      0|    *outError = streamError;
  989|      0|  }
  990|      0|  return data;
  991|      0|}
  992|       |
  993|       |#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  994|       |
  995|      0|- (void)simulateFetchForTestBlock {
  996|      0|  // This is invoked on the same thread as the beginFetch method was.
  997|      0|  //
  998|      0|  // Callbacks will all occur on the callback queue.
  999|      0|  _testBlock(self, ^(NSURLResponse *response, NSData *responseData, NSError *error) {
 1000|      0|      // Callback from test block.
 1001|      0|      if (response == nil && responseData == nil && error == nil) {
 1002|      0|        // Assume the fetcher should execute rather than be tested.
 1003|      0|        self->_testBlock = nil;
 1004|      0|        self->_isUsingTestBlock = NO;
 1005|      0|        [self->_sessionTask resume];
 1006|      0|        return;
 1007|      0|      }
 1008|      0|
 1009|      0|      GTMSessionFetcherBodyStreamProvider bodyStreamProvider = self.bodyStreamProvider;
 1010|      0|      if (bodyStreamProvider) {
 1011|      0|        bodyStreamProvider(^(NSInputStream *bodyStream){
 1012|      0|          // Read from the input stream into an NSData buffer.  We'll drain the stream
 1013|      0|          // explicitly on a background queue.
 1014|      0|          [self invokeOnCallbackQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)
 1015|      0|                     afterUserStopped:NO
 1016|      0|                                block:^{
 1017|      0|            NSError *streamError;
 1018|      0|            NSData *streamedData = GTMDataFromInputStream(bodyStream, &streamError);
 1019|      0|
 1020|      0|            dispatch_async(dispatch_get_main_queue(), ^{
 1021|      0|              // Continue callbacks on the main thread, since serial behavior
 1022|      0|              // is more reliable for tests.
 1023|      0|              [self simulateDataCallbacksForTestBlockWithBodyData:streamedData
 1024|      0|                                                         response:response
 1025|      0|                                                     responseData:responseData
 1026|      0|                                                            error:(error ?: streamError)];
 1027|      0|            });
 1028|      0|          }];
 1029|      0|        });
 1030|      0|      } else {
 1031|      0|        // No input stream; use the supplied data or file URL.
 1032|      0|        NSURL *bodyFileURL = self.bodyFileURL;
 1033|      0|        if (bodyFileURL) {
 1034|      0|          NSError *readError;
 1035|      0|          self->_bodyData = [NSData dataWithContentsOfURL:bodyFileURL
 1036|      0|                                            options:NSDataReadingMappedIfSafe
 1037|      0|                                              error:&readError];
 1038|      0|          error = readError;
 1039|      0|        }
 1040|      0|
 1041|      0|        // No stream provider.
 1042|      0|
 1043|      0|        // In real fetches, nothing happens until the run loop spins, so apps have leeway to
 1044|      0|        // set callbacks after they call beginFetch. We'll mirror that fetcher behavior by
 1045|      0|        // delaying callbacks here at least to the next spin of the run loop.  That keeps
 1046|      0|        // immediate, synchronous setting of callback blocks after beginFetch working in tests.
 1047|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1048|      0|          [self simulateDataCallbacksForTestBlockWithBodyData:self->_bodyData
 1049|      0|                                                     response:response
 1050|      0|                                                 responseData:responseData
 1051|      0|                                                        error:error];
 1052|      0|        });
 1053|      0|      }
 1054|      0|    });
 1055|      0|}
 1056|       |
 1057|       |- (void)simulateByteTransferReportWithDataLength:(int64_t)totalDataLength
 1058|      0|                                           block:(GTMSessionFetcherSendProgressBlock)block {
 1059|      0|  // This utility method simulates transfer progress with up to three callbacks.
 1060|      0|  // It is used to call back to any of the progress blocks.
 1061|      0|  int64_t sendReportSize = totalDataLength / 3 + 1;
 1062|      0|  int64_t totalSent = 0;
 1063|      0|  while (totalSent < totalDataLength) {
 1064|      0|    int64_t bytesRemaining = totalDataLength - totalSent;
 1065|      0|    sendReportSize = MIN(sendReportSize, bytesRemaining);
 1066|      0|    totalSent += sendReportSize;
 1067|      0|    [self invokeOnCallbackQueueUnlessStopped:^{
 1068|      0|        block(sendReportSize, totalSent, totalDataLength);
 1069|      0|    }];
 1070|      0|  }
 1071|      0|}
 1072|       |
 1073|       |- (void)simulateDataCallbacksForTestBlockWithBodyData:(NSData * GTM_NULLABLE_TYPE)bodyData
 1074|       |                                             response:(NSURLResponse *)response
 1075|       |                                         responseData:(NSData *)suppliedData
 1076|      0|                                                error:(NSError *)suppliedError {
 1077|      0|  __block NSData *responseData = suppliedData;
 1078|      0|  __block NSError *responseError = suppliedError;
 1079|      0|
 1080|      0|  // This method does the test simulation of callbacks once the upload
 1081|      0|  // and download data are known.
 1082|      0|  @synchronized(self) {
 1083|      0|    GTMSessionMonitorSynchronized(self);
 1084|      0|
 1085|      0|    // Get copies of ivars we'll access in async invocations.  This simulation assumes
 1086|      0|    // they won't change during fetcher execution.
 1087|      0|    NSURL *destinationFileURL = _destinationFileURL;
 1088|      0|    GTMSessionFetcherWillRedirectBlock willRedirectBlock = _willRedirectBlock;
 1089|      0|    GTMSessionFetcherDidReceiveResponseBlock didReceiveResponseBlock = _didReceiveResponseBlock;
 1090|      0|    GTMSessionFetcherSendProgressBlock sendProgressBlock = _sendProgressBlock;
 1091|      0|    GTMSessionFetcherDownloadProgressBlock downloadProgressBlock = _downloadProgressBlock;
 1092|      0|    GTMSessionFetcherAccumulateDataBlock accumulateDataBlock = _accumulateDataBlock;
 1093|      0|    GTMSessionFetcherReceivedProgressBlock receivedProgressBlock = _receivedProgressBlock;
 1094|      0|    GTMSessionFetcherWillCacheURLResponseBlock willCacheURLResponseBlock =
 1095|      0|        _willCacheURLResponseBlock;
 1096|      0|    GTMSessionFetcherChallengeBlock challengeBlock = _challengeBlock;
 1097|      0|
 1098|      0|    // Simulate receipt of redirection.
 1099|      0|    if (willRedirectBlock) {
 1100|      0|      [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1101|      0|                                                          block:^{
 1102|      0|          willRedirectBlock((NSHTTPURLResponse *)response, self->_request,
 1103|      0|                             ^(NSURLRequest *redirectRequest) {
 1104|      0|              // For simulation, we'll assume the app will just continue.
 1105|      0|          });
 1106|      0|      }];
 1107|      0|    }
 1108|      0|
 1109|      0|    // If the fetcher has a challenge block, simulate a challenge.
 1110|      0|    //
 1111|      0|    // It might be nice to eventually let the user determine which testBlock
 1112|      0|    // fetches get challenged rather than always executing the supplied
 1113|      0|    // challenge block.
 1114|      0|    if (challengeBlock) {
 1115|      0|      [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1116|      0|                                                          block:^{
 1117|      0|        NSURL *requestURL = self->_request.URL;
 1118|      0|        NSString *host = requestURL.host;
 1119|      0|        NSURLProtectionSpace *pspace =
 1120|      0|            [[NSURLProtectionSpace alloc] initWithHost:host
 1121|      0|                                                  port:requestURL.port.integerValue
 1122|      0|                                              protocol:requestURL.scheme
 1123|      0|                                                 realm:nil
 1124|      0|                                  authenticationMethod:NSURLAuthenticationMethodHTTPBasic];
 1125|      0|        id<NSURLAuthenticationChallengeSender> unusedSender =
 1126|      0|            (id<NSURLAuthenticationChallengeSender>)[NSNull null];
 1127|      0|        NSURLAuthenticationChallenge *challenge =
 1128|      0|            [[NSURLAuthenticationChallenge alloc] initWithProtectionSpace:pspace
 1129|      0|                                                       proposedCredential:nil
 1130|      0|                                                     previousFailureCount:0
 1131|      0|                                                          failureResponse:nil
 1132|      0|                                                                    error:nil
 1133|      0|                                                                   sender:unusedSender];
 1134|      0|        challengeBlock(self, challenge, ^(NSURLSessionAuthChallengeDisposition disposition,
 1135|      0|                                          NSURLCredential * GTM_NULLABLE_TYPE credential){
 1136|      0|          // We could change the responseData and responseError based on the disposition,
 1137|      0|          // but it's easier for apps to just supply the expected data and error
 1138|      0|          // directly to the test block. So this simulation ignores the disposition.
 1139|      0|        });
 1140|      0|      }];
 1141|      0|    }
 1142|      0|
 1143|      0|    // Simulate receipt of an initial response.
 1144|      0|    if (response && didReceiveResponseBlock) {
 1145|      0|      [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1146|      0|                                                          block:^{
 1147|      0|          didReceiveResponseBlock(response, ^(NSURLSessionResponseDisposition desiredDisposition) {
 1148|      0|            // For simulation, we'll assume the disposition is to continue.
 1149|      0|          });
 1150|      0|      }];
 1151|      0|    }
 1152|      0|
 1153|      0|    // Simulate reporting send progress.
 1154|      0|    if (sendProgressBlock) {
 1155|      0|      [self simulateByteTransferReportWithDataLength:(int64_t)bodyData.length
 1156|      0|                                               block:^(int64_t bytesSent,
 1157|      0|                                                       int64_t totalBytesSent,
 1158|      0|                                                       int64_t totalBytesExpectedToSend) {
 1159|      0|          // This is invoked on the callback queue unless stopped.
 1160|      0|          sendProgressBlock(bytesSent, totalBytesSent, totalBytesExpectedToSend);
 1161|      0|      }];
 1162|      0|    }
 1163|      0|
 1164|      0|    if (destinationFileURL) {
 1165|      0|      // Simulate download to file progress.
 1166|      0|      if (downloadProgressBlock) {
 1167|      0|        [self simulateByteTransferReportWithDataLength:(int64_t)responseData.length
 1168|      0|                                                 block:^(int64_t bytesDownloaded,
 1169|      0|                                                         int64_t totalBytesDownloaded,
 1170|      0|                                                         int64_t totalBytesExpectedToDownload) {
 1171|      0|            // This is invoked on the callback queue unless stopped.
 1172|      0|            downloadProgressBlock(bytesDownloaded, totalBytesDownloaded,
 1173|      0|                                  totalBytesExpectedToDownload);
 1174|      0|        }];
 1175|      0|      }
 1176|      0|
 1177|      0|      NSError *writeError;
 1178|      0|      [responseData writeToURL:destinationFileURL
 1179|      0|                       options:NSDataWritingAtomic
 1180|      0|                         error:&writeError];
 1181|      0|      if (writeError) {
 1182|      0|        // Tell the test code that writing failed.
 1183|      0|        responseError = writeError;
 1184|      0|      }
 1185|      0|    } else {
 1186|      0|      // Simulate download to NSData progress.
 1187|      0|      if ((accumulateDataBlock || receivedProgressBlock) && responseData) {
 1188|      0|        [self simulateByteTransferWithData:responseData
 1189|      0|                                     block:^(NSData *data,
 1190|      0|                                             int64_t bytesReceived,
 1191|      0|                                             int64_t totalBytesReceived,
 1192|      0|                                             int64_t totalBytesExpectedToReceive) {
 1193|      0|          // This is invoked on the callback queue unless stopped.
 1194|      0|          if (accumulateDataBlock) {
 1195|      0|            accumulateDataBlock(data);
 1196|      0|          }
 1197|      0|
 1198|      0|          if (receivedProgressBlock) {
 1199|      0|            receivedProgressBlock(bytesReceived, totalBytesReceived);
 1200|      0|          }
 1201|      0|        }];
 1202|      0|      }
 1203|      0|
 1204|      0|      if (!accumulateDataBlock) {
 1205|      0|        _downloadedData = [responseData mutableCopy];
 1206|      0|      }
 1207|      0|
 1208|      0|      if (willCacheURLResponseBlock) {
 1209|      0|        // Simulate letting the client inspect and alter the cached response.
 1210|      0|        NSData *cachedData = responseData ?: [[NSData alloc] init];  // Always have non-nil data.
 1211|      0|        NSCachedURLResponse *cachedResponse =
 1212|      0|            [[NSCachedURLResponse alloc] initWithResponse:response
 1213|      0|                                                     data:cachedData];
 1214|      0|        [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1215|      0|                                                            block:^{
 1216|      0|            willCacheURLResponseBlock(cachedResponse, ^(NSCachedURLResponse *responseToCache){
 1217|      0|                // The app may provide an alternative response, or nil to defeat caching.
 1218|      0|            });
 1219|      0|        }];
 1220|      0|      }
 1221|      0|    }
 1222|      0|    _response = response;
 1223|      0|  }  // @synchronized(self)
 1224|      0|
 1225|      0|  NSOperationQueue *queue = self.sessionDelegateQueue;
 1226|      0|  [queue addOperationWithBlock:^{
 1227|      0|    // Rather than invoke failToBeginFetchWithError: we want to simulate completion of
 1228|      0|    // a connection that started and ended, so we'll call down to finishWithError:
 1229|      0|    NSInteger status = responseError ? responseError.code : 200;
 1230|      0|    if (status >= 200 && status <= 399) {
 1231|      0|      [self finishWithError:nil shouldRetry:NO];
 1232|      0|    } else {
 1233|      0|      [self shouldRetryNowForStatus:status
 1234|      0|                              error:responseError
 1235|      0|                   forceAssumeRetry:NO
 1236|      0|                           response:^(BOOL shouldRetry) {
 1237|      0|          [self finishWithError:responseError shouldRetry:shouldRetry];
 1238|      0|      }];
 1239|      0|    }
 1240|      0|  }];
 1241|      0|}
 1242|       |
 1243|       |- (void)simulateByteTransferWithData:(NSData *)responseData
 1244|      0|                               block:(GTMSessionFetcherSimulateByteTransferBlock)transferBlock {
 1245|      0|  // This utility method simulates transfering data to the client. It divides the data into at most
 1246|      0|  // "chunkCount" chunks and then passes each chunk along with a progress update to transferBlock.
 1247|      0|  // This function can be used with accumulateDataBlock or receivedProgressBlock.
 1248|      0|
 1249|      0|  NSUInteger chunkCount = MAX(self.testBlockAccumulateDataChunkCount, (NSUInteger) 1);
 1250|      0|  NSUInteger totalDataLength = responseData.length;
 1251|      0|  NSUInteger sendDataSize = totalDataLength / chunkCount + 1;
 1252|      0|  NSUInteger totalSent = 0;
 1253|      0|  while (totalSent < totalDataLength) {
 1254|      0|    NSUInteger bytesRemaining = totalDataLength - totalSent;
 1255|      0|    sendDataSize = MIN(sendDataSize, bytesRemaining);
 1256|      0|    NSData *chunkData = [responseData subdataWithRange:NSMakeRange(totalSent, sendDataSize)];
 1257|      0|    totalSent += sendDataSize;
 1258|      0|    [self invokeOnCallbackQueueUnlessStopped:^{
 1259|      0|      transferBlock(chunkData,
 1260|      0|                    (int64_t)sendDataSize,
 1261|      0|                    (int64_t)totalSent,
 1262|      0|                    (int64_t)totalDataLength);
 1263|      0|    }];
 1264|      0|  }
 1265|      0|}
 1266|       |
 1267|       |#endif  // !GTM_DISABLE_FETCHER_TEST_BLOCK
 1268|       |
 1269|      0|- (void)setSessionTask:(NSURLSessionTask *)sessionTask {
 1270|      0|  @synchronized(self) {
 1271|      0|    GTMSessionMonitorSynchronized(self);
 1272|      0|
 1273|      0|    if (_sessionTask != sessionTask) {
 1274|      0|      _sessionTask = sessionTask;
 1275|      0|      if (_sessionTask) {
 1276|      0|        // Request could be nil on restoring this fetcher from a background session.
 1277|      0|        if (!_request) {
 1278|      0|          _request = [_sessionTask.originalRequest mutableCopy];
 1279|      0|        }
 1280|      0|      }
 1281|      0|    }
 1282|      0|  }  // @synchronized(self)
 1283|      0|}
 1284|       |
 1285|      0|- (NSURLSessionTask * GTM_NULLABLE_TYPE)sessionTask {
 1286|      0|  @synchronized(self) {
 1287|      0|    GTMSessionMonitorSynchronized(self);
 1288|      0|
 1289|      0|    return _sessionTask;
 1290|      0|  }  // @synchronized(self)
 1291|      0|}
 1292|       |
 1293|      2|+ (NSUserDefaults *)fetcherUserDefaults {
 1294|      2|  static NSUserDefaults *gFetcherUserDefaults = nil;
 1295|      2|
 1296|      2|  static dispatch_once_t onceToken;
 1297|      2|  dispatch_once(&onceToken, ^{
 1298|      1|    Class fetcherUserDefaultsClass = NSClassFromString(@"GTMSessionFetcherUserDefaultsFactory");
 1299|      1|    if (fetcherUserDefaultsClass) {
 1300|      0|      gFetcherUserDefaults = [fetcherUserDefaultsClass fetcherUserDefaults];
 1301|      1|    } else {
 1302|      1|      gFetcherUserDefaults = [NSUserDefaults standardUserDefaults];
 1303|      1|    }
 1304|      1|  });
 1305|      2|  return gFetcherUserDefaults;
 1306|      2|}
 1307|       |
 1308|      0|- (void)addPersistedBackgroundSessionToDefaults {
 1309|      0|  NSString *sessionIdentifier = self.sessionIdentifier;
 1310|      0|  if (!sessionIdentifier) {
 1311|      0|    return;
 1312|      0|  }
 1313|      0|  NSArray *oldBackgroundSessions = [[self class] activePersistedBackgroundSessions];
 1314|      0|  if ([oldBackgroundSessions containsObject:_sessionIdentifier]) {
 1315|      0|    return;
 1316|      0|  }
 1317|      0|  NSMutableArray *newBackgroundSessions =
 1318|      0|      [NSMutableArray arrayWithArray:oldBackgroundSessions];
 1319|      0|  [newBackgroundSessions addObject:sessionIdentifier];
 1320|      0|  GTM_LOG_BACKGROUND_SESSION(@"Add to background sessions: %@", newBackgroundSessions);
 1321|      0|
 1322|      0|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1323|      0|  [userDefaults setObject:newBackgroundSessions
 1324|      0|                   forKey:kGTMSessionFetcherPersistedDestinationKey];
 1325|      0|  [userDefaults synchronize];
 1326|      0|}
 1327|       |
 1328|      0|- (void)removePersistedBackgroundSessionFromDefaults {
 1329|      0|  NSString *sessionIdentifier = self.sessionIdentifier;
 1330|      0|  if (!sessionIdentifier) return;
 1331|      0|
 1332|      0|  NSArray *oldBackgroundSessions = [[self class] activePersistedBackgroundSessions];
 1333|      0|  if (!oldBackgroundSessions) {
 1334|      0|    return;
 1335|      0|  }
 1336|      0|  NSMutableArray *newBackgroundSessions =
 1337|      0|      [NSMutableArray arrayWithArray:oldBackgroundSessions];
 1338|      0|  NSUInteger sessionIndex = [newBackgroundSessions indexOfObject:sessionIdentifier];
 1339|      0|  if (sessionIndex == NSNotFound) {
 1340|      0|    return;
 1341|      0|  }
 1342|      0|  [newBackgroundSessions removeObjectAtIndex:sessionIndex];
 1343|      0|  GTM_LOG_BACKGROUND_SESSION(@"Remove from background sessions: %@", newBackgroundSessions);
 1344|      0|
 1345|      0|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1346|      0|  if (newBackgroundSessions.count == 0) {
 1347|      0|    [userDefaults removeObjectForKey:kGTMSessionFetcherPersistedDestinationKey];
 1348|      0|  } else {
 1349|      0|    [userDefaults setObject:newBackgroundSessions
 1350|      0|                     forKey:kGTMSessionFetcherPersistedDestinationKey];
 1351|      0|  }
 1352|      0|  [userDefaults synchronize];
 1353|      0|}
 1354|       |
 1355|      0|+ (GTM_NULLABLE NSArray *)activePersistedBackgroundSessions {
 1356|      0|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1357|      0|  NSArray *oldBackgroundSessions =
 1358|      0|      [userDefaults arrayForKey:kGTMSessionFetcherPersistedDestinationKey];
 1359|      0|  if (oldBackgroundSessions.count == 0) {
 1360|      0|    return nil;
 1361|      0|  }
 1362|      0|  NSMutableArray *activeBackgroundSessions = nil;
 1363|      0|  NSMapTable *sessionIdentifierToFetcherMap = [self sessionIdentifierToFetcherMap];
 1364|      0|  for (NSString *sessionIdentifier in oldBackgroundSessions) {
 1365|      0|    GTMSessionFetcher *fetcher = [sessionIdentifierToFetcherMap objectForKey:sessionIdentifier];
 1366|      0|    if (fetcher) {
 1367|      0|      if (!activeBackgroundSessions) {
 1368|      0|        activeBackgroundSessions = [[NSMutableArray alloc] init];
 1369|      0|      }
 1370|      0|      [activeBackgroundSessions addObject:sessionIdentifier];
 1371|      0|    }
 1372|      0|  }
 1373|      0|  return activeBackgroundSessions;
 1374|      0|}
 1375|       |
 1376|      2|+ (NSArray *)fetchersForBackgroundSessions {
 1377|      2|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1378|      2|  NSArray *backgroundSessions =
 1379|      2|      [userDefaults arrayForKey:kGTMSessionFetcherPersistedDestinationKey];
 1380|      2|  NSMapTable *sessionIdentifierToFetcherMap = [self sessionIdentifierToFetcherMap];
 1381|      2|  NSMutableArray *fetchers = [NSMutableArray array];
 1382|      2|  for (NSString *sessionIdentifier in backgroundSessions) {
 1383|      0|    GTMSessionFetcher *fetcher = [sessionIdentifierToFetcherMap objectForKey:sessionIdentifier];
 1384|      0|    if (!fetcher) {
 1385|      0|      fetcher = [self fetcherWithSessionIdentifier:sessionIdentifier];
 1386|      0|      GTMSESSION_ASSERT_DEBUG(fetcher != nil,
 1387|      0|                              @"Unexpected invalid session identifier: %@", sessionIdentifier);
 1388|      0|      [fetcher beginFetchWithCompletionHandler:nil];
 1389|      0|    }
 1390|      0|    GTM_LOG_BACKGROUND_SESSION(@"%@ restoring session %@ by creating fetcher %@ %p",
 1391|      0|                               [self class], sessionIdentifier, fetcher, fetcher);
 1392|      0|    if (fetcher != nil) {
 1393|      0|      [fetchers addObject:fetcher];
 1394|      0|    }
 1395|      0|  }
 1396|      2|  return fetchers;
 1397|      2|}
 1398|       |
 1399|       |#if TARGET_OS_IPHONE && !TARGET_OS_WATCH
 1400|       |+ (void)application:(UIApplication *)application
 1401|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
 1402|      0|                      completionHandler:(GTMSessionFetcherSystemCompletionHandler)completionHandler {
 1403|      0|  GTMSessionFetcher *fetcher = [self fetcherWithSessionIdentifier:identifier];
 1404|      0|  if (fetcher != nil) {
 1405|      0|    fetcher.systemCompletionHandler = completionHandler;
 1406|      0|  } else {
 1407|      0|    GTM_LOG_BACKGROUND_SESSION(@"%@ did not create background session identifier: %@",
 1408|      0|                               [self class], identifier);
 1409|      0|  }
 1410|      0|}
 1411|       |#endif
 1412|       |
 1413|      0|- (NSString * GTM_NULLABLE_TYPE)sessionIdentifier {
 1414|      0|  @synchronized(self) {
 1415|      0|    GTMSessionMonitorSynchronized(self);
 1416|      0|
 1417|      0|    return _sessionIdentifier;
 1418|      0|  }  // @synchronized(self)
 1419|      0|}
 1420|       |
 1421|      0|- (void)setSessionIdentifier:(NSString *)sessionIdentifier {
 1422|      0|  GTMSESSION_ASSERT_DEBUG(sessionIdentifier != nil, @"Invalid session identifier");
 1423|      0|  @synchronized(self) {
 1424|      0|    GTMSessionMonitorSynchronized(self);
 1425|      0|
 1426|      0|    GTMSESSION_ASSERT_DEBUG(!_session, @"Unable to set session identifier after session created");
 1427|      0|    _sessionIdentifier = [sessionIdentifier copy];
 1428|      0|    _usingBackgroundSession = YES;
 1429|      0|    _canShareSession = NO;
 1430|      0|    [self restoreDefaultStateForSessionIdentifierMetadata];
 1431|      0|  }  // @synchronized(self)
 1432|      0|}
 1433|       |
 1434|      0|- (void)setSessionIdentifierInternal:(GTM_NULLABLE NSString *)sessionIdentifier {
 1435|      0|  // This internal method only does a synchronized set of the session identifier.
 1436|      0|  // It does not have side effects on the background session, shared session, or
 1437|      0|  // session identifier metadata.
 1438|      0|  @synchronized(self) {
 1439|      0|    GTMSessionMonitorSynchronized(self);
 1440|      0|
 1441|      0|    _sessionIdentifier = [sessionIdentifier copy];
 1442|      0|  }  // @synchronized(self)
 1443|      0|}
 1444|       |
 1445|      0|- (NSDictionary * GTM_NULLABLE_TYPE)sessionUserInfo {
 1446|      0|  @synchronized(self) {
 1447|      0|    GTMSessionMonitorSynchronized(self);
 1448|      0|
 1449|      0|    if (_sessionUserInfo == nil) {
 1450|      0|      // We'll return the metadata dictionary with internal keys removed. This avoids the user
 1451|      0|      // re-using the userInfo dictionary later and accidentally including the internal keys.
 1452|      0|      NSMutableDictionary *metadata = [[self sessionIdentifierMetadataUnsynchronized] mutableCopy];
 1453|      0|      NSSet *keysToRemove = [metadata keysOfEntriesPassingTest:^BOOL(id key, id obj, BOOL *stop) {
 1454|      0|          return [key hasPrefix:@"_"];
 1455|      0|      }];
 1456|      0|      [metadata removeObjectsForKeys:[keysToRemove allObjects]];
 1457|      0|      if (metadata.count > 0) {
 1458|      0|        _sessionUserInfo = metadata;
 1459|      0|      }
 1460|      0|    }
 1461|      0|    return _sessionUserInfo;
 1462|      0|  }  // @synchronized(self)
 1463|      0|}
 1464|       |
 1465|      0|- (void)setSessionUserInfo:(NSDictionary * GTM_NULLABLE_TYPE)dictionary {
 1466|      0|  @synchronized(self) {
 1467|      0|    GTMSessionMonitorSynchronized(self);
 1468|      0|
 1469|      0|    GTMSESSION_ASSERT_DEBUG(_sessionIdentifier == nil, @"Too late to assign userInfo");
 1470|      0|    _sessionUserInfo = dictionary;
 1471|      0|  }  // @synchronized(self)
 1472|      0|}
 1473|       |
 1474|      0|- (GTM_NULLABLE NSDictionary *)sessionIdentifierDefaultMetadata {
 1475|      0|  GTMSessionCheckSynchronized(self);
 1476|      0|
 1477|      0|  NSMutableDictionary *defaultUserInfo = [[NSMutableDictionary alloc] init];
 1478|      0|  if (_destinationFileURL) {
 1479|      0|    defaultUserInfo[kGTMSessionIdentifierDestinationFileURLMetadataKey] =
 1480|      0|        [_destinationFileURL absoluteString];
 1481|      0|  }
 1482|      0|  if (_bodyFileURL) {
 1483|      0|    defaultUserInfo[kGTMSessionIdentifierBodyFileURLMetadataKey] = [_bodyFileURL absoluteString];
 1484|      0|  }
 1485|      0|  return (defaultUserInfo.count > 0) ? defaultUserInfo : nil;
 1486|      0|}
 1487|       |
 1488|      0|- (void)restoreDefaultStateForSessionIdentifierMetadata {
 1489|      0|  GTMSessionCheckSynchronized(self);
 1490|      0|
 1491|      0|  NSDictionary *metadata = [self sessionIdentifierMetadataUnsynchronized];
 1492|      0|  NSString *destinationFileURLString = metadata[kGTMSessionIdentifierDestinationFileURLMetadataKey];
 1493|      0|  if (destinationFileURLString) {
 1494|      0|    _destinationFileURL = [NSURL URLWithString:destinationFileURLString];
 1495|      0|    GTM_LOG_BACKGROUND_SESSION(@"Restoring destination file URL: %@", _destinationFileURL);
 1496|      0|  }
 1497|      0|  NSString *bodyFileURLString = metadata[kGTMSessionIdentifierBodyFileURLMetadataKey];
 1498|      0|  if (bodyFileURLString) {
 1499|      0|    _bodyFileURL = [NSURL URLWithString:bodyFileURLString];
 1500|      0|    GTM_LOG_BACKGROUND_SESSION(@"Restoring body file URL: %@", _bodyFileURL);
 1501|      0|  }
 1502|      0|}
 1503|       |
 1504|      0|- (NSDictionary * GTM_NULLABLE_TYPE)sessionIdentifierMetadata {
 1505|      0|  @synchronized(self) {
 1506|      0|    GTMSessionMonitorSynchronized(self);
 1507|      0|
 1508|      0|    return [self sessionIdentifierMetadataUnsynchronized];
 1509|      0|  }
 1510|      0|}
 1511|       |
 1512|      0|- (NSDictionary * GTM_NULLABLE_TYPE)sessionIdentifierMetadataUnsynchronized {
 1513|      0|  GTMSessionCheckSynchronized(self);
 1514|      0|
 1515|      0|  // Session Identifier format: "com.google.<ClassName>_<UUID>_<Metadata in JSON format>
 1516|      0|  if (!_sessionIdentifier) {
 1517|      0|    return nil;
 1518|      0|  }
 1519|      0|  NSScanner *metadataScanner = [NSScanner scannerWithString:_sessionIdentifier];
 1520|      0|  [metadataScanner setCharactersToBeSkipped:nil];
 1521|      0|  NSString *metadataString;
 1522|      0|  NSString *uuid;
 1523|      0|  if ([metadataScanner scanUpToString:@"_" intoString:NULL] &&
 1524|      0|      [metadataScanner scanString:@"_" intoString:NULL] &&
 1525|      0|      [metadataScanner scanUpToString:@"_" intoString:&uuid] &&
 1526|      0|      [metadataScanner scanString:@"_" intoString:NULL] &&
 1527|      0|      [metadataScanner scanUpToString:@"\n" intoString:&metadataString]) {
 1528|      0|    _sessionIdentifierUUID = uuid;
 1529|      0|    NSData *metadataData = [metadataString dataUsingEncoding:NSUTF8StringEncoding];
 1530|      0|    NSError *error;
 1531|      0|    NSDictionary *metadataDict =
 1532|      0|      [NSJSONSerialization JSONObjectWithData:metadataData
 1533|      0|                                      options:0
 1534|      0|                                        error:&error];
 1535|      0|    GTM_LOG_BACKGROUND_SESSION(@"User Info from session identifier: %@ %@",
 1536|      0|                               metadataDict, error ? error : @"");
 1537|      0|    return metadataDict;
 1538|      0|  }
 1539|      0|  return nil;
 1540|      0|}
 1541|       |
 1542|      0|- (NSString *)createSessionIdentifierWithMetadata:(NSDictionary * GTM_NULLABLE_TYPE)metadataToInclude {
 1543|      0|  NSString *result;
 1544|      0|  @synchronized(self) {
 1545|      0|    GTMSessionMonitorSynchronized(self);
 1546|      0|
 1547|      0|    // Session Identifier format: "com.google.<ClassName>_<UUID>_<Metadata in JSON format>
 1548|      0|    GTMSESSION_ASSERT_DEBUG(!_sessionIdentifier, @"Session identifier already created");
 1549|      0|    _sessionIdentifierUUID = [[NSUUID UUID] UUIDString];
 1550|      0|    _sessionIdentifier =
 1551|      0|      [NSString stringWithFormat:@"%@_%@", kGTMSessionIdentifierPrefix, _sessionIdentifierUUID];
 1552|      0|    // Start with user-supplied keys so they cannot accidentally override the fetcher's keys.
 1553|      0|    NSMutableDictionary *metadataDict =
 1554|      0|        [NSMutableDictionary dictionaryWithDictionary:(NSDictionary * GTM_NONNULL_TYPE)_sessionUserInfo];
 1555|      0|
 1556|      0|    if (metadataToInclude) {
 1557|      0|      [metadataDict addEntriesFromDictionary:(NSDictionary *)metadataToInclude];
 1558|      0|    }
 1559|      0|    NSDictionary *defaultMetadataDict = [self sessionIdentifierDefaultMetadata];
 1560|      0|    if (defaultMetadataDict) {
 1561|      0|      [metadataDict addEntriesFromDictionary:defaultMetadataDict];
 1562|      0|    }
 1563|      0|    if (metadataDict.count > 0) {
 1564|      0|      NSData *metadataData = [NSJSONSerialization dataWithJSONObject:metadataDict
 1565|      0|                                                             options:0
 1566|      0|                                                               error:NULL];
 1567|      0|      GTMSESSION_ASSERT_DEBUG(metadataData != nil,
 1568|      0|                              @"Session identifier user info failed to convert to JSON");
 1569|      0|      if (metadataData.length > 0) {
 1570|      0|        NSString *metadataString = [[NSString alloc] initWithData:metadataData
 1571|      0|                                                         encoding:NSUTF8StringEncoding];
 1572|      0|        _sessionIdentifier =
 1573|      0|          [_sessionIdentifier stringByAppendingFormat:@"_%@", metadataString];
 1574|      0|      }
 1575|      0|    }
 1576|      0|    _didCreateSessionIdentifier = YES;
 1577|      0|    result = _sessionIdentifier;
 1578|      0|  }  // @synchronized(self)
 1579|      0|  return result;
 1580|      0|}
 1581|       |
 1582|      0|- (void)failToBeginFetchWithError:(NSError *)error {
 1583|      0|  @synchronized(self) {
 1584|      0|    GTMSessionMonitorSynchronized(self);
 1585|      0|
 1586|      0|    _hasStoppedFetching = YES;
 1587|      0|  }
 1588|      0|
 1589|      0|  if (error == nil) {
 1590|      0|    error = [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
 1591|      0|                                code:GTMSessionFetcherErrorDownloadFailed
 1592|      0|                            userInfo:nil];
 1593|      0|  }
 1594|      0|
 1595|      0|  [self invokeFetchCallbacksOnCallbackQueueWithData:nil
 1596|      0|                                              error:error];
 1597|      0|  [self releaseCallbacks];
 1598|      0|
 1599|      0|  [_service fetcherDidStop:self];
 1600|      0|
 1601|      0|  self.authorizer = nil;
 1602|      0|}
 1603|       |
 1604|      0|+ (GTMSessionCookieStorage *)staticCookieStorage {
 1605|      0|  static GTMSessionCookieStorage *gCookieStorage = nil;
 1606|      0|
 1607|      0|  static dispatch_once_t onceToken;
 1608|      0|  dispatch_once(&onceToken, ^{
 1609|      0|    gCookieStorage = [[GTMSessionCookieStorage alloc] init];
 1610|      0|  });
 1611|      0|  return gCookieStorage;
 1612|      0|}
 1613|       |
 1614|       |#if GTM_BACKGROUND_TASK_FETCHING
 1615|       |
 1616|      0|- (void)endBackgroundTask {
 1617|      0|  // Whenever the connection stops or background execution expires,
 1618|      0|  // we need to tell UIApplication we're done.
 1619|      0|  UIBackgroundTaskIdentifier bgTaskID;
 1620|      0|  @synchronized(self) {
 1621|      0|    bgTaskID = self.backgroundTaskIdentifier;
 1622|      0|    if (bgTaskID != UIBackgroundTaskInvalid) {
 1623|      0|      self.backgroundTaskIdentifier = UIBackgroundTaskInvalid;
 1624|      0|    }
 1625|      0|  }
 1626|      0|
 1627|      0|  if (bgTaskID != UIBackgroundTaskInvalid) {
 1628|      0|    id<GTMUIApplicationProtocol> app = [[self class] fetcherUIApplication];
 1629|      0|    [app endBackgroundTask:bgTaskID];
 1630|      0|  }
 1631|      0|}
 1632|       |
 1633|       |#endif // GTM_BACKGROUND_TASK_FETCHING
 1634|       |
 1635|      0|- (void)authorizeRequest {
 1636|      0|  GTMSessionCheckNotSynchronized(self);
 1637|      0|
 1638|      0|  id authorizer = self.authorizer;
 1639|      0|  SEL asyncAuthSel = @selector(authorizeRequest:delegate:didFinishSelector:);
 1640|      0|  if ([authorizer respondsToSelector:asyncAuthSel]) {
 1641|      0|    SEL callbackSel = @selector(authorizer:request:finishedWithError:);
 1642|      0|    NSMutableURLRequest *mutableRequest = [self.request mutableCopy];
 1643|      0|    [authorizer authorizeRequest:mutableRequest
 1644|      0|                        delegate:self
 1645|      0|               didFinishSelector:callbackSel];
 1646|      0|  } else {
 1647|      0|    GTMSESSION_ASSERT_DEBUG(authorizer == nil, @"invalid authorizer for fetch");
 1648|      0|
 1649|      0|    // No authorizing possible, and authorizing happens only after any delay;
 1650|      0|    // just begin fetching
 1651|      0|    [self beginFetchMayDelay:NO
 1652|      0|                mayAuthorize:NO];
 1653|      0|  }
 1654|      0|}
 1655|       |
 1656|       |- (void)authorizer:(id<GTMFetcherAuthorizationProtocol>)auth
 1657|       |           request:(NSMutableURLRequest *)authorizedRequest
 1658|      0| finishedWithError:(NSError *)error {
 1659|      0|  GTMSessionCheckNotSynchronized(self);
 1660|      0|
 1661|      0|  if (error != nil) {
 1662|      0|    // We can't fetch without authorization
 1663|      0|    [self failToBeginFetchWithError:error];
 1664|      0|  } else {
 1665|      0|    @synchronized(self) {
 1666|      0|      _request = authorizedRequest;
 1667|      0|    }
 1668|      0|    [self beginFetchMayDelay:NO
 1669|      0|                mayAuthorize:NO];
 1670|      0|  }
 1671|      0|}
 1672|       |
 1673|       |
 1674|      0|- (BOOL)canFetchWithBackgroundSession {
 1675|      0|  // Subclasses may override.
 1676|      0|  return YES;
 1677|      0|}
 1678|       |
 1679|       |// Returns YES if the fetcher has been started and has not yet stopped.
 1680|       |//
 1681|       |// Fetching includes waiting for authorization or for retry, waiting to be allowed by the
 1682|       |// service object to start the request, and actually fetching the request.
 1683|      0|- (BOOL)isFetching {
 1684|      0|  @synchronized(self) {
 1685|      0|    GTMSessionMonitorSynchronized(self);
 1686|      0|
 1687|      0|    return [self isFetchingUnsynchronized];
 1688|      0|  }
 1689|      0|}
 1690|       |
 1691|      0|- (BOOL)isFetchingUnsynchronized {
 1692|      0|  GTMSessionCheckSynchronized(self);
 1693|      0|
 1694|      0|  BOOL hasBegun = (_initialBeginFetchDate != nil);
 1695|      0|  return hasBegun && !_hasStoppedFetching;
 1696|      0|}
 1697|       |
 1698|      0|- (NSURLResponse * GTM_NULLABLE_TYPE)response {
 1699|      0|  @synchronized(self) {
 1700|      0|    GTMSessionMonitorSynchronized(self);
 1701|      0|
 1702|      0|    NSURLResponse *response = [self responseUnsynchronized];
 1703|      0|    return response;
 1704|      0|  }  // @synchronized(self)
 1705|      0|}
 1706|       |
 1707|      0|- (NSURLResponse * GTM_NULLABLE_TYPE)responseUnsynchronized {
 1708|      0|  GTMSessionCheckSynchronized(self);
 1709|      0|
 1710|      0|  NSURLResponse *response = _sessionTask.response;
 1711|      0|  if (!response) response = _response;
 1712|      0|  return response;
 1713|      0|}
 1714|       |
 1715|      0|- (NSInteger)statusCode {
 1716|      0|  @synchronized(self) {
 1717|      0|    GTMSessionMonitorSynchronized(self);
 1718|      0|
 1719|      0|    NSInteger statusCode = [self statusCodeUnsynchronized];
 1720|      0|    return statusCode;
 1721|      0|  }  // @synchronized(self)
 1722|      0|}
 1723|       |
 1724|      0|- (NSInteger)statusCodeUnsynchronized {
 1725|      0|  GTMSessionCheckSynchronized(self);
 1726|      0|
 1727|      0|  NSURLResponse *response = [self responseUnsynchronized];
 1728|      0|  NSInteger statusCode;
 1729|      0|
 1730|      0|  if ([response respondsToSelector:@selector(statusCode)]) {
 1731|      0|    statusCode = [(NSHTTPURLResponse *)response statusCode];
 1732|      0|  } else {
 1733|      0|    //  Default to zero, in hopes of hinting "Unknown" (we can't be
 1734|      0|    //  sure that things are OK enough to use 200).
 1735|      0|    statusCode = 0;
 1736|      0|  }
 1737|      0|  return statusCode;
 1738|      0|}
 1739|       |
 1740|      0|- (NSDictionary * GTM_NULLABLE_TYPE)responseHeaders {
 1741|      0|  GTMSessionCheckNotSynchronized(self);
 1742|      0|
 1743|      0|  NSURLResponse *response = self.response;
 1744|      0|  if ([response respondsToSelector:@selector(allHeaderFields)]) {
 1745|      0|    NSDictionary *headers = [(NSHTTPURLResponse *)response allHeaderFields];
 1746|      0|    return headers;
 1747|      0|  }
 1748|      0|  return nil;
 1749|      0|}
 1750|       |
 1751|      0|- (NSDictionary * GTM_NULLABLE_TYPE)responseHeadersUnsynchronized {
 1752|      0|  GTMSessionCheckSynchronized(self);
 1753|      0|
 1754|      0|  NSURLResponse *response = [self responseUnsynchronized];
 1755|      0|  if ([response respondsToSelector:@selector(allHeaderFields)]) {
 1756|      0|    NSDictionary *headers = [(NSHTTPURLResponse *)response allHeaderFields];
 1757|      0|    return headers;
 1758|      0|  }
 1759|      0|  return nil;
 1760|      0|}
 1761|       |
 1762|      0|- (void)releaseCallbacks {
 1763|      0|  // Avoid releasing blocks in the sync section since objects dealloc'd by
 1764|      0|  // the blocks being released may call back into the fetcher or fetcher
 1765|      0|  // service.
 1766|      0|  dispatch_queue_t NS_VALID_UNTIL_END_OF_SCOPE holdCallbackQueue;
 1767|      0|  GTMSessionFetcherCompletionHandler NS_VALID_UNTIL_END_OF_SCOPE holdCompletionHandler;
 1768|      0|  @synchronized(self) {
 1769|      0|    GTMSessionMonitorSynchronized(self);
 1770|      0|
 1771|      0|    holdCallbackQueue = _callbackQueue;
 1772|      0|    holdCompletionHandler = _completionHandler;
 1773|      0|
 1774|      0|    _callbackQueue = nil;
 1775|      0|    _completionHandler = nil;  // Setter overridden in upload. Setter assumed to be used externally.
 1776|      0|  }
 1777|      0|
 1778|      0|  // Set local callback pointers to nil here rather than let them release at the end of the scope
 1779|      0|  // to make any problems due to the blocks being released be a bit more obvious in a stack trace.
 1780|      0|  holdCallbackQueue = nil;
 1781|      0|  holdCompletionHandler = nil;
 1782|      0|
 1783|      0|  self.configurationBlock = nil;
 1784|      0|  self.didReceiveResponseBlock = nil;
 1785|      0|  self.challengeBlock = nil;
 1786|      0|  self.willRedirectBlock = nil;
 1787|      0|  self.sendProgressBlock = nil;
 1788|      0|  self.receivedProgressBlock = nil;
 1789|      0|  self.downloadProgressBlock = nil;
 1790|      0|  self.accumulateDataBlock = nil;
 1791|      0|  self.willCacheURLResponseBlock = nil;
 1792|      0|  self.retryBlock = nil;
 1793|      0|  self.testBlock = nil;
 1794|      0|  self.resumeDataBlock = nil;
 1795|      0|}
 1796|       |
 1797|      0|- (void)forgetSessionIdentifierForFetcher {
 1798|      0|  GTMSessionCheckSynchronized(self);
 1799|      0|  [self forgetSessionIdentifierForFetcherWithoutSyncCheck];
 1800|      0|}
 1801|       |
 1802|      0|- (void)forgetSessionIdentifierForFetcherWithoutSyncCheck {
 1803|      0|  // This should be called inside a @synchronized block (except during dealloc.)
 1804|      0|  if (_sessionIdentifier) {
 1805|      0|    NSMapTable *sessionIdentifierToFetcherMap = [[self class] sessionIdentifierToFetcherMap];
 1806|      0|    [sessionIdentifierToFetcherMap removeObjectForKey:_sessionIdentifier];
 1807|      0|    _sessionIdentifier = nil;
 1808|      0|    _didCreateSessionIdentifier = NO;
 1809|      0|  }
 1810|      0|}
 1811|       |
 1812|       |// External stop method
 1813|      0|- (void)stopFetching {
 1814|      0|  @synchronized(self) {
 1815|      0|    GTMSessionMonitorSynchronized(self);
 1816|      0|
 1817|      0|    // Prevent enqueued callbacks from executing.
 1818|      0|    _userStoppedFetching = YES;
 1819|      0|  }  // @synchronized(self)
 1820|      0|  [self stopFetchReleasingCallbacks:YES];
 1821|      0|}
 1822|       |
 1823|       |// Cancel the fetch of the URL that's currently in progress.
 1824|       |//
 1825|       |// If shouldReleaseCallbacks is NO then the fetch will be retried so the callbacks
 1826|       |// need to still be retained.
 1827|      0|- (void)stopFetchReleasingCallbacks:(BOOL)shouldReleaseCallbacks {
 1828|      0|  [self removePersistedBackgroundSessionFromDefaults];
 1829|      0|
 1830|      0|  id<GTMSessionFetcherServiceProtocol> service;
 1831|      0|  NSMutableURLRequest *request;
 1832|      0|
 1833|      0|  // If the task or the retry timer is all that's retaining the fetcher,
 1834|      0|  // we want to be sure this instance survives stopping at least long enough for
 1835|      0|  // the stack to unwind.
 1836|      0|  __autoreleasing GTMSessionFetcher *holdSelf = self;
 1837|      0|
 1838|      0|  BOOL hasCanceledTask = NO;
 1839|      0|
 1840|      0|  [holdSelf destroyRetryTimer];
 1841|      0|
 1842|      0|  @synchronized(self) {
 1843|      0|    GTMSessionMonitorSynchronized(self);
 1844|      0|
 1845|      0|    _hasStoppedFetching = YES;
 1846|      0|
 1847|      0|    service = _service;
 1848|      0|    request = _request;
 1849|      0|
 1850|      0|    if (_sessionTask) {
 1851|      0|      // In case cancelling the task or session calls this recursively, we want
 1852|      0|      // to ensure that we'll only release the task and delegate once,
 1853|      0|      // so first set _sessionTask to nil
 1854|      0|      //
 1855|      0|      // This may be called in a callback from the task, so use autorelease to avoid
 1856|      0|      // releasing the task in its own callback.
 1857|      0|      __autoreleasing NSURLSessionTask *oldTask = _sessionTask;
 1858|      0|      if (!_isUsingTestBlock) {
 1859|      0|        _response = _sessionTask.response;
 1860|      0|      }
 1861|      0|      _sessionTask = nil;
 1862|      0|
 1863|      0|      if ([oldTask state] != NSURLSessionTaskStateCompleted) {
 1864|      0|        // For download tasks, when the fetch is stopped, we may provide resume data that can
 1865|      0|        // be used to create a new session.
 1866|      0|        BOOL mayResume = (_resumeDataBlock
 1867|      0|                          && [oldTask respondsToSelector:@selector(cancelByProducingResumeData:)]);
 1868|      0|        if (!mayResume) {
 1869|      0|          [oldTask cancel];
 1870|      0|          // A side effect of stopping the task is that URLSession:task:didCompleteWithError:
 1871|      0|          // will be invoked asynchronously on the delegate queue.
 1872|      0|        } else {
 1873|      0|          void (^resumeBlock)(NSData *) = _resumeDataBlock;
 1874|      0|          _resumeDataBlock = nil;
 1875|      0|
 1876|      0|          // Save callbackQueue since releaseCallbacks clears it.
 1877|      0|          dispatch_queue_t callbackQueue = _callbackQueue;
 1878|      0|          dispatch_group_enter(_callbackGroup);
 1879|      0|          [(NSURLSessionDownloadTask *)oldTask cancelByProducingResumeData:^(NSData *resumeData) {
 1880|      0|              [self invokeOnCallbackQueue:callbackQueue
 1881|      0|                         afterUserStopped:YES
 1882|      0|                                    block:^{
 1883|      0|                  resumeBlock(resumeData);
 1884|      0|                  dispatch_group_leave(self->_callbackGroup);
 1885|      0|              }];
 1886|      0|          }];
 1887|      0|        }
 1888|      0|        hasCanceledTask = YES;
 1889|      0|      }
 1890|      0|    }
 1891|      0|
 1892|      0|    // If the task was canceled, wait until the URLSession:task:didCompleteWithError: to call
 1893|      0|    // finishTasksAndInvalidate, since calling it immediately tends to crash, see radar 18471901.
 1894|      0|    if (_session) {
 1895|      0|      BOOL shouldInvalidate = _shouldInvalidateSession;
 1896|      0|#if TARGET_OS_IPHONE
 1897|      0|      // Don't invalidate if we've got a systemCompletionHandler, since
 1898|      0|      // URLSessionDidFinishEventsForBackgroundURLSession: won't be called if invalidated.
 1899|      0|      shouldInvalidate = shouldInvalidate && !self.systemCompletionHandler;
 1900|      0|#endif
 1901|      0|      if (shouldInvalidate) {
 1902|      0|        __autoreleasing NSURLSession *oldSession = _session;
 1903|      0|        _session = nil;
 1904|      0|
 1905|      0|        if (!hasCanceledTask) {
 1906|      0|          [oldSession finishTasksAndInvalidate];
 1907|      0|        } else {
 1908|      0|          _sessionNeedingInvalidation = oldSession;
 1909|      0|        }
 1910|      0|      }
 1911|      0|    }
 1912|      0|  }  // @synchronized(self)
 1913|      0|
 1914|      0|  // send the stopped notification
 1915|      0|  [self sendStopNotificationIfNeeded];
 1916|      0|
 1917|      0|  [_authorizer stopAuthorizationForRequest:request];
 1918|      0|
 1919|      0|  if (shouldReleaseCallbacks) {
 1920|      0|    [self releaseCallbacks];
 1921|      0|
 1922|      0|    self.authorizer = nil;
 1923|      0|  }
 1924|      0|
 1925|      0|  [service fetcherDidStop:self];
 1926|      0|
 1927|      0|#if GTM_BACKGROUND_TASK_FETCHING
 1928|      0|  [self endBackgroundTask];
 1929|      0|#endif
 1930|      0|}
 1931|       |
 1932|      0|- (void)setStopNotificationNeeded:(BOOL)flag {
 1933|      0|  @synchronized(self) {
 1934|      0|    GTMSessionMonitorSynchronized(self);
 1935|      0|
 1936|      0|    _isStopNotificationNeeded = flag;
 1937|      0|  }  // @synchronized(self)
 1938|      0|}
 1939|       |
 1940|      0|- (void)sendStopNotificationIfNeeded {
 1941|      0|  BOOL sendNow = NO;
 1942|      0|  @synchronized(self) {
 1943|      0|    GTMSessionMonitorSynchronized(self);
 1944|      0|
 1945|      0|    if (_isStopNotificationNeeded) {
 1946|      0|      _isStopNotificationNeeded = NO;
 1947|      0|      sendNow = YES;
 1948|      0|    }
 1949|      0|  }  // @synchronized(self)
 1950|      0|
 1951|      0|  if (sendNow) {
 1952|      0|    [self postNotificationOnMainThreadWithName:kGTMSessionFetcherStoppedNotification
 1953|      0|                                      userInfo:nil
 1954|      0|                                  requireAsync:NO];
 1955|      0|  }
 1956|      0|}
 1957|       |
 1958|      0|- (void)retryFetch {
 1959|      0|  [self stopFetchReleasingCallbacks:NO];
 1960|      0|
 1961|      0|  // A retry will need a configuration with a fresh session identifier.
 1962|      0|  @synchronized(self) {
 1963|      0|    GTMSessionMonitorSynchronized(self);
 1964|      0|
 1965|      0|    if (_sessionIdentifier && _didCreateSessionIdentifier) {
 1966|      0|      [self forgetSessionIdentifierForFetcher];
 1967|      0|      _configuration = nil;
 1968|      0|    }
 1969|      0|
 1970|      0|    if (_canShareSession) {
 1971|      0|      // Force a grab of the current session from the fetcher service in case
 1972|      0|      // the service's old one has become invalid.
 1973|      0|      _session = nil;
 1974|      0|    }
 1975|      0|  }  // @synchronized(self)
 1976|      0|
 1977|      0|  [self beginFetchForRetry];
 1978|      0|}
 1979|       |
 1980|      0|- (BOOL)waitForCompletionWithTimeout:(NSTimeInterval)timeoutInSeconds {
 1981|      0|  // Uncovered in upload fetcher testing, because the chunk fetcher is being waited on, and gets
 1982|      0|  // released by the upload code. The uploader just holds onto it with an ivar, and that gets
 1983|      0|  // nilled in the chunk fetcher callback.
 1984|      0|  // Used once in while loop just to avoid unused variable compiler warning.
 1985|      0|  __autoreleasing GTMSessionFetcher *holdSelf = self;
 1986|      0|
 1987|      0|  NSDate *giveUpDate = [NSDate dateWithTimeIntervalSinceNow:timeoutInSeconds];
 1988|      0|
 1989|      0|  BOOL shouldSpinRunLoop = ([NSThread isMainThread] &&
 1990|      0|                            (!self.callbackQueue
 1991|      0|                             || self.callbackQueue == dispatch_get_main_queue()));
 1992|      0|  BOOL expired = NO;
 1993|      0|
 1994|      0|  // Loop until the callbacks have been called and released, and until
 1995|      0|  // the connection is no longer pending, until there are no callback dispatches
 1996|      0|  // in flight, or until the timeout has expired.
 1997|      0|  int64_t delta = (int64_t)(100 * NSEC_PER_MSEC);  // 100 ms
 1998|      0|  while (1) {
 1999|      0|    BOOL isTaskInProgress = (holdSelf->_sessionTask
 2000|      0|                             && [_sessionTask state] != NSURLSessionTaskStateCompleted);
 2001|      0|    BOOL needsToCallCompletion = (_completionHandler != nil);
 2002|      0|    BOOL isCallbackInProgress = (_callbackGroup
 2003|      0|        && dispatch_group_wait(_callbackGroup, dispatch_time(DISPATCH_TIME_NOW, delta)));
 2004|      0|
 2005|      0|    if (!isTaskInProgress && !needsToCallCompletion && !isCallbackInProgress) break;
 2006|      0|
 2007|      0|    expired = ([giveUpDate timeIntervalSinceNow] < 0);
 2008|      0|    if (expired) {
 2009|      0|      GTMSESSION_LOG_DEBUG(@"GTMSessionFetcher waitForCompletionWithTimeout:%0.1f expired -- "
 2010|      0|                           @"%@%@%@", timeoutInSeconds,
 2011|      0|                           isTaskInProgress ? @"taskInProgress " : @"",
 2012|      0|                           needsToCallCompletion ? @"needsToCallCompletion " : @"",
 2013|      0|                           isCallbackInProgress ? @"isCallbackInProgress" : @"");
 2014|      0|      break;
 2015|      0|    }
 2016|      0|
 2017|      0|    // Run the current run loop 1/1000 of a second to give the networking
 2018|      0|    // code a chance to work
 2019|      0|    const NSTimeInterval kSpinInterval = 0.001;
 2020|      0|    if (shouldSpinRunLoop) {
 2021|      0|      NSDate *stopDate = [NSDate dateWithTimeIntervalSinceNow:kSpinInterval];
 2022|      0|      [[NSRunLoop currentRunLoop] runUntilDate:stopDate];
 2023|      0|    } else {
 2024|      0|      [NSThread sleepForTimeInterval:kSpinInterval];
 2025|      0|    }
 2026|      0|  }
 2027|      0|  return !expired;
 2028|      0|}
 2029|       |
 2030|      0|+ (void)setGlobalTestBlock:(GTMSessionFetcherTestBlock GTM_NULLABLE_TYPE)block {
 2031|       |#if GTM_DISABLE_FETCHER_TEST_BLOCK
 2032|       |  GTMSESSION_ASSERT_DEBUG(block == nil, @"test blocks disabled");
 2033|       |#endif
 2034|       |  gGlobalTestBlock = [block copy];
 2035|      0|}
 2036|       |
 2037|       |#if GTM_BACKGROUND_TASK_FETCHING
 2038|       |
 2039|       |static GTM_NULLABLE_TYPE id<GTMUIApplicationProtocol> gSubstituteUIApp;
 2040|       |
 2041|      0|+ (void)setSubstituteUIApplication:(nullable id<GTMUIApplicationProtocol>)app {
 2042|      0|  gSubstituteUIApp = app;
 2043|      0|}
 2044|       |
 2045|      0|+ (nullable id<GTMUIApplicationProtocol>)substituteUIApplication {
 2046|      0|  return gSubstituteUIApp;
 2047|      0|}
 2048|       |
 2049|      0|+ (nullable id<GTMUIApplicationProtocol>)fetcherUIApplication {
 2050|      0|  id<GTMUIApplicationProtocol> app = gSubstituteUIApp;
 2051|      0|  if (app) return app;
 2052|      0|
 2053|      0|  // iOS App extensions should not call [UIApplication sharedApplication], even
 2054|      0|  // if UIApplication responds to it.
 2055|      0|
 2056|      0|  static Class applicationClass = nil;
 2057|      0|  static dispatch_once_t onceToken;
 2058|      0|  dispatch_once(&onceToken, ^{
 2059|      0|    BOOL isAppExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
 2060|      0|    if (!isAppExtension) {
 2061|      0|      Class cls = NSClassFromString(@"UIApplication");
 2062|      0|      if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
 2063|      0|        applicationClass = cls;
 2064|      0|      }
 2065|      0|    }
 2066|      0|  });
 2067|      0|
 2068|      0|  if (applicationClass) {
 2069|      0|    app = (id<GTMUIApplicationProtocol>)[applicationClass sharedApplication];
 2070|      0|  }
 2071|      0|  return app;
 2072|      0|}
 2073|       |#endif //  GTM_BACKGROUND_TASK_FETCHING
 2074|       |
 2075|       |#pragma mark NSURLSession Delegate Methods
 2076|       |
 2077|       |// NSURLSession documentation indicates that redirectRequest can be passed to the handler
 2078|       |// but empirically redirectRequest lacks the HTTP body, so passing it will break POSTs.
 2079|       |// Instead, we construct a new request, a copy of the original, with overrides from the
 2080|       |// redirect.
 2081|       |
 2082|       |- (void)URLSession:(NSURLSession *)session
 2083|       |              task:(NSURLSessionTask *)task
 2084|       |willPerformHTTPRedirection:(NSHTTPURLResponse *)redirectResponse
 2085|       |        newRequest:(NSURLRequest *)redirectRequest
 2086|      0| completionHandler:(void (^)(NSURLRequest * GTM_NULLABLE_TYPE))handler {
 2087|      0|  [self setSessionTask:task];
 2088|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ willPerformHTTPRedirection:%@ newRequest:%@",
 2089|      0|                           [self class], self, session, task, redirectResponse, redirectRequest);
 2090|      0|
 2091|      0|  if ([self userStoppedFetching]) {
 2092|      0|    handler(nil);
 2093|      0|    return;
 2094|      0|  }
 2095|      0|  if (redirectRequest && redirectResponse) {
 2096|      0|    // Copy the original request, including the body.
 2097|      0|    NSURLRequest *originalRequest = self.request;
 2098|      0|    NSMutableURLRequest *newRequest = [originalRequest mutableCopy];
 2099|      0|
 2100|      0|    // The new requests's URL overrides the original's URL.
 2101|      0|    [newRequest setURL:[GTMSessionFetcher redirectURLWithOriginalRequestURL:originalRequest.URL
 2102|      0|                                                         redirectRequestURL:redirectRequest.URL]];
 2103|      0|
 2104|      0|    // Any headers in the redirect override headers in the original.
 2105|      0|    NSDictionary *redirectHeaders = redirectRequest.allHTTPHeaderFields;
 2106|      0|    for (NSString *key in redirectHeaders) {
 2107|      0|      NSString *value = [redirectHeaders objectForKey:key];
 2108|      0|      [newRequest setValue:value forHTTPHeaderField:key];
 2109|      0|    }
 2110|      0|
 2111|      0|    redirectRequest = newRequest;
 2112|      0|
 2113|      0|      // Log the response we just received
 2114|      0|    [self setResponse:redirectResponse];
 2115|      0|    [self logNowWithError:nil];
 2116|      0|
 2117|      0|    GTMSessionFetcherWillRedirectBlock willRedirectBlock = self.willRedirectBlock;
 2118|      0|    if (willRedirectBlock) {
 2119|      0|      @synchronized(self) {
 2120|      0|        GTMSessionMonitorSynchronized(self);
 2121|      0|        [self invokeOnCallbackQueueAfterUserStopped:YES
 2122|      0|                                              block:^{
 2123|      0|            willRedirectBlock(redirectResponse, redirectRequest, ^(NSURLRequest *clientRequest) {
 2124|      0|
 2125|      0|                // Update the request for future logging.
 2126|      0|                [self updateMutableRequest:[clientRequest mutableCopy]];
 2127|      0|
 2128|      0|                handler(clientRequest);
 2129|      0|            });
 2130|      0|        }];
 2131|      0|      }  // @synchronized(self)
 2132|      0|      return;
 2133|      0|    }
 2134|      0|    // Continues here if the client did not provide a redirect block.
 2135|      0|
 2136|      0|    // Update the request for future logging.
 2137|      0|    [self updateMutableRequest:[redirectRequest mutableCopy]];
 2138|      0|  }
 2139|      0|  handler(redirectRequest);
 2140|      0|}
 2141|       |
 2142|       |- (void)URLSession:(NSURLSession *)session
 2143|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2144|       |didReceiveResponse:(NSURLResponse *)response
 2145|      0| completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))handler {
 2146|      0|  [self setSessionTask:dataTask];
 2147|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ didReceiveResponse:%@",
 2148|      0|                           [self class], self, session, dataTask, response);
 2149|      0|  void (^accumulateAndFinish)(NSURLSessionResponseDisposition) =
 2150|      0|      ^(NSURLSessionResponseDisposition dispositionValue) {
 2151|      0|      // This method is called when the server has determined that it
 2152|      0|      // has enough information to create the NSURLResponse
 2153|      0|      // it can be called multiple times, for example in the case of a
 2154|      0|      // redirect, so each time we reset the data.
 2155|      0|      @synchronized(self) {
 2156|      0|        GTMSessionMonitorSynchronized(self);
 2157|      0|
 2158|      0|        BOOL hadPreviousData = self->_downloadedLength > 0;
 2159|      0|
 2160|      0|        [self->_downloadedData setLength:0];
 2161|      0|        self->_downloadedLength = 0;
 2162|      0|
 2163|      0|        if (hadPreviousData && (dispositionValue != NSURLSessionResponseCancel)) {
 2164|      0|          // Tell the accumulate block to discard prior data.
 2165|      0|          GTMSessionFetcherAccumulateDataBlock accumulateBlock = self->_accumulateDataBlock;
 2166|      0|          if (accumulateBlock) {
 2167|      0|            [self invokeOnCallbackQueueUnlessStopped:^{
 2168|      0|                accumulateBlock(nil);
 2169|      0|            }];
 2170|      0|          }
 2171|      0|        }
 2172|      0|      }  // @synchronized(self)
 2173|      0|      handler(dispositionValue);
 2174|      0|  };
 2175|      0|
 2176|      0|  GTMSessionFetcherDidReceiveResponseBlock receivedResponseBlock;
 2177|      0|  @synchronized(self) {
 2178|      0|    GTMSessionMonitorSynchronized(self);
 2179|      0|
 2180|      0|    receivedResponseBlock = _didReceiveResponseBlock;
 2181|      0|    if (receivedResponseBlock) {
 2182|      0|      // We will ultimately need to call back to NSURLSession's handler with the disposition value
 2183|      0|      // for this delegate method even if the user has stopped the fetcher.
 2184|      0|      [self invokeOnCallbackQueueAfterUserStopped:YES
 2185|      0|                                            block:^{
 2186|      0|        receivedResponseBlock(response, ^(NSURLSessionResponseDisposition desiredDisposition) {
 2187|      0|          accumulateAndFinish(desiredDisposition);
 2188|      0|        });
 2189|      0|      }];
 2190|      0|    }
 2191|      0|  }  // @synchronized(self)
 2192|      0|
 2193|      0|  if (receivedResponseBlock == nil) {
 2194|      0|    accumulateAndFinish(NSURLSessionResponseAllow);
 2195|      0|  }
 2196|      0|}
 2197|       |
 2198|       |- (void)URLSession:(NSURLSession *)session
 2199|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2200|      0|didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask {
 2201|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ didBecomeDownloadTask:%@",
 2202|      0|                           [self class], self, session, dataTask, downloadTask);
 2203|      0|  [self setSessionTask:downloadTask];
 2204|      0|}
 2205|       |
 2206|       |
 2207|       |- (void)URLSession:(NSURLSession *)session
 2208|       |              task:(NSURLSessionTask *)task
 2209|       |didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 2210|       | completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
 2211|      0|                             NSURLCredential * GTM_NULLABLE_TYPE credential))handler {
 2212|      0|  [self setSessionTask:task];
 2213|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ didReceiveChallenge:%@",
 2214|      0|                           [self class], self, session, task, challenge);
 2215|      0|
 2216|      0|  GTMSessionFetcherChallengeBlock challengeBlock = self.challengeBlock;
 2217|      0|  if (challengeBlock) {
 2218|      0|    // The fetcher user has provided custom challenge handling.
 2219|      0|    //
 2220|      0|    // We will ultimately need to call back to NSURLSession's handler with the disposition value
 2221|      0|    // for this delegate method even if the user has stopped the fetcher.
 2222|      0|    @synchronized(self) {
 2223|      0|      GTMSessionMonitorSynchronized(self);
 2224|      0|
 2225|      0|      [self invokeOnCallbackQueueAfterUserStopped:YES
 2226|      0|                                            block:^{
 2227|      0|        challengeBlock(self, challenge, handler);
 2228|      0|      }];
 2229|      0|    }
 2230|      0|  } else {
 2231|      0|    // No challenge block was provided by the client.
 2232|      0|    [self respondToChallenge:challenge
 2233|      0|           completionHandler:handler];
 2234|      0|  }
 2235|      0|}
 2236|       |
 2237|       |- (void)respondToChallenge:(NSURLAuthenticationChallenge *)challenge
 2238|       |         completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
 2239|      0|                                     NSURLCredential * GTM_NULLABLE_TYPE credential))handler {
 2240|      0|  @synchronized(self) {
 2241|      0|    GTMSessionMonitorSynchronized(self);
 2242|      0|
 2243|      0|    NSInteger previousFailureCount = [challenge previousFailureCount];
 2244|      0|    if (previousFailureCount <= 2) {
 2245|      0|      NSURLProtectionSpace *protectionSpace = [challenge protectionSpace];
 2246|      0|      NSString *authenticationMethod = [protectionSpace authenticationMethod];
 2247|      0|      if ([authenticationMethod isEqual:NSURLAuthenticationMethodServerTrust]) {
 2248|      0|        // SSL.
 2249|      0|        //
 2250|      0|        // Background sessions seem to require an explicit check of the server trust object
 2251|      0|        // rather than default handling.
 2252|      0|        SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
 2253|      0|        if (serverTrust == NULL) {
 2254|      0|          // No server trust information is available.
 2255|      0|          handler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
 2256|      0|        } else {
 2257|      0|          // Server trust information is available.
 2258|      0|          void (^callback)(SecTrustRef, BOOL) = ^(SecTrustRef trustRef, BOOL allow){
 2259|      0|            if (allow) {
 2260|      0|              NSURLCredential *trustCredential = [NSURLCredential credentialForTrust:trustRef];
 2261|      0|              handler(NSURLSessionAuthChallengeUseCredential, trustCredential);
 2262|      0|            } else {
 2263|      0|              GTMSESSION_LOG_DEBUG(@"Cancelling authentication challenge for %@", self->_request.URL);
 2264|      0|              handler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
 2265|      0|            }
 2266|      0|          };
 2267|      0|          if (_allowInvalidServerCertificates) {
 2268|      0|            callback(serverTrust, YES);
 2269|      0|          } else {
 2270|      0|            [[self class] evaluateServerTrust:serverTrust
 2271|      0|                                   forRequest:_request
 2272|      0|                            completionHandler:callback];
 2273|      0|          }
 2274|      0|        }
 2275|      0|        return;
 2276|      0|      }
 2277|      0|
 2278|      0|      NSURLCredential *credential = _credential;
 2279|      0|
 2280|      0|      if ([[challenge protectionSpace] isProxy] && _proxyCredential != nil) {
 2281|      0|        credential = _proxyCredential;
 2282|      0|      }
 2283|      0|
 2284|      0|      if (credential) {
 2285|      0|        handler(NSURLSessionAuthChallengeUseCredential, credential);
 2286|      0|      } else {
 2287|      0|        // The credential is still nil; tell the OS to use the default handling. This is needed
 2288|      0|        // for things that can come out of the keychain (proxies, client certificates, etc.).
 2289|      0|        //
 2290|      0|        // Note: Looking up a credential with NSURLCredentialStorage's
 2291|      0|        // defaultCredentialForProtectionSpace: is *not* the same invoking the handler with
 2292|      0|        // NSURLSessionAuthChallengePerformDefaultHandling. In the case of
 2293|      0|        // NSURLAuthenticationMethodClientCertificate, you can get nil back from
 2294|      0|        // NSURLCredentialStorage, while using this code path instead works.
 2295|      0|        handler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
 2296|      0|      }
 2297|      0|
 2298|      0|    } else {
 2299|      0|      // We've failed auth 3 times.  The completion handler will be called with code
 2300|      0|      // NSURLErrorCancelled.
 2301|      0|      handler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
 2302|      0|    }
 2303|      0|  }  // @synchronized(self)
 2304|      0|}
 2305|       |
 2306|       |// Return redirect URL based on the original request URL and redirect request URL.
 2307|       |//
 2308|       |// Method disallows any scheme changes between the original request URL and redirect request URL
 2309|       |// aside from "http" to "https". If a change in scheme is detected the redirect URL inherits the
 2310|       |// scheme from the original request URL.
 2311|       |+ (GTM_NULLABLE NSURL *)redirectURLWithOriginalRequestURL:(GTM_NULLABLE NSURL *)originalRequestURL
 2312|      0|                                       redirectRequestURL:(GTM_NULLABLE NSURL *)redirectRequestURL {
 2313|      0|  // In the case of an NSURLSession redirect, neither URL should ever be nil; as a sanity check
 2314|      0|  // if either is nil return the other URL.
 2315|      0|  if (!redirectRequestURL) return originalRequestURL;
 2316|      0|  if (!originalRequestURL) return redirectRequestURL;
 2317|      0|
 2318|      0|  NSString *originalScheme = originalRequestURL.scheme;
 2319|      0|  NSString *redirectScheme = redirectRequestURL.scheme;
 2320|      0|  BOOL insecureToSecureRedirect =
 2321|      0|      (originalScheme != nil && [originalScheme caseInsensitiveCompare:@"http"] == NSOrderedSame &&
 2322|      0|       redirectScheme != nil && [redirectScheme caseInsensitiveCompare:@"https"] == NSOrderedSame);
 2323|      0|
 2324|      0|  // This can't really be nil for the inputs, but to keep the analyzer happy
 2325|      0|  // for the -caseInsensitiveCompare: call below, give it a value if it were.
 2326|      0|  if (!originalScheme) originalScheme = @"https";
 2327|      0|
 2328|      0|  // Check for changes to the scheme and disallow any changes except for http to https.
 2329|      0|  if (!insecureToSecureRedirect &&
 2330|      0|      (redirectScheme.length != originalScheme.length ||
 2331|      0|       [redirectScheme caseInsensitiveCompare:originalScheme] != NSOrderedSame)) {
 2332|      0|    NSURLComponents *components =
 2333|      0|        [NSURLComponents componentsWithURL:(NSURL * _Nonnull)redirectRequestURL
 2334|      0|                   resolvingAgainstBaseURL:NO];
 2335|      0|    components.scheme = originalScheme;
 2336|      0|    return components.URL;
 2337|      0|  }
 2338|      0|
 2339|      0|  return redirectRequestURL;
 2340|      0|}
 2341|       |
 2342|       |// Validate the certificate chain.
 2343|       |//
 2344|       |// This may become a public method if it appears to be useful to users.
 2345|       |+ (void)evaluateServerTrust:(SecTrustRef)serverTrust
 2346|       |                 forRequest:(NSURLRequest *)request
 2347|      0|          completionHandler:(void (^)(SecTrustRef trustRef, BOOL allow))handler {
 2348|      0|  // Retain the trust object to avoid a SecTrustEvaluate() crash on iOS 7.
 2349|      0|  CFRetain(serverTrust);
 2350|      0|
 2351|      0|  // Evaluate the certificate chain.
 2352|      0|  //
 2353|      0|  // The delegate queue may be the main thread. Trust evaluation could cause some
 2354|      0|  // blocking network activity, so we must evaluate async, as documented at
 2355|      0|  // https://developer.apple.com/library/ios/technotes/tn2232/
 2356|      0|  //
 2357|      0|  // We must also avoid multiple uses of the trust object, per docs:
 2358|      0|  // "It is not safe to call this function concurrently with any other function that uses
 2359|      0|  // the same trust management object, or to re-enter this function for the same trust
 2360|      0|  // management object."
 2361|      0|  //
 2362|      0|  // SecTrustEvaluateAsync both does sync execution of Evaluate and calls back on the
 2363|      0|  // queue passed to it, according to at sources in
 2364|      0|  // http://www.opensource.apple.com/source/libsecurity_keychain/libsecurity_keychain-55050.9/lib/SecTrust.cpp
 2365|      0|  // It would require a global serial queue to ensure the evaluate happens only on a
 2366|      0|  // single thread at a time, so we'll stick with using SecTrustEvaluate on a background
 2367|      0|  // thread.
 2368|      0|  dispatch_queue_t evaluateBackgroundQueue =
 2369|      0|    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
 2370|      0|  dispatch_async(evaluateBackgroundQueue, ^{
 2371|      0|    // It looks like the implementation of SecTrustEvaluate() on Mac grabs a global lock,
 2372|      0|    // so it may be redundant for us to also lock, but it's easy to synchronize here
 2373|      0|    // anyway.
 2374|      0|    BOOL shouldAllow;
 2375|       |#if GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR
 2376|       |    CFErrorRef errorRef = NULL;
 2377|       |    @synchronized ([GTMSessionFetcher class]) {
 2378|       |      GTMSessionMonitorSynchronized([GTMSessionFetcher class]);
 2379|       |
 2380|       |      // SecTrustEvaluateWithError handles both the "proceed" and "unspecified" cases,
 2381|       |      // so it is not necessary to check the trust result the evaluation returns true.
 2382|       |      shouldAllow = SecTrustEvaluateWithError(serverTrust, &errorRef);
 2383|       |    }
 2384|       |
 2385|       |    if (errorRef) {
 2386|       |      GTMSESSION_LOG_DEBUG(@"Error %d evaluating trust for %@",
 2387|       |                           (int)CFErrorGetCode(errorRef), request);
 2388|       |      CFRelease(errorRef);
 2389|       |    }
 2390|       |#else
 2391|       |    SecTrustResultType trustEval = kSecTrustResultInvalid;
 2392|      0|    OSStatus trustError;
 2393|      0|    @synchronized([GTMSessionFetcher class]) {
 2394|      0|      GTMSessionMonitorSynchronized([GTMSessionFetcher class]);
 2395|      0|
 2396|      0|      trustError = SecTrustEvaluate(serverTrust, &trustEval);
 2397|      0|    }
 2398|      0|    if (trustError != errSecSuccess) {
 2399|      0|      GTMSESSION_LOG_DEBUG(@"Error %d evaluating trust for %@",
 2400|      0|                           (int)trustError, request);
 2401|      0|      shouldAllow = NO;
 2402|      0|    } else {
 2403|      0|      // Having a trust level "unspecified" by the user is the usual result, described at
 2404|      0|      //   https://developer.apple.com/library/mac/qa/qa1360
 2405|      0|      if (trustEval == kSecTrustResultUnspecified
 2406|      0|          || trustEval == kSecTrustResultProceed) {
 2407|      0|        shouldAllow = YES;
 2408|      0|      } else {
 2409|      0|        shouldAllow = NO;
 2410|      0|        GTMSESSION_LOG_DEBUG(@"Challenge SecTrustResultType %u for %@, properties: %@",
 2411|      0|                             trustEval, request.URL.host,
 2412|      0|                             CFBridgingRelease(SecTrustCopyProperties(serverTrust)));
 2413|      0|      }
 2414|      0|    }
 2415|      0|#endif  // GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR
 2416|      0|    handler(serverTrust, shouldAllow);
 2417|      0|
 2418|      0|    CFRelease(serverTrust);
 2419|      0|  });
 2420|      0|}
 2421|       |
 2422|      0|- (void)invokeOnCallbackQueueUnlessStopped:(void (^)(void))block {
 2423|      0|  [self invokeOnCallbackQueueAfterUserStopped:NO
 2424|      0|                                        block:block];
 2425|      0|}
 2426|       |
 2427|       |- (void)invokeOnCallbackQueueAfterUserStopped:(BOOL)afterStopped
 2428|      0|                                        block:(void (^)(void))block {
 2429|      0|  GTMSessionCheckSynchronized(self);
 2430|      0|
 2431|      0|  [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:afterStopped
 2432|      0|                                                      block:block];
 2433|      0|}
 2434|       |
 2435|       |- (void)invokeOnCallbackUnsynchronizedQueueAfterUserStopped:(BOOL)afterStopped
 2436|      0|                                                      block:(void (^)(void))block {
 2437|      0|  // testBlock simulation code may not be synchronizing when this is invoked.
 2438|      0|  [self invokeOnCallbackQueue:_callbackQueue
 2439|      0|             afterUserStopped:afterStopped
 2440|      0|                        block:block];
 2441|      0|}
 2442|       |
 2443|       |- (void)invokeOnCallbackQueue:(dispatch_queue_t)callbackQueue
 2444|       |             afterUserStopped:(BOOL)afterStopped
 2445|      0|                        block:(void (^)(void))block {
 2446|      0|  if (callbackQueue) {
 2447|      0|    dispatch_group_async(_callbackGroup, callbackQueue, ^{
 2448|      0|        if (!afterStopped) {
 2449|      0|          NSDate *serviceStoppedAllDate = [self->_service stoppedAllFetchersDate];
 2450|      0|
 2451|      0|          @synchronized(self) {
 2452|      0|            GTMSessionMonitorSynchronized(self);
 2453|      0|
 2454|      0|            // Avoid a race between stopFetching and the callback.
 2455|      0|            if (self->_userStoppedFetching) {
 2456|      0|              return;
 2457|      0|            }
 2458|      0|
 2459|      0|            // Also avoid calling back if the service has stopped all fetchers
 2460|      0|            // since this one was created. The fetcher may have stopped before
 2461|      0|            // stopAllFetchers was invoked, so _userStoppedFetching wasn't set,
 2462|      0|            // but the app still won't expect the callback to fire after
 2463|      0|            // the service's stopAllFetchers was invoked.
 2464|      0|            if (serviceStoppedAllDate
 2465|      0|                && [self->_initialBeginFetchDate compare:serviceStoppedAllDate] != NSOrderedDescending) {
 2466|      0|              // stopAllFetchers was called after this fetcher began.
 2467|      0|              return;
 2468|      0|            }
 2469|      0|          }  // @synchronized(self)
 2470|      0|        }
 2471|      0|        block();
 2472|      0|    });
 2473|      0|  }
 2474|      0|}
 2475|       |
 2476|       |- (void)invokeFetchCallbacksOnCallbackQueueWithData:(GTM_NULLABLE NSData *)data
 2477|      0|                                              error:(GTM_NULLABLE NSError *)error {
 2478|      0|  // Callbacks will be released in the method stopFetchReleasingCallbacks:
 2479|      0|  GTMSessionFetcherCompletionHandler handler;
 2480|      0|  @synchronized(self) {
 2481|      0|    GTMSessionMonitorSynchronized(self);
 2482|      0|
 2483|      0|    handler = _completionHandler;
 2484|      0|
 2485|      0|    if (handler) {
 2486|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2487|      0|        handler(data, error);
 2488|      0|
 2489|      0|        // Post a notification, primarily to allow code to collect responses for
 2490|      0|        // testing.
 2491|      0|        //
 2492|      0|        // The observing code is not likely on the fetcher's callback
 2493|      0|        // queue, so this posts explicitly to the main queue.
 2494|      0|        NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
 2495|      0|        if (data) {
 2496|      0|          userInfo[kGTMSessionFetcherCompletionDataKey] = data;
 2497|      0|        }
 2498|      0|        if (error) {
 2499|      0|          userInfo[kGTMSessionFetcherCompletionErrorKey] = error;
 2500|      0|        }
 2501|      0|        [self postNotificationOnMainThreadWithName:kGTMSessionFetcherCompletionInvokedNotification
 2502|      0|                                          userInfo:userInfo
 2503|      0|                                      requireAsync:NO];
 2504|      0|      }];
 2505|      0|    }
 2506|      0|  }  // @synchronized(self)
 2507|      0|}
 2508|       |
 2509|       |- (void)postNotificationOnMainThreadWithName:(NSString *)noteName
 2510|       |                                    userInfo:(GTM_NULLABLE NSDictionary *)userInfo
 2511|      0|                                requireAsync:(BOOL)requireAsync {
 2512|      0|  dispatch_block_t postBlock = ^{
 2513|      0|    [[NSNotificationCenter defaultCenter] postNotificationName:noteName
 2514|      0|                                                        object:self
 2515|      0|                                                      userInfo:userInfo];
 2516|      0|  };
 2517|      0|
 2518|      0|  if ([NSThread isMainThread] && !requireAsync) {
 2519|      0|    // Post synchronously for compatibility with older code using the fetcher.
 2520|      0|
 2521|      0|    // Avoid calling out to other code from inside a sync block to avoid risk
 2522|      0|    // of a deadlock or of recursive sync.
 2523|      0|    GTMSessionCheckNotSynchronized(self);
 2524|      0|
 2525|      0|    postBlock();
 2526|      0|  } else {
 2527|      0|    dispatch_async(dispatch_get_main_queue(), postBlock);
 2528|      0|  }
 2529|      0|}
 2530|       |
 2531|       |- (void)URLSession:(NSURLSession *)session
 2532|       |              task:(NSURLSessionTask *)uploadTask
 2533|      0| needNewBodyStream:(void (^)(NSInputStream * GTM_NULLABLE_TYPE bodyStream))completionHandler {
 2534|      0|  [self setSessionTask:uploadTask];
 2535|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ needNewBodyStream:",
 2536|      0|                           [self class], self, session, uploadTask);
 2537|      0|  @synchronized(self) {
 2538|      0|    GTMSessionMonitorSynchronized(self);
 2539|      0|
 2540|      0|    GTMSessionFetcherBodyStreamProvider provider = _bodyStreamProvider;
 2541|      0|#if !STRIP_GTM_FETCH_LOGGING
 2542|      0|    if ([self respondsToSelector:@selector(loggedStreamProviderForStreamProvider:)]) {
 2543|      0|      provider = [self performSelector:@selector(loggedStreamProviderForStreamProvider:)
 2544|      0|                            withObject:provider];
 2545|      0|    }
 2546|      0|#endif
 2547|      0|    if (provider) {
 2548|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2549|      0|          provider(completionHandler);
 2550|      0|      }];
 2551|      0|    } else {
 2552|      0|      GTMSESSION_ASSERT_DEBUG(NO, @"NSURLSession expects a stream provider");
 2553|      0|
 2554|      0|      completionHandler(nil);
 2555|      0|    }
 2556|      0|  }  // @synchronized(self)
 2557|      0|}
 2558|       |
 2559|       |- (void)URLSession:(NSURLSession *)session
 2560|       |              task:(NSURLSessionTask *)task
 2561|       |   didSendBodyData:(int64_t)bytesSent
 2562|       |    totalBytesSent:(int64_t)totalBytesSent
 2563|      0|totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
 2564|      0|  [self setSessionTask:task];
 2565|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ didSendBodyData:%lld"
 2566|      0|                           @" totalBytesSent:%lld totalBytesExpectedToSend:%lld",
 2567|      0|                           [self class], self, session, task, bytesSent, totalBytesSent,
 2568|      0|                           totalBytesExpectedToSend);
 2569|      0|  @synchronized(self) {
 2570|      0|    GTMSessionMonitorSynchronized(self);
 2571|      0|
 2572|      0|    if (!_sendProgressBlock) {
 2573|      0|      return;
 2574|      0|    }
 2575|      0|    // We won't hold on to send progress block; it's ok to not send it if the upload finishes.
 2576|      0|    [self invokeOnCallbackQueueUnlessStopped:^{
 2577|      0|      GTMSessionFetcherSendProgressBlock progressBlock;
 2578|      0|      @synchronized(self) {
 2579|      0|        GTMSessionMonitorSynchronized(self);
 2580|      0|
 2581|      0|        progressBlock = self->_sendProgressBlock;
 2582|      0|      }
 2583|      0|      if (progressBlock) {
 2584|      0|        progressBlock(bytesSent, totalBytesSent, totalBytesExpectedToSend);
 2585|      0|      }
 2586|      0|    }];
 2587|      0|  }  // @synchronized(self)
 2588|      0|}
 2589|       |
 2590|       |- (void)URLSession:(NSURLSession *)session
 2591|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2592|      0|    didReceiveData:(NSData *)data {
 2593|      0|  [self setSessionTask:dataTask];
 2594|      0|  NSUInteger bufferLength = data.length;
 2595|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ didReceiveData:%p (%llu bytes)",
 2596|      0|                           [self class], self, session, dataTask, data,
 2597|      0|                           (unsigned long long)bufferLength);
 2598|      0|  if (bufferLength == 0) {
 2599|      0|    // Observed on completing an out-of-process upload.
 2600|      0|    return;
 2601|      0|  }
 2602|      0|  @synchronized(self) {
 2603|      0|    GTMSessionMonitorSynchronized(self);
 2604|      0|
 2605|      0|    GTMSessionFetcherAccumulateDataBlock accumulateBlock = _accumulateDataBlock;
 2606|      0|    if (accumulateBlock) {
 2607|      0|      // Let the client accumulate the data.
 2608|      0|      _downloadedLength += bufferLength;
 2609|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2610|      0|          accumulateBlock(data);
 2611|      0|      }];
 2612|      0|    } else if (!_userStoppedFetching) {
 2613|      0|      // Append to the mutable data buffer unless the fetch has been cancelled.
 2614|      0|
 2615|      0|      // Resumed upload tasks may not yet have a data buffer.
 2616|      0|      if (_downloadedData == nil) {
 2617|      0|        // Using NSClassFromString for iOS 6 compatibility.
 2618|      0|        GTMSESSION_ASSERT_DEBUG(
 2619|      0|            ![dataTask isKindOfClass:NSClassFromString(@"NSURLSessionDownloadTask")],
 2620|      0|            @"Resumed download tasks should not receive data bytes");
 2621|      0|        _downloadedData = [[NSMutableData alloc] init];
 2622|      0|      }
 2623|      0|
 2624|      0|      [_downloadedData appendData:data];
 2625|      0|      _downloadedLength = (int64_t)_downloadedData.length;
 2626|      0|
 2627|      0|      // We won't hold on to receivedProgressBlock here; it's ok to not send
 2628|      0|      // it if the transfer finishes.
 2629|      0|      if (_receivedProgressBlock) {
 2630|      0|        [self invokeOnCallbackQueueUnlessStopped:^{
 2631|      0|            GTMSessionFetcherReceivedProgressBlock progressBlock;
 2632|      0|            @synchronized(self) {
 2633|      0|              GTMSessionMonitorSynchronized(self);
 2634|      0|
 2635|      0|              progressBlock = self->_receivedProgressBlock;
 2636|      0|            }
 2637|      0|            if (progressBlock) {
 2638|      0|              progressBlock((int64_t)bufferLength, self->_downloadedLength);
 2639|      0|            }
 2640|      0|        }];
 2641|      0|      }
 2642|      0|    }
 2643|      0|  }  // @synchronized(self)
 2644|      0|}
 2645|       |
 2646|       |- (void)URLSession:(NSURLSession *)session
 2647|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2648|       | willCacheResponse:(NSCachedURLResponse *)proposedResponse
 2649|      0| completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler {
 2650|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ willCacheResponse:%@ %@",
 2651|      0|                           [self class], self, session, dataTask,
 2652|      0|                           proposedResponse, proposedResponse.response);
 2653|      0|  GTMSessionFetcherWillCacheURLResponseBlock callback;
 2654|      0|  @synchronized(self) {
 2655|      0|    GTMSessionMonitorSynchronized(self);
 2656|      0|
 2657|      0|    callback = _willCacheURLResponseBlock;
 2658|      0|
 2659|      0|    if (callback) {
 2660|      0|      [self invokeOnCallbackQueueAfterUserStopped:YES
 2661|      0|                                            block:^{
 2662|      0|          callback(proposedResponse, completionHandler);
 2663|      0|      }];
 2664|      0|    }
 2665|      0|  }  // @synchronized(self)
 2666|      0|  if (!callback) {
 2667|      0|    completionHandler(proposedResponse);
 2668|      0|  }
 2669|      0|}
 2670|       |
 2671|       |
 2672|       |- (void)URLSession:(NSURLSession *)session
 2673|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 2674|       |      didWriteData:(int64_t)bytesWritten
 2675|       | totalBytesWritten:(int64_t)totalBytesWritten
 2676|      0|totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
 2677|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ downloadTask:%@ didWriteData:%lld"
 2678|      0|                           @" bytesWritten:%lld totalBytesExpectedToWrite:%lld",
 2679|      0|                           [self class], self, session, downloadTask, bytesWritten,
 2680|      0|                           totalBytesWritten, totalBytesExpectedToWrite);
 2681|      0|  [self setSessionTask:downloadTask];
 2682|      0|  @synchronized(self) {
 2683|      0|    GTMSessionMonitorSynchronized(self);
 2684|      0|
 2685|      0|    if ((totalBytesExpectedToWrite != NSURLSessionTransferSizeUnknown) &&
 2686|      0|        (totalBytesExpectedToWrite < totalBytesWritten)) {
 2687|      0|      // Have observed cases were bytesWritten == totalBytesExpectedToWrite,
 2688|      0|      // but totalBytesWritten > totalBytesExpectedToWrite, so setting to unkown in these cases.
 2689|      0|      totalBytesExpectedToWrite = NSURLSessionTransferSizeUnknown;
 2690|      0|    }
 2691|      0|
 2692|      0|    GTMSessionFetcherDownloadProgressBlock progressBlock;
 2693|      0|    progressBlock = self->_downloadProgressBlock;
 2694|      0|    if (progressBlock) {
 2695|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2696|      0|        progressBlock(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
 2697|      0|      }];
 2698|      0|    }
 2699|      0|  }  // @synchronized(self)
 2700|      0|}
 2701|       |
 2702|       |- (void)URLSession:(NSURLSession *)session
 2703|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 2704|       | didResumeAtOffset:(int64_t)fileOffset
 2705|      0|expectedTotalBytes:(int64_t)expectedTotalBytes {
 2706|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ downloadTask:%@ didResumeAtOffset:%lld"
 2707|      0|                           @" expectedTotalBytes:%lld",
 2708|      0|                           [self class], self, session, downloadTask, fileOffset,
 2709|      0|                           expectedTotalBytes);
 2710|      0|  [self setSessionTask:downloadTask];
 2711|      0|}
 2712|       |
 2713|       |- (void)URLSession:(NSURLSession *)session
 2714|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 2715|      0|didFinishDownloadingToURL:(NSURL *)downloadLocationURL {
 2716|      0|  // Download may have relaunched app, so update _sessionTask.
 2717|      0|  [self setSessionTask:downloadTask];
 2718|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ downloadTask:%@ didFinishDownloadingToURL:%@",
 2719|      0|                           [self class], self, session, downloadTask, downloadLocationURL);
 2720|      0|  NSNumber *fileSizeNum;
 2721|      0|  [downloadLocationURL getResourceValue:&fileSizeNum
 2722|      0|                                 forKey:NSURLFileSizeKey
 2723|      0|                                  error:NULL];
 2724|      0|  @synchronized(self) {
 2725|      0|    GTMSessionMonitorSynchronized(self);
 2726|      0|
 2727|      0|    NSURL *destinationURL = _destinationFileURL;
 2728|      0|
 2729|      0|    _downloadedLength = fileSizeNum.longLongValue;
 2730|      0|
 2731|      0|    // Overwrite any previous file at the destination URL.
 2732|      0|    NSFileManager *fileMgr = [NSFileManager defaultManager];
 2733|      0|    NSError *removeError;
 2734|      0|    if (![fileMgr removeItemAtURL:destinationURL error:&removeError]
 2735|      0|        && removeError.code != NSFileNoSuchFileError) {
 2736|      0|      GTMSESSION_LOG_DEBUG(@"Could not remove previous file at %@ due to %@",
 2737|      0|                           downloadLocationURL.path, removeError);
 2738|      0|    }
 2739|      0|
 2740|      0|    NSInteger statusCode = [self statusCodeUnsynchronized];
 2741|      0|    if (statusCode < 200 || statusCode > 399) {
 2742|      0|      // In OS X 10.11, the response body is written to a file even on a server
 2743|      0|      // status error.  For convenience of the fetcher client, we'll skip saving the
 2744|      0|      // downloaded body to the destination URL so that clients do not need to know
 2745|      0|      // to delete the file following fetch errors.
 2746|      0|      GTMSESSION_LOG_DEBUG(@"Abandoning download due to status %ld, file %@",
 2747|      0|                           (long)statusCode, downloadLocationURL.path);
 2748|      0|
 2749|      0|      // On error code, add the contents of the temporary file to _downloadTaskErrorData
 2750|      0|      // This way fetcher clients have access to error details possibly passed by the server.
 2751|      0|      if (_downloadedLength > 0 && _downloadedLength <= kMaximumDownloadErrorDataLength) {
 2752|      0|        _downloadTaskErrorData = [NSData dataWithContentsOfURL:downloadLocationURL];
 2753|      0|      } else if (_downloadedLength > kMaximumDownloadErrorDataLength) {
 2754|      0|        GTMSESSION_LOG_DEBUG(@"Download error data for file %@ not passed to userInfo due to size "
 2755|      0|                             @"%lld", downloadLocationURL.path, _downloadedLength);
 2756|      0|      }
 2757|      0|    } else {
 2758|      0|      NSError *moveError;
 2759|      0|      NSURL *destinationFolderURL = [destinationURL URLByDeletingLastPathComponent];
 2760|      0|      BOOL didMoveDownload = NO;
 2761|      0|      if ([fileMgr createDirectoryAtURL:destinationFolderURL
 2762|      0|            withIntermediateDirectories:YES
 2763|      0|                             attributes:nil
 2764|      0|                                  error:&moveError]) {
 2765|      0|        didMoveDownload = [fileMgr moveItemAtURL:downloadLocationURL
 2766|      0|                                           toURL:destinationURL
 2767|      0|                                           error:&moveError];
 2768|      0|      }
 2769|      0|      if (!didMoveDownload) {
 2770|      0|        _downloadFinishedError = moveError;
 2771|      0|      }
 2772|      0|      GTM_LOG_BACKGROUND_SESSION(@"%@ %p Moved download from \"%@\" to \"%@\"  %@",
 2773|      0|                                 [self class], self,
 2774|      0|                                 downloadLocationURL.path, destinationURL.path,
 2775|      0|                                 error ? error : @"");
 2776|      0|    }
 2777|      0|  }  // @synchronized(self)
 2778|      0|}
 2779|       |
 2780|       |/* Sent as the last message related to a specific task.  Error may be
 2781|       | * nil, which implies that no error occurred and this task is complete.
 2782|       | */
 2783|       |- (void)URLSession:(NSURLSession *)session
 2784|       |              task:(NSURLSessionTask *)task
 2785|      0|didCompleteWithError:(NSError *)error {
 2786|      0|  [self setSessionTask:task];
 2787|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ didCompleteWithError:%@",
 2788|      0|                           [self class], self, session, task, error);
 2789|      0|
 2790|      0|  NSInteger status = self.statusCode;
 2791|      0|  BOOL forceAssumeRetry = NO;
 2792|      0|  BOOL succeeded = NO;
 2793|      0|  @synchronized(self) {
 2794|      0|    GTMSessionMonitorSynchronized(self);
 2795|      0|
 2796|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
 2797|      0|    // The task is never resumed when a testBlock is used. When the session is destroyed,
 2798|      0|    // we should ignore the callback, since the testBlock support code itself invokes
 2799|      0|    // shouldRetryNowForStatus: and finishWithError:shouldRetry:
 2800|      0|    if (_isUsingTestBlock) return;
 2801|      0|#endif
 2802|      0|
 2803|      0|    if (error == nil) {
 2804|      0|      error = _downloadFinishedError;
 2805|      0|    }
 2806|      0|    succeeded = (error == nil && status >= 0 && status < 300);
 2807|      0|    if (succeeded) {
 2808|      0|      // Succeeded.
 2809|      0|      _bodyLength = task.countOfBytesSent;
 2810|      0|    }
 2811|      0|  }  // @synchronized(self)
 2812|      0|
 2813|      0|  if (succeeded) {
 2814|      0|    [self finishWithError:nil shouldRetry:NO];
 2815|      0|    return;
 2816|      0|  }
 2817|      0|  // For background redirects, no delegate method is called, so we cannot restore a stripped
 2818|      0|  // Authorization header, so if a 403 ("Forbidden") was generated due to a missing OAuth 2 header,
 2819|      0|  // set the current request's URL to the redirected URL, so we in effect restore the Authorization
 2820|      0|  // header.
 2821|      0|  if ((status == 403) && self.usingBackgroundSession) {
 2822|      0|    NSURL *redirectURL = self.response.URL;
 2823|      0|    NSURLRequest *request = self.request;
 2824|      0|    if (![request.URL isEqual:redirectURL]) {
 2825|      0|      NSString *authorizationHeader = [request.allHTTPHeaderFields objectForKey:@"Authorization"];
 2826|      0|      if (authorizationHeader != nil) {
 2827|      0|        NSMutableURLRequest *mutableRequest = [request mutableCopy];
 2828|      0|        mutableRequest.URL = redirectURL;
 2829|      0|        [self updateMutableRequest:mutableRequest];
 2830|      0|        // Avoid assuming the session is still valid.
 2831|      0|        self.session = nil;
 2832|      0|        forceAssumeRetry = YES;
 2833|      0|      }
 2834|      0|    }
 2835|      0|  }
 2836|      0|
 2837|      0|  // If invalidating the session was deferred in stopFetchReleasingCallbacks: then do it now.
 2838|      0|  NSURLSession *oldSession = self.sessionNeedingInvalidation;
 2839|      0|  if (oldSession) {
 2840|      0|    [self setSessionNeedingInvalidation:NULL];
 2841|      0|    [oldSession finishTasksAndInvalidate];
 2842|      0|  }
 2843|      0|
 2844|      0|  // Failed.
 2845|      0|  [self shouldRetryNowForStatus:status
 2846|      0|                          error:error
 2847|      0|               forceAssumeRetry:forceAssumeRetry
 2848|      0|                       response:^(BOOL shouldRetry) {
 2849|      0|    [self finishWithError:error shouldRetry:shouldRetry];
 2850|      0|  }];
 2851|      0|}
 2852|       |
 2853|       |#if TARGET_OS_IPHONE
 2854|      0|- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
 2855|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSessionDidFinishEventsForBackgroundURLSession:%@",
 2856|      0|                           [self class], self, session);
 2857|      0|  [self removePersistedBackgroundSessionFromDefaults];
 2858|      0|
 2859|      0|  GTMSessionFetcherSystemCompletionHandler handler;
 2860|      0|  @synchronized(self) {
 2861|      0|    GTMSessionMonitorSynchronized(self);
 2862|      0|
 2863|      0|    handler = self.systemCompletionHandler;
 2864|      0|    self.systemCompletionHandler = nil;
 2865|      0|  }  // @synchronized(self)
 2866|      0|  if (handler) {
 2867|      0|    GTM_LOG_BACKGROUND_SESSION(@"%@ %p Calling system completionHandler", [self class], self);
 2868|      0|    handler();
 2869|      0|
 2870|      0|    @synchronized(self) {
 2871|      0|      GTMSessionMonitorSynchronized(self);
 2872|      0|
 2873|      0|      NSURLSession *oldSession = _session;
 2874|      0|      _session = nil;
 2875|      0|      if (_shouldInvalidateSession) {
 2876|      0|        [oldSession finishTasksAndInvalidate];
 2877|      0|      }
 2878|      0|    }  // @synchronized(self)
 2879|      0|  }
 2880|      0|}
 2881|       |#endif
 2882|       |
 2883|      0|- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(GTM_NULLABLE NSError *)error {
 2884|      0|  // This may happen repeatedly for retries.  On authentication callbacks, the retry
 2885|      0|  // may begin before the prior session sends the didBecomeInvalid delegate message.
 2886|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ didBecomeInvalidWithError:%@",
 2887|      0|                           [self class], self, session, error);
 2888|      0|  if (session == (NSURLSession *)self.session) {
 2889|      0|    GTM_LOG_SESSION_DELEGATE(@"  Unexpected retained invalid session: %@", session);
 2890|      0|    self.session = nil;
 2891|      0|  }
 2892|      0|}
 2893|       |
 2894|      0|- (void)finishWithError:(GTM_NULLABLE NSError *)error shouldRetry:(BOOL)shouldRetry {
 2895|      0|  [self removePersistedBackgroundSessionFromDefaults];
 2896|      0|
 2897|      0|  BOOL shouldStopFetching = YES;
 2898|      0|  NSData *downloadedData = nil;
 2899|      0|#if !STRIP_GTM_FETCH_LOGGING
 2900|      0|  BOOL shouldDeferLogging = NO;
 2901|      0|#endif
 2902|      0|  BOOL shouldBeginRetryTimer = NO;
 2903|      0|  NSInteger status = [self statusCode];
 2904|      0|  NSURL *destinationURL = self.destinationFileURL;
 2905|      0|
 2906|      0|  BOOL fetchSucceeded = (error == nil && status >= 0 && status < 300);
 2907|      0|
 2908|      0|#if !STRIP_GTM_FETCH_LOGGING
 2909|      0|  if (!fetchSucceeded) {
 2910|      0|    if (!shouldDeferLogging && !self.hasLoggedError) {
 2911|      0|      [self logNowWithError:error];
 2912|      0|      self.hasLoggedError = YES;
 2913|      0|    }
 2914|      0|  }
 2915|      0|#endif  // !STRIP_GTM_FETCH_LOGGING
 2916|      0|
 2917|      0|  @synchronized(self) {
 2918|      0|    GTMSessionMonitorSynchronized(self);
 2919|      0|
 2920|      0|#if !STRIP_GTM_FETCH_LOGGING
 2921|      0|    shouldDeferLogging = _deferResponseBodyLogging;
 2922|      0|#endif
 2923|      0|    if (fetchSucceeded) {
 2924|      0|      // Success
 2925|      0|      if ((_downloadedData.length > 0) && (destinationURL != nil)) {
 2926|      0|        // Overwrite any previous file at the destination URL.
 2927|      0|        NSFileManager *fileMgr = [NSFileManager defaultManager];
 2928|      0|        [fileMgr removeItemAtURL:destinationURL
 2929|      0|                           error:NULL];
 2930|      0|        NSURL *destinationFolderURL = [destinationURL URLByDeletingLastPathComponent];
 2931|      0|        BOOL didMoveDownload = NO;
 2932|      0|        if ([fileMgr createDirectoryAtURL:destinationFolderURL
 2933|      0|              withIntermediateDirectories:YES
 2934|      0|                               attributes:nil
 2935|      0|                                    error:&error]) {
 2936|      0|          didMoveDownload = [_downloadedData writeToURL:destinationURL
 2937|      0|                                                options:NSDataWritingAtomic
 2938|      0|                                                  error:&error];
 2939|      0|        }
 2940|      0|        if (didMoveDownload) {
 2941|      0|          _downloadedData = nil;
 2942|      0|        } else {
 2943|      0|          _downloadFinishedError = error;
 2944|      0|        }
 2945|      0|      }
 2946|      0|      downloadedData = _downloadedData;
 2947|      0|    } else {
 2948|      0|      // Unsuccessful with error or status over 300. Retry or notify the delegate of failure
 2949|      0|      if (shouldRetry) {
 2950|      0|        // Retrying.
 2951|      0|        shouldBeginRetryTimer = YES;
 2952|      0|        shouldStopFetching = NO;
 2953|      0|      } else {
 2954|      0|        if (error == nil) {
 2955|      0|          // Create an error.
 2956|      0|          NSDictionary *userInfo = GTMErrorUserInfoForData(
 2957|      0|              _downloadedData.length > 0 ? _downloadedData : _downloadTaskErrorData,
 2958|      0|              [self responseHeadersUnsynchronized]);
 2959|      0|
 2960|      0|          error = [NSError errorWithDomain:kGTMSessionFetcherStatusDomain
 2961|      0|                                      code:status
 2962|      0|                                  userInfo:userInfo];
 2963|      0|        } else {
 2964|      0|          // If the error had resume data, and the client supplied a resume block, pass the
 2965|      0|          // data to the client.
 2966|      0|          void (^resumeBlock)(NSData *) = _resumeDataBlock;
 2967|      0|          _resumeDataBlock = nil;
 2968|      0|          if (resumeBlock) {
 2969|      0|            NSData *resumeData = [error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData];
 2970|      0|            if (resumeData) {
 2971|      0|              [self invokeOnCallbackQueueAfterUserStopped:YES block:^{
 2972|      0|                  resumeBlock(resumeData);
 2973|      0|              }];
 2974|      0|            }
 2975|      0|          }
 2976|      0|        }
 2977|      0|        if (_downloadedData.length > 0) {
 2978|      0|          downloadedData = _downloadedData;
 2979|      0|        }
 2980|      0|        // If the error occurred after retries, report the number and duration of the
 2981|      0|        // retries. This provides a clue to a developer looking at the error description
 2982|      0|        // that the fetcher did retry before failing with this error.
 2983|      0|        if (_retryCount > 0) {
 2984|      0|          NSMutableDictionary *userInfoWithRetries =
 2985|      0|              [NSMutableDictionary dictionaryWithDictionary:(NSDictionary *)error.userInfo];
 2986|      0|          NSTimeInterval timeSinceInitialRequest = -[_initialRequestDate timeIntervalSinceNow];
 2987|      0|          [userInfoWithRetries setObject:@(timeSinceInitialRequest)
 2988|      0|                                  forKey:kGTMSessionFetcherElapsedIntervalWithRetriesKey];
 2989|      0|          [userInfoWithRetries setObject:@(_retryCount)
 2990|      0|                                  forKey:kGTMSessionFetcherNumberOfRetriesDoneKey];
 2991|      0|          error = [NSError errorWithDomain:(NSString *)error.domain
 2992|      0|                                      code:error.code
 2993|      0|                                  userInfo:userInfoWithRetries];
 2994|      0|        }
 2995|      0|      }
 2996|      0|    }
 2997|      0|  }  // @synchronized(self)
 2998|      0|
 2999|      0|  if (shouldBeginRetryTimer) {
 3000|      0|    [self beginRetryTimer];
 3001|      0|  }
 3002|      0|
 3003|      0|  // We want to send the stop notification before calling the delegate's
 3004|      0|  // callback selector, since the callback selector may release all of
 3005|      0|  // the fetcher properties that the client is using to track the fetches.
 3006|      0|  //
 3007|      0|  // We'll also stop now so that, to any observers watching the notifications,
 3008|      0|  // it doesn't look like our wait for a retry (which may be long,
 3009|      0|  // 30 seconds or more) is part of the network activity.
 3010|      0|  [self sendStopNotificationIfNeeded];
 3011|      0|
 3012|      0|  if (shouldStopFetching) {
 3013|      0|    [self invokeFetchCallbacksOnCallbackQueueWithData:downloadedData
 3014|      0|                                                error:error];
 3015|      0|    // The upload subclass doesn't want to release callbacks until upload chunks have completed.
 3016|      0|    BOOL shouldRelease = [self shouldReleaseCallbacksUponCompletion];
 3017|      0|    [self stopFetchReleasingCallbacks:shouldRelease];
 3018|      0|  }
 3019|      0|
 3020|      0|#if !STRIP_GTM_FETCH_LOGGING
 3021|      0|  // _hasLoggedError is only set by this method
 3022|      0|  if (!shouldDeferLogging && !_hasLoggedError) {
 3023|      0|    [self logNowWithError:error];
 3024|      0|  }
 3025|      0|#endif
 3026|      0|}
 3027|       |
 3028|      0|- (BOOL)shouldReleaseCallbacksUponCompletion {
 3029|      0|  // A subclass can override this to keep callbacks around after the
 3030|      0|  // connection has finished successfully
 3031|      0|  return YES;
 3032|      0|}
 3033|       |
 3034|      0|- (void)logNowWithError:(GTM_NULLABLE NSError *)error {
 3035|      0|  GTMSessionCheckNotSynchronized(self);
 3036|      0|
 3037|      0|  // If the logging category is available, then log the current request,
 3038|      0|  // response, data, and error
 3039|      0|  if ([self respondsToSelector:@selector(logFetchWithError:)]) {
 3040|      0|    [self performSelector:@selector(logFetchWithError:) withObject:error];
 3041|      0|  }
 3042|      0|}
 3043|       |
 3044|       |#pragma mark Retries
 3045|       |
 3046|      0|- (BOOL)isRetryError:(NSError *)error {
 3047|      0|  struct RetryRecord {
 3048|      0|    __unsafe_unretained NSString *const domain;
 3049|      0|    NSInteger code;
 3050|      0|  };
 3051|      0|
 3052|      0|  struct RetryRecord retries[] = {
 3053|      0|    { kGTMSessionFetcherStatusDomain, 408 }, // request timeout
 3054|      0|    { kGTMSessionFetcherStatusDomain, 502 }, // failure gatewaying to another server
 3055|      0|    { kGTMSessionFetcherStatusDomain, 503 }, // service unavailable
 3056|      0|    { kGTMSessionFetcherStatusDomain, 504 }, // request timeout
 3057|      0|    { NSURLErrorDomain, NSURLErrorTimedOut },
 3058|      0|    { NSURLErrorDomain, NSURLErrorNetworkConnectionLost },
 3059|      0|    { nil, 0 }
 3060|      0|  };
 3061|      0|
 3062|      0|  // NSError's isEqual always returns false for equal but distinct instances
 3063|      0|  // of NSError, so we have to compare the domain and code values explicitly
 3064|      0|  NSString *domain = error.domain;
 3065|      0|  NSInteger code = error.code;
 3066|      0|  for (int idx = 0; retries[idx].domain != nil; idx++) {
 3067|      0|    if (code == retries[idx].code && [domain isEqual:retries[idx].domain]) {
 3068|      0|      return YES;
 3069|      0|    }
 3070|      0|  }
 3071|      0|  return NO;
 3072|      0|}
 3073|       |
 3074|       |// shouldRetryNowForStatus:error: responds with YES if the user has enabled retries
 3075|       |// and the status or error is one that is suitable for retrying.  "Suitable"
 3076|       |// means either the isRetryError:'s list contains the status or error, or the
 3077|       |// user's retry block is present and returns YES when called, or the
 3078|       |// authorizer may be able to fix.
 3079|       |- (void)shouldRetryNowForStatus:(NSInteger)status
 3080|       |                          error:(NSError *)error
 3081|       |               forceAssumeRetry:(BOOL)forceAssumeRetry
 3082|      0|                       response:(GTMSessionFetcherRetryResponse)response {
 3083|      0|  // Determine if a refreshed authorizer may avoid an authorization error
 3084|      0|  BOOL willRetry = NO;
 3085|      0|
 3086|      0|  // We assume _authorizer is immutable after beginFetch, and _hasAttemptedAuthRefresh is modified
 3087|      0|  // only in this method, and this method is invoked on the serial delegate queue.
 3088|      0|  //
 3089|      0|  // We want to avoid calling the authorizer from inside a sync block.
 3090|      0|  BOOL isFirstAuthError = (_authorizer != nil
 3091|      0|                           && !_hasAttemptedAuthRefresh
 3092|      0|                           && status == GTMSessionFetcherStatusUnauthorized); // 401
 3093|      0|
 3094|      0|  BOOL hasPrimed = NO;
 3095|      0|  if (isFirstAuthError) {
 3096|      0|    if ([_authorizer respondsToSelector:@selector(primeForRefresh)]) {
 3097|      0|      hasPrimed = [_authorizer primeForRefresh];
 3098|      0|    }
 3099|      0|  }
 3100|      0|
 3101|      0|  BOOL shouldRetryForAuthRefresh = NO;
 3102|      0|  if (hasPrimed) {
 3103|      0|    shouldRetryForAuthRefresh = YES;
 3104|      0|    _hasAttemptedAuthRefresh = YES;
 3105|      0|    [self updateRequestValue:nil forHTTPHeaderField:@"Authorization"];
 3106|      0|  }
 3107|      0|
 3108|      0|  @synchronized(self) {
 3109|      0|    GTMSessionMonitorSynchronized(self);
 3110|      0|
 3111|      0|    BOOL shouldDoRetry = [self isRetryEnabledUnsynchronized];
 3112|      0|    if (shouldDoRetry && ![self hasRetryAfterInterval]) {
 3113|      0|
 3114|      0|      // Determine if we're doing exponential backoff retries
 3115|      0|      shouldDoRetry = [self nextRetryIntervalUnsynchronized] < _maxRetryInterval;
 3116|      0|
 3117|      0|      if (shouldDoRetry) {
 3118|      0|        // If an explicit max retry interval was set, we expect repeated backoffs to take
 3119|      0|        // up to roughly twice that for repeated fast failures.  If the initial attempt is
 3120|      0|        // already more than 3 times the max retry interval, then failures have taken a long time
 3121|      0|        // (such as from network timeouts) so don't retry again to avoid the app becoming
 3122|      0|        // unexpectedly unresponsive.
 3123|      0|        if (_maxRetryInterval > 0) {
 3124|      0|          NSTimeInterval maxAllowedIntervalBeforeRetry = _maxRetryInterval * 3;
 3125|      0|          NSTimeInterval timeSinceInitialRequest = -[_initialRequestDate timeIntervalSinceNow];
 3126|      0|          if (timeSinceInitialRequest > maxAllowedIntervalBeforeRetry) {
 3127|      0|            shouldDoRetry = NO;
 3128|      0|          }
 3129|      0|        }
 3130|      0|      }
 3131|      0|    }
 3132|      0|    BOOL canRetry = shouldRetryForAuthRefresh || forceAssumeRetry || shouldDoRetry;
 3133|      0|    if (canRetry) {
 3134|      0|      NSDictionary *userInfo =
 3135|      0|          GTMErrorUserInfoForData(_downloadedData, [self responseHeadersUnsynchronized]);
 3136|      0|      NSError *statusError = [NSError errorWithDomain:kGTMSessionFetcherStatusDomain
 3137|      0|                                                 code:status
 3138|      0|                                             userInfo:userInfo];
 3139|      0|      if (error == nil) {
 3140|      0|        error = statusError;
 3141|      0|      }
 3142|      0|      willRetry = shouldRetryForAuthRefresh ||
 3143|      0|                  forceAssumeRetry ||
 3144|      0|                  [self isRetryError:error] ||
 3145|      0|                  ((error != statusError) && [self isRetryError:statusError]);
 3146|      0|
 3147|      0|      // If the user has installed a retry callback, consult that.
 3148|      0|      GTMSessionFetcherRetryBlock retryBlock = _retryBlock;
 3149|      0|      if (retryBlock) {
 3150|      0|        [self invokeOnCallbackQueueUnlessStopped:^{
 3151|      0|            retryBlock(willRetry, error, response);
 3152|      0|        }];
 3153|      0|        return;
 3154|      0|      }
 3155|      0|    }
 3156|      0|  }  // @synchronized(self)
 3157|      0|  response(willRetry);
 3158|      0|}
 3159|       |
 3160|      0|- (BOOL)hasRetryAfterInterval {
 3161|      0|  GTMSessionCheckSynchronized(self);
 3162|      0|
 3163|      0|  NSDictionary *responseHeaders = [self responseHeadersUnsynchronized];
 3164|      0|  NSString *retryAfterValue = [responseHeaders valueForKey:@"Retry-After"];
 3165|      0|  return (retryAfterValue != nil);
 3166|      0|}
 3167|       |
 3168|      0|- (NSTimeInterval)retryAfterInterval {
 3169|      0|  GTMSessionCheckSynchronized(self);
 3170|      0|
 3171|      0|  NSDictionary *responseHeaders = [self responseHeadersUnsynchronized];
 3172|      0|  NSString *retryAfterValue = [responseHeaders valueForKey:@"Retry-After"];
 3173|      0|  if (retryAfterValue == nil) {
 3174|      0|    return 0;
 3175|      0|  }
 3176|      0|  // Retry-After formatted as HTTP-date | delta-seconds
 3177|      0|  // Reference: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
 3178|      0|  NSDateFormatter *rfc1123DateFormatter = [[NSDateFormatter alloc] init];
 3179|      0|  rfc1123DateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"];
 3180|      0|  rfc1123DateFormatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@"GMT"];
 3181|      0|  rfc1123DateFormatter.dateFormat = @"EEE',' dd MMM yyyy HH':'mm':'ss z";
 3182|      0|  NSDate *retryAfterDate = [rfc1123DateFormatter dateFromString:retryAfterValue];
 3183|      0|  NSTimeInterval retryAfterInterval = (retryAfterDate != nil) ?
 3184|      0|      retryAfterDate.timeIntervalSinceNow : retryAfterValue.intValue;
 3185|      0|  retryAfterInterval = MAX(0, retryAfterInterval);
 3186|      0|  return retryAfterInterval;
 3187|      0|}
 3188|       |
 3189|      0|- (void)beginRetryTimer {
 3190|      0|  if (![NSThread isMainThread]) {
 3191|      0|    // Defer creating and starting the timer until we're on the main thread to ensure it has
 3192|      0|    // a run loop.
 3193|      0|    dispatch_group_async(_callbackGroup, dispatch_get_main_queue(), ^{
 3194|      0|        [self beginRetryTimer];
 3195|      0|    });
 3196|      0|    return;
 3197|      0|  }
 3198|      0|
 3199|      0|  [self destroyRetryTimer];
 3200|      0|  
 3201|      0|#if GTM_BACKGROUND_TASK_FETCHING
 3202|      0|  // Don't keep a background task active while awaiting retry, which can lead to the
 3203|      0|  // app exceeding the allotted time for keeping the background task open, causing the
 3204|      0|  // system to terminate the app. When the retry starts, a new background task will
 3205|      0|  // be created.
 3206|      0|  [self endBackgroundTask];
 3207|      0|#endif  // GTM_BACKGROUND_TASK_FETCHING
 3208|      0|
 3209|      0|  @synchronized(self) {
 3210|      0|    GTMSessionMonitorSynchronized(self);
 3211|      0|
 3212|      0|    NSTimeInterval nextInterval = [self nextRetryIntervalUnsynchronized];
 3213|      0|    NSTimeInterval maxInterval = _maxRetryInterval;
 3214|      0|    NSTimeInterval newInterval = MIN(nextInterval, (maxInterval > 0 ? maxInterval : DBL_MAX));
 3215|      0|    NSTimeInterval newIntervalTolerance = (newInterval / 10) > 1.0 ?: 1.0;
 3216|      0|
 3217|      0|    _lastRetryInterval = newInterval;
 3218|      0|
 3219|      0|    _retryTimer = [NSTimer timerWithTimeInterval:newInterval
 3220|      0|                                          target:self
 3221|      0|                                        selector:@selector(retryTimerFired:)
 3222|      0|                                        userInfo:nil
 3223|      0|                                         repeats:NO];
 3224|      0|    _retryTimer.tolerance = newIntervalTolerance;
 3225|      0|    [[NSRunLoop mainRunLoop] addTimer:_retryTimer
 3226|      0|                              forMode:NSDefaultRunLoopMode];
 3227|      0|  }  // @synchronized(self)
 3228|      0|
 3229|      0|  [self postNotificationOnMainThreadWithName:kGTMSessionFetcherRetryDelayStartedNotification
 3230|      0|                                    userInfo:nil
 3231|      0|                                requireAsync:NO];
 3232|      0|}
 3233|       |
 3234|      0|- (void)retryTimerFired:(NSTimer *)timer {
 3235|      0|  [self destroyRetryTimer];
 3236|      0|
 3237|      0|  @synchronized(self) {
 3238|      0|    GTMSessionMonitorSynchronized(self);
 3239|      0|
 3240|      0|    _retryCount++;
 3241|      0|  }  // @synchronized(self)
 3242|      0|
 3243|      0|  NSOperationQueue *queue = self.sessionDelegateQueue;
 3244|      0|  [queue addOperationWithBlock:^{
 3245|      0|    [self retryFetch];
 3246|      0|  }];
 3247|      0|}
 3248|       |
 3249|      0|- (void)destroyRetryTimer {
 3250|      0|  BOOL shouldNotify = NO;
 3251|      0|
 3252|      0|  @synchronized(self) {
 3253|      0|    GTMSessionMonitorSynchronized(self);
 3254|      0|
 3255|      0|    if (_retryTimer) {
 3256|      0|      [_retryTimer invalidate];
 3257|      0|      _retryTimer = nil;
 3258|      0|      shouldNotify = YES;
 3259|      0|    }
 3260|      0|  }
 3261|      0|
 3262|      0|  if (shouldNotify) {
 3263|      0|    [self postNotificationOnMainThreadWithName:kGTMSessionFetcherRetryDelayStoppedNotification
 3264|      0|                                      userInfo:nil
 3265|      0|                                  requireAsync:NO];
 3266|      0|  }
 3267|      0|}
 3268|       |
 3269|      0|- (NSUInteger)retryCount {
 3270|      0|  @synchronized(self) {
 3271|      0|    GTMSessionMonitorSynchronized(self);
 3272|      0|
 3273|      0|    return _retryCount;
 3274|      0|  }  // @synchronized(self)
 3275|      0|}
 3276|       |
 3277|      0|- (NSTimeInterval)nextRetryInterval {
 3278|      0|  @synchronized(self) {
 3279|      0|    GTMSessionMonitorSynchronized(self);
 3280|      0|
 3281|      0|    NSTimeInterval interval = [self nextRetryIntervalUnsynchronized];
 3282|      0|    return interval;
 3283|      0|  }  // @synchronized(self)
 3284|      0|}
 3285|       |
 3286|      0|- (NSTimeInterval)nextRetryIntervalUnsynchronized {
 3287|      0|  GTMSessionCheckSynchronized(self);
 3288|      0|
 3289|      0|  NSInteger statusCode = [self statusCodeUnsynchronized];
 3290|      0|  if ((statusCode == 503) && [self hasRetryAfterInterval]) {
 3291|      0|    NSTimeInterval secs = [self retryAfterInterval];
 3292|      0|    return secs;
 3293|      0|  }
 3294|      0|  // The next wait interval is the factor (2.0) times the last interval,
 3295|      0|  // but never less than the minimum interval.
 3296|      0|  NSTimeInterval secs = _lastRetryInterval * _retryFactor;
 3297|      0|  if (_maxRetryInterval > 0) {
 3298|      0|    secs = MIN(secs, _maxRetryInterval);
 3299|      0|  }
 3300|      0|  secs = MAX(secs, _minRetryInterval);
 3301|      0|
 3302|      0|  return secs;
 3303|      0|}
 3304|       |
 3305|      0|- (NSTimer *)retryTimer {
 3306|      0|  @synchronized(self) {
 3307|      0|    GTMSessionMonitorSynchronized(self);
 3308|      0|
 3309|      0|    return _retryTimer;
 3310|      0|  }  // @synchronized(self)
 3311|      0|}
 3312|       |
 3313|      0|- (BOOL)isRetryEnabled {
 3314|      0|  @synchronized(self) {
 3315|      0|    GTMSessionMonitorSynchronized(self);
 3316|      0|
 3317|      0|    return _isRetryEnabled;
 3318|      0|  }  // @synchronized(self)
 3319|      0|}
 3320|       |
 3321|      0|- (BOOL)isRetryEnabledUnsynchronized {
 3322|      0|  GTMSessionCheckSynchronized(self);
 3323|      0|
 3324|      0|  return _isRetryEnabled;
 3325|      0|}
 3326|       |
 3327|      0|- (void)setRetryEnabled:(BOOL)flag {
 3328|      0|
 3329|      0|  @synchronized(self) {
 3330|      0|    GTMSessionMonitorSynchronized(self);
 3331|      0|
 3332|      0|    if (flag && !_isRetryEnabled) {
 3333|      0|      // We defer initializing these until the user calls setRetryEnabled
 3334|      0|      // to avoid using the random number generator if it's not needed.
 3335|      0|      // However, this means min and max intervals for this fetcher are reset
 3336|      0|      // as a side effect of calling setRetryEnabled.
 3337|      0|      //
 3338|      0|      // Make an initial retry interval random between 1.0 and 2.0 seconds
 3339|      0|      _minRetryInterval = InitialMinRetryInterval();
 3340|      0|      _maxRetryInterval = kUnsetMaxRetryInterval;
 3341|      0|      _retryFactor = 2.0;
 3342|      0|      _lastRetryInterval = 0.0;
 3343|      0|    }
 3344|      0|    _isRetryEnabled = flag;
 3345|      0|  }  // @synchronized(self)
 3346|      0|};
 3347|       |
 3348|      0|- (NSTimeInterval)maxRetryInterval {
 3349|      0|  @synchronized(self) {
 3350|      0|    GTMSessionMonitorSynchronized(self);
 3351|      0|
 3352|      0|    return _maxRetryInterval;
 3353|      0|  }  // @synchronized(self)
 3354|      0|}
 3355|       |
 3356|      0|- (void)setMaxRetryInterval:(NSTimeInterval)secs {
 3357|      0|  @synchronized(self) {
 3358|      0|    GTMSessionMonitorSynchronized(self);
 3359|      0|
 3360|      0|    if (secs > 0) {
 3361|      0|      _maxRetryInterval = secs;
 3362|      0|    } else {
 3363|      0|      _maxRetryInterval = kUnsetMaxRetryInterval;
 3364|      0|    }
 3365|      0|  }  // @synchronized(self)
 3366|      0|}
 3367|       |
 3368|      0|- (double)minRetryInterval {
 3369|      0|  @synchronized(self) {
 3370|      0|    GTMSessionMonitorSynchronized(self);
 3371|      0|
 3372|      0|    return _minRetryInterval;
 3373|      0|  }  // @synchronized(self)
 3374|      0|}
 3375|       |
 3376|      0|- (void)setMinRetryInterval:(NSTimeInterval)secs {
 3377|      0|  @synchronized(self) {
 3378|      0|    GTMSessionMonitorSynchronized(self);
 3379|      0|
 3380|      0|    if (secs > 0) {
 3381|      0|      _minRetryInterval = secs;
 3382|      0|    } else {
 3383|      0|      // Set min interval to a random value between 1.0 and 2.0 seconds
 3384|      0|      // so that if multiple clients start retrying at the same time, they'll
 3385|      0|      // repeat at different times and avoid overloading the server
 3386|      0|      _minRetryInterval = InitialMinRetryInterval();
 3387|      0|    }
 3388|      0|  }  // @synchronized(self)
 3389|      0|
 3390|      0|}
 3391|       |
 3392|       |#pragma mark iOS System Completion Handlers
 3393|       |
 3394|       |#if TARGET_OS_IPHONE
 3395|       |static NSMutableDictionary *gSystemCompletionHandlers = nil;
 3396|       |
 3397|      0|- (GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandler {
 3398|      0|  return [[self class] systemCompletionHandlerForSessionIdentifier:_sessionIdentifier];
 3399|      0|}
 3400|       |
 3401|      0|- (void)setSystemCompletionHandler:(GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandler {
 3402|      0|  [[self class] setSystemCompletionHandler:systemCompletionHandler
 3403|      0|                      forSessionIdentifier:_sessionIdentifier];
 3404|      0|}
 3405|       |
 3406|       |+ (void)setSystemCompletionHandler:(GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandler
 3407|      0|              forSessionIdentifier:(NSString *)sessionIdentifier {
 3408|      0|  if (!sessionIdentifier) {
 3409|      0|    NSLog(@"%s with nil identifier", __PRETTY_FUNCTION__);
 3410|      0|    return;
 3411|      0|  }
 3412|      0|
 3413|      0|  @synchronized([GTMSessionFetcher class]) {
 3414|      0|    if (gSystemCompletionHandlers == nil && systemCompletionHandler != nil) {
 3415|      0|      gSystemCompletionHandlers = [[NSMutableDictionary alloc] init];
 3416|      0|    }
 3417|      0|    // Use setValue: to remove the object if completionHandler is nil.
 3418|      0|    [gSystemCompletionHandlers setValue:systemCompletionHandler
 3419|      0|                                 forKey:sessionIdentifier];
 3420|      0|  }
 3421|      0|}
 3422|       |
 3423|      0|+ (GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandlerForSessionIdentifier:(NSString *)sessionIdentifier {
 3424|      0|  if (!sessionIdentifier) {
 3425|      0|    return nil;
 3426|      0|  }
 3427|      0|  @synchronized([GTMSessionFetcher class]) {
 3428|      0|    return [gSystemCompletionHandlers objectForKey:sessionIdentifier];
 3429|      0|  }
 3430|      0|}
 3431|       |#endif  // TARGET_OS_IPHONE
 3432|       |
 3433|       |#pragma mark Getters and Setters
 3434|       |
 3435|       |@synthesize downloadResumeData = _downloadResumeData,
 3436|       |            configuration = _configuration,
 3437|       |            configurationBlock = _configurationBlock,
 3438|       |            sessionTask = _sessionTask,
 3439|       |            wasCreatedFromBackgroundSession = _wasCreatedFromBackgroundSession,
 3440|       |            sessionUserInfo = _sessionUserInfo,
 3441|       |            taskDescription = _taskDescription,
 3442|       |            taskPriority = _taskPriority,
 3443|       |            usingBackgroundSession = _usingBackgroundSession,
 3444|       |            canShareSession = _canShareSession,
 3445|       |            completionHandler = _completionHandler,
 3446|       |            credential = _credential,
 3447|       |            proxyCredential = _proxyCredential,
 3448|       |            bodyData = _bodyData,
 3449|       |            bodyLength = _bodyLength,
 3450|       |            service = _service,
 3451|       |            serviceHost = _serviceHost,
 3452|       |            accumulateDataBlock = _accumulateDataBlock,
 3453|       |            receivedProgressBlock = _receivedProgressBlock,
 3454|       |            downloadProgressBlock = _downloadProgressBlock,
 3455|       |            resumeDataBlock = _resumeDataBlock,
 3456|       |            didReceiveResponseBlock = _didReceiveResponseBlock,
 3457|       |            challengeBlock = _challengeBlock,
 3458|       |            willRedirectBlock = _willRedirectBlock,
 3459|       |            sendProgressBlock = _sendProgressBlock,
 3460|       |            willCacheURLResponseBlock = _willCacheURLResponseBlock,
 3461|       |            retryBlock = _retryBlock,
 3462|       |            retryFactor = _retryFactor,
 3463|       |            allowedInsecureSchemes = _allowedInsecureSchemes,
 3464|       |            allowLocalhostRequest = _allowLocalhostRequest,
 3465|       |            allowInvalidServerCertificates = _allowInvalidServerCertificates,
 3466|       |            cookieStorage = _cookieStorage,
 3467|       |            callbackQueue = _callbackQueue,
 3468|       |            initialBeginFetchDate = _initialBeginFetchDate,
 3469|       |            testBlock = _testBlock,
 3470|       |            testBlockAccumulateDataChunkCount = _testBlockAccumulateDataChunkCount,
 3471|       |            comment = _comment,
 3472|       |            log = _log;
 3473|       |
 3474|       |#if !STRIP_GTM_FETCH_LOGGING
 3475|       |@synthesize redirectedFromURL = _redirectedFromURL,
 3476|       |            logRequestBody = _logRequestBody,
 3477|       |            logResponseBody = _logResponseBody,
 3478|       |            hasLoggedError = _hasLoggedError;
 3479|       |#endif
 3480|       |
 3481|       |#if GTM_BACKGROUND_TASK_FETCHING
 3482|       |@synthesize backgroundTaskIdentifier = _backgroundTaskIdentifier,
 3483|       |            skipBackgroundTask = _skipBackgroundTask;
 3484|       |#endif
 3485|       |
 3486|      0|- (GTM_NULLABLE NSURLRequest *)request {
 3487|      0|  @synchronized(self) {
 3488|      0|    GTMSessionMonitorSynchronized(self);
 3489|      0|
 3490|      0|    return [_request copy];
 3491|      0|  }  // @synchronized(self)
 3492|      0|}
 3493|       |
 3494|      0|- (void)setRequest:(GTM_NULLABLE NSURLRequest *)request {
 3495|      0|  @synchronized(self) {
 3496|      0|    GTMSessionMonitorSynchronized(self);
 3497|      0|
 3498|      0|    if (![self isFetchingUnsynchronized]) {
 3499|      0|      _request = [request mutableCopy];
 3500|      0|    } else {
 3501|      0|      GTMSESSION_ASSERT_DEBUG(0, @"request may not be set after beginFetch has been invoked");
 3502|      0|    }
 3503|      0|  }  // @synchronized(self)
 3504|      0|}
 3505|       |
 3506|      0|- (GTM_NULLABLE NSMutableURLRequest *)mutableRequestForTesting {
 3507|      0|  // Allow tests only to modify the request, useful during retries.
 3508|      0|  return _request;
 3509|      0|}
 3510|       |
 3511|       |// Internal method for updating the request property such as on redirects.
 3512|      0|- (void)updateMutableRequest:(GTM_NULLABLE NSMutableURLRequest *)request {
 3513|      0|  @synchronized(self) {
 3514|      0|    GTMSessionMonitorSynchronized(self);
 3515|      0|
 3516|      0|    _request = request;
 3517|      0|  }  // @synchronized(self)
 3518|      0|}
 3519|       |
 3520|       |// Set a header field value on the request. Header field value changes will not
 3521|       |// affect a fetch after the fetch has begun.
 3522|      0|- (void)setRequestValue:(GTM_NULLABLE NSString *)value forHTTPHeaderField:(NSString *)field {
 3523|      0|  if (![self isFetching]) {
 3524|      0|    [self updateRequestValue:value forHTTPHeaderField:field];
 3525|      0|  } else {
 3526|      0|    GTMSESSION_ASSERT_DEBUG(0, @"request may not be set after beginFetch has been invoked");
 3527|      0|  }
 3528|      0|}
 3529|       |
 3530|       |// Internal method for updating request headers.
 3531|      0|- (void)updateRequestValue:(GTM_NULLABLE NSString *)value forHTTPHeaderField:(NSString *)field {
 3532|      0|  @synchronized(self) {
 3533|      0|    GTMSessionMonitorSynchronized(self);
 3534|      0|
 3535|      0|    [_request setValue:value forHTTPHeaderField:field];
 3536|      0|  }  // @synchronized(self)
 3537|      0|}
 3538|       |
 3539|      0|- (void)setResponse:(GTM_NULLABLE NSURLResponse *)response {
 3540|      0|  @synchronized(self) {
 3541|      0|    GTMSessionMonitorSynchronized(self);
 3542|      0|
 3543|      0|    _response = response;
 3544|      0|  }  // @synchronized(self)
 3545|      0|}
 3546|       |
 3547|      0|- (int64_t)bodyLength {
 3548|      0|  @synchronized(self) {
 3549|      0|    GTMSessionMonitorSynchronized(self);
 3550|      0|
 3551|      0|    if (_bodyLength == NSURLSessionTransferSizeUnknown) {
 3552|      0|      if (_bodyData) {
 3553|      0|        _bodyLength = (int64_t)_bodyData.length;
 3554|      0|      } else if (_bodyFileURL) {
 3555|      0|        NSNumber *fileSizeNum = nil;
 3556|      0|        NSError *fileSizeError = nil;
 3557|      0|        if ([_bodyFileURL getResourceValue:&fileSizeNum
 3558|      0|                                    forKey:NSURLFileSizeKey
 3559|      0|                                     error:&fileSizeError]) {
 3560|      0|          _bodyLength = [fileSizeNum longLongValue];
 3561|      0|        }
 3562|      0|      }
 3563|      0|    }
 3564|      0|    return _bodyLength;
 3565|      0|  }  // @synchronized(self)
 3566|      0|}
 3567|       |
 3568|      0|- (BOOL)useUploadTask {
 3569|      0|  @synchronized(self) {
 3570|      0|    GTMSessionMonitorSynchronized(self);
 3571|      0|
 3572|      0|    return _useUploadTask;
 3573|      0|  }  // @synchronized(self)
 3574|      0|}
 3575|       |
 3576|      0|- (void)setUseUploadTask:(BOOL)flag {
 3577|      0|  @synchronized(self) {
 3578|      0|    GTMSessionMonitorSynchronized(self);
 3579|      0|
 3580|      0|    if (flag != _useUploadTask) {
 3581|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3582|      0|                              @"useUploadTask should not change after beginFetch has been invoked");
 3583|      0|      _useUploadTask = flag;
 3584|      0|    }
 3585|      0|  }  // @synchronized(self)
 3586|      0|}
 3587|       |
 3588|      0|- (GTM_NULLABLE NSURL *)bodyFileURL {
 3589|      0|  @synchronized(self) {
 3590|      0|    GTMSessionMonitorSynchronized(self);
 3591|      0|
 3592|      0|    return _bodyFileURL;
 3593|      0|  }  // @synchronized(self)
 3594|      0|}
 3595|       |
 3596|      0|- (void)setBodyFileURL:(GTM_NULLABLE NSURL *)fileURL {
 3597|      0|  @synchronized(self) {
 3598|      0|    GTMSessionMonitorSynchronized(self);
 3599|      0|
 3600|      0|    // The comparison here is a trivial optimization and forgiveness for any client that
 3601|      0|    // repeatedly sets the property, so it just uses pointer comparison rather than isEqual:.
 3602|      0|    if (fileURL != _bodyFileURL) {
 3603|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3604|      0|                              @"fileURL should not change after beginFetch has been invoked");
 3605|      0|
 3606|      0|      _bodyFileURL = fileURL;
 3607|      0|    }
 3608|      0|  }  // @synchronized(self)
 3609|      0|}
 3610|       |
 3611|      0|- (GTM_NULLABLE GTMSessionFetcherBodyStreamProvider)bodyStreamProvider {
 3612|      0|  @synchronized(self) {
 3613|      0|    GTMSessionMonitorSynchronized(self);
 3614|      0|
 3615|      0|    return _bodyStreamProvider;
 3616|      0|  }  // @synchronized(self)
 3617|      0|}
 3618|       |
 3619|      0|- (void)setBodyStreamProvider:(GTM_NULLABLE GTMSessionFetcherBodyStreamProvider)block {
 3620|      0|  @synchronized(self) {
 3621|      0|    GTMSessionMonitorSynchronized(self);
 3622|      0|
 3623|      0|    GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3624|      0|                            @"stream provider should not change after beginFetch has been invoked");
 3625|      0|
 3626|      0|    _bodyStreamProvider = [block copy];
 3627|      0|  }  // @synchronized(self)
 3628|      0|}
 3629|       |
 3630|      0|- (GTM_NULLABLE id<GTMFetcherAuthorizationProtocol>)authorizer {
 3631|      0|  @synchronized(self) {
 3632|      0|    GTMSessionMonitorSynchronized(self);
 3633|      0|
 3634|      0|    return _authorizer;
 3635|      0|  }  // @synchronized(self)
 3636|      0|}
 3637|       |
 3638|      0|- (void)setAuthorizer:(GTM_NULLABLE id<GTMFetcherAuthorizationProtocol>)authorizer {
 3639|      0|  @synchronized(self) {
 3640|      0|    GTMSessionMonitorSynchronized(self);
 3641|      0|
 3642|      0|    if (authorizer != _authorizer) {
 3643|      0|      if ([self isFetchingUnsynchronized]) {
 3644|      0|        GTMSESSION_ASSERT_DEBUG(0, @"authorizer should not change after beginFetch has been invoked");
 3645|      0|      } else {
 3646|      0|        _authorizer = authorizer;
 3647|      0|      }
 3648|      0|    }
 3649|      0|  }  // @synchronized(self)
 3650|      0|}
 3651|       |
 3652|      0|- (GTM_NULLABLE NSData *)downloadedData {
 3653|      0|  @synchronized(self) {
 3654|      0|    GTMSessionMonitorSynchronized(self);
 3655|      0|
 3656|      0|    return _downloadedData;
 3657|      0|  }  // @synchronized(self)
 3658|      0|}
 3659|       |
 3660|      0|- (void)setDownloadedData:(GTM_NULLABLE NSData *)data {
 3661|      0|  @synchronized(self) {
 3662|      0|    GTMSessionMonitorSynchronized(self);
 3663|      0|
 3664|      0|    _downloadedData = [data mutableCopy];
 3665|      0|  }  // @synchronized(self)
 3666|      0|}
 3667|       |
 3668|      0|- (int64_t)downloadedLength {
 3669|      0|  @synchronized(self) {
 3670|      0|    GTMSessionMonitorSynchronized(self);
 3671|      0|
 3672|      0|    return _downloadedLength;
 3673|      0|  }  // @synchronized(self)
 3674|      0|}
 3675|       |
 3676|      0|- (void)setDownloadedLength:(int64_t)length {
 3677|      0|  @synchronized(self) {
 3678|      0|    GTMSessionMonitorSynchronized(self);
 3679|      0|
 3680|      0|    _downloadedLength = length;
 3681|      0|  }  // @synchronized(self)
 3682|      0|}
 3683|       |
 3684|      0|- (dispatch_queue_t GTM_NONNULL_TYPE)callbackQueue {
 3685|      0|  @synchronized(self) {
 3686|      0|    GTMSessionMonitorSynchronized(self);
 3687|      0|
 3688|      0|    return _callbackQueue;
 3689|      0|  }  // @synchronized(self)
 3690|      0|}
 3691|       |
 3692|      0|- (void)setCallbackQueue:(dispatch_queue_t GTM_NULLABLE_TYPE)queue {
 3693|      0|  @synchronized(self) {
 3694|      0|    GTMSessionMonitorSynchronized(self);
 3695|      0|
 3696|      0|    _callbackQueue = queue ?: dispatch_get_main_queue();
 3697|      0|  }  // @synchronized(self)
 3698|      0|}
 3699|       |
 3700|      0|- (GTM_NULLABLE NSURLSession *)session {
 3701|      0|  @synchronized(self) {
 3702|      0|    GTMSessionMonitorSynchronized(self);
 3703|      0|
 3704|      0|    return _session;
 3705|      0|  }  // @synchronized(self)
 3706|      0|}
 3707|       |
 3708|      0|- (NSInteger)servicePriority {
 3709|      0|  @synchronized(self) {
 3710|      0|    GTMSessionMonitorSynchronized(self);
 3711|      0|
 3712|      0|    return _servicePriority;
 3713|      0|  }  // @synchronized(self)
 3714|      0|}
 3715|       |
 3716|      0|- (void)setServicePriority:(NSInteger)value {
 3717|      0|  @synchronized(self) {
 3718|      0|    GTMSessionMonitorSynchronized(self);
 3719|      0|
 3720|      0|    if (value != _servicePriority) {
 3721|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3722|      0|        @"servicePriority should not change after beginFetch has been invoked");
 3723|      0|
 3724|      0|      _servicePriority = value;
 3725|      0|    }
 3726|      0|  }  // @synchronized(self)
 3727|      0|}
 3728|       |
 3729|       |
 3730|      0|- (void)setSession:(GTM_NULLABLE NSURLSession *)session {
 3731|      0|  @synchronized(self) {
 3732|      0|    GTMSessionMonitorSynchronized(self);
 3733|      0|
 3734|      0|    _session = session;
 3735|      0|  }  // @synchronized(self)
 3736|      0|}
 3737|       |
 3738|      0|- (BOOL)canShareSession {
 3739|      0|  @synchronized(self) {
 3740|      0|    GTMSessionMonitorSynchronized(self);
 3741|      0|
 3742|      0|    return _canShareSession;
 3743|      0|  }  // @synchronized(self)
 3744|      0|}
 3745|       |
 3746|      0|- (void)setCanShareSession:(BOOL)flag {
 3747|      0|  @synchronized(self) {
 3748|      0|    GTMSessionMonitorSynchronized(self);
 3749|      0|
 3750|      0|    _canShareSession = flag;
 3751|      0|  }  // @synchronized(self)
 3752|      0|}
 3753|       |
 3754|      0|- (BOOL)useBackgroundSession {
 3755|      0|  // This reflects if the user requested a background session, not necessarily
 3756|      0|  // if one was created. That is tracked with _usingBackgroundSession.
 3757|      0|  @synchronized(self) {
 3758|      0|    GTMSessionMonitorSynchronized(self);
 3759|      0|
 3760|      0|    return _userRequestedBackgroundSession;
 3761|      0|  }  // @synchronized(self)
 3762|      0|}
 3763|       |
 3764|      0|- (void)setUseBackgroundSession:(BOOL)flag {
 3765|      0|  @synchronized(self) {
 3766|      0|    GTMSessionMonitorSynchronized(self);
 3767|      0|
 3768|      0|    if (flag != _userRequestedBackgroundSession) {
 3769|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3770|      0|          @"useBackgroundSession should not change after beginFetch has been invoked");
 3771|      0|
 3772|      0|      _userRequestedBackgroundSession = flag;
 3773|      0|    }
 3774|      0|  }  // @synchronized(self)
 3775|      0|}
 3776|       |
 3777|      0|- (BOOL)isUsingBackgroundSession {
 3778|      0|  @synchronized(self) {
 3779|      0|    GTMSessionMonitorSynchronized(self);
 3780|      0|
 3781|      0|    return _usingBackgroundSession;
 3782|      0|  }  // @synchronized(self)
 3783|      0|}
 3784|       |
 3785|      0|- (void)setUsingBackgroundSession:(BOOL)flag {
 3786|      0|  @synchronized(self) {
 3787|      0|    GTMSessionMonitorSynchronized(self);
 3788|      0|
 3789|      0|    _usingBackgroundSession = flag;
 3790|      0|  }  // @synchronized(self)
 3791|      0|}
 3792|       |
 3793|      0|- (GTM_NULLABLE NSURLSession *)sessionNeedingInvalidation {
 3794|      0|  @synchronized(self) {
 3795|      0|    GTMSessionMonitorSynchronized(self);
 3796|      0|
 3797|      0|    return _sessionNeedingInvalidation;
 3798|      0|  }  // @synchronized(self)
 3799|      0|}
 3800|       |
 3801|      0|- (void)setSessionNeedingInvalidation:(GTM_NULLABLE NSURLSession *)session {
 3802|      0|  @synchronized(self) {
 3803|      0|    GTMSessionMonitorSynchronized(self);
 3804|      0|
 3805|      0|    _sessionNeedingInvalidation = session;
 3806|      0|  }  // @synchronized(self)
 3807|      0|}
 3808|       |
 3809|      0|- (NSOperationQueue * GTM_NONNULL_TYPE)sessionDelegateQueue {
 3810|      0|  @synchronized(self) {
 3811|      0|    GTMSessionMonitorSynchronized(self);
 3812|      0|
 3813|      0|    return _delegateQueue;
 3814|      0|  }  // @synchronized(self)
 3815|      0|}
 3816|       |
 3817|      0|- (void)setSessionDelegateQueue:(NSOperationQueue * GTM_NULLABLE_TYPE)queue {
 3818|      0|  @synchronized(self) {
 3819|      0|    GTMSessionMonitorSynchronized(self);
 3820|      0|
 3821|      0|    if (queue != _delegateQueue) {
 3822|      0|      if ([self isFetchingUnsynchronized]) {
 3823|      0|        GTMSESSION_ASSERT_DEBUG(0, @"sessionDelegateQueue should not change after fetch begins");
 3824|      0|      } else {
 3825|      0|        _delegateQueue = queue ?: [NSOperationQueue mainQueue];
 3826|      0|      }
 3827|      0|    }
 3828|      0|  }  // @synchronized(self)
 3829|      0|}
 3830|       |
 3831|      0|- (BOOL)userStoppedFetching {
 3832|      0|  @synchronized(self) {
 3833|      0|    GTMSessionMonitorSynchronized(self);
 3834|      0|
 3835|      0|    return _userStoppedFetching;
 3836|      0|  }  // @synchronized(self)
 3837|      0|}
 3838|       |
 3839|      0|- (GTM_NULLABLE id)userData {
 3840|      0|  @synchronized(self) {
 3841|      0|    GTMSessionMonitorSynchronized(self);
 3842|      0|
 3843|      0|    return _userData;
 3844|      0|  }  // @synchronized(self)
 3845|      0|}
 3846|       |
 3847|      0|- (void)setUserData:(GTM_NULLABLE id)theObj {
 3848|      0|  @synchronized(self) {
 3849|      0|    GTMSessionMonitorSynchronized(self);
 3850|      0|
 3851|      0|    _userData = theObj;
 3852|      0|  }  // @synchronized(self)
 3853|      0|}
 3854|       |
 3855|      0|- (GTM_NULLABLE NSURL *)destinationFileURL {
 3856|      0|  @synchronized(self) {
 3857|      0|    GTMSessionMonitorSynchronized(self);
 3858|      0|
 3859|      0|    return _destinationFileURL;
 3860|      0|  }  // @synchronized(self)
 3861|      0|}
 3862|       |
 3863|      0|- (void)setDestinationFileURL:(GTM_NULLABLE NSURL *)destinationFileURL {
 3864|      0|  @synchronized(self) {
 3865|      0|    GTMSessionMonitorSynchronized(self);
 3866|      0|
 3867|      0|    if (((_destinationFileURL == nil) && (destinationFileURL == nil)) ||
 3868|      0|        [_destinationFileURL isEqual:destinationFileURL]) {
 3869|      0|      return;
 3870|      0|    }
 3871|      0|    if (_sessionIdentifier) {
 3872|      0|      // This is something we don't expect to happen in production.
 3873|      0|      // However if it ever happen, leave a system log.
 3874|      0|      NSLog(@"%@: Destination File URL changed from (%@) to (%@) after session identifier has "
 3875|      0|            @"been created.",
 3876|      0|            [self class], _destinationFileURL, destinationFileURL);
 3877|      0|#if DEBUG
 3878|      0|      // On both the simulator and devices, the path can change to the download file, but the name
 3879|      0|      // shouldn't change. Technically, this isn't supported in the fetcher, but the change of
 3880|      0|      // URL is expected to happen only across development runs through Xcode.
 3881|      0|      NSString *oldFilename = [_destinationFileURL lastPathComponent];
 3882|      0|      NSString *newFilename = [destinationFileURL lastPathComponent];
 3883|      0|      #pragma unused(oldFilename)
 3884|      0|      #pragma unused(newFilename)
 3885|      0|      GTMSESSION_ASSERT_DEBUG([oldFilename isEqualToString:newFilename],
 3886|      0|          @"Destination File URL cannot be changed after session identifier has been created");
 3887|      0|#endif
 3888|      0|    }
 3889|      0|    _destinationFileURL = destinationFileURL;
 3890|      0|  }  // @synchronized(self)
 3891|      0|}
 3892|       |
 3893|      0|- (void)setProperties:(GTM_NULLABLE NSDictionary *)dict {
 3894|      0|  @synchronized(self) {
 3895|      0|    GTMSessionMonitorSynchronized(self);
 3896|      0|
 3897|      0|    _properties = [dict mutableCopy];
 3898|      0|  }  // @synchronized(self)
 3899|      0|}
 3900|       |
 3901|      0|- (GTM_NULLABLE NSDictionary *)properties {
 3902|      0|  @synchronized(self) {
 3903|      0|    GTMSessionMonitorSynchronized(self);
 3904|      0|
 3905|      0|    return _properties;
 3906|      0|  }  // @synchronized(self)
 3907|      0|}
 3908|       |
 3909|      0|- (void)setProperty:(GTM_NULLABLE id)obj forKey:(NSString *)key {
 3910|      0|  @synchronized(self) {
 3911|      0|    GTMSessionMonitorSynchronized(self);
 3912|      0|
 3913|      0|    if (_properties == nil && obj != nil) {
 3914|      0|      _properties = [[NSMutableDictionary alloc] init];
 3915|      0|    }
 3916|      0|    [_properties setValue:obj forKey:key];
 3917|      0|  }  // @synchronized(self)
 3918|      0|}
 3919|       |
 3920|      0|- (GTM_NULLABLE id)propertyForKey:(NSString *)key {
 3921|      0|  @synchronized(self) {
 3922|      0|    GTMSessionMonitorSynchronized(self);
 3923|      0|
 3924|      0|    return [_properties objectForKey:key];
 3925|      0|  }  // @synchronized(self)
 3926|      0|}
 3927|       |
 3928|      0|- (void)addPropertiesFromDictionary:(NSDictionary *)dict {
 3929|      0|  @synchronized(self) {
 3930|      0|    GTMSessionMonitorSynchronized(self);
 3931|      0|
 3932|      0|    if (_properties == nil && dict != nil) {
 3933|      0|      [self setProperties:[dict mutableCopy]];
 3934|      0|    } else {
 3935|      0|      [_properties addEntriesFromDictionary:dict];
 3936|      0|    }
 3937|      0|  }  // @synchronized(self)
 3938|      0|}
 3939|       |
 3940|      0|- (void)setCommentWithFormat:(id)format, ... {
 3941|      0|#if !STRIP_GTM_FETCH_LOGGING
 3942|      0|  NSString *result = format;
 3943|      0|  if (format) {
 3944|      0|    va_list argList;
 3945|      0|    va_start(argList, format);
 3946|      0|
 3947|      0|    result = [[NSString alloc] initWithFormat:format
 3948|      0|                                    arguments:argList];
 3949|      0|    va_end(argList);
 3950|      0|  }
 3951|      0|  [self setComment:result];
 3952|      0|#endif
 3953|      0|}
 3954|       |
 3955|       |#if !STRIP_GTM_FETCH_LOGGING
 3956|      0|- (NSData *)loggedStreamData {
 3957|      0|  return _loggedStreamData;
 3958|      0|}
 3959|       |
 3960|      0|- (void)appendLoggedStreamData:dataToAdd {
 3961|      0|  if (!_loggedStreamData) {
 3962|      0|    _loggedStreamData = [NSMutableData data];
 3963|      0|  }
 3964|      0|  [_loggedStreamData appendData:dataToAdd];
 3965|      0|}
 3966|       |
 3967|      0|- (void)clearLoggedStreamData {
 3968|      0|  _loggedStreamData = nil;
 3969|      0|}
 3970|       |
 3971|      0|- (void)setDeferResponseBodyLogging:(BOOL)deferResponseBodyLogging {
 3972|      0|  @synchronized(self) {
 3973|      0|    GTMSessionMonitorSynchronized(self);
 3974|      0|
 3975|      0|    if (deferResponseBodyLogging != _deferResponseBodyLogging) {
 3976|      0|      _deferResponseBodyLogging = deferResponseBodyLogging;
 3977|      0|      if (!deferResponseBodyLogging && !self.hasLoggedError) {
 3978|      0|        [_delegateQueue addOperationWithBlock:^{
 3979|      0|          [self logNowWithError:nil];
 3980|      0|        }];
 3981|      0|      }
 3982|      0|    }
 3983|      0|  }  // @synchronized(self)
 3984|      0|}
 3985|       |
 3986|      0|- (BOOL)deferResponseBodyLogging {
 3987|      0|  @synchronized(self) {
 3988|      0|    GTMSessionMonitorSynchronized(self);
 3989|      0|
 3990|      0|    return _deferResponseBodyLogging;
 3991|      0|  }  // @synchronized(self)
 3992|      0|}
 3993|       |
 3994|       |#else
 3995|       |+ (void)setLoggingEnabled:(BOOL)flag {
 3996|       |}
 3997|       |
 3998|       |+ (BOOL)isLoggingEnabled {
 3999|       |  return NO;
 4000|       |}
 4001|       |#endif // STRIP_GTM_FETCH_LOGGING
 4002|       |
 4003|       |@end
 4004|       |
 4005|       |@implementation GTMSessionFetcher (BackwardsCompatibilityOnly)
 4006|       |
 4007|      0|- (void)setCookieStorageMethod:(NSInteger)method {
 4008|      0|  // For backwards compatibility with the old fetcher, we'll support the old constants.
 4009|      0|  //
 4010|      0|  // Clients using the GTMSessionFetcher class should set the cookie storage explicitly
 4011|      0|  // themselves.
 4012|      0|  NSHTTPCookieStorage *storage = nil;
 4013|      0|  switch(method) {
 4014|      0|    case 0:  // kGTMHTTPFetcherCookieStorageMethodStatic
 4015|      0|             // nil storage will use [[self class] staticCookieStorage] when the fetch begins.
 4016|      0|      break;
 4017|      0|    case 1:  // kGTMHTTPFetcherCookieStorageMethodFetchHistory
 4018|      0|             // Do nothing; use whatever was set by the fetcher service.
 4019|      0|      return;
 4020|      0|    case 2:  // kGTMHTTPFetcherCookieStorageMethodSystemDefault
 4021|      0|      storage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
 4022|      0|      break;
 4023|      0|    case 3:  // kGTMHTTPFetcherCookieStorageMethodNone
 4024|      0|             // Create temporary storage for this fetcher only.
 4025|      0|      storage = [[GTMSessionCookieStorage alloc] init];
 4026|      0|      break;
 4027|      0|    default:
 4028|      0|      GTMSESSION_ASSERT_DEBUG(0, @"Invalid cookie storage method: %d", (int)method);
 4029|      0|  }
 4030|      0|  self.cookieStorage = storage;
 4031|      0|}
 4032|       |
 4033|       |@end
 4034|       |
 4035|       |@implementation GTMSessionCookieStorage {
 4036|       |  NSMutableArray *_cookies;
 4037|       |  NSHTTPCookieAcceptPolicy _policy;
 4038|       |}
 4039|       |
 4040|      0|- (id)init {
 4041|      0|  self = [super init];
 4042|      0|  if (self != nil) {
 4043|      0|    _cookies = [[NSMutableArray alloc] init];
 4044|      0|  }
 4045|      0|  return self;
 4046|      0|}
 4047|       |
 4048|      0|- (GTM_NULLABLE NSArray *)cookies {
 4049|      0|  @synchronized(self) {
 4050|      0|    GTMSessionMonitorSynchronized(self);
 4051|      0|
 4052|      0|    return [_cookies copy];
 4053|      0|  }  // @synchronized(self)
 4054|      0|}
 4055|       |
 4056|      0|- (void)setCookie:(NSHTTPCookie *)cookie {
 4057|      0|  if (!cookie) return;
 4058|      0|  if (_policy == NSHTTPCookieAcceptPolicyNever) return;
 4059|      0|
 4060|      0|  @synchronized(self) {
 4061|      0|    GTMSessionMonitorSynchronized(self);
 4062|      0|
 4063|      0|    [self internalSetCookie:cookie];
 4064|      0|  }  // @synchronized(self)
 4065|      0|}
 4066|       |
 4067|       |// Note: this should only be called from inside a @synchronized(self) block.
 4068|      0|- (void)internalSetCookie:(NSHTTPCookie *)newCookie {
 4069|      0|  GTMSessionCheckSynchronized(self);
 4070|      0|
 4071|      0|  if (_policy == NSHTTPCookieAcceptPolicyNever) return;
 4072|      0|
 4073|      0|  BOOL isValidCookie = (newCookie.name.length > 0
 4074|      0|                        && newCookie.domain.length > 0
 4075|      0|                        && newCookie.path.length > 0);
 4076|      0|  GTMSESSION_ASSERT_DEBUG(isValidCookie, @"invalid cookie: %@", newCookie);
 4077|      0|
 4078|      0|  if (isValidCookie) {
 4079|      0|    // Remove the cookie if it's currently in the array.
 4080|      0|    NSHTTPCookie *oldCookie = [self cookieMatchingCookie:newCookie];
 4081|      0|    if (oldCookie) {
 4082|      0|      [_cookies removeObjectIdenticalTo:oldCookie];
 4083|      0|    }
 4084|      0|
 4085|      0|    if (![[self class] hasCookieExpired:newCookie]) {
 4086|      0|      [_cookies addObject:newCookie];
 4087|      0|    }
 4088|      0|  }
 4089|      0|}
 4090|       |
 4091|       |// Add all cookies in the new cookie array to the storage,
 4092|       |// replacing stored cookies as appropriate.
 4093|       |//
 4094|       |// Side effect: removes expired cookies from the storage array.
 4095|      0|- (void)setCookies:(GTM_NULLABLE NSArray *)newCookies {
 4096|      0|  @synchronized(self) {
 4097|      0|    GTMSessionMonitorSynchronized(self);
 4098|      0|
 4099|      0|    [self removeExpiredCookies];
 4100|      0|
 4101|      0|    for (NSHTTPCookie *newCookie in newCookies) {
 4102|      0|      [self internalSetCookie:newCookie];
 4103|      0|    }
 4104|      0|  }  // @synchronized(self)
 4105|      0|}
 4106|       |
 4107|      0|- (void)setCookies:(NSArray *)cookies forURL:(GTM_NULLABLE NSURL *)URL mainDocumentURL:(GTM_NULLABLE NSURL *)mainDocumentURL {
 4108|      0|  @synchronized(self) {
 4109|      0|    GTMSessionMonitorSynchronized(self);
 4110|      0|
 4111|      0|    if (_policy == NSHTTPCookieAcceptPolicyNever) {
 4112|      0|      return;
 4113|      0|    }
 4114|      0|
 4115|      0|    if (_policy == NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain) {
 4116|      0|      NSString *mainHost = mainDocumentURL.host;
 4117|      0|      NSString *associatedHost = URL.host;
 4118|      0|      if (!mainHost || ![associatedHost hasSuffix:mainHost]) {
 4119|      0|        return;
 4120|      0|      }
 4121|      0|    }
 4122|      0|  }  // @synchronized(self)
 4123|      0|  [self setCookies:cookies];
 4124|      0|}
 4125|       |
 4126|      0|- (void)deleteCookie:(NSHTTPCookie *)cookie {
 4127|      0|  if (!cookie) return;
 4128|      0|
 4129|      0|  @synchronized(self) {
 4130|      0|    GTMSessionMonitorSynchronized(self);
 4131|      0|
 4132|      0|    NSHTTPCookie *foundCookie = [self cookieMatchingCookie:cookie];
 4133|      0|    if (foundCookie) {
 4134|      0|      [_cookies removeObjectIdenticalTo:foundCookie];
 4135|      0|    }
 4136|      0|  }  // @synchronized(self)
 4137|      0|}
 4138|       |
 4139|       |// Retrieve all cookies appropriate for the given URL, considering
 4140|       |// domain, path, cookie name, expiration, security setting.
 4141|       |// Side effect: removed expired cookies from the storage array.
 4142|      0|- (GTM_NULLABLE NSArray *)cookiesForURL:(NSURL *)theURL {
 4143|      0|  NSMutableArray *foundCookies = nil;
 4144|      0|
 4145|      0|  @synchronized(self) {
 4146|      0|    GTMSessionMonitorSynchronized(self);
 4147|      0|
 4148|      0|    [self removeExpiredCookies];
 4149|      0|
 4150|      0|    // We'll prepend "." to the desired domain, since we want the
 4151|      0|    // actual domain "nytimes.com" to still match the cookie domain
 4152|      0|    // ".nytimes.com" when we check it below with hasSuffix.
 4153|      0|    NSString *host = theURL.host.lowercaseString;
 4154|      0|    NSString *path = theURL.path;
 4155|      0|    NSString *scheme = [theURL scheme];
 4156|      0|
 4157|      0|    NSString *requestingDomain = nil;
 4158|      0|    BOOL isLocalhostRetrieval = NO;
 4159|      0|
 4160|      0|    if (IsLocalhost(host)) {
 4161|      0|      isLocalhostRetrieval = YES;
 4162|      0|    } else {
 4163|      0|      if (host.length > 0) {
 4164|      0|        requestingDomain = [@"." stringByAppendingString:host];
 4165|      0|      }
 4166|      0|    }
 4167|      0|
 4168|      0|    for (NSHTTPCookie *storedCookie in _cookies) {
 4169|      0|      NSString *cookieDomain = storedCookie.domain.lowercaseString;
 4170|      0|      NSString *cookiePath = storedCookie.path;
 4171|      0|      BOOL cookieIsSecure = [storedCookie isSecure];
 4172|      0|
 4173|      0|      BOOL isDomainOK;
 4174|      0|
 4175|      0|      if (isLocalhostRetrieval) {
 4176|      0|        // Prior to 10.5.6, the domain stored into NSHTTPCookies for localhost
 4177|      0|        // is "localhost.local"
 4178|      0|        isDomainOK = (IsLocalhost(cookieDomain)
 4179|      0|                      || [cookieDomain isEqual:@"localhost.local"]);
 4180|      0|      } else {
 4181|      0|        // Ensure we're matching exact domain names. We prepended a dot to the
 4182|      0|        // requesting domain, so we can also prepend one here if needed before
 4183|      0|        // checking if the request contains the cookie domain.
 4184|      0|        if (![cookieDomain hasPrefix:@"."]) {
 4185|      0|          cookieDomain = [@"." stringByAppendingString:cookieDomain];
 4186|      0|        }
 4187|      0|        isDomainOK = [requestingDomain hasSuffix:cookieDomain];
 4188|      0|      }
 4189|      0|
 4190|      0|      BOOL isPathOK = [cookiePath isEqual:@"/"] || [path hasPrefix:cookiePath];
 4191|      0|      BOOL isSecureOK = (!cookieIsSecure
 4192|      0|                         || [scheme caseInsensitiveCompare:@"https"] == NSOrderedSame);
 4193|      0|
 4194|      0|      if (isDomainOK && isPathOK && isSecureOK) {
 4195|      0|        if (foundCookies == nil) {
 4196|      0|          foundCookies = [NSMutableArray array];
 4197|      0|        }
 4198|      0|        [foundCookies addObject:storedCookie];
 4199|      0|      }
 4200|      0|    }
 4201|      0|  }  // @synchronized(self)
 4202|      0|  return foundCookies;
 4203|      0|}
 4204|       |
 4205|       |// Override methods from the NSHTTPCookieStorage (NSURLSessionTaskAdditions) category.
 4206|      0|- (void)storeCookies:(NSArray *)cookies forTask:(NSURLSessionTask *)task {
 4207|      0|  NSURLRequest *currentRequest = task.currentRequest;
 4208|      0|  [self setCookies:cookies forURL:currentRequest.URL mainDocumentURL:nil];
 4209|      0|}
 4210|       |
 4211|       |- (void)getCookiesForTask:(NSURLSessionTask *)task
 4212|      0|        completionHandler:(void (^)(GTM_NSArrayOf(NSHTTPCookie *) *))completionHandler {
 4213|      0|  if (completionHandler) {
 4214|      0|    NSURLRequest *currentRequest = task.currentRequest;
 4215|      0|    NSURL *currentRequestURL = currentRequest.URL;
 4216|      0|    NSArray *cookies = [self cookiesForURL:currentRequestURL];
 4217|      0|    completionHandler(cookies);
 4218|      0|  }
 4219|      0|}
 4220|       |
 4221|       |// Return a cookie from the array with the same name, domain, and path as the
 4222|       |// given cookie, or else return nil if none found.
 4223|       |//
 4224|       |// Both the cookie being tested and all cookies in the storage array should
 4225|       |// be valid (non-nil name, domains, paths).
 4226|       |//
 4227|       |// Note: this should only be called from inside a @synchronized(self) block
 4228|      0|- (GTM_NULLABLE NSHTTPCookie *)cookieMatchingCookie:(NSHTTPCookie *)cookie {
 4229|      0|  GTMSessionCheckSynchronized(self);
 4230|      0|
 4231|      0|  NSString *name = cookie.name;
 4232|      0|  NSString *domain = cookie.domain;
 4233|      0|  NSString *path = cookie.path;
 4234|      0|
 4235|      0|  GTMSESSION_ASSERT_DEBUG(name && domain && path,
 4236|      0|                          @"Invalid stored cookie (name:%@ domain:%@ path:%@)", name, domain, path);
 4237|      0|
 4238|      0|  for (NSHTTPCookie *storedCookie in _cookies) {
 4239|      0|    if ([storedCookie.name isEqual:name]
 4240|      0|        && [storedCookie.domain isEqual:domain]
 4241|      0|        && [storedCookie.path isEqual:path]) {
 4242|      0|      return storedCookie;
 4243|      0|    }
 4244|      0|  }
 4245|      0|  return nil;
 4246|      0|}
 4247|       |
 4248|       |// Internal routine to remove any expired cookies from the array, excluding
 4249|       |// cookies with nil expirations.
 4250|       |//
 4251|       |// Note: this should only be called from inside a @synchronized(self) block
 4252|      0|- (void)removeExpiredCookies {
 4253|      0|  GTMSessionCheckSynchronized(self);
 4254|      0|
 4255|      0|  // Count backwards since we're deleting items from the array
 4256|      0|  for (NSInteger idx = (NSInteger)_cookies.count - 1; idx >= 0; idx--) {
 4257|      0|    NSHTTPCookie *storedCookie = [_cookies objectAtIndex:(NSUInteger)idx];
 4258|      0|    if ([[self class] hasCookieExpired:storedCookie]) {
 4259|      0|      [_cookies removeObjectAtIndex:(NSUInteger)idx];
 4260|      0|    }
 4261|      0|  }
 4262|      0|}
 4263|       |
 4264|      0|+ (BOOL)hasCookieExpired:(NSHTTPCookie *)cookie {
 4265|      0|  NSDate *expiresDate = [cookie expiresDate];
 4266|      0|  if (expiresDate == nil) {
 4267|      0|    // Cookies seem to have a Expires property even when the expiresDate method returns nil.
 4268|      0|    id expiresVal = [[cookie properties] objectForKey:NSHTTPCookieExpires];
 4269|      0|    if ([expiresVal isKindOfClass:[NSDate class]]) {
 4270|      0|      expiresDate = expiresVal;
 4271|      0|    }
 4272|      0|  }
 4273|      0|  BOOL hasExpired = (expiresDate != nil && [expiresDate timeIntervalSinceNow] < 0);
 4274|      0|  return hasExpired;
 4275|      0|}
 4276|       |
 4277|      0|- (void)removeAllCookies {
 4278|      0|  @synchronized(self) {
 4279|      0|    GTMSessionMonitorSynchronized(self);
 4280|      0|
 4281|      0|    [_cookies removeAllObjects];
 4282|      0|  }  // @synchronized(self)
 4283|      0|}
 4284|       |
 4285|      0|- (NSHTTPCookieAcceptPolicy)cookieAcceptPolicy {
 4286|      0|  @synchronized(self) {
 4287|      0|    GTMSessionMonitorSynchronized(self);
 4288|      0|
 4289|      0|    return _policy;
 4290|      0|  }  // @synchronized(self)
 4291|      0|}
 4292|       |
 4293|      0|- (void)setCookieAcceptPolicy:(NSHTTPCookieAcceptPolicy)cookieAcceptPolicy {
 4294|      0|  @synchronized(self) {
 4295|      0|    GTMSessionMonitorSynchronized(self);
 4296|      0|
 4297|      0|    _policy = cookieAcceptPolicy;
 4298|      0|  }  // @synchronized(self)
 4299|      0|}
 4300|       |
 4301|       |@end
 4302|       |
 4303|      0|void GTMSessionFetcherAssertValidSelector(id GTM_NULLABLE_TYPE obj, SEL GTM_NULLABLE_TYPE sel, ...) {
 4304|      0|  // Verify that the object's selector is implemented with the proper
 4305|      0|  // number and type of arguments
 4306|      0|#if DEBUG
 4307|      0|  va_list argList;
 4308|      0|  va_start(argList, sel);
 4309|      0|
 4310|      0|  if (obj && sel) {
 4311|      0|    // Check that the selector is implemented
 4312|      0|    if (![obj respondsToSelector:sel]) {
 4313|      0|      NSLog(@"\"%@\" selector \"%@\" is unimplemented or misnamed",
 4314|      0|                             NSStringFromClass([(id)obj class]),
 4315|      0|                             NSStringFromSelector((SEL)sel));
 4316|      0|      NSCAssert(0, @"callback selector unimplemented or misnamed");
 4317|      0|    } else {
 4318|      0|      const char *expectedArgType;
 4319|      0|      unsigned int argCount = 2; // skip self and _cmd
 4320|      0|      NSMethodSignature *sig = [obj methodSignatureForSelector:sel];
 4321|      0|
 4322|      0|      // Check that each expected argument is present and of the correct type
 4323|      0|      while ((expectedArgType = va_arg(argList, const char*)) != 0) {
 4324|      0|
 4325|      0|        if ([sig numberOfArguments] > argCount) {
 4326|      0|          const char *foundArgType = [sig getArgumentTypeAtIndex:argCount];
 4327|      0|
 4328|      0|          if (0 != strncmp(foundArgType, expectedArgType, strlen(expectedArgType))) {
 4329|      0|            NSLog(@"\"%@\" selector \"%@\" argument %d should be type %s",
 4330|      0|                  NSStringFromClass([(id)obj class]),
 4331|      0|                  NSStringFromSelector((SEL)sel), (argCount - 2), expectedArgType);
 4332|      0|            NSCAssert(0, @"callback selector argument type mistake");
 4333|      0|          }
 4334|      0|        }
 4335|      0|        argCount++;
 4336|      0|      }
 4337|      0|
 4338|      0|      // Check that the proper number of arguments are present in the selector
 4339|      0|      if (argCount != [sig numberOfArguments]) {
 4340|      0|        NSLog(@"\"%@\" selector \"%@\" should have %d arguments",
 4341|      0|              NSStringFromClass([(id)obj class]),
 4342|      0|              NSStringFromSelector((SEL)sel), (argCount - 2));
 4343|      0|        NSCAssert(0, @"callback selector arguments incorrect");
 4344|      0|      }
 4345|      0|    }
 4346|      0|  }
 4347|      0|
 4348|      0|  va_end(argList);
 4349|      0|#endif
 4350|      0|}
 4351|       |
 4352|      0|NSString *GTMFetcherCleanedUserAgentString(NSString *str) {
 4353|      0|  // Reference http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html
 4354|      0|  // and http://www-archive.mozilla.org/build/user-agent-strings.html
 4355|      0|
 4356|      0|  if (str == nil) return @"";
 4357|      0|
 4358|      0|  NSMutableString *result = [NSMutableString stringWithString:str];
 4359|      0|
 4360|      0|  // Replace spaces and commas with underscores
 4361|      0|  [result replaceOccurrencesOfString:@" "
 4362|      0|                          withString:@"_"
 4363|      0|                             options:0
 4364|      0|                               range:NSMakeRange(0, result.length)];
 4365|      0|  [result replaceOccurrencesOfString:@","
 4366|      0|                          withString:@"_"
 4367|      0|                             options:0
 4368|      0|                               range:NSMakeRange(0, result.length)];
 4369|      0|
 4370|      0|  // Delete http token separators and remaining whitespace
 4371|      0|  static NSCharacterSet *charsToDelete = nil;
 4372|      0|  if (charsToDelete == nil) {
 4373|      0|    // Make a set of unwanted characters
 4374|      0|    NSString *const kSeparators = @"()<>@;:\\\"/[]?={}";
 4375|      0|
 4376|      0|    NSMutableCharacterSet *mutableChars =
 4377|      0|        [[NSCharacterSet whitespaceAndNewlineCharacterSet] mutableCopy];
 4378|      0|    [mutableChars addCharactersInString:kSeparators];
 4379|      0|    charsToDelete = [mutableChars copy]; // hang on to an immutable copy
 4380|      0|  }
 4381|      0|
 4382|      0|  while (1) {
 4383|      0|    NSRange separatorRange = [result rangeOfCharacterFromSet:charsToDelete];
 4384|      0|    if (separatorRange.location == NSNotFound) break;
 4385|      0|
 4386|      0|    [result deleteCharactersInRange:separatorRange];
 4387|      0|  };
 4388|      0|
 4389|      0|  return result;
 4390|      0|}
 4391|       |
 4392|      0|NSString *GTMFetcherSystemVersionString(void) {
 4393|      0|  static NSString *sSavedSystemString;
 4394|      0|
 4395|      0|  static dispatch_once_t onceToken;
 4396|      0|  dispatch_once(&onceToken, ^{
 4397|      0|    // The Xcode 8 SDKs finally cleaned up this mess by providing TARGET_OS_OSX
 4398|      0|    // and TARGET_OS_IOS, but to build with older SDKs, those don't exist and
 4399|      0|    // instead one has to rely on TARGET_OS_MAC (which is true for iOS, watchOS,
 4400|      0|    // and tvOS) and TARGET_OS_IPHONE (which is true for iOS, watchOS, tvOS). So
 4401|      0|    // one has to order these carefully so you pick off the specific things
 4402|      0|    // first.
 4403|      0|    // If the code can ever assume Xcode 8 or higher (even when building for
 4404|      0|    // older OSes), then
 4405|      0|    //   TARGET_OS_MAC -> TARGET_OS_OSX
 4406|      0|    //   TARGET_OS_IPHONE -> TARGET_OS_IOS
 4407|      0|    //   TARGET_IPHONE_SIMULATOR -> TARGET_OS_SIMULATOR
 4408|       |#if TARGET_OS_WATCH
 4409|       |    // watchOS - WKInterfaceDevice
 4410|       |
 4411|       |    WKInterfaceDevice *currentDevice = [WKInterfaceDevice currentDevice];
 4412|       |
 4413|       |    NSString *rawModel = [currentDevice model];
 4414|       |    NSString *model = GTMFetcherCleanedUserAgentString(rawModel);
 4415|       |
 4416|       |    NSString *systemVersion = [currentDevice systemVersion];
 4417|       |
 4418|       |#if TARGET_OS_SIMULATOR
 4419|       |    NSString *hardwareModel = @"sim";
 4420|       |#else
 4421|       |    NSString *hardwareModel;
 4422|       |    struct utsname unameRecord;
 4423|       |    if (uname(&unameRecord) == 0) {
 4424|       |      NSString *machineName = @(unameRecord.machine);
 4425|       |      hardwareModel = GTMFetcherCleanedUserAgentString(machineName);
 4426|       |    }
 4427|       |    if (hardwareModel.length == 0) {
 4428|       |      hardwareModel = @"unk";
 4429|       |    }
 4430|       |#endif
 4431|       |
 4432|       |    sSavedSystemString = [[NSString alloc] initWithFormat:@"%@/%@ hw/%@",
 4433|       |                          model, systemVersion, hardwareModel];
 4434|       |    // Example:  Apple_Watch/3.0 hw/Watch1_2
 4435|       |#elif TARGET_OS_TV || TARGET_OS_IPHONE
 4436|       |    // iOS and tvOS have UIDevice, use that.
 4437|      0|    UIDevice *currentDevice = [UIDevice currentDevice];
 4438|      0|
 4439|      0|    NSString *rawModel = [currentDevice model];
 4440|      0|    NSString *model = GTMFetcherCleanedUserAgentString(rawModel);
 4441|      0|
 4442|      0|    NSString *systemVersion = [currentDevice systemVersion];
 4443|      0|
 4444|      0|#if TARGET_IPHONE_SIMULATOR || TARGET_OS_SIMULATOR
 4445|      0|    NSString *hardwareModel = @"sim";
 4446|       |#else
 4447|       |    NSString *hardwareModel;
 4448|       |    struct utsname unameRecord;
 4449|       |    if (uname(&unameRecord) == 0) {
 4450|       |      NSString *machineName = @(unameRecord.machine);
 4451|       |      hardwareModel = GTMFetcherCleanedUserAgentString(machineName);
 4452|       |    }
 4453|       |    if (hardwareModel.length == 0) {
 4454|       |      hardwareModel = @"unk";
 4455|       |    }
 4456|       |#endif
 4457|       |
 4458|      0|    sSavedSystemString = [[NSString alloc] initWithFormat:@"%@/%@ hw/%@",
 4459|      0|                          model, systemVersion, hardwareModel];
 4460|      0|    // Example:  iPod_Touch/2.2 hw/iPod1_1
 4461|      0|    // Example:  Apple_TV/9.2 hw/AppleTV5,3
 4462|       |#elif TARGET_OS_MAC
 4463|       |    // Mac build
 4464|       |    NSProcessInfo *procInfo = [NSProcessInfo processInfo];
 4465|       |#if !defined(MAC_OS_X_VERSION_10_10)
 4466|       |    BOOL hasOperatingSystemVersion = NO;
 4467|       |#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10
 4468|       |    BOOL hasOperatingSystemVersion =
 4469|       |        [procInfo respondsToSelector:@selector(operatingSystemVersion)];
 4470|       |#else
 4471|       |    BOOL hasOperatingSystemVersion = YES;
 4472|       |#endif
 4473|       |    NSString *versString;
 4474|       |    if (hasOperatingSystemVersion) {
 4475|       |#if defined(MAC_OS_X_VERSION_10_10)
 4476|       |      // A reference to NSOperatingSystemVersion requires the 10.10 SDK.
 4477|       |#pragma clang diagnostic push
 4478|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
 4479|       |// Disable unguarded availability warning as we can't use the @availability macro until we require
 4480|       |// all clients to build with Xcode 9 or above.
 4481|       |      NSOperatingSystemVersion version = procInfo.operatingSystemVersion;
 4482|       |#pragma clang diagnostic pop
 4483|       |      versString = [NSString stringWithFormat:@"%ld.%ld.%ld",
 4484|       |                    (long)version.majorVersion, (long)version.minorVersion,
 4485|       |                    (long)version.patchVersion];
 4486|       |#else
 4487|       |#pragma unused(procInfo)
 4488|       |#endif
 4489|       |    } else {
 4490|       |      // With Gestalt inexplicably deprecated in 10.8, we're reduced to reading
 4491|       |      // the system plist file.
 4492|       |      NSString *const kPath = @"/System/Library/CoreServices/SystemVersion.plist";
 4493|       |      NSDictionary *plist = [NSDictionary dictionaryWithContentsOfFile:kPath];
 4494|       |      versString = [plist objectForKey:@"ProductVersion"];
 4495|       |      if (versString.length == 0) {
 4496|       |        versString = @"10.?.?";
 4497|       |      }
 4498|       |    }
 4499|       |
 4500|       |    sSavedSystemString = [[NSString alloc] initWithFormat:@"MacOSX/%@", versString];
 4501|       |#elif defined(_SYS_UTSNAME_H)
 4502|       |    // Foundation-only build
 4503|       |    struct utsname unameRecord;
 4504|       |    uname(&unameRecord);
 4505|       |
 4506|       |    sSavedSystemString = [NSString stringWithFormat:@"%s/%s",
 4507|       |                          unameRecord.sysname, unameRecord.release]; // "Darwin/8.11.1"
 4508|       |#else
 4509|       |#error No branch taken for a default user agent
 4510|       |#endif
 4511|       |  });
 4512|      0|  return sSavedSystemString;
 4513|      0|}
 4514|       |
 4515|      0|NSString *GTMFetcherStandardUserAgentString(NSBundle * GTM_NULLABLE_TYPE bundle) {
 4516|      0|  NSString *result = [NSString stringWithFormat:@"%@ %@",
 4517|      0|                      GTMFetcherApplicationIdentifier(bundle),
 4518|      0|                      GTMFetcherSystemVersionString()];
 4519|      0|  return result;
 4520|      0|}
 4521|       |
 4522|      0|NSString *GTMFetcherApplicationIdentifier(NSBundle * GTM_NULLABLE_TYPE bundle) {
 4523|      0|  @synchronized([GTMSessionFetcher class]) {
 4524|      0|    static NSMutableDictionary *sAppIDMap = nil;
 4525|      0|
 4526|      0|    // If there's a bundle ID, use that; otherwise, use the process name
 4527|      0|    if (bundle == nil) {
 4528|      0|      bundle = [NSBundle mainBundle];
 4529|      0|    }
 4530|      0|    NSString *bundleID = [bundle bundleIdentifier];
 4531|      0|    if (bundleID == nil) {
 4532|      0|      bundleID = @"";
 4533|      0|    }
 4534|      0|
 4535|      0|    NSString *identifier = [sAppIDMap objectForKey:bundleID];
 4536|      0|    if (identifier) return identifier;
 4537|      0|
 4538|      0|    // Apps may add a string to the info.plist to uniquely identify different builds.
 4539|      0|    identifier = [bundle objectForInfoDictionaryKey:@"GTMUserAgentID"];
 4540|      0|    if (identifier.length == 0) {
 4541|      0|      if (bundleID.length > 0) {
 4542|      0|        identifier = bundleID;
 4543|      0|      } else {
 4544|      0|        // Fall back on the procname, prefixed by "proc" to flag that it's
 4545|      0|        // autogenerated and perhaps unreliable
 4546|      0|        NSString *procName = [[NSProcessInfo processInfo] processName];
 4547|      0|        identifier = [NSString stringWithFormat:@"proc_%@", procName];
 4548|      0|      }
 4549|      0|    }
 4550|      0|
 4551|      0|    // Clean up whitespace and special characters
 4552|      0|    identifier = GTMFetcherCleanedUserAgentString(identifier);
 4553|      0|
 4554|      0|    // If there's a version number, append that
 4555|      0|    NSString *version = [bundle objectForInfoDictionaryKey:@"CFBundleShortVersionString"];
 4556|      0|    if (version.length == 0) {
 4557|      0|      version = [bundle objectForInfoDictionaryKey:@"CFBundleVersion"];
 4558|      0|    }
 4559|      0|
 4560|      0|    // Clean up whitespace and special characters
 4561|      0|    version = GTMFetcherCleanedUserAgentString(version);
 4562|      0|
 4563|      0|    // Glue the two together (cleanup done above or else cleanup would strip the
 4564|      0|    // slash)
 4565|      0|    if (version.length > 0) {
 4566|      0|      identifier = [identifier stringByAppendingFormat:@"/%@", version];
 4567|      0|    }
 4568|      0|
 4569|      0|    if (sAppIDMap == nil) {
 4570|      0|      sAppIDMap = [[NSMutableDictionary alloc] init];
 4571|      0|    }
 4572|      0|    [sAppIDMap setObject:identifier forKey:bundleID];
 4573|      0|    return identifier;
 4574|      0|  }
 4575|      0|}
 4576|       |
 4577|       |#if DEBUG && (!defined(NS_BLOCK_ASSERTIONS) || GTMSESSION_ASSERT_AS_LOG)
 4578|       |@implementation GTMSessionSyncMonitorInternal {
 4579|       |  NSValue *_objectKey;        // The synchronize target object.
 4580|       |  const char *_functionName;  // The function containing the monitored sync block.
 4581|       |}
 4582|       |
 4583|       |- (instancetype)initWithSynchronizationObject:(id)object
 4584|       |                               allowRecursive:(BOOL)allowRecursive
 4585|      0|                                 functionName:(const char *)functionName {
 4586|      0|  self = [super init];
 4587|      0|  if (self) {
 4588|      0|    Class threadKey = [GTMSessionSyncMonitorInternal class];
 4589|      0|    _objectKey = [NSValue valueWithNonretainedObject:object];
 4590|      0|    _functionName = functionName;
 4591|      0|
 4592|      0|    NSMutableDictionary *threadDict = [NSThread currentThread].threadDictionary;
 4593|      0|    NSMutableDictionary *counters = threadDict[threadKey];
 4594|      0|    if (counters == nil) {
 4595|      0|      counters = [NSMutableDictionary dictionary];
 4596|      0|      threadDict[(id)threadKey] = counters;
 4597|      0|    }
 4598|      0|    NSCountedSet *functionNamesCounter = counters[_objectKey];
 4599|      0|    NSUInteger numberOfSyncingFunctions = functionNamesCounter.count;
 4600|      0|
 4601|      0|    if (!allowRecursive) {
 4602|      0|      BOOL isTopLevelSyncScope = (numberOfSyncingFunctions == 0);
 4603|      0|      NSArray *stack = [NSThread callStackSymbols];
 4604|      0|      GTMSESSION_ASSERT_DEBUG(isTopLevelSyncScope,
 4605|      0|                              @"*** Recursive sync on %@ at %s; previous sync at %@\n%@",
 4606|      0|                              [object class], functionName, functionNamesCounter.allObjects,
 4607|      0|                              [stack subarrayWithRange:NSMakeRange(1, stack.count - 1)]);
 4608|      0|    }
 4609|      0|
 4610|      0|    if (!functionNamesCounter) {
 4611|      0|      functionNamesCounter = [NSCountedSet set];
 4612|      0|      counters[_objectKey] = functionNamesCounter;
 4613|      0|    }
 4614|      0|    [functionNamesCounter addObject:(id _Nonnull)@(functionName)];
 4615|      0|  }
 4616|      0|  return self;
 4617|      0|}
 4618|       |
 4619|      0|- (void)dealloc {
 4620|      0|  Class threadKey = [GTMSessionSyncMonitorInternal class];
 4621|      0|
 4622|      0|  NSMutableDictionary *threadDict = [NSThread currentThread].threadDictionary;
 4623|      0|  NSMutableDictionary *counters = threadDict[threadKey];
 4624|      0|  NSCountedSet *functionNamesCounter = counters[_objectKey];
 4625|      0|  NSString *functionNameStr = @(_functionName);
 4626|      0|  NSUInteger numberOfSyncsByThisFunction = [functionNamesCounter countForObject:functionNameStr];
 4627|      0|  NSArray *stack = [NSThread callStackSymbols];
 4628|      0|  GTMSESSION_ASSERT_DEBUG(numberOfSyncsByThisFunction > 0, @"Sync not found on %@ at %s\n%@",
 4629|      0|                          [_objectKey.nonretainedObjectValue class], _functionName,
 4630|      0|                          [stack subarrayWithRange:NSMakeRange(1, stack.count - 1)]);
 4631|      0|  [functionNamesCounter removeObject:functionNameStr];
 4632|      0|  if (functionNamesCounter.count == 0) {
 4633|      0|    [counters removeObjectForKey:_objectKey];
 4634|      0|  }
 4635|      0|}
 4636|       |
 4637|      0|+ (NSArray *)functionsHoldingSynchronizationOnObject:(id)object {
 4638|      0|  Class threadKey = [GTMSessionSyncMonitorInternal class];
 4639|      0|  NSValue *localObjectKey = [NSValue valueWithNonretainedObject:object];
 4640|      0|
 4641|      0|  NSMutableDictionary *threadDict = [NSThread currentThread].threadDictionary;
 4642|      0|  NSMutableDictionary *counters = threadDict[threadKey];
 4643|      0|  NSCountedSet *functionNamesCounter = counters[localObjectKey];
 4644|      0|  return functionNamesCounter.count > 0 ? functionNamesCounter.allObjects : nil;
 4645|      0|}
 4646|       |@end
 4647|       |#endif  // DEBUG && (!defined(NS_BLOCK_ASSERTIONS) || GTMSESSION_ASSERT_AS_LOG)
 4648|       |GTM_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GTMSessionFetcher/Source/GTMSessionFetcherLogging.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#include <sys/stat.h>
   21|       |#include <unistd.h>
   22|       |
   23|       |#import "GTMSessionFetcherLogging.h"
   24|       |
   25|       |#ifndef STRIP_GTM_FETCH_LOGGING
   26|       |  #error GTMSessionFetcher headers should have defaulted this if it wasn't already defined.
   27|       |#endif
   28|       |
   29|       |#if !STRIP_GTM_FETCH_LOGGING
   30|       |
   31|       |// Sensitive credential strings are replaced in logs with _snip_
   32|       |//
   33|       |// Apps that must see the contents of sensitive tokens can set this to 1
   34|       |#ifndef SKIP_GTM_FETCH_LOGGING_SNIPPING
   35|       |#define SKIP_GTM_FETCH_LOGGING_SNIPPING 0
   36|       |#endif
   37|       |
   38|       |// If GTMReadMonitorInputStream is available, it can be used for
   39|       |// capturing uploaded streams of data
   40|       |//
   41|       |// We locally declare methods of GTMReadMonitorInputStream so we
   42|       |// do not need to import the header, as some projects may not have it available
   43|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
   44|       |@interface GTMReadMonitorInputStream : NSInputStream
   45|       |
   46|       |+ (instancetype)inputStreamWithStream:(NSInputStream *)input;
   47|       |
   48|       |@property (assign) id readDelegate;
   49|       |@property (assign) SEL readSelector;
   50|       |
   51|       |@end
   52|       |#else
   53|       |@class GTMReadMonitorInputStream;
   54|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
   55|       |
   56|       |@interface GTMSessionFetcher (GTMHTTPFetcherLoggingUtilities)
   57|       |
   58|       |+ (NSString *)headersStringForDictionary:(NSDictionary *)dict;
   59|       |+ (NSString *)snipSubstringOfString:(NSString *)originalStr
   60|       |                 betweenStartString:(NSString *)startStr
   61|       |                          endString:(NSString *)endStr;
   62|       |- (void)inputStream:(GTMReadMonitorInputStream *)stream
   63|       |     readIntoBuffer:(void *)buffer
   64|       |             length:(int64_t)length;
   65|       |
   66|       |@end
   67|       |
   68|       |@implementation GTMSessionFetcher (GTMSessionFetcherLogging)
   69|       |
   70|       |// fetchers come and fetchers go, but statics are forever
   71|       |static BOOL gIsLoggingEnabled = NO;
   72|       |static BOOL gIsLoggingToFile = YES;
   73|       |static NSString *gLoggingDirectoryPath = nil;
   74|       |static NSString *gLogDirectoryForCurrentRun = nil;
   75|       |static NSString *gLoggingDateStamp = nil;
   76|       |static NSString *gLoggingProcessName = nil;
   77|       |
   78|      0|+ (void)setLoggingDirectory:(NSString *)path {
   79|      0|  gLoggingDirectoryPath = [path copy];
   80|      0|}
   81|       |
   82|      0|+ (NSString *)loggingDirectory {
   83|      0|  if (!gLoggingDirectoryPath) {
   84|      0|    NSArray *paths = nil;
   85|      0|#if TARGET_IPHONE_SIMULATOR
   86|      0|    // default to a directory called GTMHTTPDebugLogs into a sandbox-safe
   87|      0|    // directory that a developer can find easily, the application home
   88|      0|    paths = @[ NSHomeDirectory() ];
   89|       |#elif TARGET_OS_IPHONE
   90|       |    // Neither ~/Desktop nor ~/Home is writable on an actual iOS, watchOS, or tvOS device.
   91|       |    // Put it in ~/Documents.
   92|       |    paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
   93|       |#else
   94|       |    // default to a directory called GTMHTTPDebugLogs in the desktop folder
   95|       |    paths = NSSearchPathForDirectoriesInDomains(NSDesktopDirectory, NSUserDomainMask, YES);
   96|       |#endif
   97|       |
   98|      0|    NSString *desktopPath = paths.firstObject;
   99|      0|    if (desktopPath) {
  100|      0|      NSString *const kGTMLogFolderName = @"GTMHTTPDebugLogs";
  101|      0|      NSString *logsFolderPath = [desktopPath stringByAppendingPathComponent:kGTMLogFolderName];
  102|      0|
  103|      0|      NSFileManager *fileMgr = [NSFileManager defaultManager];
  104|      0|      BOOL isDir;
  105|      0|      BOOL doesFolderExist = [fileMgr fileExistsAtPath:logsFolderPath isDirectory:&isDir];
  106|      0|      if (!doesFolderExist) {
  107|      0|        // make the directory
  108|      0|        doesFolderExist = [fileMgr createDirectoryAtPath:logsFolderPath
  109|      0|                             withIntermediateDirectories:YES
  110|      0|                                              attributes:nil
  111|      0|                                                   error:NULL];
  112|      0|        if (doesFolderExist) {
  113|      0|          // The directory has been created. Exclude it from backups.
  114|      0|          NSURL *pathURL = [NSURL fileURLWithPath:logsFolderPath isDirectory:YES];
  115|      0|          [pathURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:NULL];
  116|      0|        }
  117|      0|      }
  118|      0|
  119|      0|      if (doesFolderExist) {
  120|      0|        // it's there; store it in the global
  121|      0|        gLoggingDirectoryPath = [logsFolderPath copy];
  122|      0|      }
  123|      0|    }
  124|      0|  }
  125|      0|  return gLoggingDirectoryPath;
  126|      0|}
  127|       |
  128|      0|+ (void)setLogDirectoryForCurrentRun:(NSString *)logDirectoryForCurrentRun {
  129|      0|  // Set the path for this run's logs.
  130|      0|  gLogDirectoryForCurrentRun = [logDirectoryForCurrentRun copy];
  131|      0|}
  132|       |
  133|      0|+ (NSString *)logDirectoryForCurrentRun {
  134|      0|  // make a directory for this run's logs, like SyncProto_logs_10-16_01-56-58PM
  135|      0|  if (gLogDirectoryForCurrentRun) return gLogDirectoryForCurrentRun;
  136|      0|
  137|      0|  NSString *parentDir = [self loggingDirectory];
  138|      0|  NSString *logNamePrefix = [self processNameLogPrefix];
  139|      0|  NSString *dateStamp = [self loggingDateStamp];
  140|      0|  NSString *dirName = [NSString stringWithFormat:@"%@%@", logNamePrefix, dateStamp];
  141|      0|  NSString *logDirectory = [parentDir stringByAppendingPathComponent:dirName];
  142|      0|
  143|      0|  if (gIsLoggingToFile) {
  144|      0|    NSFileManager *fileMgr = [NSFileManager defaultManager];
  145|      0|    // Be sure that the first time this app runs, it's not writing to a preexisting folder
  146|      0|    static BOOL gShouldReuseFolder = NO;
  147|      0|    if (!gShouldReuseFolder) {
  148|      0|      gShouldReuseFolder = YES;
  149|      0|      NSString *origLogDir = logDirectory;
  150|      0|      for (int ctr = 2; ctr < 20; ++ctr) {
  151|      0|        if (![fileMgr fileExistsAtPath:logDirectory]) break;
  152|      0|
  153|      0|        // append a digit
  154|      0|        logDirectory = [origLogDir stringByAppendingFormat:@"_%d", ctr];
  155|      0|      }
  156|      0|    }
  157|      0|    if (![fileMgr createDirectoryAtPath:logDirectory
  158|      0|            withIntermediateDirectories:YES
  159|      0|                             attributes:nil
  160|      0|                                  error:NULL]) return nil;
  161|      0|  }
  162|      0|  gLogDirectoryForCurrentRun = logDirectory;
  163|      0|
  164|      0|  return gLogDirectoryForCurrentRun;
  165|      0|}
  166|       |
  167|      0|+ (void)setLoggingEnabled:(BOOL)isLoggingEnabled {
  168|      0|  gIsLoggingEnabled = isLoggingEnabled;
  169|      0|}
  170|       |
  171|      0|+ (BOOL)isLoggingEnabled {
  172|      0|  return gIsLoggingEnabled;
  173|      0|}
  174|       |
  175|      0|+ (void)setLoggingToFileEnabled:(BOOL)isLoggingToFileEnabled {
  176|      0|  gIsLoggingToFile = isLoggingToFileEnabled;
  177|      0|}
  178|       |
  179|      0|+ (BOOL)isLoggingToFileEnabled {
  180|      0|  return gIsLoggingToFile;
  181|      0|}
  182|       |
  183|      0|+ (void)setLoggingProcessName:(NSString *)processName {
  184|      0|  gLoggingProcessName = [processName copy];
  185|      0|}
  186|       |
  187|      0|+ (NSString *)loggingProcessName {
  188|      0|  // get the process name (once per run) replacing spaces with underscores
  189|      0|  if (!gLoggingProcessName) {
  190|      0|    NSString *procName = [[NSProcessInfo processInfo] processName];
  191|      0|    gLoggingProcessName = [procName stringByReplacingOccurrencesOfString:@" " withString:@"_"];
  192|      0|  }
  193|      0|  return gLoggingProcessName;
  194|      0|}
  195|       |
  196|      0|+ (void)setLoggingDateStamp:(NSString *)dateStamp {
  197|      0|  gLoggingDateStamp = [dateStamp copy];
  198|      0|}
  199|       |
  200|      0|+ (NSString *)loggingDateStamp {
  201|      0|  // We'll pick one date stamp per run, so a run that starts at a later second
  202|      0|  // will get a unique results html file
  203|      0|  if (!gLoggingDateStamp) {
  204|      0|    // produce a string like 08-21_01-41-23PM
  205|      0|
  206|      0|    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
  207|      0|    [formatter setFormatterBehavior:NSDateFormatterBehavior10_4];
  208|      0|    [formatter setDateFormat:@"M-dd_hh-mm-ssa"];
  209|      0|
  210|      0|    gLoggingDateStamp = [formatter stringFromDate:[NSDate date]];
  211|      0|  }
  212|      0|  return gLoggingDateStamp;
  213|      0|}
  214|       |
  215|      0|+ (NSString *)processNameLogPrefix {
  216|      0|  static NSString *gPrefix = nil;
  217|      0|  if (!gPrefix) {
  218|      0|    NSString *processName = [self loggingProcessName];
  219|      0|    gPrefix = [[NSString alloc] initWithFormat:@"%@_log_", processName];
  220|      0|  }
  221|      0|  return gPrefix;
  222|      0|}
  223|       |
  224|      0|+ (NSString *)symlinkNameSuffix {
  225|      0|  return @"_log_newest.html";
  226|      0|}
  227|       |
  228|      0|+ (NSString *)htmlFileName {
  229|      0|  return @"aperçu_http_log.html";
  230|      0|}
  231|       |
  232|      0|+ (void)deleteLogDirectoriesOlderThanDate:(NSDate *)cutoffDate {
  233|      0|  NSFileManager *fileMgr = [NSFileManager defaultManager];
  234|      0|  NSURL *parentDir = [NSURL fileURLWithPath:[[self class] loggingDirectory]];
  235|      0|  NSURL *logDirectoryForCurrentRun =
  236|      0|      [NSURL fileURLWithPath:[[self class] logDirectoryForCurrentRun]];
  237|      0|  NSError *error;
  238|      0|  NSArray *contents = [fileMgr contentsOfDirectoryAtURL:parentDir
  239|      0|                             includingPropertiesForKeys:@[ NSURLContentModificationDateKey ]
  240|      0|                                                options:0
  241|      0|                                                  error:&error];
  242|      0|  for (NSURL *itemURL in contents) {
  243|      0|    if ([itemURL isEqual:logDirectoryForCurrentRun]) continue;
  244|      0|
  245|      0|    NSDate *modDate;
  246|      0|    if ([itemURL getResourceValue:&modDate
  247|      0|                           forKey:NSURLContentModificationDateKey
  248|      0|                            error:&error]) {
  249|      0|      if ([modDate compare:cutoffDate] == NSOrderedAscending) {
  250|      0|        if (![fileMgr removeItemAtURL:itemURL error:&error]) {
  251|      0|          NSLog(@"deleteLogDirectoriesOlderThanDate failed to delete %@: %@",
  252|      0|                itemURL.path, error);
  253|      0|        }
  254|      0|      }
  255|      0|    } else {
  256|      0|      NSLog(@"deleteLogDirectoriesOlderThanDate failed to get mod date of %@: %@",
  257|      0|            itemURL.path, error);
  258|      0|    }
  259|      0|  }
  260|      0|}
  261|       |
  262|       |// formattedStringFromData returns a prettyprinted string for XML or JSON input,
  263|       |// and a plain string for other input data
  264|       |- (NSString *)formattedStringFromData:(NSData *)inputData
  265|       |                          contentType:(NSString *)contentType
  266|      0|                                 JSON:(NSDictionary **)outJSON {
  267|      0|  if (!inputData) return nil;
  268|      0|
  269|      0|  // if the content type is JSON and we have the parsing class available, use that
  270|      0|  if ([contentType hasPrefix:@"application/json"] && inputData.length > 5) {
  271|      0|    // convert from JSON string to NSObjects and back to a formatted string
  272|      0|    NSMutableDictionary *obj = [NSJSONSerialization JSONObjectWithData:inputData
  273|      0|                                                               options:NSJSONReadingMutableContainers
  274|      0|                                                                 error:NULL];
  275|      0|    if (obj) {
  276|      0|      if (outJSON) *outJSON = obj;
  277|      0|      if ([obj isKindOfClass:[NSMutableDictionary class]]) {
  278|      0|        // for security and privacy, omit OAuth 2 response access and refresh tokens
  279|      0|        if ([obj valueForKey:@"refresh_token"] != nil) {
  280|      0|          [obj setObject:@"_snip_" forKey:@"refresh_token"];
  281|      0|        }
  282|      0|        if ([obj valueForKey:@"access_token"] != nil) {
  283|      0|          [obj setObject:@"_snip_" forKey:@"access_token"];
  284|      0|        }
  285|      0|      }
  286|      0|      NSData *data = [NSJSONSerialization dataWithJSONObject:obj
  287|      0|                                                     options:NSJSONWritingPrettyPrinted
  288|      0|                                                       error:NULL];
  289|      0|      if (data) {
  290|      0|        NSString *jsonStr = [[NSString alloc] initWithData:data
  291|      0|                                                  encoding:NSUTF8StringEncoding];
  292|      0|        return jsonStr;
  293|      0|      }
  294|      0|    }
  295|      0|  }
  296|      0|
  297|       |#if !TARGET_OS_IPHONE && !GTM_SKIP_LOG_XMLFORMAT
  298|       |  // verify that this data starts with the bytes indicating XML
  299|       |
  300|       |  NSString *const kXMLLintPath = @"/usr/bin/xmllint";
  301|       |  static BOOL gHasCheckedAvailability = NO;
  302|       |  static BOOL gIsXMLLintAvailable = NO;
  303|       |
  304|       |  if (!gHasCheckedAvailability) {
  305|       |    gIsXMLLintAvailable = [[NSFileManager defaultManager] fileExistsAtPath:kXMLLintPath];
  306|       |    gHasCheckedAvailability = YES;
  307|       |  }
  308|       |  if (gIsXMLLintAvailable
  309|       |      && inputData.length > 5
  310|       |      && strncmp(inputData.bytes, "<?xml", 5) == 0) {
  311|       |
  312|       |    // call xmllint to format the data
  313|       |    NSTask *task = [[NSTask alloc] init];
  314|       |    [task setLaunchPath:kXMLLintPath];
  315|       |
  316|       |    // use the dash argument to specify stdin as the source file
  317|       |    [task setArguments:@[ @"--format", @"-" ]];
  318|       |    [task setEnvironment:@{}];
  319|       |
  320|       |    NSPipe *inputPipe = [NSPipe pipe];
  321|       |    NSPipe *outputPipe = [NSPipe pipe];
  322|       |    [task setStandardInput:inputPipe];
  323|       |    [task setStandardOutput:outputPipe];
  324|       |
  325|       |    [task launch];
  326|       |
  327|       |    [[inputPipe fileHandleForWriting] writeData:inputData];
  328|       |    [[inputPipe fileHandleForWriting] closeFile];
  329|       |
  330|       |    // drain the stdout before waiting for the task to exit
  331|       |    NSData *formattedData = [[outputPipe fileHandleForReading] readDataToEndOfFile];
  332|       |
  333|       |    [task waitUntilExit];
  334|       |
  335|       |    int status = [task terminationStatus];
  336|       |    if (status == 0 && formattedData.length > 0) {
  337|       |      // success
  338|       |      inputData = formattedData;
  339|       |    }
  340|       |  }
  341|       |#else
  342|       |  // we can't call external tasks on the iPhone; leave the XML unformatted
  343|      0|#endif
  344|      0|
  345|      0|  NSString *dataStr = [[NSString alloc] initWithData:inputData
  346|      0|                                            encoding:NSUTF8StringEncoding];
  347|      0|  return dataStr;
  348|      0|}
  349|       |
  350|       |// stringFromStreamData creates a string given the supplied data
  351|       |//
  352|       |// If NSString can create a UTF-8 string from the data, then that is returned.
  353|       |//
  354|       |// Otherwise, this routine tries to find a MIME boundary at the beginning of the data block, and
  355|       |// uses that to break up the data into parts. Each part will be used to try to make a UTF-8 string.
  356|       |// For parts that fail, a replacement string showing the part header and <<n bytes>> is supplied
  357|       |// in place of the binary data.
  358|       |
  359|       |- (NSString *)stringFromStreamData:(NSData *)data
  360|      0|                       contentType:(NSString *)contentType {
  361|      0|
  362|      0|  if (!data) return nil;
  363|      0|
  364|      0|  // optimistically, see if the whole data block is UTF-8
  365|      0|  NSString *streamDataStr = [self formattedStringFromData:data
  366|      0|                                              contentType:contentType
  367|      0|                                                     JSON:NULL];
  368|      0|  if (streamDataStr) return streamDataStr;
  369|      0|
  370|      0|  // Munge a buffer by replacing non-ASCII bytes with underscores, and turn that munged buffer an
  371|      0|  // NSString.  That gives us a string we can use with NSScanner.
  372|      0|  NSMutableData *mutableData = [NSMutableData dataWithData:data];
  373|      0|  unsigned char *bytes = (unsigned char *)mutableData.mutableBytes;
  374|      0|
  375|      0|  for (unsigned int idx = 0; idx < mutableData.length; ++idx) {
  376|      0|    if (bytes[idx] > 0x7F || bytes[idx] == 0) {
  377|      0|      bytes[idx] = '_';
  378|      0|    }
  379|      0|  }
  380|      0|
  381|      0|  NSString *mungedStr = [[NSString alloc] initWithData:mutableData
  382|      0|                                              encoding:NSUTF8StringEncoding];
  383|      0|  if (mungedStr) {
  384|      0|
  385|      0|    // scan for the boundary string
  386|      0|    NSString *boundary = nil;
  387|      0|    NSScanner *scanner = [NSScanner scannerWithString:mungedStr];
  388|      0|
  389|      0|    if ([scanner scanUpToString:@"\r\n" intoString:&boundary]
  390|      0|        && [boundary hasPrefix:@"--"]) {
  391|      0|
  392|      0|      // we found a boundary string; use it to divide the string into parts
  393|      0|      NSArray *mungedParts = [mungedStr componentsSeparatedByString:boundary];
  394|      0|
  395|      0|      // look at each munged part in the original string, and try to convert those into UTF-8
  396|      0|      NSMutableArray *origParts = [NSMutableArray array];
  397|      0|      NSUInteger offset = 0;
  398|      0|      for (NSString *mungedPart in mungedParts) {
  399|      0|        NSUInteger partSize = mungedPart.length;
  400|      0|        NSData *origPartData = [data subdataWithRange:NSMakeRange(offset, partSize)];
  401|      0|        NSString *origPartStr = [[NSString alloc] initWithData:origPartData
  402|      0|                                                      encoding:NSUTF8StringEncoding];
  403|      0|        if (origPartStr) {
  404|      0|          // we could make this original part into UTF-8; use the string
  405|      0|          [origParts addObject:origPartStr];
  406|      0|        } else {
  407|      0|          // this part can't be made into UTF-8; scan the header, if we can
  408|      0|          NSString *header = nil;
  409|      0|          NSScanner *headerScanner = [NSScanner scannerWithString:mungedPart];
  410|      0|          if (![headerScanner scanUpToString:@"\r\n\r\n" intoString:&header]) {
  411|      0|            // we couldn't find a header
  412|      0|            header = @"";
  413|      0|          }
  414|      0|          // make a part string with the header and <<n bytes>>
  415|      0|          NSString *binStr = [NSString stringWithFormat:@"\r%@\r<<%lu bytes>>\r",
  416|      0|                              header, (long)(partSize - header.length)];
  417|      0|          [origParts addObject:binStr];
  418|      0|        }
  419|      0|        offset += partSize + boundary.length;
  420|      0|      }
  421|      0|      // rejoin the original parts
  422|      0|      streamDataStr = [origParts componentsJoinedByString:boundary];
  423|      0|    }
  424|      0|  }
  425|      0|  if (!streamDataStr) {
  426|      0|    // give up; just make a string showing the uploaded bytes
  427|      0|    streamDataStr = [NSString stringWithFormat:@"<<%u bytes>>", (unsigned int)data.length];
  428|      0|  }
  429|      0|  return streamDataStr;
  430|      0|}
  431|       |
  432|       |// logFetchWithError is called following a successful or failed fetch attempt
  433|       |//
  434|       |// This method does all the work for appending to and creating log files
  435|       |
  436|      0|- (void)logFetchWithError:(NSError *)error {
  437|      0|  if (![[self class] isLoggingEnabled]) return;
  438|      0|  NSString *logDirectory = [[self class] logDirectoryForCurrentRun];
  439|      0|  if (!logDirectory) return;
  440|      0|  NSString *processName = [[self class] loggingProcessName];
  441|      0|
  442|      0|  // TODO: add Javascript to display response data formatted in hex
  443|      0|
  444|      0|  // each response's NSData goes into its own xml or txt file, though all responses for this run of
  445|      0|  // the app share a main html file. This counter tracks all fetch responses for this app run.
  446|      0|  //
  447|      0|  // we'll use a local variable since this routine may be reentered while waiting for XML formatting
  448|      0|  // to be completed by an external task
  449|      0|  static int gResponseCounter = 0;
  450|      0|  int responseCounter = ++gResponseCounter;
  451|      0|
  452|      0|  NSURLResponse *response = [self response];
  453|      0|  NSDictionary *responseHeaders = [self responseHeaders];
  454|      0|  NSString *responseDataStr = nil;
  455|      0|  NSDictionary *responseJSON = nil;
  456|      0|
  457|      0|  // if there's response data, decide what kind of file to put it in based on the first bytes of the
  458|      0|  // file or on the mime type supplied by the server
  459|      0|  NSString *responseMIMEType = [response MIMEType];
  460|      0|  BOOL isResponseImage = NO;
  461|      0|
  462|      0|  // file name for an image data file
  463|      0|  NSString *responseDataFileName = nil;
  464|      0|
  465|      0|  int64_t responseDataLength = self.downloadedLength;
  466|      0|  if (responseDataLength > 0) {
  467|      0|    NSData *downloadedData = self.downloadedData;
  468|      0|    if (downloadedData == nil
  469|      0|        && responseDataLength > 0
  470|      0|        && responseDataLength < 20000
  471|      0|        && self.destinationFileURL) {
  472|      0|      // There's a download file that's not too big, so get the data to display from the downloaded
  473|      0|      // file.
  474|      0|      NSURL *destinationURL = self.destinationFileURL;
  475|      0|      downloadedData = [NSData dataWithContentsOfURL:destinationURL];
  476|      0|    }
  477|      0|    NSString *responseType = [responseHeaders valueForKey:@"Content-Type"];
  478|      0|    responseDataStr = [self formattedStringFromData:downloadedData
  479|      0|                                        contentType:responseType
  480|      0|                                               JSON:&responseJSON];
  481|      0|    NSString *responseDataExtn = nil;
  482|      0|    NSData *dataToWrite = nil;
  483|      0|    if (responseDataStr) {
  484|      0|      // we were able to make a UTF-8 string from the response data
  485|      0|      if ([responseMIMEType isEqual:@"application/atom+xml"]
  486|      0|          || [responseMIMEType hasSuffix:@"/xml"]) {
  487|      0|        responseDataExtn = @"xml";
  488|      0|        dataToWrite = [responseDataStr dataUsingEncoding:NSUTF8StringEncoding];
  489|      0|      }
  490|      0|    } else if ([responseMIMEType isEqual:@"image/jpeg"]) {
  491|      0|      responseDataExtn = @"jpg";
  492|      0|      dataToWrite = downloadedData;
  493|      0|      isResponseImage = YES;
  494|      0|    } else if ([responseMIMEType isEqual:@"image/gif"]) {
  495|      0|      responseDataExtn = @"gif";
  496|      0|      dataToWrite = downloadedData;
  497|      0|      isResponseImage = YES;
  498|      0|    } else if ([responseMIMEType isEqual:@"image/png"]) {
  499|      0|      responseDataExtn = @"png";
  500|      0|      dataToWrite = downloadedData;
  501|      0|      isResponseImage = YES;
  502|      0|    } else {
  503|      0|      // add more non-text types here
  504|      0|    }
  505|      0|    // if we have an extension, save the raw data in a file with that extension
  506|      0|    if (responseDataExtn && dataToWrite) {
  507|      0|      // generate a response file base name like
  508|      0|      NSString *responseBaseName = [NSString stringWithFormat:@"fetch_%d_response", responseCounter];
  509|      0|      responseDataFileName = [responseBaseName stringByAppendingPathExtension:responseDataExtn];
  510|      0|      NSString *responseDataFilePath = [logDirectory stringByAppendingPathComponent:responseDataFileName];
  511|      0|
  512|      0|      NSError *downloadedError = nil;
  513|      0|      if (gIsLoggingToFile && ![dataToWrite writeToFile:responseDataFilePath
  514|      0|                                                options:0
  515|      0|                                                  error:&downloadedError]) {
  516|      0|        NSLog(@"%@ logging write error:%@ (%@)", [self class], downloadedError, responseDataFileName);
  517|      0|      }
  518|      0|    }
  519|      0|  }
  520|      0|  // we'll have one main html file per run of the app
  521|      0|  NSString *htmlName = [[self class] htmlFileName];
  522|      0|  NSString *htmlPath =[logDirectory stringByAppendingPathComponent:htmlName];
  523|      0|
  524|      0|  // if the html file exists (from logging previous fetches) we don't need
  525|      0|  // to re-write the header or the scripts
  526|      0|  NSFileManager *fileMgr = [NSFileManager defaultManager];
  527|      0|  BOOL didFileExist = [fileMgr fileExistsAtPath:htmlPath];
  528|      0|
  529|      0|  NSMutableString* outputHTML = [NSMutableString string];
  530|      0|
  531|      0|  // we need a header to say we'll have UTF-8 text
  532|      0|  if (!didFileExist) {
  533|      0|    [outputHTML appendFormat:@"<html><head><meta http-equiv=\"content-type\" "
  534|      0|        "content=\"text/html; charset=UTF-8\"><title>%@ HTTP fetch log %@</title>",
  535|      0|        processName, [[self class] loggingDateStamp]];
  536|      0|  }
  537|      0|  // now write the visible html elements
  538|      0|  NSString *copyableFileName = [NSString stringWithFormat:@"fetch_%d.txt", responseCounter];
  539|      0|
  540|      0|  NSDate *now = [NSDate date];
  541|      0|  // write the date & time, the comment, and the link to the plain-text (copyable) log
  542|      0|  [outputHTML appendFormat:@"<b>%@ &nbsp;&nbsp;&nbsp;&nbsp; ", now];
  543|      0|
  544|      0|  NSString *comment = [self comment];
  545|      0|  if (comment.length > 0) {
  546|      0|    [outputHTML appendFormat:@"%@ &nbsp;&nbsp;&nbsp;&nbsp; ", comment];
  547|      0|  }
  548|      0|  [outputHTML appendFormat:@"</b><a href='%@'><i>request/response log</i></a><br>", copyableFileName];
  549|      0|  NSTimeInterval elapsed = -self.initialBeginFetchDate.timeIntervalSinceNow;
  550|      0|  [outputHTML appendFormat:@"elapsed: %5.3fsec<br>", elapsed];
  551|      0|
  552|      0|  // write the request URL
  553|      0|  NSURLRequest *request = self.request;
  554|      0|  NSString *requestMethod = request.HTTPMethod;
  555|      0|  NSURL *requestURL = request.URL;
  556|      0|
  557|      0|  // Save the request URL for next time in case this redirects.
  558|      0|  NSString *redirectedFromURLString = [self.redirectedFromURL absoluteString];
  559|      0|  self.redirectedFromURL = [requestURL copy];
  560|      0|  if (redirectedFromURLString) {
  561|      0|    [outputHTML appendFormat:@"<FONT COLOR='#990066'><i>redirected from %@</i></FONT><br>",
  562|      0|                              redirectedFromURLString];
  563|      0|  }
  564|      0|  [outputHTML appendFormat:@"<b>request:</b> %@ <code>%@</code><br>\n", requestMethod, requestURL];
  565|      0|
  566|      0|  // write the request headers
  567|      0|  NSDictionary *requestHeaders = request.allHTTPHeaderFields;
  568|      0|  NSUInteger numberOfRequestHeaders = requestHeaders.count;
  569|      0|  if (numberOfRequestHeaders > 0) {
  570|      0|    // Indicate if the request is authorized; warn if the request is authorized but non-SSL
  571|      0|    NSString *auth = [requestHeaders objectForKey:@"Authorization"];
  572|      0|    NSString *headerDetails = @"";
  573|      0|    if (auth) {
  574|      0|      BOOL isInsecure = [[requestURL scheme] isEqual:@"http"];
  575|      0|      if (isInsecure) {
  576|      0|        // 26A0 = ⚠
  577|      0|        headerDetails =
  578|      0|            @"&nbsp;&nbsp;&nbsp;<i>authorized, non-SSL</i><FONT COLOR='#FF00FF'> &#x26A0;</FONT> ";
  579|      0|      } else {
  580|      0|        headerDetails = @"&nbsp;&nbsp;&nbsp;<i>authorized</i>";
  581|      0|      }
  582|      0|    }
  583|      0|    NSString *cookiesHdr = [requestHeaders objectForKey:@"Cookie"];
  584|      0|    if (cookiesHdr) {
  585|      0|      headerDetails = [headerDetails stringByAppendingString:@"&nbsp;&nbsp;&nbsp;<i>cookies</i>"];
  586|      0|    }
  587|      0|    NSString *matchHdr = [requestHeaders objectForKey:@"If-Match"];
  588|      0|    if (matchHdr) {
  589|      0|      headerDetails = [headerDetails stringByAppendingString:@"&nbsp;&nbsp;&nbsp;<i>if-match</i>"];
  590|      0|    }
  591|      0|    matchHdr = [requestHeaders objectForKey:@"If-None-Match"];
  592|      0|    if (matchHdr) {
  593|      0|      headerDetails = [headerDetails stringByAppendingString:@"&nbsp;&nbsp;&nbsp;<i>if-none-match</i>"];
  594|      0|    }
  595|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; headers: %d  %@<br>",
  596|      0|                              (int)numberOfRequestHeaders, headerDetails];
  597|      0|  } else {
  598|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; headers: none<br>"];
  599|      0|  }
  600|      0|  // write the request post data
  601|      0|  NSData *bodyData = nil;
  602|      0|  NSData *loggedStreamData = self.loggedStreamData;
  603|      0|  if (loggedStreamData) {
  604|      0|    bodyData = loggedStreamData;
  605|      0|  } else {
  606|      0|    bodyData = self.bodyData;
  607|      0|    if (bodyData == nil) {
  608|      0|      bodyData = self.request.HTTPBody;
  609|      0|    }
  610|      0|  }
  611|      0|  uint64_t bodyDataLength = bodyData.length;
  612|      0|
  613|      0|  if (bodyData.length == 0) {
  614|      0|    // If the data is in a body upload file URL, read that in if it's not huge.
  615|      0|    NSURL *bodyFileURL = self.bodyFileURL;
  616|      0|    if (bodyFileURL) {
  617|      0|      NSNumber *fileSizeNum = nil;
  618|      0|      NSError *fileSizeError = nil;
  619|      0|      if ([bodyFileURL getResourceValue:&fileSizeNum
  620|      0|                                 forKey:NSURLFileSizeKey
  621|      0|                                  error:&fileSizeError]) {
  622|      0|        bodyDataLength = [fileSizeNum unsignedLongLongValue];
  623|      0|        if (bodyDataLength > 0 && bodyDataLength < 50000) {
  624|      0|          bodyData = [NSData dataWithContentsOfURL:bodyFileURL
  625|      0|                                           options:NSDataReadingUncached
  626|      0|                                             error:&fileSizeError];
  627|      0|        }
  628|      0|      }
  629|      0|    }
  630|      0|  }
  631|      0|  NSString *bodyDataStr = nil;
  632|      0|  NSString *postType = [requestHeaders valueForKey:@"Content-Type"];
  633|      0|
  634|      0|  if (bodyDataLength > 0) {
  635|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; data: %llu bytes, <code>%@</code><br>\n",
  636|      0|                              bodyDataLength, postType ? postType : @"(no type)"];
  637|      0|    NSString *logRequestBody = self.logRequestBody;
  638|      0|    if (logRequestBody) {
  639|      0|      bodyDataStr = [logRequestBody copy];
  640|      0|      self.logRequestBody = nil;
  641|      0|    } else {
  642|      0|      bodyDataStr = [self stringFromStreamData:bodyData
  643|      0|                                   contentType:postType];
  644|      0|      if (bodyDataStr) {
  645|      0|        // remove OAuth 2 client secret and refresh token
  646|      0|        bodyDataStr = [[self class] snipSubstringOfString:bodyDataStr
  647|      0|                                       betweenStartString:@"client_secret="
  648|      0|                                                endString:@"&"];
  649|      0|        bodyDataStr = [[self class] snipSubstringOfString:bodyDataStr
  650|      0|                                       betweenStartString:@"refresh_token="
  651|      0|                                                endString:@"&"];
  652|      0|        // remove ClientLogin password
  653|      0|        bodyDataStr = [[self class] snipSubstringOfString:bodyDataStr
  654|      0|                                       betweenStartString:@"&Passwd="
  655|      0|                                                endString:@"&"];
  656|      0|      }
  657|      0|    }
  658|      0|  } else {
  659|      0|    // no post data
  660|      0|  }
  661|      0|  // write the response status, MIME type, URL
  662|      0|  NSInteger status = [self statusCode];
  663|      0|  if (response) {
  664|      0|    NSString *statusString = @"";
  665|      0|    if (status != 0) {
  666|      0|      if (status == 200 || status == 201) {
  667|      0|        statusString = [NSString stringWithFormat:@"%ld", (long)status];
  668|      0|
  669|      0|        // report any JSON-RPC error
  670|      0|        if ([responseJSON isKindOfClass:[NSDictionary class]]) {
  671|      0|          NSDictionary *jsonError = [responseJSON objectForKey:@"error"];
  672|      0|          if ([jsonError isKindOfClass:[NSDictionary class]]) {
  673|      0|            NSString *jsonCode = [[jsonError valueForKey:@"code"] description];
  674|      0|            NSString *jsonMessage = [jsonError valueForKey:@"message"];
  675|      0|            if (jsonCode || jsonMessage) {
  676|      0|              // 2691 = ⚑
  677|      0|              NSString *const jsonErrFmt =
  678|      0|                  @"&nbsp;&nbsp;&nbsp;<i>JSON error:</i> <FONT COLOR='#FF00FF'>%@ %@ &nbsp;&#x2691;</FONT>";
  679|      0|              statusString = [statusString stringByAppendingFormat:jsonErrFmt,
  680|      0|                              jsonCode ? jsonCode : @"",
  681|      0|                              jsonMessage ? jsonMessage : @""];
  682|      0|            }
  683|      0|          }
  684|      0|        }
  685|      0|      } else {
  686|      0|        // purple for anything other than 200 or 201
  687|      0|        NSString *flag = status >= 400 ? @"&nbsp;&#x2691;" : @""; // 2691 = ⚑
  688|      0|        NSString *explanation = [NSHTTPURLResponse localizedStringForStatusCode:status];
  689|      0|        NSString *const statusFormat = @"<FONT COLOR='#FF00FF'>%ld %@ %@</FONT>";
  690|      0|        statusString = [NSString stringWithFormat:statusFormat, (long)status, explanation, flag];
  691|      0|      }
  692|      0|    }
  693|      0|    // show the response URL only if it's different from the request URL
  694|      0|    NSString *responseURLStr = @"";
  695|      0|    NSURL *responseURL = response.URL;
  696|      0|
  697|      0|    if (responseURL && ![responseURL isEqual:request.URL]) {
  698|      0|      NSString *const responseURLFormat =
  699|      0|          @"<FONT COLOR='#FF00FF'>response URL:</FONT> <code>%@</code><br>\n";
  700|      0|      responseURLStr = [NSString stringWithFormat:responseURLFormat, [responseURL absoluteString]];
  701|      0|    }
  702|      0|    [outputHTML appendFormat:@"<b>response:</b>&nbsp;&nbsp;status %@<br>\n%@",
  703|      0|                              statusString, responseURLStr];
  704|      0|    // Write the response headers
  705|      0|    NSUInteger numberOfResponseHeaders = responseHeaders.count;
  706|      0|    if (numberOfResponseHeaders > 0) {
  707|      0|      // Indicate if the server is setting cookies
  708|      0|      NSString *cookiesSet = [responseHeaders valueForKey:@"Set-Cookie"];
  709|      0|      NSString *cookiesStr =
  710|      0|          cookiesSet ? @"&nbsp;&nbsp;<FONT COLOR='#990066'><i>sets cookies</i></FONT>" : @"";
  711|      0|      // Indicate if the server is redirecting
  712|      0|      NSString *location = [responseHeaders valueForKey:@"Location"];
  713|      0|      BOOL isRedirect = status >= 300 && status <= 399 && location != nil;
  714|      0|      NSString *redirectsStr =
  715|      0|          isRedirect ? @"&nbsp;&nbsp;<FONT COLOR='#990066'><i>redirects</i></FONT>" : @"";
  716|      0|      [outputHTML appendFormat:@"&nbsp;&nbsp; headers: %d  %@ %@<br>\n",
  717|      0|                                (int)numberOfResponseHeaders, cookiesStr, redirectsStr];
  718|      0|    } else {
  719|      0|      [outputHTML appendString:@"&nbsp;&nbsp; headers: none<br>\n"];
  720|      0|    }
  721|      0|  }
  722|      0|  // error
  723|      0|  if (error) {
  724|      0|    [outputHTML appendFormat:@"<b>Error:</b> %@ <br>\n", error.description];
  725|      0|  }
  726|      0|  // Write the response data
  727|      0|  if (responseDataFileName) {
  728|      0|    if (isResponseImage) {
  729|      0|      // Make a small inline image that links to the full image file
  730|      0|      [outputHTML appendFormat:@"&nbsp;&nbsp; data: %lld bytes, <code>%@</code><br>",
  731|      0|                                responseDataLength, responseMIMEType];
  732|      0|      NSString *const fmt =
  733|      0|          @"<a href=\"%@\"><img src='%@' alt='image' style='border:solid thin;max-height:32'></a>\n";
  734|      0|      [outputHTML appendFormat:fmt, responseDataFileName, responseDataFileName];
  735|      0|    } else {
  736|      0|      // The response data was XML; link to the xml file
  737|      0|      NSString *const fmt =
  738|      0|          @"&nbsp;&nbsp; data: %lld bytes, <code>%@</code>&nbsp;&nbsp;&nbsp;<i><a href=\"%@\">%@</a></i>\n";
  739|      0|      [outputHTML appendFormat:fmt, responseDataLength, responseMIMEType,
  740|      0|                               responseDataFileName, [responseDataFileName pathExtension]];
  741|      0|    }
  742|      0|  } else {
  743|      0|    // The response data was not an image; just show the length and MIME type
  744|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; data: %lld bytes, <code>%@</code>\n",
  745|      0|        responseDataLength, responseMIMEType ? responseMIMEType : @"(no response type)"];
  746|      0|  }
  747|      0|  // Make a single string of the request and response, suitable for copying
  748|      0|  // to the clipboard and pasting into a bug report
  749|      0|  NSMutableString *copyable = [NSMutableString string];
  750|      0|  if (comment) {
  751|      0|    [copyable appendFormat:@"%@\n\n", comment];
  752|      0|  }
  753|      0|  [copyable appendFormat:@"%@  elapsed: %5.3fsec\n", now, elapsed];
  754|      0|  if (redirectedFromURLString) {
  755|      0|    [copyable appendFormat:@"Redirected from %@\n", redirectedFromURLString];
  756|      0|  }
  757|      0|  [copyable appendFormat:@"Request: %@ %@\n", requestMethod, requestURL];
  758|      0|  if (requestHeaders.count > 0) {
  759|      0|    [copyable appendFormat:@"Request headers:\n%@\n",
  760|      0|                            [[self class] headersStringForDictionary:requestHeaders]];
  761|      0|  }
  762|      0|  if (bodyDataLength > 0) {
  763|      0|    [copyable appendFormat:@"Request body: (%llu bytes)\n", bodyDataLength];
  764|      0|    if (bodyDataStr) {
  765|      0|      [copyable appendFormat:@"%@\n", bodyDataStr];
  766|      0|    }
  767|      0|    [copyable appendString:@"\n"];
  768|      0|  }
  769|      0|  if (response) {
  770|      0|    [copyable appendFormat:@"Response: status %d\n", (int) status];
  771|      0|    [copyable appendFormat:@"Response headers:\n%@\n",
  772|      0|                            [[self class] headersStringForDictionary:responseHeaders]];
  773|      0|    [copyable appendFormat:@"Response body: (%lld bytes)\n", responseDataLength];
  774|      0|    if (responseDataLength > 0) {
  775|      0|      NSString *logResponseBody = self.logResponseBody;
  776|      0|      if (logResponseBody) {
  777|      0|        // The user has provided the response body text.
  778|      0|        responseDataStr = [logResponseBody copy];
  779|      0|        self.logResponseBody = nil;
  780|      0|      }
  781|      0|      if (responseDataStr != nil) {
  782|      0|        [copyable appendFormat:@"%@\n", responseDataStr];
  783|      0|      } else {
  784|      0|        // Even though it's redundant, we'll put in text to indicate that all the bytes are binary.
  785|      0|        if (self.destinationFileURL) {
  786|      0|          [copyable appendFormat:@"<<%lld bytes>>  to file %@\n",
  787|      0|           responseDataLength, self.destinationFileURL.path];
  788|      0|        } else {
  789|      0|          [copyable appendFormat:@"<<%lld bytes>>\n", responseDataLength];
  790|      0|        }
  791|      0|      }
  792|      0|    }
  793|      0|  }
  794|      0|  if (error) {
  795|      0|    [copyable appendFormat:@"Error: %@\n", error];
  796|      0|  }
  797|      0|  // Save to log property before adding the separator
  798|      0|  self.log = copyable;
  799|      0|
  800|      0|  [copyable appendString:@"-----------------------------------------------------------\n"];
  801|      0|
  802|      0|  // Write the copyable version to another file (linked to at the top of the html file, above)
  803|      0|  //
  804|      0|  // Ideally, something to just copy this to the clipboard like
  805|      0|  //   <span onCopy='window.event.clipboardData.setData(\"Text\",
  806|      0|  //   \"copyable stuff\");return false;'>Copy here.</span>"
  807|      0|  // would work everywhere, but it only works in Safari as of 8/2010
  808|      0|  if (gIsLoggingToFile) {
  809|      0|    NSString *parentDir = [[self class] loggingDirectory];
  810|      0|    NSString *copyablePath = [logDirectory stringByAppendingPathComponent:copyableFileName];
  811|      0|    NSError *copyableError = nil;
  812|      0|    if (![copyable writeToFile:copyablePath
  813|      0|                    atomically:NO
  814|      0|                      encoding:NSUTF8StringEncoding
  815|      0|                         error:&copyableError]) {
  816|      0|      // Error writing to file
  817|      0|      NSLog(@"%@ logging write error:%@ (%@)", [self class], copyableError, copyablePath);
  818|      0|    }
  819|      0|    [outputHTML appendString:@"<br><hr><p>"];
  820|      0|
  821|      0|    // Append the HTML to the main output file
  822|      0|    const char* htmlBytes = outputHTML.UTF8String;
  823|      0|    NSOutputStream *stream = [NSOutputStream outputStreamToFileAtPath:htmlPath
  824|      0|                                                               append:YES];
  825|      0|    [stream open];
  826|      0|    [stream write:(const uint8_t *) htmlBytes maxLength:strlen(htmlBytes)];
  827|      0|    [stream close];
  828|      0|
  829|      0|    // Make a symlink to the latest html
  830|      0|    NSString *const symlinkNameSuffix = [[self class] symlinkNameSuffix];
  831|      0|    NSString *symlinkName = [processName stringByAppendingString:symlinkNameSuffix];
  832|      0|    NSString *symlinkPath = [parentDir stringByAppendingPathComponent:symlinkName];
  833|      0|
  834|      0|    [fileMgr removeItemAtPath:symlinkPath error:NULL];
  835|      0|    [fileMgr createSymbolicLinkAtPath:symlinkPath
  836|      0|                  withDestinationPath:htmlPath
  837|      0|                                error:NULL];
  838|      0|#if TARGET_OS_IPHONE
  839|      0|    static BOOL gReportedLoggingPath = NO;
  840|      0|    if (!gReportedLoggingPath) {
  841|      0|      gReportedLoggingPath = YES;
  842|      0|      NSLog(@"GTMSessionFetcher logging to \"%@\"", parentDir);
  843|      0|    }
  844|      0|#endif
  845|      0|  }
  846|      0|}
  847|       |
  848|      0|- (NSInputStream *)loggedInputStreamForInputStream:(NSInputStream *)inputStream {
  849|      0|  if (!inputStream) return nil;
  850|      0|  if (![GTMSessionFetcher isLoggingEnabled]) return inputStream;
  851|      0|
  852|      0|  [self clearLoggedStreamData];  // Clear any previous data.
  853|      0|  Class monitorClass = NSClassFromString(@"GTMReadMonitorInputStream");
  854|      0|  if (!monitorClass) {
  855|      0|    NSString const *str = @"<<Uploaded stream log unavailable without GTMReadMonitorInputStream>>";
  856|      0|    NSData *stringData = [str dataUsingEncoding:NSUTF8StringEncoding];
  857|      0|    [self appendLoggedStreamData:stringData];
  858|      0|    return inputStream;
  859|      0|  }
  860|      0|  inputStream = [monitorClass inputStreamWithStream:inputStream];
  861|      0|
  862|      0|  GTMReadMonitorInputStream *readMonitorInputStream = (GTMReadMonitorInputStream *)inputStream;
  863|      0|  [readMonitorInputStream setReadDelegate:self];
  864|      0|  SEL readSel = @selector(inputStream:readIntoBuffer:length:);
  865|      0|  [readMonitorInputStream setReadSelector:readSel];
  866|      0|
  867|      0|  return inputStream;
  868|      0|}
  869|       |
  870|       |- (GTMSessionFetcherBodyStreamProvider)loggedStreamProviderForStreamProvider:
  871|      0|    (GTMSessionFetcherBodyStreamProvider)streamProvider {
  872|      0|  if (!streamProvider) return nil;
  873|      0|  if (![GTMSessionFetcher isLoggingEnabled]) return streamProvider;
  874|      0|
  875|      0|  [self clearLoggedStreamData];  // Clear any previous data.
  876|      0|  Class monitorClass = NSClassFromString(@"GTMReadMonitorInputStream");
  877|      0|  if (!monitorClass) {
  878|      0|    NSString const *str = @"<<Uploaded stream log unavailable without GTMReadMonitorInputStream>>";
  879|      0|    NSData *stringData = [str dataUsingEncoding:NSUTF8StringEncoding];
  880|      0|    [self appendLoggedStreamData:stringData];
  881|      0|    return streamProvider;
  882|      0|  }
  883|      0|  GTMSessionFetcherBodyStreamProvider loggedStreamProvider =
  884|      0|      ^(GTMSessionFetcherBodyStreamProviderResponse response) {
  885|      0|      streamProvider(^(NSInputStream *bodyStream) {
  886|      0|          bodyStream = [self loggedInputStreamForInputStream:bodyStream];
  887|      0|          response(bodyStream);
  888|      0|      });
  889|      0|  };
  890|      0|  return loggedStreamProvider;
  891|      0|}
  892|       |
  893|       |@end
  894|       |
  895|       |@implementation GTMSessionFetcher (GTMSessionFetcherLoggingUtilities)
  896|       |
  897|       |- (void)inputStream:(GTMReadMonitorInputStream *)stream
  898|       |     readIntoBuffer:(void *)buffer
  899|      0|             length:(int64_t)length {
  900|      0|  // append the captured data
  901|      0|  NSData *data = [NSData dataWithBytesNoCopy:buffer
  902|      0|                                      length:(NSUInteger)length
  903|      0|                                freeWhenDone:NO];
  904|      0|  [self appendLoggedStreamData:data];
  905|      0|}
  906|       |
  907|       |#pragma mark Fomatting Utilities
  908|       |
  909|       |+ (NSString *)snipSubstringOfString:(NSString *)originalStr
  910|       |                 betweenStartString:(NSString *)startStr
  911|      0|                          endString:(NSString *)endStr {
  912|       |#if SKIP_GTM_FETCH_LOGGING_SNIPPING
  913|       |  return originalStr;
  914|       |#else
  915|      0|  if (!originalStr) return nil;
  916|      0|
  917|      0|  // Find the start string, and replace everything between it
  918|      0|  // and the end string (or the end of the original string) with "_snip_"
  919|      0|  NSRange startRange = [originalStr rangeOfString:startStr];
  920|      0|  if (startRange.location == NSNotFound) return originalStr;
  921|      0|
  922|      0|  // We found the start string
  923|      0|  NSUInteger originalLength = originalStr.length;
  924|      0|  NSUInteger startOfTarget = NSMaxRange(startRange);
  925|      0|  NSRange targetAndRest = NSMakeRange(startOfTarget, originalLength - startOfTarget);
  926|      0|  NSRange endRange = [originalStr rangeOfString:endStr
  927|      0|                                        options:0
  928|      0|                                          range:targetAndRest];
  929|      0|  NSRange replaceRange;
  930|      0|  if (endRange.location == NSNotFound) {
  931|      0|    // Found no end marker so replace to end of string
  932|      0|    replaceRange = targetAndRest;
  933|      0|  } else {
  934|      0|    // Replace up to the endStr
  935|      0|    replaceRange = NSMakeRange(startOfTarget, endRange.location - startOfTarget);
  936|      0|  }
  937|      0|  NSString *result = [originalStr stringByReplacingCharactersInRange:replaceRange
  938|      0|                                                          withString:@"_snip_"];
  939|      0|  return result;
  940|      0|#endif // SKIP_GTM_FETCH_LOGGING_SNIPPING
  941|      0|}
  942|       |
  943|      0|+ (NSString *)headersStringForDictionary:(NSDictionary *)dict {
  944|      0|  // Format the dictionary in http header style, like
  945|      0|  //   Accept:        application/json
  946|      0|  //   Cache-Control: no-cache
  947|      0|  //   Content-Type:  application/json; charset=utf-8
  948|      0|  //
  949|      0|  // Pad the key names, but not beyond 16 chars, since long custom header
  950|      0|  // keys just create too much whitespace
  951|      0|  NSArray *keys = [dict.allKeys sortedArrayUsingSelector:@selector(compare:)];
  952|      0|
  953|      0|  NSMutableString *str = [NSMutableString string];
  954|      0|  for (NSString *key in keys) {
  955|      0|    NSString *value = [dict valueForKey:key];
  956|      0|    if ([key isEqual:@"Authorization"]) {
  957|      0|      // Remove OAuth 1 token
  958|      0|      value = [[self class] snipSubstringOfString:value
  959|      0|                               betweenStartString:@"oauth_token=\""
  960|      0|                                        endString:@"\""];
  961|      0|
  962|      0|      // Remove OAuth 2 bearer token (draft 16, and older form)
  963|      0|      value = [[self class] snipSubstringOfString:value
  964|      0|                               betweenStartString:@"Bearer "
  965|      0|                                        endString:@"\n"];
  966|      0|      value = [[self class] snipSubstringOfString:value
  967|      0|                               betweenStartString:@"OAuth "
  968|      0|                                        endString:@"\n"];
  969|      0|
  970|      0|      // Remove Google ClientLogin
  971|      0|      value = [[self class] snipSubstringOfString:value
  972|      0|                               betweenStartString:@"GoogleLogin auth="
  973|      0|                                        endString:@"\n"];
  974|      0|    }
  975|      0|    [str appendFormat:@"  %@: %@\n", key, value];
  976|      0|  }
  977|      0|  return str;
  978|      0|}
  979|       |
  980|       |@end
  981|       |
  982|       |#endif // !STRIP_GTM_FETCH_LOGGING

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GTMSessionFetcher/Source/GTMSessionFetcherService.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#import "GTMSessionFetcherService.h"
   21|       |
   22|       |NSString *const kGTMSessionFetcherServiceSessionBecameInvalidNotification
   23|       |    = @"kGTMSessionFetcherServiceSessionBecameInvalidNotification";
   24|       |NSString *const kGTMSessionFetcherServiceSessionKey
   25|       |    = @"kGTMSessionFetcherServiceSessionKey";
   26|       |
   27|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
   28|       |@interface GTMSessionFetcher (ServiceMethods)
   29|       |- (BOOL)beginFetchMayDelay:(BOOL)mayDelay
   30|       |              mayAuthorize:(BOOL)mayAuthorize;
   31|       |@end
   32|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
   33|       |
   34|       |@interface GTMSessionFetcherService ()
   35|       |
   36|       |@property(atomic, strong, readwrite) NSDictionary *delayedFetchersByHost;
   37|       |@property(atomic, strong, readwrite) NSDictionary *runningFetchersByHost;
   38|       |
   39|       |@end
   40|       |
   41|       |// Since NSURLSession doesn't support a separate delegate per task (!), instances of this
   42|       |// class serve as a session delegate trampoline.
   43|       |//
   44|       |// This class maps a session's tasks to fetchers, and resends delegate messages to the task's
   45|       |// fetcher.
   46|       |@interface GTMSessionFetcherSessionDelegateDispatcher : NSObject<NSURLSessionDelegate>
   47|       |
   48|       |// The session for the tasks in this dispatcher's task-to-fetcher map.
   49|       |@property(atomic) NSURLSession *session;
   50|       |
   51|       |// The timer interval for invalidating a session that has no active tasks.
   52|       |@property(atomic) NSTimeInterval discardInterval;
   53|       |
   54|       |// The current discard timer.
   55|       |@property(atomic, readonly) NSTimer *discardTimer;
   56|       |
   57|       |
   58|       |- (instancetype)initWithParentService:(GTMSessionFetcherService *)parentService
   59|       |               sessionDiscardInterval:(NSTimeInterval)discardInterval;
   60|       |
   61|       |- (void)setFetcher:(GTMSessionFetcher *)fetcher
   62|       |           forTask:(NSURLSessionTask *)task;
   63|       |- (void)removeFetcher:(GTMSessionFetcher *)fetcher;
   64|       |
   65|       |// Before using a session, tells the delegate dispatcher to stop the discard timer.
   66|       |- (void)startSessionUsage;
   67|       |
   68|       |// When abandoning a delegate dispatcher, we want to avoid the session retaining
   69|       |// the delegate after tasks complete.
   70|       |- (void)abandon;
   71|       |
   72|       |@end
   73|       |
   74|       |
   75|       |@implementation GTMSessionFetcherService {
   76|       |  NSMutableDictionary *_delayedFetchersByHost;
   77|       |  NSMutableDictionary *_runningFetchersByHost;
   78|       |  NSUInteger _maxRunningFetchersPerHost;
   79|       |
   80|       |  // When this ivar is nil, the service will not reuse sessions.
   81|       |  GTMSessionFetcherSessionDelegateDispatcher *_delegateDispatcher;
   82|       |
   83|       |  // Fetchers will wait on this if another fetcher is creating the shared NSURLSession.
   84|       |  dispatch_semaphore_t _sessionCreationSemaphore;
   85|       |
   86|       |  dispatch_queue_t _callbackQueue;
   87|       |  NSOperationQueue *_delegateQueue;
   88|       |  NSHTTPCookieStorage *_cookieStorage;
   89|       |  NSString *_userAgent;
   90|       |  NSTimeInterval _timeout;
   91|       |
   92|       |  NSURLCredential *_credential;       // Username & password.
   93|       |  NSURLCredential *_proxyCredential;  // Credential supplied to proxy servers.
   94|       |
   95|       |  NSInteger _cookieStorageMethod;
   96|       |
   97|       |  id<GTMFetcherAuthorizationProtocol> _authorizer;
   98|       |
   99|       |  // For waitForCompletionOfAllFetchersWithTimeout: we need to wait on stopped fetchers since
  100|       |  // they've not yet finished invoking their queued callbacks. This array is nil except when
  101|       |  // waiting on fetchers.
  102|       |  NSMutableArray *_stoppedFetchersToWaitFor;
  103|       |
  104|       |  // For fetchers that enqueued their callbacks before stopAllFetchers was called on the service,
  105|       |  // set a barrier so the callbacks know to bail out.
  106|       |  NSDate *_stoppedAllFetchersDate;
  107|       |}
  108|       |
  109|       |@synthesize maxRunningFetchersPerHost = _maxRunningFetchersPerHost,
  110|       |            configuration = _configuration,
  111|       |            configurationBlock = _configurationBlock,
  112|       |            cookieStorage = _cookieStorage,
  113|       |            userAgent = _userAgent,
  114|       |            challengeBlock = _challengeBlock,
  115|       |            credential = _credential,
  116|       |            proxyCredential = _proxyCredential,
  117|       |            allowedInsecureSchemes = _allowedInsecureSchemes,
  118|       |            allowLocalhostRequest = _allowLocalhostRequest,
  119|       |            allowInvalidServerCertificates = _allowInvalidServerCertificates,
  120|       |            retryEnabled = _retryEnabled,
  121|       |            retryBlock = _retryBlock,
  122|       |            maxRetryInterval = _maxRetryInterval,
  123|       |            minRetryInterval = _minRetryInterval,
  124|       |            properties = _properties,
  125|       |            unusedSessionTimeout = _unusedSessionTimeout,
  126|       |            testBlock = _testBlock;
  127|       |
  128|       |#if GTM_BACKGROUND_TASK_FETCHING
  129|       |@synthesize skipBackgroundTask = _skipBackgroundTask;
  130|       |#endif
  131|       |
  132|      0|- (instancetype)init {
  133|      0|  self = [super init];
  134|      0|  if (self) {
  135|      0|    _delayedFetchersByHost = [[NSMutableDictionary alloc] init];
  136|      0|    _runningFetchersByHost = [[NSMutableDictionary alloc] init];
  137|      0|    _maxRunningFetchersPerHost = 10;
  138|      0|    _cookieStorageMethod = -1;
  139|      0|    _unusedSessionTimeout = 60.0;
  140|      0|    _delegateDispatcher =
  141|      0|        [[GTMSessionFetcherSessionDelegateDispatcher alloc] initWithParentService:self
  142|      0|                                                           sessionDiscardInterval:_unusedSessionTimeout];
  143|      0|    _callbackQueue = dispatch_get_main_queue();
  144|      0|
  145|      0|    _delegateQueue = [[NSOperationQueue alloc] init];
  146|      0|    _delegateQueue.maxConcurrentOperationCount = 1;
  147|      0|    _delegateQueue.name = @"com.google.GTMSessionFetcher.NSURLSessionDelegateQueue";
  148|      0|
  149|      0|    _sessionCreationSemaphore = dispatch_semaphore_create(1);
  150|      0|
  151|      0|    // Starting with the SDKs for OS X 10.11/iOS 9, the service has a default useragent.
  152|      0|    // Apps can remove this and get the default system "CFNetwork" useragent by setting the
  153|      0|    // fetcher service's userAgent property to nil.
  154|      0|#if (!TARGET_OS_IPHONE && defined(MAC_OS_X_VERSION_10_11) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11) \
  155|      0|    || (TARGET_OS_IPHONE && defined(__IPHONE_9_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_9_0)
  156|      0|    _userAgent = GTMFetcherStandardUserAgentString(nil);
  157|      0|#endif
  158|      0|  }
  159|      0|  return self;
  160|      0|}
  161|       |
  162|      0|- (void)dealloc {
  163|      0|  [self detachAuthorizer];
  164|      0|  [_delegateDispatcher abandon];
  165|      0|}
  166|       |
  167|       |#pragma mark Generate a new fetcher
  168|       |
  169|       |// Clients may override this method. Clients should not override any other library methods.
  170|       |- (id)fetcherWithRequest:(NSURLRequest *)request
  171|      0|            fetcherClass:(Class)fetcherClass {
  172|      0|  GTMSessionFetcher *fetcher = [[fetcherClass alloc] initWithRequest:request
  173|      0|                                                       configuration:self.configuration];
  174|      0|  fetcher.callbackQueue = self.callbackQueue;
  175|      0|  fetcher.sessionDelegateQueue = self.sessionDelegateQueue;
  176|      0|  fetcher.challengeBlock = self.challengeBlock;
  177|      0|  fetcher.credential = self.credential;
  178|      0|  fetcher.proxyCredential = self.proxyCredential;
  179|      0|  fetcher.authorizer = self.authorizer;
  180|      0|  fetcher.cookieStorage = self.cookieStorage;
  181|      0|  fetcher.allowedInsecureSchemes = self.allowedInsecureSchemes;
  182|      0|  fetcher.allowLocalhostRequest = self.allowLocalhostRequest;
  183|      0|  fetcher.allowInvalidServerCertificates = self.allowInvalidServerCertificates;
  184|      0|  fetcher.configurationBlock = self.configurationBlock;
  185|      0|  fetcher.retryEnabled = self.retryEnabled;
  186|      0|  fetcher.retryBlock = self.retryBlock;
  187|      0|  fetcher.maxRetryInterval = self.maxRetryInterval;
  188|      0|  fetcher.minRetryInterval = self.minRetryInterval;
  189|      0|  fetcher.properties = self.properties;
  190|      0|  fetcher.service = self;
  191|      0|  if (self.cookieStorageMethod >= 0) {
  192|      0|    [fetcher setCookieStorageMethod:self.cookieStorageMethod];
  193|      0|  }
  194|      0|
  195|      0|#if GTM_BACKGROUND_TASK_FETCHING
  196|      0|  fetcher.skipBackgroundTask = self.skipBackgroundTask;
  197|      0|#endif
  198|      0|
  199|      0|  NSString *userAgent = self.userAgent;
  200|      0|  if (userAgent.length > 0
  201|      0|      && [request valueForHTTPHeaderField:@"User-Agent"] == nil) {
  202|      0|    [fetcher setRequestValue:userAgent
  203|      0|          forHTTPHeaderField:@"User-Agent"];
  204|      0|  }
  205|      0|  fetcher.testBlock = self.testBlock;
  206|      0|
  207|      0|  return fetcher;
  208|      0|}
  209|       |
  210|      0|- (GTMSessionFetcher *)fetcherWithRequest:(NSURLRequest *)request {
  211|      0|  return [self fetcherWithRequest:request
  212|      0|                     fetcherClass:[GTMSessionFetcher class]];
  213|      0|}
  214|       |
  215|      0|- (GTMSessionFetcher *)fetcherWithURL:(NSURL *)requestURL {
  216|      0|  return [self fetcherWithRequest:[NSURLRequest requestWithURL:requestURL]];
  217|      0|}
  218|       |
  219|      0|- (GTMSessionFetcher *)fetcherWithURLString:(NSString *)requestURLString {
  220|      0|  NSURL *url = [NSURL URLWithString:requestURLString];
  221|      0|  return [self fetcherWithURL:url];
  222|      0|}
  223|       |
  224|       |// Returns a session for the fetcher's host, or nil.
  225|      0|- (NSURLSession *)session {
  226|      0|  @synchronized(self) {
  227|      0|    GTMSessionMonitorSynchronized(self);
  228|      0|
  229|      0|    NSURLSession *session = _delegateDispatcher.session;
  230|      0|    return session;
  231|      0|  }
  232|      0|}
  233|       |
  234|       |// Returns a session for the fetcher's host, or nil.  For shared sessions, this
  235|       |// waits on a semaphore, blocking other fetchers while the caller creates the
  236|       |// session if needed.
  237|      0|- (NSURLSession *)sessionForFetcherCreation {
  238|      0|  @synchronized(self) {
  239|      0|    GTMSessionMonitorSynchronized(self);
  240|      0|    if (!_delegateDispatcher) {
  241|      0|      // This fetcher is creating a non-shared session, so skip the semaphore usage.
  242|      0|      return nil;
  243|      0|    }
  244|      0|  }
  245|      0|
  246|      0|  // Wait if another fetcher is currently creating a session; avoid waiting
  247|      0|  // inside the @synchronized block, as that can deadlock.
  248|      0|  dispatch_semaphore_wait(_sessionCreationSemaphore, DISPATCH_TIME_FOREVER);
  249|      0|
  250|      0|  @synchronized(self) {
  251|      0|    GTMSessionMonitorSynchronized(self);
  252|      0|
  253|      0|    // Before getting the NSURLSession for task creation, it is
  254|      0|    // important to invalidate and nil out the session discard timer; otherwise
  255|      0|    // the session can be invalidated between when it is returned to the
  256|      0|    // fetcher, and when the fetcher attempts to create its NSURLSessionTask.
  257|      0|    [_delegateDispatcher startSessionUsage];
  258|      0|
  259|      0|    NSURLSession *session = _delegateDispatcher.session;
  260|      0|    if (session) {
  261|      0|      // The calling fetcher will receive a preexisting session, so
  262|      0|      // we can allow other fetchers to create a session.
  263|      0|      dispatch_semaphore_signal(_sessionCreationSemaphore);
  264|      0|    } else {
  265|      0|      // No existing session was obtained, so the calling fetcher will create the session;
  266|      0|      // it *must* invoke fetcherDidCreateSession: to signal the dispatcher's semaphore after
  267|      0|      // the session has been created (or fails to be created) to avoid a hang.
  268|      0|    }
  269|      0|    return session;
  270|      0|  }
  271|      0|}
  272|       |
  273|      0|- (id<NSURLSessionDelegate>)sessionDelegate {
  274|      0|  @synchronized(self) {
  275|      0|    GTMSessionMonitorSynchronized(self);
  276|      0|
  277|      0|    return _delegateDispatcher;
  278|      0|  }
  279|      0|}
  280|       |
  281|       |#pragma mark Queue Management
  282|       |
  283|       |- (void)addRunningFetcher:(GTMSessionFetcher *)fetcher
  284|      0|                  forHost:(NSString *)host {
  285|      0|  // Add to the array of running fetchers for this host, creating the array if needed.
  286|      0|  NSMutableArray *runningForHost = [_runningFetchersByHost objectForKey:host];
  287|      0|  if (runningForHost == nil) {
  288|      0|    runningForHost = [NSMutableArray arrayWithObject:fetcher];
  289|      0|    [_runningFetchersByHost setObject:runningForHost forKey:host];
  290|      0|  } else {
  291|      0|    [runningForHost addObject:fetcher];
  292|      0|  }
  293|      0|}
  294|       |
  295|       |- (void)addDelayedFetcher:(GTMSessionFetcher *)fetcher
  296|      0|                  forHost:(NSString *)host {
  297|      0|  // Add to the array of delayed fetchers for this host, creating the array if needed.
  298|      0|  NSMutableArray *delayedForHost = [_delayedFetchersByHost objectForKey:host];
  299|      0|  if (delayedForHost == nil) {
  300|      0|    delayedForHost = [NSMutableArray arrayWithObject:fetcher];
  301|      0|    [_delayedFetchersByHost setObject:delayedForHost forKey:host];
  302|      0|  } else {
  303|      0|    [delayedForHost addObject:fetcher];
  304|      0|  }
  305|      0|}
  306|       |
  307|      0|- (BOOL)isDelayingFetcher:(GTMSessionFetcher *)fetcher {
  308|      0|  @synchronized(self) {
  309|      0|    GTMSessionMonitorSynchronized(self);
  310|      0|
  311|      0|    NSString *host = fetcher.request.URL.host;
  312|      0|    if (host == nil) {
  313|      0|      return NO;
  314|      0|    }
  315|      0|    NSArray *delayedForHost = [_delayedFetchersByHost objectForKey:host];
  316|      0|    NSUInteger idx = [delayedForHost indexOfObjectIdenticalTo:fetcher];
  317|      0|    BOOL isDelayed = (delayedForHost != nil) && (idx != NSNotFound);
  318|      0|    return isDelayed;
  319|      0|  }
  320|      0|}
  321|       |
  322|      0|- (BOOL)fetcherShouldBeginFetching:(GTMSessionFetcher *)fetcher {
  323|      0|  // Entry point from the fetcher
  324|      0|  NSURL *requestURL = fetcher.request.URL;
  325|      0|  NSString *host = requestURL.host;
  326|      0|
  327|      0|  // Addresses "file:///path" case where localhost is the implicit host.
  328|      0|  if (host.length == 0 && [requestURL isFileURL]) {
  329|      0|    host = @"localhost";
  330|      0|  }
  331|      0|
  332|      0|  if (host.length == 0) {
  333|      0|    // Data URIs legitimately have no host, reject other hostless URLs.
  334|      0|    GTMSESSION_ASSERT_DEBUG([[requestURL scheme] isEqual:@"data"], @"%@ lacks host", fetcher);
  335|      0|    return YES;
  336|      0|  }
  337|      0|
  338|      0|  BOOL shouldBeginResult;
  339|      0|
  340|      0|  @synchronized(self) {
  341|      0|    GTMSessionMonitorSynchronized(self);
  342|      0|
  343|      0|    NSMutableArray *runningForHost = [_runningFetchersByHost objectForKey:host];
  344|      0|    if (runningForHost != nil
  345|      0|        && [runningForHost indexOfObjectIdenticalTo:fetcher] != NSNotFound) {
  346|      0|      GTMSESSION_ASSERT_DEBUG(NO, @"%@ was already running", fetcher);
  347|      0|      return YES;
  348|      0|    }
  349|      0|
  350|      0|    BOOL shouldRunNow = (fetcher.usingBackgroundSession
  351|      0|                         || _maxRunningFetchersPerHost == 0
  352|      0|                         || _maxRunningFetchersPerHost >
  353|      0|                         [[self class] numberOfNonBackgroundSessionFetchers:runningForHost]);
  354|      0|    if (shouldRunNow) {
  355|      0|      [self addRunningFetcher:fetcher forHost:host];
  356|      0|      shouldBeginResult = YES;
  357|      0|    } else {
  358|      0|      [self addDelayedFetcher:fetcher forHost:host];
  359|      0|      shouldBeginResult = NO;
  360|      0|    }
  361|      0|  }  // @synchronized(self)
  362|      0|
  363|      0|  // We'll save the host that serves as the key for this fetcher's array
  364|      0|  // to avoid any chance of the underlying request changing, stranding
  365|      0|  // the fetcher in the wrong array
  366|      0|  fetcher.serviceHost = host;
  367|      0|
  368|      0|  return shouldBeginResult;
  369|      0|}
  370|       |
  371|      0|- (void)startFetcher:(GTMSessionFetcher *)fetcher {
  372|      0|  [fetcher beginFetchMayDelay:NO
  373|      0|                 mayAuthorize:YES];
  374|      0|}
  375|       |
  376|       |// Internal utility. Returns a fetcher's delegate if it's a dispatcher, or nil if the fetcher
  377|       |// is its own delegate (possibly via proxy) and has no dispatcher.
  378|      0|- (GTMSessionFetcherSessionDelegateDispatcher *)delegateDispatcherForFetcher:(GTMSessionFetcher *)fetcher {
  379|      0|  GTMSessionCheckNotSynchronized(self);
  380|      0|
  381|      0|  NSURLSession *fetcherSession = fetcher.session;
  382|      0|  if (fetcherSession) {
  383|      0|    id<NSURLSessionDelegate> fetcherDelegate = fetcherSession.delegate;
  384|      0|    // If the delegate is non-nil and claims to be a GTMSessionFetcher, there is no dispatcher;
  385|      0|    // assume the fetcher is the delegate or has been proxied (some third-party frameworks
  386|      0|    // are known to swizzle NSURLSession to proxy its delegate).
  387|      0|    BOOL hasDispatcher = (fetcherDelegate != nil &&
  388|      0|                          ![fetcherDelegate isKindOfClass:[GTMSessionFetcher class]]);
  389|      0|    if (hasDispatcher) {
  390|      0|      GTMSESSION_ASSERT_DEBUG([fetcherDelegate isKindOfClass:[GTMSessionFetcherSessionDelegateDispatcher class]],
  391|      0|                              @"Fetcher delegate class: %@", [fetcherDelegate class]);
  392|      0|      return (GTMSessionFetcherSessionDelegateDispatcher *)fetcherDelegate;
  393|      0|    }
  394|      0|  }
  395|      0|  return nil;
  396|      0|}
  397|       |
  398|      0|- (void)fetcherDidCreateSession:(GTMSessionFetcher *)fetcher {
  399|      0|  if (fetcher.canShareSession) {
  400|      0|    NSURLSession *fetcherSession = fetcher.session;
  401|      0|    GTMSESSION_ASSERT_DEBUG(fetcherSession != nil, @"Fetcher missing its session: %@", fetcher);
  402|      0|
  403|      0|    GTMSessionFetcherSessionDelegateDispatcher *delegateDispatcher =
  404|      0|        [self delegateDispatcherForFetcher:fetcher];
  405|      0|    if (delegateDispatcher) {
  406|      0|      GTMSESSION_ASSERT_DEBUG(delegateDispatcher.session == nil,
  407|      0|                              @"Fetcher made an extra session: %@", fetcher);
  408|      0|
  409|      0|      // Save this fetcher's session.
  410|      0|      delegateDispatcher.session = fetcherSession;
  411|      0|
  412|      0|      // Allow other fetchers to request this session now.
  413|      0|      dispatch_semaphore_signal(_sessionCreationSemaphore);
  414|      0|    }
  415|      0|  }
  416|      0|}
  417|       |
  418|      0|- (void)fetcherDidBeginFetching:(GTMSessionFetcher *)fetcher {
  419|      0|  // If this fetcher has a separate delegate with a shared session, then
  420|      0|  // this fetcher should be added to the delegate's map of tasks to fetchers.
  421|      0|  GTMSessionFetcherSessionDelegateDispatcher *delegateDispatcher =
  422|      0|      [self delegateDispatcherForFetcher:fetcher];
  423|      0|  if (delegateDispatcher) {
  424|      0|    GTMSESSION_ASSERT_DEBUG(fetcher.canShareSession,
  425|      0|                            @"Inappropriate shared session: %@", fetcher);
  426|      0|
  427|      0|    // There should already be a session, from this or a previous fetcher.
  428|      0|    //
  429|      0|    // Sanity check that the fetcher's session is the delegate's shared session.
  430|      0|    NSURLSession *sharedSession = delegateDispatcher.session;
  431|      0|    NSURLSession *fetcherSession = fetcher.session;
  432|      0|    GTMSESSION_ASSERT_DEBUG(sharedSession != nil, @"Missing delegate session: %@", fetcher);
  433|      0|    GTMSESSION_ASSERT_DEBUG(fetcherSession == sharedSession,
  434|      0|                            @"Inconsistent session: %@ %@ (shared: %@)",
  435|      0|                            fetcher, fetcherSession, sharedSession);
  436|      0|
  437|      0|    if (sharedSession != nil && fetcherSession == sharedSession) {
  438|      0|      NSURLSessionTask *task = fetcher.sessionTask;
  439|      0|      GTMSESSION_ASSERT_DEBUG(task != nil, @"Missing session task: %@", fetcher);
  440|      0|
  441|      0|      if (task) {
  442|      0|        [delegateDispatcher setFetcher:fetcher
  443|      0|                               forTask:task];
  444|      0|      }
  445|      0|    }
  446|      0|  }
  447|      0|}
  448|       |
  449|      0|- (void)stopFetcher:(GTMSessionFetcher *)fetcher {
  450|      0|  [fetcher stopFetching];
  451|      0|}
  452|       |
  453|      0|- (void)fetcherDidStop:(GTMSessionFetcher *)fetcher {
  454|      0|  // Entry point from the fetcher
  455|      0|  NSString *host = fetcher.serviceHost;
  456|      0|  if (!host) {
  457|      0|    // fetcher has been stopped previously
  458|      0|    return;
  459|      0|  }
  460|      0|
  461|      0|  // This removeFetcher: invocation is a fallback; typically, fetchers are removed from the task
  462|      0|  // map when the task completes.
  463|      0|  GTMSessionFetcherSessionDelegateDispatcher *delegateDispatcher =
  464|      0|      [self delegateDispatcherForFetcher:fetcher];
  465|      0|  [delegateDispatcher removeFetcher:fetcher];
  466|      0|
  467|      0|  NSMutableArray *fetchersToStart;
  468|      0|
  469|      0|  @synchronized(self) {
  470|      0|    GTMSessionMonitorSynchronized(self);
  471|      0|
  472|      0|    // If a test is waiting for all fetchers to stop, it needs to wait for this one
  473|      0|    // to invoke its callbacks on the callback queue.
  474|      0|    [_stoppedFetchersToWaitFor addObject:fetcher];
  475|      0|
  476|      0|    NSMutableArray *runningForHost = [_runningFetchersByHost objectForKey:host];
  477|      0|    [runningForHost removeObject:fetcher];
  478|      0|
  479|      0|    NSMutableArray *delayedForHost = [_delayedFetchersByHost objectForKey:host];
  480|      0|    [delayedForHost removeObject:fetcher];
  481|      0|
  482|      0|    while (delayedForHost.count > 0
  483|      0|           && [[self class] numberOfNonBackgroundSessionFetchers:runningForHost]
  484|      0|              < _maxRunningFetchersPerHost) {
  485|      0|      // Start another delayed fetcher running, scanning for the minimum
  486|      0|      // priority value, defaulting to FIFO for equal priorities
  487|      0|      GTMSessionFetcher *nextFetcher = nil;
  488|      0|      for (GTMSessionFetcher *delayedFetcher in delayedForHost) {
  489|      0|        if (nextFetcher == nil
  490|      0|            || delayedFetcher.servicePriority < nextFetcher.servicePriority) {
  491|      0|          nextFetcher = delayedFetcher;
  492|      0|        }
  493|      0|      }
  494|      0|
  495|      0|      if (nextFetcher) {
  496|      0|        [self addRunningFetcher:nextFetcher forHost:host];
  497|      0|        runningForHost = [_runningFetchersByHost objectForKey:host];
  498|      0|
  499|      0|        [delayedForHost removeObjectIdenticalTo:nextFetcher];
  500|      0|
  501|      0|        if (!fetchersToStart) {
  502|      0|          fetchersToStart = [NSMutableArray array];
  503|      0|        }
  504|      0|        [fetchersToStart addObject:nextFetcher];
  505|      0|      }
  506|      0|    }
  507|      0|
  508|      0|    if (runningForHost.count == 0) {
  509|      0|      // None left; remove the empty array
  510|      0|      [_runningFetchersByHost removeObjectForKey:host];
  511|      0|    }
  512|      0|
  513|      0|    if (delayedForHost.count == 0) {
  514|      0|      [_delayedFetchersByHost removeObjectForKey:host];
  515|      0|    }
  516|      0|  }  // @synchronized(self)
  517|      0|
  518|      0|  // Start fetchers outside of the synchronized block to avoid a deadlock.
  519|      0|  for (GTMSessionFetcher *nextFetcher in fetchersToStart) {
  520|      0|    [self startFetcher:nextFetcher];
  521|      0|  }
  522|      0|
  523|      0|  // The fetcher is no longer in the running or the delayed array,
  524|      0|  // so remove its host and thread properties
  525|      0|  fetcher.serviceHost = nil;
  526|      0|}
  527|       |
  528|      0|- (NSUInteger)numberOfFetchers {
  529|      0|  NSUInteger running = [self numberOfRunningFetchers];
  530|      0|  NSUInteger delayed = [self numberOfDelayedFetchers];
  531|      0|  return running + delayed;
  532|      0|}
  533|       |
  534|      0|- (NSUInteger)numberOfRunningFetchers {
  535|      0|  @synchronized(self) {
  536|      0|    GTMSessionMonitorSynchronized(self);
  537|      0|
  538|      0|    NSUInteger sum = 0;
  539|      0|    for (NSString *host in _runningFetchersByHost) {
  540|      0|      NSArray *fetchers = [_runningFetchersByHost objectForKey:host];
  541|      0|      sum += fetchers.count;
  542|      0|    }
  543|      0|    return sum;
  544|      0|  }
  545|      0|}
  546|       |
  547|      0|- (NSUInteger)numberOfDelayedFetchers {
  548|      0|  @synchronized(self) {
  549|      0|    GTMSessionMonitorSynchronized(self);
  550|      0|
  551|      0|    NSUInteger sum = 0;
  552|      0|    for (NSString *host in _delayedFetchersByHost) {
  553|      0|      NSArray *fetchers = [_delayedFetchersByHost objectForKey:host];
  554|      0|      sum += fetchers.count;
  555|      0|    }
  556|      0|    return sum;
  557|      0|  }
  558|      0|}
  559|       |
  560|      0|- (NSArray *)issuedFetchers {
  561|      0|  @synchronized(self) {
  562|      0|    GTMSessionMonitorSynchronized(self);
  563|      0|
  564|      0|    NSMutableArray *allFetchers = [NSMutableArray array];
  565|      0|    void (^accumulateFetchers)(id, id, BOOL *) = ^(NSString *host,
  566|      0|                                                   NSArray *fetchersForHost,
  567|      0|                                                   BOOL *stop) {
  568|      0|        [allFetchers addObjectsFromArray:fetchersForHost];
  569|      0|    };
  570|      0|    [_runningFetchersByHost enumerateKeysAndObjectsUsingBlock:accumulateFetchers];
  571|      0|    [_delayedFetchersByHost enumerateKeysAndObjectsUsingBlock:accumulateFetchers];
  572|      0|
  573|      0|    GTMSESSION_ASSERT_DEBUG(allFetchers.count == [NSSet setWithArray:allFetchers].count,
  574|      0|                            @"Fetcher appears multiple times\n running: %@\n delayed: %@",
  575|      0|                            _runningFetchersByHost, _delayedFetchersByHost);
  576|      0|
  577|      0|    return allFetchers.count > 0 ? allFetchers : nil;
  578|      0|  }
  579|      0|}
  580|       |
  581|      0|- (NSArray *)issuedFetchersWithRequestURL:(NSURL *)requestURL {
  582|      0|  NSString *host = requestURL.host;
  583|      0|  if (host.length == 0) return nil;
  584|      0|
  585|      0|  NSURL *targetURL = [requestURL absoluteURL];
  586|      0|
  587|      0|  NSArray *allFetchers = [self issuedFetchers];
  588|      0|  NSIndexSet *indexes = [allFetchers indexesOfObjectsPassingTest:^BOOL(GTMSessionFetcher *fetcher,
  589|      0|                                                                       NSUInteger idx,
  590|      0|                                                                       BOOL *stop) {
  591|      0|      NSURL *fetcherURL = [fetcher.request.URL absoluteURL];
  592|      0|      return [fetcherURL isEqual:targetURL];
  593|      0|  }];
  594|      0|
  595|      0|  NSArray *result = nil;
  596|      0|  if (indexes.count > 0) {
  597|      0|    result = [allFetchers objectsAtIndexes:indexes];
  598|      0|  }
  599|      0|  return result;
  600|      0|}
  601|       |
  602|      0|- (void)stopAllFetchers {
  603|      0|  NSArray *delayedFetchersByHost;
  604|      0|  NSArray *runningFetchersByHost;
  605|      0|
  606|      0|  @synchronized(self) {
  607|      0|    GTMSessionMonitorSynchronized(self);
  608|      0|
  609|      0|    // Set the time barrier so fetchers know not to call back even if
  610|      0|    // the stop calls below occur after the fetchers naturally
  611|      0|    // stopped and so were removed from _runningFetchersByHost,
  612|      0|    // but while the callbacks were already enqueued before stopAllFetchers
  613|      0|    // was invoked.
  614|      0|    _stoppedAllFetchersDate = [[NSDate alloc] init];
  615|      0|
  616|      0|    // Remove fetchers from the delayed list to avoid fetcherDidStop: from
  617|      0|    // starting more fetchers running as a side effect of stopping one
  618|      0|    delayedFetchersByHost = _delayedFetchersByHost.allValues;
  619|      0|    [_delayedFetchersByHost removeAllObjects];
  620|      0|
  621|      0|    runningFetchersByHost = _runningFetchersByHost.allValues;
  622|      0|    [_runningFetchersByHost removeAllObjects];
  623|      0|  }
  624|      0|
  625|      0|  for (NSArray *delayedForHost in delayedFetchersByHost) {
  626|      0|    for (GTMSessionFetcher *fetcher in delayedForHost) {
  627|      0|      [self stopFetcher:fetcher];
  628|      0|    }
  629|      0|  }
  630|      0|
  631|      0|  for (NSArray *runningForHost in runningFetchersByHost) {
  632|      0|    for (GTMSessionFetcher *fetcher in runningForHost) {
  633|      0|      [self stopFetcher:fetcher];
  634|      0|    }
  635|      0|  }
  636|      0|}
  637|       |
  638|      0|- (NSDate *)stoppedAllFetchersDate {
  639|      0|  @synchronized(self) {
  640|      0|    GTMSessionMonitorSynchronized(self);
  641|      0|
  642|      0|    return _stoppedAllFetchersDate;
  643|      0|  }
  644|      0|}
  645|       |
  646|       |#pragma mark Accessors
  647|       |
  648|      0|- (BOOL)reuseSession {
  649|      0|  @synchronized(self) {
  650|      0|    GTMSessionMonitorSynchronized(self);
  651|      0|
  652|      0|    return _delegateDispatcher != nil;
  653|      0|  }
  654|      0|}
  655|       |
  656|      0|- (void)setReuseSession:(BOOL)shouldReuse {
  657|      0|  @synchronized(self) {
  658|      0|    GTMSessionMonitorSynchronized(self);
  659|      0|
  660|      0|    BOOL wasReusing = (_delegateDispatcher != nil);
  661|      0|    if (shouldReuse != wasReusing) {
  662|      0|      [self abandonDispatcher];
  663|      0|      if (shouldReuse) {
  664|      0|        _delegateDispatcher =
  665|      0|            [[GTMSessionFetcherSessionDelegateDispatcher alloc] initWithParentService:self
  666|      0|                                                               sessionDiscardInterval:_unusedSessionTimeout];
  667|      0|      } else {
  668|      0|        _delegateDispatcher = nil;
  669|      0|      }
  670|      0|    }
  671|      0|  }
  672|      0|}
  673|       |
  674|      0|- (void)resetSession {
  675|      0|  GTMSessionCheckNotSynchronized(self);
  676|      0|  dispatch_semaphore_wait(_sessionCreationSemaphore, DISPATCH_TIME_FOREVER);
  677|      0|
  678|      0|  @synchronized(self) {
  679|      0|    GTMSessionMonitorSynchronized(self);
  680|      0|    [self resetSessionInternal];
  681|      0|  }
  682|      0|
  683|      0|  dispatch_semaphore_signal(_sessionCreationSemaphore);
  684|      0|}
  685|       |
  686|      0|- (void)resetSessionInternal {
  687|      0|  GTMSessionCheckSynchronized(self);
  688|      0|
  689|      0|  // The old dispatchers may be retained as delegates of any ongoing sessions by those sessions.
  690|      0|  if (_delegateDispatcher) {
  691|      0|    [self abandonDispatcher];
  692|      0|    _delegateDispatcher =
  693|      0|        [[GTMSessionFetcherSessionDelegateDispatcher alloc] initWithParentService:self
  694|      0|                                                           sessionDiscardInterval:_unusedSessionTimeout];
  695|      0|  }
  696|      0|}
  697|       |
  698|      0|- (void)resetSessionForDispatcherDiscardTimer:(NSTimer *)timer {
  699|      0|  GTMSessionCheckNotSynchronized(self);
  700|      0|
  701|      0|  dispatch_semaphore_wait(_sessionCreationSemaphore, DISPATCH_TIME_FOREVER);
  702|      0|  @synchronized(self) {
  703|      0|    GTMSessionMonitorSynchronized(self);
  704|      0|
  705|      0|    if (_delegateDispatcher.discardTimer == timer) {
  706|      0|      // If the delegate dispatcher's current discardTimer is the same object as the timer
  707|      0|      // that fired, no fetcher has recently attempted to start using the session by calling
  708|      0|      // startSessionUsage, which invalidates and nils out the timer.
  709|      0|      [self resetSessionInternal];
  710|      0|    } else {
  711|      0|      // A fetcher has invalidated the timer between its triggering and now, potentially
  712|      0|      // meaning a fetcher has requested access to the NSURLSession, and may be in the process
  713|      0|      // of starting a new task. The dispatcher should not be abandoned, as this can lead
  714|      0|      // to a race condition between calling -finishTasksAndInvalidate on the NSURLSession
  715|      0|      // and the fetcher attempting to create a new task.
  716|      0|    }
  717|      0|  }
  718|      0|
  719|      0|  dispatch_semaphore_signal(_sessionCreationSemaphore);
  720|      0|}
  721|       |
  722|      0|- (NSTimeInterval)unusedSessionTimeout {
  723|      0|  @synchronized(self) {
  724|      0|    GTMSessionMonitorSynchronized(self);
  725|      0|
  726|      0|    return _unusedSessionTimeout;
  727|      0|  }
  728|      0|}
  729|       |
  730|      0|- (void)setUnusedSessionTimeout:(NSTimeInterval)timeout {
  731|      0|  @synchronized(self) {
  732|      0|    GTMSessionMonitorSynchronized(self);
  733|      0|
  734|      0|    _unusedSessionTimeout = timeout;
  735|      0|    _delegateDispatcher.discardInterval = timeout;
  736|      0|  }
  737|      0|}
  738|       |
  739|       |// This method should be called inside of @synchronized(self)
  740|      0|- (void)abandonDispatcher {
  741|      0|  GTMSessionCheckSynchronized(self);
  742|      0|  [_delegateDispatcher abandon];
  743|      0|}
  744|       |
  745|      0|- (NSDictionary *)runningFetchersByHost {
  746|      0|  @synchronized(self) {
  747|      0|    GTMSessionMonitorSynchronized(self);
  748|      0|
  749|      0|    return [_runningFetchersByHost copy];
  750|      0|  }
  751|      0|}
  752|       |
  753|      0|- (void)setRunningFetchersByHost:(NSDictionary *)dict {
  754|      0|  @synchronized(self) {
  755|      0|    GTMSessionMonitorSynchronized(self);
  756|      0|
  757|      0|    _runningFetchersByHost = [dict mutableCopy];
  758|      0|  }
  759|      0|}
  760|       |
  761|      0|- (NSDictionary *)delayedFetchersByHost {
  762|      0|  @synchronized(self) {
  763|      0|    GTMSessionMonitorSynchronized(self);
  764|      0|
  765|      0|    return [_delayedFetchersByHost copy];
  766|      0|  }
  767|      0|}
  768|       |
  769|      0|- (void)setDelayedFetchersByHost:(NSDictionary *)dict {
  770|      0|  @synchronized(self) {
  771|      0|    GTMSessionMonitorSynchronized(self);
  772|      0|
  773|      0|    _delayedFetchersByHost = [dict mutableCopy];
  774|      0|  }
  775|      0|}
  776|       |
  777|      0|- (id<GTMFetcherAuthorizationProtocol>)authorizer {
  778|      0|  @synchronized(self) {
  779|      0|    GTMSessionMonitorSynchronized(self);
  780|      0|
  781|      0|    return _authorizer;
  782|      0|  }
  783|      0|}
  784|       |
  785|      0|- (void)setAuthorizer:(id<GTMFetcherAuthorizationProtocol>)obj {
  786|      0|  @synchronized(self) {
  787|      0|    GTMSessionMonitorSynchronized(self);
  788|      0|
  789|      0|    if (obj != _authorizer) {
  790|      0|      [self detachAuthorizer];
  791|      0|    }
  792|      0|
  793|      0|    _authorizer = obj;
  794|      0|  }
  795|      0|
  796|      0|  // Use the fetcher service for the authorization fetches if the auth
  797|      0|  // object supports fetcher services
  798|      0|  if ([obj respondsToSelector:@selector(setFetcherService:)]) {
  799|      0|#if GTM_USE_SESSION_FETCHER
  800|      0|    [obj setFetcherService:self];
  801|       |#else
  802|       |    [obj setFetcherService:(id)self];
  803|       |#endif
  804|       |  }
  805|      0|}
  806|       |
  807|       |// This should be called inside a @synchronized(self) block except during dealloc.
  808|      0|- (void)detachAuthorizer {
  809|      0|  // This method is called by the fetcher service's dealloc and setAuthorizer:
  810|      0|  // methods; do not override.
  811|      0|  //
  812|      0|  // The fetcher service retains the authorizer, and the authorizer has a
  813|      0|  // weak pointer to the fetcher service (a non-zeroing pointer for
  814|      0|  // compatibility with iOS 4 and Mac OS X 10.5/10.6.)
  815|      0|  //
  816|      0|  // When this fetcher service no longer uses the authorizer, we want to remove
  817|      0|  // the authorizer's dependence on the fetcher service.  Authorizers can still
  818|      0|  // function without a fetcher service.
  819|      0|  if ([_authorizer respondsToSelector:@selector(fetcherService)]) {
  820|      0|    id authFetcherService = [_authorizer fetcherService];
  821|      0|    if (authFetcherService == self) {
  822|      0|      [_authorizer setFetcherService:nil];
  823|      0|    }
  824|      0|  }
  825|      0|}
  826|       |
  827|      0|- (dispatch_queue_t GTM_NONNULL_TYPE)callbackQueue {
  828|      0|  @synchronized(self) {
  829|      0|    GTMSessionMonitorSynchronized(self);
  830|      0|
  831|      0|    return _callbackQueue;
  832|      0|  }  // @synchronized(self)
  833|      0|}
  834|       |
  835|      0|- (void)setCallbackQueue:(dispatch_queue_t GTM_NULLABLE_TYPE)queue {
  836|      0|  @synchronized(self) {
  837|      0|    GTMSessionMonitorSynchronized(self);
  838|      0|
  839|      0|    _callbackQueue = queue ?: dispatch_get_main_queue();
  840|      0|  }  // @synchronized(self)
  841|      0|}
  842|       |
  843|      0|- (NSOperationQueue * GTM_NONNULL_TYPE)sessionDelegateQueue {
  844|      0|  @synchronized(self) {
  845|      0|    GTMSessionMonitorSynchronized(self);
  846|      0|
  847|      0|    return _delegateQueue;
  848|      0|  }  // @synchronized(self)
  849|      0|}
  850|       |
  851|      0|- (void)setSessionDelegateQueue:(NSOperationQueue * GTM_NULLABLE_TYPE)queue {
  852|      0|  @synchronized(self) {
  853|      0|    GTMSessionMonitorSynchronized(self);
  854|      0|
  855|      0|    _delegateQueue = queue ?: [NSOperationQueue mainQueue];
  856|      0|  }  // @synchronized(self)
  857|      0|}
  858|       |
  859|      0|- (NSOperationQueue *)delegateQueue {
  860|      0|  // Provided for compatibility with the old fetcher service.  The gtm-oauth2 code respects
  861|      0|  // any custom delegate queue for calling the app.
  862|      0|  return nil;
  863|      0|}
  864|       |
  865|      0|+ (NSUInteger)numberOfNonBackgroundSessionFetchers:(NSArray *)fetchers {
  866|      0|  NSUInteger sum = 0;
  867|      0|  for (GTMSessionFetcher *fetcher in fetchers) {
  868|      0|    if (!fetcher.usingBackgroundSession) {
  869|      0|      ++sum;
  870|      0|    }
  871|      0|  }
  872|      0|  return sum;
  873|      0|}
  874|       |
  875|       |@end
  876|       |
  877|       |@implementation GTMSessionFetcherService (TestingSupport)
  878|       |
  879|       |+ (instancetype)mockFetcherServiceWithFakedData:(NSData *)fakedDataOrNil
  880|      0|                                     fakedError:(NSError *)fakedErrorOrNil {
  881|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  882|      0|  NSURL *url = [NSURL URLWithString:@"http://example.invalid"];
  883|      0|  NSHTTPURLResponse *fakedResponse =
  884|      0|      [[NSHTTPURLResponse alloc] initWithURL:url
  885|      0|                                  statusCode:(fakedErrorOrNil ? 500 : 200)
  886|      0|                                 HTTPVersion:@"HTTP/1.1"
  887|      0|                                headerFields:nil];
  888|      0|  return [self mockFetcherServiceWithFakedData:fakedDataOrNil
  889|      0|                                 fakedResponse:fakedResponse
  890|      0|                                    fakedError:fakedErrorOrNil];
  891|       |#else
  892|       |  GTMSESSION_ASSERT_DEBUG(0, @"Test blocks disabled");
  893|       |  return nil;
  894|       |#endif  // GTM_DISABLE_FETCHER_TEST_BLOCK
  895|       |}
  896|       |
  897|       |+ (instancetype)mockFetcherServiceWithFakedData:(NSData *)fakedDataOrNil
  898|       |                                  fakedResponse:(NSHTTPURLResponse *)fakedResponse
  899|      0|                                     fakedError:(NSError *)fakedErrorOrNil {
  900|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  901|      0|  GTMSessionFetcherService *service = [[self alloc] init];
  902|      0|  service.allowedInsecureSchemes = @[ @"http" ];
  903|      0|  service.testBlock = ^(GTMSessionFetcher *fetcherToTest,
  904|      0|                        GTMSessionFetcherTestResponse testResponse) {
  905|      0|    testResponse(fakedResponse, fakedDataOrNil, fakedErrorOrNil);
  906|      0|  };
  907|      0|  return service;
  908|       |#else
  909|       |  GTMSESSION_ASSERT_DEBUG(0, @"Test blocks disabled");
  910|       |  return nil;
  911|       |#endif  // GTM_DISABLE_FETCHER_TEST_BLOCK
  912|       |}
  913|       |
  914|       |#pragma mark Synchronous Wait for Unit Testing
  915|       |
  916|      0|- (BOOL)waitForCompletionOfAllFetchersWithTimeout:(NSTimeInterval)timeoutInSeconds {
  917|      0|  NSDate *giveUpDate = [NSDate dateWithTimeIntervalSinceNow:timeoutInSeconds];
  918|      0|  _stoppedFetchersToWaitFor = [NSMutableArray array];
  919|      0|
  920|      0|  BOOL shouldSpinRunLoop = [NSThread isMainThread];
  921|      0|  const NSTimeInterval kSpinInterval = 0.001;
  922|      0|  BOOL didTimeOut = NO;
  923|      0|  while (([self numberOfFetchers] > 0 || _stoppedFetchersToWaitFor.count > 0)) {
  924|      0|    didTimeOut = [giveUpDate timeIntervalSinceNow] < 0;
  925|      0|    if (didTimeOut) break;
  926|      0|
  927|      0|    GTMSessionFetcher *stoppedFetcher = _stoppedFetchersToWaitFor.firstObject;
  928|      0|    if (stoppedFetcher) {
  929|      0|      [_stoppedFetchersToWaitFor removeObject:stoppedFetcher];
  930|      0|      [stoppedFetcher waitForCompletionWithTimeout:10.0 * kSpinInterval];
  931|      0|    }
  932|      0|
  933|      0|    if (shouldSpinRunLoop) {
  934|      0|      NSDate *stopDate = [NSDate dateWithTimeIntervalSinceNow:kSpinInterval];
  935|      0|      [[NSRunLoop currentRunLoop] runUntilDate:stopDate];
  936|      0|    } else {
  937|      0|      [NSThread sleepForTimeInterval:kSpinInterval];
  938|      0|    }
  939|      0|  }
  940|      0|  _stoppedFetchersToWaitFor = nil;
  941|      0|
  942|      0|  return !didTimeOut;
  943|      0|}
  944|       |
  945|       |@end
  946|       |
  947|       |@implementation GTMSessionFetcherService (BackwardsCompatibilityOnly)
  948|       |
  949|      0|- (NSInteger)cookieStorageMethod {
  950|      0|  @synchronized(self) {
  951|      0|    GTMSessionMonitorSynchronized(self);
  952|      0|
  953|      0|    return _cookieStorageMethod;
  954|      0|  }
  955|      0|}
  956|       |
  957|      0|- (void)setCookieStorageMethod:(NSInteger)cookieStorageMethod {
  958|      0|  @synchronized(self) {
  959|      0|    GTMSessionMonitorSynchronized(self);
  960|      0|
  961|      0|    _cookieStorageMethod = cookieStorageMethod;
  962|      0|  }
  963|      0|}
  964|       |
  965|       |@end
  966|       |
  967|       |@implementation GTMSessionFetcherSessionDelegateDispatcher {
  968|       |  __weak GTMSessionFetcherService *_parentService;
  969|       |  NSURLSession *_session;
  970|       |
  971|       |  // The task map maps NSURLSessionTasks to GTMSessionFetchers
  972|       |  NSMutableDictionary *_taskToFetcherMap;
  973|       |  // The discard timer will invalidate sessions after the session's last task completes.
  974|       |  NSTimer *_discardTimer;
  975|       |  NSTimeInterval _discardInterval;
  976|       |}
  977|       |
  978|       |@synthesize discardInterval = _discardInterval,
  979|       |            session = _session;
  980|       |
  981|      0|- (instancetype)init {
  982|      0|  [self doesNotRecognizeSelector:_cmd];
  983|      0|  return nil;
  984|      0|}
  985|       |
  986|       |- (instancetype)initWithParentService:(GTMSessionFetcherService *)parentService
  987|      0|               sessionDiscardInterval:(NSTimeInterval)discardInterval {
  988|      0|  self = [super init];
  989|      0|  if (self) {
  990|      0|    _discardInterval = discardInterval;
  991|      0|    _parentService = parentService;
  992|      0|  }
  993|      0|  return self;
  994|      0|}
  995|       |
  996|      0|- (NSString *)description {
  997|      0|  return [NSString stringWithFormat:@"%@ %p %@ %@",
  998|      0|          [self class], self,
  999|      0|          _session ?: @"<no session>",
 1000|      0|          _taskToFetcherMap.count > 0 ? _taskToFetcherMap : @"<no tasks>"];
 1001|      0|}
 1002|       |
 1003|      0|- (NSTimer *)discardTimer {
 1004|      0|  GTMSessionCheckNotSynchronized(self);
 1005|      0|  @synchronized(self) {
 1006|      0|    return _discardTimer;
 1007|      0|  }
 1008|      0|}
 1009|       |
 1010|       |// This method should be called inside of a @synchronized(self) block.
 1011|      0|- (void)startDiscardTimer {
 1012|      0|  GTMSessionCheckSynchronized(self);
 1013|      0|  [_discardTimer invalidate];
 1014|      0|  _discardTimer = nil;
 1015|      0|  if (_discardInterval > 0) {
 1016|      0|    _discardTimer = [NSTimer timerWithTimeInterval:_discardInterval
 1017|      0|                                            target:self
 1018|      0|                                          selector:@selector(discardTimerFired:)
 1019|      0|                                          userInfo:nil
 1020|      0|                                           repeats:NO];
 1021|      0|    [_discardTimer setTolerance:(_discardInterval / 10)];
 1022|      0|    [[NSRunLoop mainRunLoop] addTimer:_discardTimer forMode:NSRunLoopCommonModes];
 1023|      0|  }
 1024|      0|}
 1025|       |
 1026|       |// This method should be called inside of a @synchronized(self) block.
 1027|      0|- (void)destroyDiscardTimer {
 1028|      0|  GTMSessionCheckSynchronized(self);
 1029|      0|  [_discardTimer invalidate];
 1030|      0|  _discardTimer = nil;
 1031|      0|}
 1032|       |
 1033|      0|- (void)discardTimerFired:(NSTimer *)timer {
 1034|      0|  GTMSessionFetcherService *service;
 1035|      0|  @synchronized(self) {
 1036|      0|    GTMSessionMonitorSynchronized(self);
 1037|      0|
 1038|      0|    NSUInteger numberOfTasks = _taskToFetcherMap.count;
 1039|      0|    if (numberOfTasks == 0) {
 1040|      0|      service = _parentService;
 1041|      0|    }
 1042|      0|  }
 1043|      0|
 1044|      0|  // Inform the service that the discard timer has fired, and should check whether the
 1045|      0|  // service can abandon us. -resetSession cannot be called directly, as there is a
 1046|      0|  // race condition that must be guarded against with the NSURLSession being returned
 1047|      0|  // from sessionForFetcherCreation outside other locks. The service can take steps
 1048|      0|  // to prevent resetting the session if that has occurred.
 1049|      0|  //
 1050|      0|  // The service must be called from outside the @synchronized block.
 1051|      0|  [service resetSessionForDispatcherDiscardTimer:timer];
 1052|      0|}
 1053|       |
 1054|      0|- (void)abandon {
 1055|      0|  @synchronized(self) {
 1056|      0|    GTMSessionMonitorSynchronized(self);
 1057|      0|
 1058|      0|    [self destroySessionAndTimer];
 1059|      0|  }
 1060|      0|}
 1061|       |
 1062|      0|- (void)startSessionUsage {
 1063|      0|  @synchronized(self) {
 1064|      0|    GTMSessionMonitorSynchronized(self);
 1065|      0|
 1066|      0|    [self destroyDiscardTimer];
 1067|      0|  }
 1068|      0|}
 1069|       |
 1070|       |// This method should be called inside of a @synchronized(self) block.
 1071|      0|- (void)destroySessionAndTimer {
 1072|      0|  GTMSessionCheckSynchronized(self);
 1073|      0|  [self destroyDiscardTimer];
 1074|      0|
 1075|      0|  // Break any retain cycle from the session holding the delegate.
 1076|      0|  [_session finishTasksAndInvalidate];
 1077|      0|
 1078|      0|  // Immediately clear the session so no new task may be issued with it.
 1079|      0|  //
 1080|      0|  // The _taskToFetcherMap needs to stay valid until the outstanding tasks finish.
 1081|      0|  _session = nil;
 1082|      0|}
 1083|       |
 1084|      0|- (void)setFetcher:(GTMSessionFetcher *)fetcher forTask:(NSURLSessionTask *)task {
 1085|      0|  GTMSESSION_ASSERT_DEBUG(fetcher != nil, @"missing fetcher");
 1086|      0|
 1087|      0|  @synchronized(self) {
 1088|      0|    GTMSessionMonitorSynchronized(self);
 1089|      0|
 1090|      0|    if (_taskToFetcherMap == nil) {
 1091|      0|      _taskToFetcherMap = [[NSMutableDictionary alloc] init];
 1092|      0|    }
 1093|      0|
 1094|      0|    if (fetcher) {
 1095|      0|      [_taskToFetcherMap setObject:fetcher forKey:task];
 1096|      0|      [self destroyDiscardTimer];
 1097|      0|    }
 1098|      0|  }
 1099|      0|}
 1100|       |
 1101|      0|- (void)removeFetcher:(GTMSessionFetcher *)fetcher {
 1102|      0|  @synchronized(self) {
 1103|      0|    GTMSessionMonitorSynchronized(self);
 1104|      0|
 1105|      0|    // Typically, a fetcher should be removed when its task invokes
 1106|      0|    // URLSession:task:didCompleteWithError:.
 1107|      0|    //
 1108|      0|    // When fetching with a testBlock, though, the task completed delegate
 1109|      0|    // method may not be invoked, requiring cleanup here.
 1110|      0|    NSArray *tasks = [_taskToFetcherMap allKeysForObject:fetcher];
 1111|      0|    GTMSESSION_ASSERT_DEBUG(tasks.count <= 1, @"fetcher task not unmapped: %@", tasks);
 1112|      0|    [_taskToFetcherMap removeObjectsForKeys:tasks];
 1113|      0|
 1114|      0|    if (_taskToFetcherMap.count == 0) {
 1115|      0|      [self startDiscardTimer];
 1116|      0|    }
 1117|      0|  }
 1118|      0|}
 1119|       |
 1120|       |// This helper method provides synchronized access to the task map for the delegate
 1121|       |// methods below.
 1122|      0|- (id)fetcherForTask:(NSURLSessionTask *)task {
 1123|      0|  @synchronized(self) {
 1124|      0|    GTMSessionMonitorSynchronized(self);
 1125|      0|
 1126|      0|    return [_taskToFetcherMap objectForKey:task];
 1127|      0|  }
 1128|      0|}
 1129|       |
 1130|      0|- (void)removeTaskFromMap:(NSURLSessionTask *)task {
 1131|      0|  @synchronized(self) {
 1132|      0|    GTMSessionMonitorSynchronized(self);
 1133|      0|
 1134|      0|    [_taskToFetcherMap removeObjectForKey:task];
 1135|      0|  }
 1136|      0|}
 1137|       |
 1138|      0|- (void)setSession:(NSURLSession *)session {
 1139|      0|  @synchronized(self) {
 1140|      0|    GTMSessionMonitorSynchronized(self);
 1141|      0|
 1142|      0|    _session = session;
 1143|      0|  }
 1144|      0|}
 1145|       |
 1146|      0|- (NSURLSession *)session {
 1147|      0|  @synchronized(self) {
 1148|      0|    GTMSessionMonitorSynchronized(self);
 1149|      0|
 1150|      0|    return _session;
 1151|      0|  }
 1152|      0|}
 1153|       |
 1154|      0|- (NSTimeInterval)discardInterval {
 1155|      0|  @synchronized(self) {
 1156|      0|    GTMSessionMonitorSynchronized(self);
 1157|      0|
 1158|      0|    return _discardInterval;
 1159|      0|  }
 1160|      0|}
 1161|       |
 1162|      0|- (void)setDiscardInterval:(NSTimeInterval)interval {
 1163|      0|  @synchronized(self) {
 1164|      0|    GTMSessionMonitorSynchronized(self);
 1165|      0|
 1166|      0|    _discardInterval = interval;
 1167|      0|  }
 1168|      0|}
 1169|       |
 1170|       |// NSURLSessionDelegate protocol methods.
 1171|       |
 1172|       |// - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session;
 1173|       |//
 1174|       |// TODO(seh): How do we route this to an appropriate fetcher?
 1175|       |
 1176|       |
 1177|      0|- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(NSError *)error {
 1178|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ didBecomeInvalidWithError:%@",
 1179|      0|                           [self class], self, session, error);
 1180|      0|  NSDictionary *localTaskToFetcherMap;
 1181|      0|  @synchronized(self) {
 1182|      0|    GTMSessionMonitorSynchronized(self);
 1183|      0|
 1184|      0|    _session = nil;
 1185|      0|
 1186|      0|    localTaskToFetcherMap = [_taskToFetcherMap copy];
 1187|      0|  }
 1188|      0|
 1189|      0|  // Any "suspended" tasks may not have received callbacks from NSURLSession when the session
 1190|      0|  // completes; we'll call them now.
 1191|      0|  [localTaskToFetcherMap enumerateKeysAndObjectsUsingBlock:^(NSURLSessionTask *task,
 1192|      0|                                                             GTMSessionFetcher *fetcher,
 1193|      0|                                                             BOOL *stop) {
 1194|      0|    if (fetcher.session == session) {
 1195|      0|        // Our delegate method URLSession:task:didCompleteWithError: will rely on
 1196|      0|        // _taskToFetcherMap so that should still contain this fetcher.
 1197|      0|        NSError *canceledError = [NSError errorWithDomain:NSURLErrorDomain
 1198|      0|                                                     code:NSURLErrorCancelled
 1199|      0|                                                 userInfo:nil];
 1200|      0|        [self URLSession:session task:task didCompleteWithError:canceledError];
 1201|      0|      } else {
 1202|      0|        GTMSESSION_ASSERT_DEBUG(0, @"Unexpected session in fetcher: %@ has %@ (expected %@)",
 1203|      0|                                fetcher, fetcher.session, session);
 1204|      0|      }
 1205|      0|  }];
 1206|      0|
 1207|      0|  // Our tests rely on this notification to know the session discard timer fired.
 1208|      0|  NSDictionary *userInfo = @{ kGTMSessionFetcherServiceSessionKey : session };
 1209|      0|  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
 1210|      0|  [nc postNotificationName:kGTMSessionFetcherServiceSessionBecameInvalidNotification
 1211|      0|                    object:_parentService
 1212|      0|                  userInfo:userInfo];
 1213|      0|}
 1214|       |
 1215|       |
 1216|       |#pragma mark - NSURLSessionTaskDelegate
 1217|       |
 1218|       |// NSURLSessionTaskDelegate protocol methods.
 1219|       |//
 1220|       |// We won't test here if the fetcher responds to these since we only want this
 1221|       |// class to implement the same delegate methods the fetcher does (so NSURLSession's
 1222|       |// tests for respondsToSelector: will have the same result whether the session
 1223|       |// delegate is the fetcher or this dispatcher.)
 1224|       |
 1225|       |- (void)URLSession:(NSURLSession *)session
 1226|       |              task:(NSURLSessionTask *)task
 1227|       |willPerformHTTPRedirection:(NSHTTPURLResponse *)response
 1228|       |        newRequest:(NSURLRequest *)request
 1229|      0| completionHandler:(void (^)(NSURLRequest *))completionHandler {
 1230|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1231|      0|  [fetcher URLSession:session
 1232|      0|                 task:task
 1233|      0|willPerformHTTPRedirection:response
 1234|      0|           newRequest:request
 1235|      0|    completionHandler:completionHandler];
 1236|      0|}
 1237|       |
 1238|       |- (void)URLSession:(NSURLSession *)session
 1239|       |              task:(NSURLSessionTask *)task
 1240|       |didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 1241|      0| completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))handler {
 1242|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1243|      0|  [fetcher URLSession:session
 1244|      0|                 task:task
 1245|      0|  didReceiveChallenge:challenge
 1246|      0|    completionHandler:handler];
 1247|      0|}
 1248|       |
 1249|       |- (void)URLSession:(NSURLSession *)session
 1250|       |              task:(NSURLSessionTask *)task
 1251|      0| needNewBodyStream:(void (^)(NSInputStream *bodyStream))handler {
 1252|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1253|      0|  [fetcher URLSession:session
 1254|      0|                 task:task
 1255|      0|    needNewBodyStream:handler];
 1256|      0|}
 1257|       |
 1258|       |- (void)URLSession:(NSURLSession *)session
 1259|       |              task:(NSURLSessionTask *)task
 1260|       |   didSendBodyData:(int64_t)bytesSent
 1261|       |    totalBytesSent:(int64_t)totalBytesSent
 1262|      0|totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
 1263|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1264|      0|  [fetcher URLSession:session
 1265|      0|                 task:task
 1266|      0|      didSendBodyData:bytesSent
 1267|      0|       totalBytesSent:totalBytesSent
 1268|      0|totalBytesExpectedToSend:totalBytesExpectedToSend];
 1269|      0|}
 1270|       |
 1271|       |- (void)URLSession:(NSURLSession *)session
 1272|       |              task:(NSURLSessionTask *)task
 1273|      0|didCompleteWithError:(NSError *)error {
 1274|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1275|      0|
 1276|      0|  // This is the usual way tasks are removed from the task map.
 1277|      0|  [self removeTaskFromMap:task];
 1278|      0|
 1279|      0|  [fetcher URLSession:session
 1280|      0|                 task:task
 1281|      0| didCompleteWithError:error];
 1282|      0|}
 1283|       |
 1284|       |// NSURLSessionDataDelegate protocol methods.
 1285|       |
 1286|       |- (void)URLSession:(NSURLSession *)session
 1287|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1288|       |didReceiveResponse:(NSURLResponse *)response
 1289|      0| completionHandler:(void (^)(NSURLSessionResponseDisposition))handler {
 1290|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1291|      0|  [fetcher URLSession:session
 1292|      0|             dataTask:dataTask
 1293|      0|   didReceiveResponse:response
 1294|      0|    completionHandler:handler];
 1295|      0|}
 1296|       |
 1297|       |- (void)URLSession:(NSURLSession *)session
 1298|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1299|      0|didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask {
 1300|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1301|      0|  GTMSESSION_ASSERT_DEBUG(fetcher != nil, @"Missing fetcher for %@", dataTask);
 1302|      0|  [self removeTaskFromMap:dataTask];
 1303|      0|  if (fetcher) {
 1304|      0|    GTMSESSION_ASSERT_DEBUG([fetcher isKindOfClass:[GTMSessionFetcher class]],
 1305|      0|                            @"Expecting GTMSessionFetcher");
 1306|      0|    [self setFetcher:(GTMSessionFetcher *)fetcher forTask:downloadTask];
 1307|      0|  }
 1308|      0|
 1309|      0|  [fetcher URLSession:session
 1310|      0|             dataTask:dataTask
 1311|      0|didBecomeDownloadTask:downloadTask];
 1312|      0|}
 1313|       |
 1314|       |- (void)URLSession:(NSURLSession *)session
 1315|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1316|      0|    didReceiveData:(NSData *)data {
 1317|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1318|      0|  [fetcher URLSession:session
 1319|      0|             dataTask:dataTask
 1320|      0|       didReceiveData:data];
 1321|      0|}
 1322|       |
 1323|       |- (void)URLSession:(NSURLSession *)session
 1324|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1325|       | willCacheResponse:(NSCachedURLResponse *)proposedResponse
 1326|      0| completionHandler:(void (^)(NSCachedURLResponse *))handler {
 1327|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1328|      0|  [fetcher URLSession:session
 1329|      0|             dataTask:dataTask
 1330|      0|    willCacheResponse:proposedResponse
 1331|      0|    completionHandler:handler];
 1332|      0|}
 1333|       |
 1334|       |// NSURLSessionDownloadDelegate protocol methods.
 1335|       |
 1336|       |- (void)URLSession:(NSURLSession *)session
 1337|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 1338|      0|didFinishDownloadingToURL:(NSURL *)location {
 1339|      0|  id<NSURLSessionDownloadDelegate> fetcher = [self fetcherForTask:downloadTask];
 1340|      0|  [fetcher URLSession:session
 1341|      0|         downloadTask:downloadTask
 1342|      0|didFinishDownloadingToURL:location];
 1343|      0|}
 1344|       |
 1345|       |- (void)URLSession:(NSURLSession *)session
 1346|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 1347|       |      didWriteData:(int64_t)bytesWritten
 1348|       | totalBytesWritten:(int64_t)totalWritten
 1349|      0|totalBytesExpectedToWrite:(int64_t)totalExpected {
 1350|      0|  id<NSURLSessionDownloadDelegate> fetcher = [self fetcherForTask:downloadTask];
 1351|      0|  [fetcher URLSession:session
 1352|      0|         downloadTask:downloadTask
 1353|      0|         didWriteData:bytesWritten
 1354|      0|    totalBytesWritten:totalWritten
 1355|      0|totalBytesExpectedToWrite:totalExpected];
 1356|      0|}
 1357|       |
 1358|       |- (void)URLSession:(NSURLSession *)session
 1359|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 1360|       | didResumeAtOffset:(int64_t)fileOffset
 1361|      0|expectedTotalBytes:(int64_t)expectedTotalBytes {
 1362|      0|  id<NSURLSessionDownloadDelegate> fetcher = [self fetcherForTask:downloadTask];
 1363|      0|  [fetcher URLSession:session
 1364|      0|         downloadTask:downloadTask
 1365|      0|    didResumeAtOffset:fileOffset
 1366|      0|   expectedTotalBytes:expectedTotalBytes];
 1367|      0|}
 1368|       |
 1369|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GTMSessionFetcher/Source/GTMSessionUploadFetcher.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#import "GTMSessionUploadFetcher.h"
   21|       |
   22|       |static NSString *const kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey = @"_upChunk";
   23|       |static NSString *const kGTMSessionIdentifierUploadFileURLMetadataKey        = @"_upFileURL";
   24|       |static NSString *const kGTMSessionIdentifierUploadFileLengthMetadataKey     = @"_upFileLen";
   25|       |static NSString *const kGTMSessionIdentifierUploadLocationURLMetadataKey    = @"_upLocURL";
   26|       |static NSString *const kGTMSessionIdentifierUploadMIMETypeMetadataKey       = @"_uploadMIME";
   27|       |static NSString *const kGTMSessionIdentifierUploadChunkSizeMetadataKey      = @"_upChSize";
   28|       |static NSString *const kGTMSessionIdentifierUploadCurrentOffsetMetadataKey  = @"_upOffset";
   29|       |static NSString *const kGTMSessionIdentifierUploadAllowsCellularAccess      = @"_upAllowsCellularAccess";
   30|       |
   31|       |static NSString *const kGTMSessionHeaderXGoogUploadChunkGranularity = @"X-Goog-Upload-Chunk-Granularity";
   32|       |static NSString *const kGTMSessionHeaderXGoogUploadCommand          = @"X-Goog-Upload-Command";
   33|       |static NSString *const kGTMSessionHeaderXGoogUploadContentLength    = @"X-Goog-Upload-Content-Length";
   34|       |static NSString *const kGTMSessionHeaderXGoogUploadContentType      = @"X-Goog-Upload-Content-Type";
   35|       |static NSString *const kGTMSessionHeaderXGoogUploadOffset           = @"X-Goog-Upload-Offset";
   36|       |static NSString *const kGTMSessionHeaderXGoogUploadProtocol         = @"X-Goog-Upload-Protocol";
   37|       |static NSString *const kGTMSessionXGoogUploadProtocolResumable      = @"resumable";
   38|       |static NSString *const kGTMSessionHeaderXGoogUploadSizeReceived     = @"X-Goog-Upload-Size-Received";
   39|       |static NSString *const kGTMSessionHeaderXGoogUploadStatus           = @"X-Goog-Upload-Status";
   40|       |static NSString *const kGTMSessionHeaderXGoogUploadURL              = @"X-Goog-Upload-URL";
   41|       |
   42|       |// Property of chunk fetchers identifying the parent upload fetcher.  Non-retained NSValue.
   43|       |static NSString *const kGTMSessionUploadFetcherChunkParentKey = @"_uploadFetcherChunkParent";
   44|       |
   45|       |int64_t const kGTMSessionUploadFetcherUnknownFileSize = -1;
   46|       |
   47|       |int64_t const kGTMSessionUploadFetcherStandardChunkSize = (int64_t)LLONG_MAX;
   48|       |
   49|       |#if TARGET_OS_IPHONE
   50|       |int64_t const kGTMSessionUploadFetcherMaximumDemandBufferSize = 10 * 1024 * 1024;  // 10 MB for iOS, watchOS, tvOS
   51|       |#else
   52|       |int64_t const kGTMSessionUploadFetcherMaximumDemandBufferSize = 100 * 1024 * 1024;  // 100 MB for macOS
   53|       |#endif
   54|       |
   55|       |typedef NS_ENUM(NSUInteger, GTMSessionUploadFetcherStatus) {
   56|       |  kStatusUnknown,
   57|       |  kStatusActive,
   58|       |  kStatusFinal,
   59|       |  kStatusCancelled,
   60|       |};
   61|       |
   62|       |NSString *const kGTMSessionFetcherUploadLocationObtainedNotification =
   63|       |    @"kGTMSessionFetcherUploadLocationObtainedNotification";
   64|       |
   65|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
   66|       |@interface GTMSessionFetcher (ProtectedMethods)
   67|       |
   68|       |// Access to non-public method on the parent fetcher class.
   69|       |- (void)stopFetchReleasingCallbacks:(BOOL)shouldReleaseCallbacks;
   70|       |- (void)createSessionIdentifierWithMetadata:(NSDictionary *)metadata;
   71|       |- (GTMSessionFetcherCompletionHandler)completionHandlerWithTarget:(id)target
   72|       |                                                didFinishSelector:(SEL)finishedSelector;
   73|       |- (void)invokeOnCallbackQueue:(dispatch_queue_t)callbackQueue
   74|       |             afterUserStopped:(BOOL)afterStopped
   75|       |                        block:(void (^)(void))block;
   76|       |- (NSTimer *)retryTimer;
   77|       |- (void)beginFetchForRetry;
   78|       |
   79|       |@property(readwrite, strong) NSData *downloadedData;
   80|       |- (void)releaseCallbacks;
   81|       |
   82|       |- (NSInteger)statusCodeUnsynchronized;
   83|       |
   84|       |- (BOOL)userStoppedFetching;
   85|       |
   86|       |@end
   87|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
   88|       |
   89|       |@interface GTMSessionUploadFetcher ()
   90|       |
   91|       |// Changing readonly to readwrite.
   92|       |@property(atomic, strong, readwrite) NSURLRequest *lastChunkRequest;
   93|       |@property(atomic, readwrite, assign) int64_t currentOffset;
   94|       |
   95|       |// Internal properties.
   96|       |@property(strong, atomic, GTM_NULLABLE) GTMSessionFetcher *fetcherInFlight;  // Synchronized on self.
   97|       |
   98|       |@property(assign, atomic, getter=isSubdataGenerating) BOOL subdataGenerating;
   99|       |@property(assign, atomic) BOOL shouldInitiateOffsetQuery;
  100|       |@property(assign, atomic) int64_t uploadGranularity;
  101|       |@property(assign, atomic) BOOL allowsCellularAccess;
  102|       |
  103|       |@end
  104|       |
  105|       |@implementation GTMSessionUploadFetcher {
  106|       |  GTMSessionFetcher *_chunkFetcher;
  107|       |
  108|       |  // We'll call through to the delegate's completion handler.
  109|       |  GTMSessionFetcherCompletionHandler _delegateCompletionHandler;
  110|       |  dispatch_queue_t _delegateCallbackQueue;
  111|       |
  112|       |  // The initial fetch's body length and bytes actually sent are
  113|       |  // needed for calculating progress during subsequent chunk uploads
  114|       |  int64_t _initialBodyLength;
  115|       |  int64_t _initialBodySent;
  116|       |
  117|       |  // The upload server address for the chunks of this upload session.
  118|       |  NSURL *_uploadLocationURL;
  119|       |
  120|       |  // _uploadData, _uploadDataProvider, or _uploadFileHandle may be set, but only one.
  121|       |  NSData *_uploadData;
  122|       |  NSFileHandle *_uploadFileHandle;
  123|       |  GTMSessionUploadFetcherDataProvider _uploadDataProvider;
  124|       |  NSURL *_uploadFileURL;
  125|       |  int64_t _uploadFileLength;
  126|       |  NSString *_uploadMIMEType;
  127|       |  int64_t _chunkSize;
  128|       |  int64_t _uploadGranularity;
  129|       |  BOOL _isPaused;
  130|       |  BOOL _isRestartedUpload;
  131|       |  BOOL _shouldInitiateOffsetQuery;
  132|       |
  133|       |  // Tied to useBackgroundSession property, since this property is applicable to chunk fetchers.
  134|       |  BOOL _useBackgroundSessionOnChunkFetchers;
  135|       |
  136|       |  // We keep the latest offset into the upload data just for progress reporting.
  137|       |  int64_t _currentOffset;
  138|       |
  139|       |  NSDictionary *_recentChunkReponseHeaders;
  140|       |  NSInteger _recentChunkStatusCode;
  141|       |
  142|       |  // For waiting, we need to know the fetcher in flight, if any, and if subdata generation
  143|       |  // is in progress.
  144|       |  GTMSessionFetcher *_fetcherInFlight;
  145|       |  BOOL _isSubdataGenerating;
  146|       |  BOOL _isCancelInFlight;
  147|       |
  148|       |  GTMSessionUploadFetcherCancellationHandler _cancellationHandler;
  149|       |}
  150|       |
  151|      1|+ (void)load {
  152|      1|  [self uploadFetchersForBackgroundSessions];
  153|      1|}
  154|       |
  155|       |+ (instancetype)uploadFetcherWithRequest:(NSURLRequest *)request
  156|       |                          uploadMIMEType:(NSString *)uploadMIMEType
  157|       |                               chunkSize:(int64_t)chunkSize
  158|      0|                          fetcherService:(GTMSessionFetcherService *)fetcherService {
  159|      0|  GTMSessionUploadFetcher *fetcher = [self uploadFetcherWithRequest:request
  160|      0|                                                     fetcherService:fetcherService];
  161|      0|  [fetcher setLocationURL:nil
  162|      0|            uploadMIMEType:uploadMIMEType
  163|      0|                 chunkSize:chunkSize
  164|      0|      allowsCellularAccess:request.allowsCellularAccess];
  165|      0|  return fetcher;
  166|      0|}
  167|       |
  168|       |+ (instancetype)uploadFetcherWithLocation:(NSURL *GTM_NULLABLE_TYPE)uploadLocationURL
  169|       |                           uploadMIMEType:(NSString *)uploadMIMEType
  170|       |                                chunkSize:(int64_t)chunkSize
  171|      0|                           fetcherService:(GTM_NULLABLE GTMSessionFetcherService *)fetcherServiceOrNil {
  172|      0|  return [self uploadFetcherWithLocation:uploadLocationURL
  173|      0|                          uploadMIMEType:uploadMIMEType
  174|      0|                               chunkSize:chunkSize
  175|      0|                    allowsCellularAccess:YES
  176|      0|                          fetcherService:fetcherServiceOrNil];
  177|      0|}
  178|       |
  179|       |+ (instancetype)uploadFetcherWithLocation:(NSURL *GTM_NULLABLE_TYPE)uploadLocationURL
  180|       |                           uploadMIMEType:(NSString *)uploadMIMEType
  181|       |                                chunkSize:(int64_t)chunkSize
  182|       |                     allowsCellularAccess:(BOOL)allowsCellularAccess
  183|      0|                           fetcherService:(GTMSessionFetcherService *)fetcherService {
  184|      0|  GTMSessionUploadFetcher *fetcher = [self uploadFetcherWithRequest:nil
  185|      0|                                                     fetcherService:fetcherService];
  186|      0|  [fetcher setLocationURL:uploadLocationURL
  187|      0|            uploadMIMEType:uploadMIMEType
  188|      0|                 chunkSize:chunkSize
  189|      0|      allowsCellularAccess:allowsCellularAccess];
  190|      0|  return fetcher;
  191|      0|}
  192|       |
  193|      0|+ (instancetype)uploadFetcherForSessionIdentifierMetadata:(NSDictionary *)metadata {
  194|      0|  GTMSESSION_ASSERT_DEBUG(
  195|      0|      [metadata[kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey] boolValue],
  196|      0|      @"Session identifier metadata is not for an upload fetcher: %@", metadata);
  197|      0|
  198|      0|  NSNumber *uploadFileLengthNum = metadata[kGTMSessionIdentifierUploadFileLengthMetadataKey];
  199|      0|  GTMSESSION_ASSERT_DEBUG(uploadFileLengthNum != nil,
  200|      0|                          @"Session metadata missing an UploadFileSize");
  201|      0|  if (uploadFileLengthNum == nil) return nil;
  202|      0|
  203|      0|  int64_t uploadFileLength = [uploadFileLengthNum longLongValue];
  204|      0|  GTMSESSION_ASSERT_DEBUG(uploadFileLength >= 0, @"Session metadata UploadFileSize is unknown");
  205|      0|
  206|      0|  NSString *uploadFileURLString = metadata[kGTMSessionIdentifierUploadFileURLMetadataKey];
  207|      0|  GTMSESSION_ASSERT_DEBUG(uploadFileURLString, @"Session metadata missing an UploadFileURL");
  208|      0|  if (uploadFileURLString == nil) return nil;
  209|      0|
  210|      0|  NSURL *uploadFileURL = [NSURL URLWithString:uploadFileURLString];
  211|      0|  // There used to be a call here to NSURL checkResourceIsReachableAndReturnError: to check for the
  212|      0|  // existence of the file (also tried NSFileManager fileExistsAtPath:). We've determined
  213|      0|  // empirically that the check can fail at startup even when the upload file does in fact exist.
  214|      0|  // For now, we'll go ahead and restore the background upload fetcher. If the file doesn't exist,
  215|      0|  // it will fail later.
  216|      0|
  217|      0|  NSString *uploadLocationURLString = metadata[kGTMSessionIdentifierUploadLocationURLMetadataKey];
  218|      0|  NSURL *uploadLocationURL =
  219|      0|      uploadLocationURLString ? [NSURL URLWithString:uploadLocationURLString] : nil;
  220|      0|
  221|      0|  NSString *uploadMIMEType =
  222|      0|      metadata[kGTMSessionIdentifierUploadMIMETypeMetadataKey];
  223|      0|  int64_t uploadChunkSize =
  224|      0|      [metadata[kGTMSessionIdentifierUploadChunkSizeMetadataKey] longLongValue];
  225|      0|  if (uploadChunkSize <= 0) {
  226|      0|    uploadChunkSize = kGTMSessionUploadFetcherStandardChunkSize;
  227|      0|  }
  228|      0|  int64_t currentOffset =
  229|      0|      [metadata[kGTMSessionIdentifierUploadCurrentOffsetMetadataKey] longLongValue];
  230|      0|
  231|      0|  BOOL allowsCellularAccess = YES;
  232|      0|  if (metadata[kGTMSessionIdentifierUploadAllowsCellularAccess]) {
  233|      0|    allowsCellularAccess = [metadata[kGTMSessionIdentifierUploadAllowsCellularAccess] boolValue];
  234|      0|  }
  235|      0|
  236|      0|  GTMSESSION_ASSERT_DEBUG(currentOffset <= uploadFileLength,
  237|      0|                          @"CurrentOffset (%lld) exceeds UploadFileSize (%lld)",
  238|      0|                          currentOffset, uploadFileLength);
  239|      0|  if (currentOffset > uploadFileLength) return nil;
  240|      0|
  241|      0|  GTMSessionUploadFetcher *uploadFetcher = [self uploadFetcherWithLocation:uploadLocationURL
  242|      0|                                                            uploadMIMEType:uploadMIMEType
  243|      0|                                                                 chunkSize:uploadChunkSize
  244|      0|                                                      allowsCellularAccess:allowsCellularAccess
  245|      0|                                                            fetcherService:nil];
  246|      0|  // Set the upload file length before setting the upload file URL tries to determine the length.
  247|      0|  [uploadFetcher setUploadFileLength:uploadFileLength];
  248|      0|
  249|      0|  uploadFetcher.uploadFileURL = uploadFileURL;
  250|      0|  uploadFetcher.sessionUserInfo = metadata;
  251|      0|  uploadFetcher.useBackgroundSession = YES;
  252|      0|  uploadFetcher.currentOffset = currentOffset;
  253|      0|  uploadFetcher.delegateCallbackQueue = uploadFetcher.callbackQueue;
  254|      0|  uploadFetcher.allowedInsecureSchemes = @[ @"http" ];  // Allowed on restored upload fetcher.
  255|      0|  return uploadFetcher;
  256|      0|}
  257|       |
  258|       |+ (instancetype)uploadFetcherWithRequest:(NSURLRequest *)request
  259|      0|                          fetcherService:(GTMSessionFetcherService *)fetcherService {
  260|      0|  // Internal utility method for instantiating fetchers
  261|      0|  GTMSessionUploadFetcher *fetcher;
  262|      0|  if ([fetcherService isKindOfClass:[GTMSessionFetcherService class]]) {
  263|      0|    fetcher = [fetcherService fetcherWithRequest:request
  264|      0|                                    fetcherClass:self];
  265|      0|  } else {
  266|      0|    fetcher = [self fetcherWithRequest:request];
  267|      0|  }
  268|      0|  fetcher.useBackgroundSession = YES;
  269|      0|  return fetcher;
  270|      0|}
  271|       |
  272|      1|+ (NSPointerArray *)uploadFetcherPointerArrayForBackgroundSessions {
  273|      1|  static NSPointerArray *gUploadFetcherPointerArrayForBackgroundSessions = nil;
  274|      1|
  275|      1|  static dispatch_once_t onceToken;
  276|      1|  dispatch_once(&onceToken, ^{
  277|      1|    gUploadFetcherPointerArrayForBackgroundSessions = [NSPointerArray weakObjectsPointerArray];
  278|      1|  });
  279|      1|  return gUploadFetcherPointerArrayForBackgroundSessions;
  280|      1|}
  281|       |
  282|      0|+ (instancetype)uploadFetcherForSessionIdentifier:(NSString *)sessionIdentifier {
  283|      0|  GTMSESSION_ASSERT_DEBUG(sessionIdentifier != nil, @"Invalid session identifier");
  284|      0|  NSArray *uploadFetchersForBackgroundSessions = [self uploadFetchersForBackgroundSessions];
  285|      0|  for (GTMSessionUploadFetcher *uploadFetcher in uploadFetchersForBackgroundSessions) {
  286|      0|    if ([uploadFetcher.chunkFetcher.sessionIdentifier isEqual:sessionIdentifier]) {
  287|      0|      return uploadFetcher;
  288|      0|    }
  289|      0|  }
  290|      0|  return nil;
  291|      0|}
  292|       |
  293|      1|+ (NSArray *)uploadFetchersForBackgroundSessions {
  294|      1|  NSMutableSet *restoredSessionIdentifiers = [[NSMutableSet alloc] init];
  295|      1|  NSMutableArray *uploadFetchers = [[NSMutableArray alloc] init];
  296|      1|  NSPointerArray *uploadFetcherPointerArray = [self uploadFetcherPointerArrayForBackgroundSessions];
  297|      1|
  298|      1|  // Collect the background session upload fetchers that are still in memory.
  299|      1|  @synchronized(uploadFetcherPointerArray) {
  300|      1|    [uploadFetcherPointerArray compact];
  301|      1|    for (GTMSessionUploadFetcher *uploadFetcher in uploadFetcherPointerArray) {
  302|      0|      NSString *sessionIdentifier = uploadFetcher.chunkFetcher.sessionIdentifier;
  303|      0|      if (sessionIdentifier) {
  304|      0|        [restoredSessionIdentifiers addObject:sessionIdentifier];
  305|      0|        [uploadFetchers addObject:uploadFetcher];
  306|      0|      }
  307|      0|    }
  308|      1|  }  // @synchronized(uploadFetcherPointerArray)
  309|      1|
  310|      1|  // The system may have other ongoing background upload sessions. Restore upload fetchers for those
  311|      1|  // too.
  312|      1|  NSArray *fetchers = [GTMSessionFetcher fetchersForBackgroundSessions];
  313|      1|  for (GTMSessionFetcher *fetcher in fetchers) {
  314|      0|    NSString *sessionIdentifier = fetcher.sessionIdentifier;
  315|      0|    if (!sessionIdentifier || [restoredSessionIdentifiers containsObject:sessionIdentifier]) {
  316|      0|      continue;
  317|      0|    }
  318|      0|    NSDictionary *sessionIdentifierMetadata = [fetcher sessionIdentifierMetadata];
  319|      0|    if (sessionIdentifierMetadata == nil) {
  320|      0|      continue;
  321|      0|    }
  322|      0|    if (![sessionIdentifierMetadata[kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey] boolValue]) {
  323|      0|      continue;
  324|      0|    }
  325|      0|    GTMSessionUploadFetcher *uploadFetcher =
  326|      0|        [self uploadFetcherForSessionIdentifierMetadata:sessionIdentifierMetadata];
  327|      0|    if (uploadFetcher == nil) {
  328|      0|      // Something went wrong with this upload fetcher, so kill the restored chunk fetcher.
  329|      0|      [fetcher stopFetching];
  330|      0|      continue;
  331|      0|    }
  332|      0|    [uploadFetchers addObject:uploadFetcher];
  333|      0|    uploadFetcher->_chunkFetcher = fetcher;
  334|      0|    uploadFetcher->_fetcherInFlight = fetcher;
  335|      0|    [uploadFetcher attachSendProgressBlockToChunkFetcher:fetcher];
  336|      0|    fetcher.completionHandler =
  337|      0|        [fetcher completionHandlerWithTarget:uploadFetcher
  338|      0|                           didFinishSelector:@selector(chunkFetcher:finishedWithData:error:)];
  339|      0|
  340|      0|    GTMSESSION_LOG_DEBUG(@"%@ restoring upload fetcher %@ for chunk fetcher %@",
  341|      0|                         [self class], uploadFetcher, fetcher);
  342|      0|  }
  343|      1|  return uploadFetchers;
  344|      1|}
  345|       |
  346|      0|- (void)setUploadData:(NSData *)data {
  347|      0|  BOOL changed = NO;
  348|      0|
  349|      0|  @synchronized(self) {
  350|      0|    GTMSessionMonitorSynchronized(self);
  351|      0|
  352|      0|    if (_uploadData != data) {
  353|      0|      _uploadData = data;
  354|      0|      changed = YES;
  355|      0|    }
  356|      0|  }
  357|      0|  if (changed) {
  358|      0|    [self setupRequestHeaders];
  359|      0|  }
  360|      0|}
  361|       |
  362|      0|- (NSData *)uploadData {
  363|      0|  @synchronized(self) {
  364|      0|    GTMSessionMonitorSynchronized(self);
  365|      0|
  366|      0|    return _uploadData;
  367|      0|  }
  368|      0|}
  369|       |
  370|      0|- (void)setUploadFileHandle:(NSFileHandle *)fh {
  371|      0|  BOOL changed = NO;
  372|      0|
  373|      0|  @synchronized(self) {
  374|      0|    GTMSessionMonitorSynchronized(self);
  375|      0|
  376|      0|    if (_uploadFileHandle != fh) {
  377|      0|      _uploadFileHandle = fh;
  378|      0|      changed = YES;
  379|      0|    }
  380|      0|  }
  381|      0|  if (changed) {
  382|      0|    [self setupRequestHeaders];
  383|      0|  }
  384|      0|}
  385|       |
  386|      0|- (NSFileHandle *)uploadFileHandle {
  387|      0|  @synchronized(self) {
  388|      0|    GTMSessionMonitorSynchronized(self);
  389|      0|
  390|      0|    return _uploadFileHandle;
  391|      0|  }
  392|      0|}
  393|       |
  394|      0|- (void)setUploadFileURL:(NSURL *)uploadURL {
  395|      0|  BOOL changed = NO;
  396|      0|
  397|      0|  @synchronized(self) {
  398|      0|    GTMSessionMonitorSynchronized(self);
  399|      0|
  400|      0|    if (_uploadFileURL != uploadURL) {
  401|      0|      _uploadFileURL = uploadURL;
  402|      0|      changed = YES;
  403|      0|    }
  404|      0|  }
  405|      0|  if (changed) {
  406|      0|    [self setupRequestHeaders];
  407|      0|  }
  408|      0|}
  409|       |
  410|      0|- (NSURL *)uploadFileURL {
  411|      0|  @synchronized(self) {
  412|      0|    GTMSessionMonitorSynchronized(self);
  413|      0|
  414|      0|    return _uploadFileURL;
  415|      0|  }
  416|      0|}
  417|       |
  418|      0|- (void)setUploadFileLength:(int64_t)fullLength {
  419|      0|  @synchronized(self) {
  420|      0|    GTMSessionMonitorSynchronized(self);
  421|      0|
  422|      0|    if (_uploadFileLength == kGTMSessionUploadFetcherUnknownFileSize &&
  423|      0|        fullLength != kGTMSessionUploadFetcherUnknownFileSize) {
  424|      0|      _uploadFileLength = fullLength;
  425|      0|    }
  426|      0|  }
  427|      0|}
  428|       |
  429|       |- (void)setUploadDataLength:(int64_t)fullLength
  430|      0|                   provider:(GTMSessionUploadFetcherDataProvider)block {
  431|      0|  @synchronized(self) {
  432|      0|    GTMSessionMonitorSynchronized(self);
  433|      0|
  434|      0|    _uploadDataProvider = [block copy];
  435|      0|    _uploadFileLength = fullLength;
  436|      0|  }
  437|      0|  [self setupRequestHeaders];
  438|      0|}
  439|       |
  440|      0|- (GTMSessionUploadFetcherDataProvider)uploadDataProvider {
  441|      0|  @synchronized(self) {
  442|      0|    GTMSessionMonitorSynchronized(self);
  443|      0|
  444|      0|    return _uploadDataProvider;
  445|      0|  }
  446|      0|}
  447|       |
  448|       |
  449|      0|- (void)setUploadMIMEType:(NSString *)uploadMIMEType {
  450|      0|  GTMSESSION_ASSERT_DEBUG(0, @"TODO: disallow setUploadMIMEType by making declaration readonly");
  451|      0|  // (and uploadMIMEType, chunksize, currentOffset)
  452|      0|  @synchronized(self) {
  453|      0|    GTMSessionMonitorSynchronized(self);
  454|      0|
  455|      0|    _uploadMIMEType = uploadMIMEType;
  456|      0|  }
  457|      0|}
  458|       |
  459|      0|- (NSString *)uploadMIMEType {
  460|      0|  @synchronized(self) {
  461|      0|    GTMSessionMonitorSynchronized(self);
  462|      0|
  463|      0|    return _uploadMIMEType;
  464|      0|  }
  465|      0|}
  466|       |
  467|      0|- (int64_t)chunkSize {
  468|      0|  @synchronized(self) {
  469|      0|    GTMSessionMonitorSynchronized(self);
  470|      0|
  471|      0|    return _chunkSize;
  472|      0|  }
  473|      0|}
  474|       |
  475|      0|- (void)setupRequestHeaders {
  476|      0|  GTMSessionCheckNotSynchronized(self);
  477|      0|
  478|      0|#if DEBUG
  479|      0|  @synchronized(self) {
  480|      0|    GTMSessionMonitorSynchronized(self);
  481|      0|
  482|      0|    int hasData = (_uploadData != nil) ? 1 : 0;
  483|      0|    int hasFileHandle = (_uploadFileHandle != nil) ? 1 : 0;
  484|      0|    int hasFileURL = (_uploadFileURL != nil) ? 1 : 0;
  485|      0|    int hasUploadDataProvider = (_uploadDataProvider != nil) ? 1 : 0;
  486|      0|    int numberOfSources = hasData + hasFileHandle + hasFileURL + hasUploadDataProvider;
  487|      0|    #pragma unused(numberOfSources)
  488|      0|    GTMSESSION_ASSERT_DEBUG(numberOfSources == 1,
  489|      0|                            @"Need just one upload source (%d)", numberOfSources);
  490|      0|  }  // @synchronized(self)
  491|      0|#endif
  492|      0|
  493|      0|  // Add our custom headers to the initial request indicating the data
  494|      0|  // type and total size to be delivered later in the chunk requests.
  495|      0|  NSMutableURLRequest *mutableRequest = [self.request mutableCopy];
  496|      0|
  497|      0|  GTMSESSION_ASSERT_DEBUG((mutableRequest == nil) != (_uploadLocationURL == nil),
  498|      0|                          @"Request and location are mutually exclusive");
  499|      0|  if (!mutableRequest) return;
  500|      0|
  501|      0|  [mutableRequest setValue:kGTMSessionXGoogUploadProtocolResumable
  502|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadProtocol];
  503|      0|  [mutableRequest setValue:@"start"
  504|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
  505|      0|  [mutableRequest setValue:_uploadMIMEType
  506|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadContentType];
  507|      0|  [mutableRequest setValue:@([self fullUploadLength]).stringValue
  508|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadContentLength];
  509|      0|
  510|      0|  NSString *method = mutableRequest.HTTPMethod;
  511|      0|  if (method == nil || [method caseInsensitiveCompare:@"GET"] == NSOrderedSame) {
  512|      0|    [mutableRequest setHTTPMethod:@"POST"];
  513|      0|  }
  514|      0|
  515|      0|  // Ensure the user agent header identifies this to the upload server as a
  516|      0|  // GTMSessionUploadFetcher client.  The /1 can be incremented in the unlikely circumstance
  517|      0|  // we need to make a bug fix in the client that the server can recognize.
  518|      0|  NSString *const kUserAgentStub = @"(GTMSUF/1)";
  519|      0|  NSString *userAgent = [mutableRequest valueForHTTPHeaderField:@"User-Agent"];
  520|      0|  if (userAgent == nil
  521|      0|      || [userAgent rangeOfString:kUserAgentStub].location == NSNotFound) {
  522|      0|    if (userAgent.length == 0) {
  523|      0|      userAgent = GTMFetcherStandardUserAgentString(nil);
  524|      0|    }
  525|      0|    userAgent = [userAgent stringByAppendingFormat:@" %@", kUserAgentStub];
  526|      0|    [mutableRequest setValue:userAgent forHTTPHeaderField:@"User-Agent"];
  527|      0|  }
  528|      0|  [self setRequest:mutableRequest];
  529|      0|}
  530|       |
  531|       |- (void)setLocationURL:(NSURL *GTM_NULLABLE_TYPE)location
  532|       |          uploadMIMEType:(NSString *)uploadMIMEType
  533|       |               chunkSize:(int64_t)chunkSize
  534|      0|    allowsCellularAccess:(BOOL)allowsCellularAccess {
  535|      0|  @synchronized(self) {
  536|      0|    GTMSessionMonitorSynchronized(self);
  537|      0|
  538|      0|    GTMSESSION_ASSERT_DEBUG(chunkSize > 0, @"chunk size is zero");
  539|      0|
  540|      0|    _allowsCellularAccess = allowsCellularAccess;
  541|      0|
  542|      0|    // When resuming an upload, set the known upload target URL.
  543|      0|    _uploadLocationURL = location;
  544|      0|
  545|      0|    _uploadMIMEType = uploadMIMEType;
  546|      0|    _chunkSize = chunkSize;
  547|      0|
  548|      0|    // Indicate that we've not yet determined the file handle's length
  549|      0|    _uploadFileLength = kGTMSessionUploadFetcherUnknownFileSize;
  550|      0|
  551|      0|    // Indicate that we've not yet determined the upload fetcher status
  552|      0|    _recentChunkStatusCode = -1;
  553|      0|
  554|      0|    // If this is restarting an upload begun by another fetcher,
  555|      0|    // the location is specified but the request is nil
  556|      0|    _isRestartedUpload = (location != nil);
  557|      0|  }  // @synchronized(self)
  558|      0|}
  559|       |
  560|      0|- (int64_t)fullUploadLength {
  561|      0|  int64_t result;
  562|      0|  @synchronized(self) {
  563|      0|    GTMSessionMonitorSynchronized(self);
  564|      0|
  565|      0|    if (_uploadData) {
  566|      0|      result = (int64_t)_uploadData.length;
  567|      0|    } else {
  568|      0|      if (_uploadFileLength == kGTMSessionUploadFetcherUnknownFileSize) {
  569|      0|        if (_uploadFileHandle) {
  570|      0|          // First time through, seek to end to determine file length
  571|      0|          _uploadFileLength = (int64_t)[_uploadFileHandle seekToEndOfFile];
  572|      0|        } else if (_uploadDataProvider) {
  573|      0|          // _uploadFileLength is set when the _uploadDataProvider is set.
  574|      0|          GTMSESSION_ASSERT_DEBUG(_uploadFileLength >= 0, @"No uploadDataProvider length set");
  575|      0|        } else {
  576|      0|          NSNumber *filesizeNum;
  577|      0|          NSError *valueError;
  578|      0|          if ([_uploadFileURL getResourceValue:&filesizeNum
  579|      0|                                        forKey:NSURLFileSizeKey
  580|      0|                                         error:&valueError]) {
  581|      0|            _uploadFileLength = filesizeNum.longLongValue;
  582|      0|          } else {
  583|      0|            GTMSESSION_ASSERT_DEBUG(NO, @"Cannot get file size: %@\n  %@",
  584|      0|                                    valueError, _uploadFileURL.path);
  585|      0|            _uploadFileLength = 0;
  586|      0|          }
  587|      0|        }
  588|      0|      }
  589|      0|      result = _uploadFileLength;
  590|      0|    }
  591|      0|  }  // @synchronized(self)
  592|      0|  return result;
  593|      0|}
  594|       |
  595|       |// Make a subdata of the upload data.
  596|       |- (void)generateChunkSubdataWithOffset:(int64_t)offset
  597|       |                                length:(int64_t)length
  598|      0|                              response:(GTMSessionUploadFetcherDataProviderResponse)response {
  599|      0|  GTMSessionUploadFetcherDataProvider uploadDataProvider = self.uploadDataProvider;
  600|      0|  if (uploadDataProvider) {
  601|      0|    uploadDataProvider(offset, length, response);
  602|      0|    return;
  603|      0|  }
  604|      0|
  605|      0|  NSData *uploadData = self.uploadData;
  606|      0|  if (uploadData) {
  607|      0|    // NSData provided.
  608|      0|    NSData *resultData;
  609|      0|    if (offset == 0 && length == (int64_t)uploadData.length) {
  610|      0|      resultData = uploadData;
  611|      0|    } else {
  612|      0|      int64_t dataLength = (int64_t)uploadData.length;
  613|      0|      // Ensure our range is valid.  b/18007814
  614|      0|      if (offset + length > dataLength) {
  615|      0|        NSString *errorMessage = [NSString stringWithFormat:
  616|      0|                                  @"Range invalid for upload data.  offset: %lld\tlength: %lld\tdataLength: %lld",
  617|      0|                                  offset, length, dataLength];
  618|      0|        GTMSESSION_ASSERT_DEBUG(NO, @"%@", errorMessage);
  619|      0|        response(nil,
  620|      0|                 kGTMSessionUploadFetcherUnknownFileSize,
  621|      0|                 [self uploadChunkUnavailableErrorWithDescription:errorMessage]);
  622|      0|        return;
  623|      0|      }
  624|      0|      NSRange range = NSMakeRange((NSUInteger)offset, (NSUInteger)length);
  625|      0|
  626|      0|      @try {
  627|      0|        resultData = [uploadData subdataWithRange:range];
  628|      0|      }
  629|      0|      @catch (NSException *exception) {
  630|      0|        NSString *errorMessage = exception.description;
  631|      0|        GTMSESSION_ASSERT_DEBUG(NO, @"%@", errorMessage);
  632|      0|        response(nil,
  633|      0|                 kGTMSessionUploadFetcherUnknownFileSize,
  634|      0|                 [self uploadChunkUnavailableErrorWithDescription:errorMessage]);
  635|      0|        return;
  636|      0|      }
  637|      0|    }
  638|      0|    response(resultData, kGTMSessionUploadFetcherUnknownFileSize, nil);
  639|      0|    return;
  640|      0|  }
  641|      0|  NSURL *uploadFileURL = self.uploadFileURL;
  642|      0|  if (uploadFileURL) {
  643|      0|    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  644|      0|      [self generateChunkSubdataFromFileURL:uploadFileURL
  645|      0|                                     offset:offset
  646|      0|                                     length:length
  647|      0|                                   response:response];
  648|      0|    });
  649|      0|    return;
  650|      0|  }
  651|      0|  GTMSESSION_ASSERT_DEBUG(_uploadFileHandle, @"Unexpectedly missing upload data package");
  652|      0|  NSFileHandle *uploadFileHandle = self.uploadFileHandle;
  653|      0|  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  654|      0|    [self generateChunkSubdataFromFileHandle:uploadFileHandle
  655|      0|                                      offset:offset
  656|      0|                                      length:length
  657|      0|                                    response:response];
  658|      0|  });
  659|      0|}
  660|       |
  661|       |- (void)generateChunkSubdataFromFileHandle:(NSFileHandle *)fileHandle
  662|       |                                    offset:(int64_t)offset
  663|       |                                    length:(int64_t)length
  664|      0|                                  response:(GTMSessionUploadFetcherDataProviderResponse)response {
  665|      0|  NSData *resultData;
  666|      0|  NSError *error;
  667|      0|  @try {
  668|      0|    [fileHandle seekToFileOffset:(unsigned long long)offset];
  669|      0|    resultData = [fileHandle readDataOfLength:(NSUInteger)length];
  670|      0|  }
  671|      0|  @catch (NSException *exception) {
  672|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"uploadFileHandle failed to read, %@", exception);
  673|      0|    error = [self uploadChunkUnavailableErrorWithDescription:exception.description];
  674|      0|  }
  675|      0|  // The response always re-dispatches to the main thread, so we skip doing that here.
  676|      0|  response(resultData, kGTMSessionUploadFetcherUnknownFileSize, error);
  677|      0|}
  678|       |
  679|       |- (void)generateChunkSubdataFromFileURL:(NSURL *)fileURL
  680|       |                                 offset:(int64_t)offset
  681|       |                                 length:(int64_t)length
  682|      0|                               response:(GTMSessionUploadFetcherDataProviderResponse)response {
  683|      0|  GTMSessionCheckNotSynchronized(self);
  684|      0|
  685|      0|  NSData *resultData;
  686|      0|  NSError *error;
  687|      0|  int64_t fullUploadLength = [self fullUploadLength];
  688|      0|  NSData *mappedData =
  689|      0|      [NSData dataWithContentsOfURL:fileURL
  690|      0|                            options:NSDataReadingMappedAlways + NSDataReadingUncached
  691|      0|                              error:&error];
  692|      0|  if (!mappedData) {
  693|      0|    // We could not create an NSData by memory-mapping the file.
  694|      0|#if TARGET_IPHONE_SIMULATOR
  695|      0|    // NSTemporaryDirectory() can differ in the simulator between app restarts,
  696|      0|    // yet the contents for the new path remains unchanged, so try the latest temp path.
  697|      0|    if ([error.domain isEqual:NSCocoaErrorDomain] && (error.code == NSFileReadNoSuchFileError)) {
  698|      0|      NSString *filename = [fileURL lastPathComponent];
  699|      0|      NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:filename];
  700|      0|      NSURL *newFileURL = [NSURL fileURLWithPath:filePath];
  701|      0|      if (![newFileURL isEqual:fileURL]) {
  702|      0|        [self generateChunkSubdataFromFileURL:newFileURL
  703|      0|                                       offset:offset
  704|      0|                                       length:length
  705|      0|                                     response:response];
  706|      0|        return;
  707|      0|      }
  708|      0|    }
  709|      0|#endif
  710|      0|
  711|      0|    // If the file is just too large to create an NSData for, or if for some other reason we can't
  712|      0|    // map it, create an NSFileHandle instead to read a subset into an NSData.
  713|      0|#if DEBUG
  714|      0|    NSNumber *fileSizeNum;
  715|      0|    BOOL hasFileSize = [fileURL getResourceValue:&fileSizeNum forKey:NSURLFileSizeKey error:NULL];
  716|      0|    GTMSESSION_LOG_DEBUG(@"Note: uploadFileURL is falling back to creating upload chunks by reading"
  717|      0|                         @" an NSFileHandle since uploadFileURL failed to map the upload file,"
  718|      0|                         @" file size %@, %@",
  719|      0|                         hasFileSize ? fileSizeNum : @"unknown", error);
  720|      0|#endif
  721|      0|
  722|      0|    NSFileHandle *fileHandle = [NSFileHandle fileHandleForReadingFromURL:fileURL
  723|      0|                                                                   error:&error];
  724|      0|    if (fileHandle != nil) {
  725|      0|      [self generateChunkSubdataFromFileHandle:fileHandle
  726|      0|                                        offset:offset
  727|      0|                                        length:length
  728|      0|                                      response:response];
  729|      0|      return;
  730|      0|    }
  731|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"uploadFileURL failed to read, %@", error);
  732|      0|    // Fall through with the error.
  733|      0|  } else {
  734|      0|    // Successfully created an NSData by memory-mapping the file.
  735|      0|    if ((NSUInteger)(offset + length) > mappedData.length) {
  736|      0|      NSString *errorMessage = [NSString stringWithFormat:
  737|      0|                                @"Range invalid for upload data.  offset: %lld\tlength: %lld\tdataLength: %lld\texpected UploadLength: %lld",
  738|      0|                                offset, length, (long long)mappedData.length, fullUploadLength];
  739|      0|      GTMSESSION_ASSERT_DEBUG(NO, @"%@", errorMessage);
  740|      0|      response(nil,
  741|      0|               kGTMSessionUploadFetcherUnknownFileSize,
  742|      0|               [self uploadChunkUnavailableErrorWithDescription:errorMessage]);
  743|      0|      return;
  744|      0|    }
  745|      0|    if (offset > 0 || length < fullUploadLength) {
  746|      0|      NSRange range = NSMakeRange((NSUInteger)offset, (NSUInteger)length);
  747|      0|      resultData = [mappedData subdataWithRange:range];
  748|      0|    } else {
  749|      0|      resultData = mappedData;
  750|      0|    }
  751|      0|  }
  752|      0|  // The response always re-dispatches to the main thread, so we skip re-dispatching here.
  753|      0|  response(resultData, kGTMSessionUploadFetcherUnknownFileSize, error);
  754|      0|}
  755|       |
  756|      0|- (NSError *)uploadChunkUnavailableErrorWithDescription:(NSString *)description {
  757|      0|  // The description in the userInfo is intended as a clue to programmers, not
  758|      0|  // for client code to examine or rely on.
  759|      0|  NSDictionary *userInfo = @{ @"description" : description };
  760|      0|  return [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
  761|      0|                             code:GTMSessionFetcherErrorUploadChunkUnavailable
  762|      0|                         userInfo:userInfo];
  763|      0|}
  764|       |
  765|      0|- (NSError *)prematureFailureErrorWithUserInfo:(NSDictionary *)userInfo {
  766|      0|  // An error for if we get an unexpected status from the upload server or
  767|      0|  // otherwise cannot continue.  This is an issue beyond the upload protocol;
  768|      0|  // there's no way the client can do anything useful except give up.
  769|      0|  NSError *error = [NSError errorWithDomain:kGTMSessionFetcherStatusDomain
  770|      0|                                       code:501  // Not implemented
  771|      0|                                   userInfo:userInfo];
  772|      0|  return error;
  773|      0|}
  774|       |
  775|      0|+ (GTMSessionUploadFetcherStatus)uploadStatusFromResponseHeaders:(NSDictionary *)responseHeaders {
  776|      0|  NSString *statusString = [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadStatus];
  777|      0|  if ([statusString isEqual:@"active"]) {
  778|      0|    return kStatusActive;
  779|      0|  }
  780|      0|  if ([statusString isEqual:@"final"]) {
  781|      0|    return kStatusFinal;
  782|      0|  }
  783|      0|  if ([statusString isEqual:@"cancelled"]) {
  784|      0|    return kStatusCancelled;
  785|      0|  }
  786|      0|  return kStatusUnknown;
  787|      0|}
  788|       |
  789|       |#pragma mark Method overrides affecting the initial fetch only
  790|       |
  791|      0|- (void)setCompletionHandler:(GTMSessionFetcherCompletionHandler)handler {
  792|      0|  @synchronized(self) {
  793|      0|    GTMSessionMonitorSynchronized(self);
  794|      0|
  795|      0|    _delegateCompletionHandler = handler;
  796|      0|  }
  797|      0|}
  798|       |
  799|      0|- (void)setDelegateCallbackQueue:(dispatch_queue_t GTM_NULLABLE_TYPE)queue {
  800|      0|  @synchronized(self) {
  801|      0|    GTMSessionMonitorSynchronized(self);
  802|      0|
  803|      0|    _delegateCallbackQueue = queue;
  804|      0|  }
  805|      0|}
  806|       |
  807|      0|- (dispatch_queue_t GTM_NULLABLE_TYPE)delegateCallbackQueue {
  808|      0|  @synchronized(self) {
  809|      0|    GTMSessionMonitorSynchronized(self);
  810|      0|
  811|      0|    return _delegateCallbackQueue;
  812|      0|  }
  813|      0|}
  814|       |
  815|      0|- (BOOL)isRestartedUpload {
  816|      0|  @synchronized(self) {
  817|      0|    GTMSessionMonitorSynchronized(self);
  818|      0|
  819|      0|    return _isRestartedUpload;
  820|      0|  }
  821|      0|}
  822|       |
  823|      0|- (GTMSessionFetcher * GTM_NULLABLE_TYPE)chunkFetcher {
  824|      0|  @synchronized(self) {
  825|      0|    GTMSessionMonitorSynchronized(self);
  826|      0|
  827|      0|    return _chunkFetcher;
  828|      0|  }
  829|      0|}
  830|       |
  831|      0|- (void)setChunkFetcher:(GTMSessionFetcher * GTM_NULLABLE_TYPE)fetcher {
  832|      0|  @synchronized(self) {
  833|      0|    GTMSessionMonitorSynchronized(self);
  834|      0|
  835|      0|    _chunkFetcher = fetcher;
  836|      0|  }
  837|      0|}
  838|       |
  839|      0|- (void)setFetcherInFlight:(GTMSessionFetcher * GTM_NULLABLE_TYPE)fetcher {
  840|      0|  @synchronized(self) {
  841|      0|    GTMSessionMonitorSynchronized(self);
  842|      0|
  843|      0|    _fetcherInFlight = fetcher;
  844|      0|  }
  845|      0|}
  846|       |
  847|      0|- (GTMSessionFetcher * GTM_NULLABLE_TYPE)fetcherInFlight {
  848|      0|  @synchronized(self) {
  849|      0|    GTMSessionMonitorSynchronized(self);
  850|      0|
  851|      0|    return _fetcherInFlight;
  852|      0|  }
  853|      0|}
  854|       |
  855|       |- (void)setCancellationHandler:(GTMSessionUploadFetcherCancellationHandler GTM_NULLABLE_TYPE)
  856|      0|    cancellationHandler {
  857|      0|  @synchronized(self) {
  858|      0|    GTMSessionMonitorSynchronized(self);
  859|      0|
  860|      0|    _cancellationHandler = cancellationHandler;
  861|      0|  }
  862|      0|}
  863|       |
  864|      0|- (GTMSessionUploadFetcherCancellationHandler GTM_NULLABLE_TYPE)cancellationHandler {
  865|      0|  @synchronized(self) {
  866|      0|    GTMSessionMonitorSynchronized(self);
  867|      0|
  868|      0|    return _cancellationHandler;
  869|      0|  }
  870|      0|}
  871|       |
  872|      0|- (void)beginFetchForRetry {
  873|      0|  GTMSessionCheckNotSynchronized(self);
  874|      0|
  875|      0|  // Override the superclass to reset the initial body length and fetcher-in-flight,
  876|      0|  // then call the superclass implementation.
  877|      0|  [self setInitialBodyLength:[self bodyLength]];
  878|      0|
  879|      0|  GTMSESSION_ASSERT_DEBUG(self.fetcherInFlight == nil, @"unexpected fetcher in flight: %@",
  880|      0|                          self.fetcherInFlight);
  881|      0|  self.fetcherInFlight = self;
  882|      0|  [super beginFetchForRetry];
  883|      0|}
  884|       |
  885|      0|- (void)beginFetchWithCompletionHandler:(GTMSessionFetcherCompletionHandler)handler {
  886|      0|  GTMSessionCheckNotSynchronized(self);
  887|      0|
  888|      0|  [self setInitialBodyLength:[self bodyLength]];
  889|      0|
  890|      0|  // We'll hold onto the superclass's callback queue so we can invoke the handler
  891|      0|  // even after the superclass has released the queue and its callback handler, as
  892|      0|  // happens during auth failure.
  893|      0|  [self setDelegateCallbackQueue:self.callbackQueue];
  894|      0|  self.completionHandler = handler;
  895|      0|
  896|      0|  if ([self isRestartedUpload]) {
  897|      0|    // When restarting an upload, we know the destination location for chunk fetches,
  898|      0|    // but we need to query to find the initial offset.
  899|      0|    if (![self isPaused]) {
  900|      0|      [self sendQueryForUploadOffsetWithFetcherProperties:self.properties];
  901|      0|    }
  902|      0|    return;
  903|      0|  }
  904|      0|  // We don't want to call into the client's completion block immediately
  905|      0|  // after the finish of the initial connection (the delegate is called only
  906|      0|  // when uploading finishes), so we substitute our own completion block to be
  907|      0|  // called when the initial connection finishes
  908|      0|  GTMSESSION_ASSERT_DEBUG(self.fetcherInFlight == nil, @"unexpected fetcher in flight: %@",
  909|      0|                          self.fetcherInFlight);
  910|      0|
  911|      0|  self.fetcherInFlight = self;
  912|      0|  [super beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
  913|      0|    self.fetcherInFlight = nil;
  914|      0|    // callback
  915|      0|
  916|      0|    BOOL hasTestBlock = (self.testBlock != nil);
  917|      0|    if (![self isRestartedUpload] && !hasTestBlock) {
  918|      0|      if (error == nil) {
  919|      0|        [self beginChunkFetches];
  920|      0|      } else {
  921|      0|        if ([self retryTimer] == nil) {
  922|      0|          [self invokeFinalCallbackWithData:nil
  923|      0|                                      error:error
  924|      0|                   shouldInvalidateLocation:YES];
  925|      0|        }
  926|      0|      }
  927|      0|    } else {
  928|      0|      // If there was no initial request, then this fetch is resuming some
  929|      0|      // other uploadFetcher's initial request, and the superclass's connection
  930|      0|      // is never used, so at this point we call the user's actual completion
  931|      0|      // block.
  932|      0|      if (!hasTestBlock) {
  933|      0|        [self invokeFinalCallbackWithData:data
  934|      0|                                    error:error
  935|      0|                 shouldInvalidateLocation:YES];
  936|      0|      } else {
  937|      0|        // There was a test block, so we won't do chunk fetches, but we simulate obtaining
  938|      0|        // the data to be uploaded from the upload data provider block or the file handle,
  939|      0|        // and then call back.
  940|      0|        [self generateChunkSubdataWithOffset:0
  941|      0|                                      length:[self fullUploadLength]
  942|      0|                                    response:^(NSData *generateData, int64_t fullUploadLength, NSError *generateError) {
  943|      0|            [self invokeFinalCallbackWithData:data
  944|      0|                                        error:error
  945|      0|                     shouldInvalidateLocation:YES];
  946|      0|        }];
  947|      0|      }
  948|      0|    }
  949|      0|  }];
  950|      0|}
  951|       |
  952|      0|- (void)beginChunkFetches {
  953|      0|  GTMSessionCheckNotSynchronized(self);
  954|      0|
  955|      0|#if DEBUG
  956|      0|  // The initial response of the resumable upload protocol should have an
  957|      0|  // empty body
  958|      0|  //
  959|      0|  // This assert typically happens because the upload create/edit link URL was
  960|      0|  // not supplied with the request, and the server is thus expecting a non-
  961|      0|  // resumable request/response.
  962|      0|  if (self.downloadedData.length > 0) {
  963|      0|    NSData *downloadedData = self.downloadedData;
  964|      0|    NSString *str = [[NSString alloc] initWithData:downloadedData
  965|      0|                                          encoding:NSUTF8StringEncoding];
  966|      0|    #pragma unused(str)
  967|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"unexpected response data (uploading to the wrong URL?)\n%@", str);
  968|      0|  }
  969|      0|#endif
  970|      0|
  971|      0|  // We need to get the upload URL from the location header to continue.
  972|      0|  NSDictionary *responseHeaders = [self responseHeaders];
  973|      0|
  974|      0|  [self retrieveUploadChunkGranularityFromResponseHeaders:responseHeaders];
  975|      0|
  976|      0|  GTMSessionUploadFetcherStatus uploadStatus =
  977|      0|      [[self class] uploadStatusFromResponseHeaders:responseHeaders];
  978|      0|  GTMSESSION_ASSERT_DEBUG(uploadStatus != kStatusUnknown,
  979|      0|      @"beginChunkFetches has unexpected upload status for headers %@", responseHeaders);
  980|      0|
  981|      0|  BOOL isPrematureStop = (uploadStatus == kStatusFinal) || (uploadStatus == kStatusCancelled);
  982|      0|
  983|      0|  NSString *uploadLocationURLStr = [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadURL];
  984|      0|  BOOL hasUploadLocation = (uploadLocationURLStr.length > 0);
  985|      0|
  986|      0|  if (isPrematureStop || !hasUploadLocation) {
  987|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"Premature failure: upload-status:\"%@\"  location:%@",
  988|      0|        [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadStatus], uploadLocationURLStr);
  989|      0|    // We cannot continue since we do not know the location to use
  990|      0|    // as our upload destination.
  991|      0|    NSDictionary *userInfo = nil;
  992|      0|    NSData *downloadedData = self.downloadedData;
  993|      0|    if (downloadedData.length > 0) {
  994|      0|      userInfo = @{ kGTMSessionFetcherStatusDataKey : downloadedData };
  995|      0|    }
  996|      0|    NSError *failureError = [self prematureFailureErrorWithUserInfo:userInfo];
  997|      0|    [self invokeFinalCallbackWithData:nil
  998|      0|                                error:failureError
  999|      0|             shouldInvalidateLocation:YES];
 1000|      0|    return;
 1001|      0|  }
 1002|      0|
 1003|      0|  self.uploadLocationURL = [NSURL URLWithString:uploadLocationURLStr];
 1004|      0|
 1005|      0|  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
 1006|      0|  [nc postNotificationName:kGTMSessionFetcherUploadLocationObtainedNotification
 1007|      0|                    object:self];
 1008|      0|
 1009|      0|  // we've now sent all of the initial post body data, so we need to include
 1010|      0|  // its size in future progress indicator callbacks
 1011|      0|  [self setInitialBodySent:[self initialBodyLength]];
 1012|      0|
 1013|      0|  // just in case the user paused us during the initial fetch...
 1014|      0|  if (![self isPaused]) {
 1015|      0|    [self uploadNextChunkWithOffset:0];
 1016|      0|  }
 1017|      0|}
 1018|       |
 1019|       |- (void)URLSession:(NSURLSession *)session
 1020|       |              task:(NSURLSessionTask *)task
 1021|       |   didSendBodyData:(int64_t)bytesSent
 1022|       |    totalBytesSent:(int64_t)totalBytesSent
 1023|      0|    totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
 1024|      0|  // Overrides the superclass.
 1025|      0|  [self invokeDelegateWithDidSendBytes:bytesSent
 1026|      0|                        totalBytesSent:totalBytesSent
 1027|      0|              totalBytesExpectedToSend:totalBytesExpectedToSend + [self fullUploadLength]];
 1028|      0|}
 1029|       |
 1030|      0|- (BOOL)shouldReleaseCallbacksUponCompletion {
 1031|      0|  // Overrides the superclass.
 1032|      0|
 1033|      0|  // We don't want the superclass to release the delegate and callback
 1034|      0|  // blocks once the initial fetch has finished
 1035|      0|  //
 1036|      0|  // This is invoked for only successful completion of the connection;
 1037|      0|  // an error always will invoke and release the callbacks
 1038|      0|  return NO;
 1039|      0|}
 1040|       |
 1041|       |- (void)invokeFinalCallbackWithData:(NSData *)data
 1042|       |                              error:(NSError *)error
 1043|      0|           shouldInvalidateLocation:(BOOL)shouldInvalidateLocation {
 1044|      0|  @synchronized(self) {
 1045|      0|    GTMSessionMonitorSynchronized(self);
 1046|      0|
 1047|      0|    if (shouldInvalidateLocation) {
 1048|      0|      _uploadLocationURL = nil;
 1049|      0|    }
 1050|      0|
 1051|      0|    dispatch_queue_t queue = _delegateCallbackQueue;
 1052|      0|    GTMSessionFetcherCompletionHandler handler = _delegateCompletionHandler;
 1053|      0|    if (queue && handler) {
 1054|      0|      [self invokeOnCallbackQueue:queue
 1055|      0|                 afterUserStopped:NO
 1056|      0|                            block:^{
 1057|      0|          handler(data, error);
 1058|      0|      }];
 1059|      0|    }
 1060|      0|  }  // @synchronized(self)
 1061|      0|
 1062|      0|  [self releaseUploadAndBaseCallbacks:!self.userStoppedFetching];
 1063|      0|}
 1064|       |
 1065|      0|- (void)releaseUploadAndBaseCallbacks:(BOOL)shouldReleaseCancellation {
 1066|      0|  @synchronized(self) {
 1067|      0|    GTMSessionMonitorSynchronized(self);
 1068|      0|
 1069|      0|    _delegateCallbackQueue = nil;
 1070|      0|    _delegateCompletionHandler = nil;
 1071|      0|    _uploadDataProvider = nil;
 1072|      0|    if (shouldReleaseCancellation) {
 1073|      0|      _cancellationHandler = nil;
 1074|      0|    }
 1075|      0|  }
 1076|      0|
 1077|      0|  // Release the base class's callbacks, too, if needed.
 1078|      0|  [self releaseCallbacks];
 1079|      0|}
 1080|       |
 1081|      0|- (void)stopFetchReleasingCallbacks:(BOOL)shouldReleaseCallbacks {
 1082|      0|  GTMSessionCheckNotSynchronized(self);
 1083|      0|
 1084|      0|  // Clear _fetcherInFlight when stopped. Moved from stopFetching, since that's a public method,
 1085|      0|  // where this method does the work. Fixes issue clearing value when retryBlock included.
 1086|      0|  GTMSessionFetcher *fetcherInFlight = self.fetcherInFlight;
 1087|      0|  if (fetcherInFlight == self) {
 1088|      0|    self.fetcherInFlight = nil;
 1089|      0|  }
 1090|      0|
 1091|      0|  [super stopFetchReleasingCallbacks:shouldReleaseCallbacks];
 1092|      0|
 1093|      0|  if (shouldReleaseCallbacks) {
 1094|      0|    [self releaseUploadAndBaseCallbacks:NO];
 1095|      0|  }
 1096|      0|}
 1097|       |
 1098|       |#pragma mark Chunk fetching methods
 1099|       |
 1100|      0|- (void)uploadNextChunkWithOffset:(int64_t)offset {
 1101|      0|  // use the properties in each chunk fetcher
 1102|      0|  NSDictionary *props = [self properties];
 1103|      0|
 1104|      0|  [self uploadNextChunkWithOffset:offset
 1105|      0|                fetcherProperties:props];
 1106|      0|}
 1107|       |
 1108|      0|- (void)sendQueryForUploadOffsetWithFetcherProperties:(NSDictionary *)props {
 1109|      0|  GTMSessionFetcher *queryFetcher = [self uploadFetcherWithProperties:props
 1110|      0|                                                         isQueryFetch:YES];
 1111|      0|  queryFetcher.bodyData = [NSData data];
 1112|      0|
 1113|      0|  NSString *originalComment = self.comment;
 1114|      0|  [queryFetcher setCommentWithFormat:@"%@ (query offset)",
 1115|      0|   originalComment ? originalComment : @"upload"];
 1116|      0|
 1117|      0|  [queryFetcher setRequestValue:@"query" forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
 1118|      0|
 1119|      0|  self.fetcherInFlight = queryFetcher;
 1120|      0|  [queryFetcher beginFetchWithDelegate:self
 1121|      0|                     didFinishSelector:@selector(queryFetcher:finishedWithData:error:)];
 1122|      0|}
 1123|       |
 1124|       |- (void)queryFetcher:(GTMSessionFetcher *)queryFetcher
 1125|       |    finishedWithData:(NSData *)data
 1126|      0|               error:(NSError *)error {
 1127|      0|  self.fetcherInFlight = nil;
 1128|      0|
 1129|      0|  NSDictionary *responseHeaders = [queryFetcher responseHeaders];
 1130|      0|  NSString *sizeReceivedHeader;
 1131|      0|
 1132|      0|  GTMSessionUploadFetcherStatus uploadStatus =
 1133|      0|      [[self class] uploadStatusFromResponseHeaders:responseHeaders];
 1134|      0|  GTMSESSION_ASSERT_DEBUG(uploadStatus != kStatusUnknown || error != nil,
 1135|      0|      @"query fetcher completion has unexpected upload status for headers %@", responseHeaders);
 1136|      0|
 1137|      0|  if (error == nil) {
 1138|      0|    sizeReceivedHeader = [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadSizeReceived];
 1139|      0|
 1140|      0|    if (uploadStatus == kStatusCancelled ||
 1141|      0|        (uploadStatus == kStatusActive && sizeReceivedHeader == nil)) {
 1142|      0|      NSDictionary *userInfo = nil;
 1143|      0|      if (data.length > 0) {
 1144|      0|        userInfo = @{ kGTMSessionFetcherStatusDataKey : data };
 1145|      0|      }
 1146|      0|      error = [self prematureFailureErrorWithUserInfo:userInfo];
 1147|      0|    }
 1148|      0|  }
 1149|      0|
 1150|      0|  if (error == nil) {
 1151|      0|    int64_t offset = [sizeReceivedHeader longLongValue];
 1152|      0|    int64_t fullUploadLength = [self fullUploadLength];
 1153|      0|    if (uploadStatus == kStatusFinal ||
 1154|      0|        (offset >= fullUploadLength &&
 1155|      0|         fullUploadLength != kGTMSessionUploadFetcherUnknownFileSize)) {
 1156|      0|      // Handle we're done
 1157|      0|      [self chunkFetcher:queryFetcher finishedWithData:data error:nil];
 1158|      0|    } else {
 1159|      0|      [self retrieveUploadChunkGranularityFromResponseHeaders:responseHeaders];
 1160|      0|      [self uploadNextChunkWithOffset:offset];
 1161|      0|    }
 1162|      0|  } else {
 1163|      0|    // Handle query error
 1164|      0|    [self chunkFetcher:queryFetcher finishedWithData:data error:error];
 1165|      0|  }
 1166|      0|}
 1167|       |
 1168|      0|- (void)sendCancelUploadWithFetcherProperties:(NSDictionary *)props {
 1169|      0|  @synchronized(self) {
 1170|      0|    _isCancelInFlight = YES;
 1171|      0|  }
 1172|      0|  GTMSessionFetcher *cancelFetcher = [self uploadFetcherWithProperties:props
 1173|      0|                                                          isQueryFetch:YES];
 1174|      0|  cancelFetcher.bodyData = [NSData data];
 1175|      0|
 1176|      0|  NSString *originalComment = self.comment;
 1177|      0|  [cancelFetcher setCommentWithFormat:@"%@ (cancel)",
 1178|      0|      originalComment ? originalComment : @"upload"];
 1179|      0|
 1180|      0|  [cancelFetcher setRequestValue:@"cancel" forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
 1181|      0|
 1182|      0|  self.fetcherInFlight = cancelFetcher;
 1183|      0|  [cancelFetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
 1184|      0|      self.fetcherInFlight = nil;
 1185|      0|      if (![self triggerCancellationHandlerForFetch:cancelFetcher data:data error:error]) {
 1186|      0|        if (error) {
 1187|      0|          GTMSESSION_LOG_DEBUG(@"cancelFetcher %@", error);
 1188|      0|        }
 1189|      0|      }
 1190|      0|      @synchronized(self) {
 1191|      0|        self->_isCancelInFlight = NO;
 1192|      0|      }
 1193|      0|  }];
 1194|      0|}
 1195|       |
 1196|       |- (void)uploadNextChunkWithOffset:(int64_t)offset
 1197|      0|                fetcherProperties:(NSDictionary *)props {
 1198|      0|  GTMSessionCheckNotSynchronized(self);
 1199|      0|
 1200|      0|  // Example chunk headers:
 1201|      0|  //  X-Goog-Upload-Command: upload, finalize
 1202|      0|  //  X-Goog-Upload-Offset: 0
 1203|      0|  //  Content-Length: 2000000
 1204|      0|  //  Content-Type: image/jpeg
 1205|      0|  //
 1206|      0|  //  {bytes 0-1999999}
 1207|      0|
 1208|      0|  // The chunk upload URL requires no authentication header.
 1209|      0|  GTMSessionFetcher *chunkFetcher = [self uploadFetcherWithProperties:props
 1210|      0|                                                         isQueryFetch:NO];
 1211|      0|  [self attachSendProgressBlockToChunkFetcher:chunkFetcher];
 1212|      0|  int64_t chunkSize = [self updateChunkFetcher:chunkFetcher
 1213|      0|                              forChunkAtOffset:offset];
 1214|      0|  BOOL isUploadingFileURL = (self.uploadFileURL != nil);
 1215|      0|  int64_t fullUploadLength = [self fullUploadLength];
 1216|      0|
 1217|      0|  // The chunk size may have changed, so determine again if we're uploading the full file.
 1218|      0|  BOOL isUploadingFullFile = (offset == 0 &&
 1219|      0|                              fullUploadLength != kGTMSessionUploadFetcherUnknownFileSize &&
 1220|      0|                              chunkSize >= fullUploadLength);
 1221|      0|  if (isUploadingFullFile && isUploadingFileURL) {
 1222|      0|    // The data is the full upload file URL.
 1223|      0|    chunkFetcher.bodyFileURL = self.uploadFileURL;
 1224|      0|    [self beginChunkFetcher:chunkFetcher
 1225|      0|                     offset:offset];
 1226|      0|  } else {
 1227|      0|    // Make an NSData for the subset for this upload chunk.
 1228|      0|    self.subdataGenerating = YES;
 1229|      0|    [self generateChunkSubdataWithOffset:offset
 1230|      0|                                  length:chunkSize
 1231|      0|                                response:^(NSData *chunkData, int64_t uploadFileLength, NSError *chunkError) {
 1232|      0|      // The subdata methods may leave us on a background thread.
 1233|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1234|      0|        self.subdataGenerating = NO;
 1235|      0|
 1236|      0|        // dont allow the updating of fileLength for uploads not using a data provider as they
 1237|      0|        // should know the file length before the upload starts.
 1238|      0|        if (self->_uploadDataProvider != nil && uploadFileLength > 0) {
 1239|      0|          [self setUploadFileLength:uploadFileLength];
 1240|      0|          // Update the command and content-length headers if this is the last chunk to be sent.
 1241|      0|          if (offset + chunkSize >= uploadFileLength) {
 1242|      0|            int64_t updatedChunkSize = [self updateChunkFetcher:chunkFetcher
 1243|      0|                                               forChunkAtOffset:offset];
 1244|      0|            if (updatedChunkSize == 0) {
 1245|      0|              // Calling beginChunkFetcher early when there is no more data to send allows us to
 1246|      0|              // properly handle nil chunkData below without having to account for the case where
 1247|      0|              // we are just finalizing the file.
 1248|      0|              chunkFetcher.bodyData = [[NSData alloc] init];
 1249|      0|              [self beginChunkFetcher:chunkFetcher
 1250|      0|                               offset:offset];
 1251|      0|              return;
 1252|      0|            }
 1253|      0|          }
 1254|      0|        }
 1255|      0|
 1256|      0|        if (chunkData == nil) {
 1257|      0|          NSError *responseError = chunkError;
 1258|      0|          if (!responseError) {
 1259|      0|            responseError = [self uploadChunkUnavailableErrorWithDescription:@"chunkData is nil"];
 1260|      0|          }
 1261|      0|          [self invokeFinalCallbackWithData:nil
 1262|      0|                                      error:responseError
 1263|      0|                   shouldInvalidateLocation:YES];
 1264|      0|          return;
 1265|      0|        }
 1266|      0|
 1267|      0|        BOOL didWriteFile = NO;
 1268|      0|        if (isUploadingFileURL) {
 1269|      0|          // Make a temporary file with the data subset.
 1270|      0|          NSString *tempName =
 1271|      0|              [NSString stringWithFormat:@"GTMUpload_temp_%@", [[NSUUID UUID] UUIDString]];
 1272|      0|          NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:tempName];
 1273|      0|          NSError *writeError;
 1274|      0|          didWriteFile = [chunkData writeToFile:tempPath
 1275|      0|                                        options:NSDataWritingAtomic
 1276|      0|                                          error:&writeError];
 1277|      0|          if (didWriteFile) {
 1278|      0|            chunkFetcher.bodyFileURL = [NSURL fileURLWithPath:tempPath];
 1279|      0|          } else {
 1280|      0|            GTMSESSION_LOG_DEBUG(@"writeToFile failed: %@\n%@", writeError, tempPath);
 1281|      0|          }
 1282|      0|        }
 1283|      0|        if (!didWriteFile) {
 1284|      0|          chunkFetcher.bodyData = [chunkData copy];
 1285|      0|        }
 1286|      0|        [self beginChunkFetcher:chunkFetcher
 1287|      0|                         offset:offset];
 1288|      0|      });
 1289|      0|    }];
 1290|      0|  }
 1291|      0|}
 1292|       |
 1293|       |- (void)beginChunkFetcher:(GTMSessionFetcher *)chunkFetcher
 1294|      0|                   offset:(int64_t)offset {
 1295|      0|
 1296|      0|  // Track the current offset for progress reporting
 1297|      0|  self.currentOffset = offset;
 1298|      0|
 1299|      0|  // Hang on to the fetcher in case we need to cancel it.  We set these before beginning the
 1300|      0|  // chunk fetch so the observers notified of chunk fetches can inspect the upload fetcher to
 1301|      0|  // match to the chunk.
 1302|      0|  self.chunkFetcher = chunkFetcher;
 1303|      0|  self.fetcherInFlight = chunkFetcher;
 1304|      0|
 1305|      0|  // Update the last chunk request, including any request headers.
 1306|      0|  self.lastChunkRequest = chunkFetcher.request;
 1307|      0|
 1308|      0|  [chunkFetcher beginFetchWithDelegate:self
 1309|      0|                     didFinishSelector:@selector(chunkFetcher:finishedWithData:error:)];
 1310|      0|}
 1311|       |
 1312|      0|- (void)attachSendProgressBlockToChunkFetcher:(GTMSessionFetcher *)chunkFetcher {
 1313|      0|  chunkFetcher.sendProgressBlock = ^(int64_t bytesSent, int64_t totalBytesSent,
 1314|      0|                                     int64_t totalBytesExpectedToSend) {
 1315|      0|    // The total bytes expected include the initial body and the full chunked
 1316|      0|    // data, independent of how big this fetcher's chunk is.
 1317|      0|    int64_t initialBodySent = [self bodyLength];  // TODO(grobbins) use [self initialBodySent]
 1318|      0|    int64_t totalSent = initialBodySent + self.currentOffset + totalBytesSent;
 1319|      0|    int64_t totalExpected = initialBodySent + [self fullUploadLength];
 1320|      0|
 1321|      0|    [self invokeDelegateWithDidSendBytes:bytesSent
 1322|      0|                          totalBytesSent:totalSent
 1323|      0|                totalBytesExpectedToSend:totalExpected];
 1324|      0|  };
 1325|      0|}
 1326|       |
 1327|      0|- (NSDictionary *)uploadSessionIdentifierMetadata {
 1328|      0|  NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
 1329|      0|  metadata[kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey] = @YES;
 1330|      0|  GTMSESSION_ASSERT_DEBUG(self.uploadFileURL,
 1331|      0|                          @"Invalid upload fetcher to create session identifier for metadata");
 1332|      0|  metadata[kGTMSessionIdentifierUploadFileURLMetadataKey] = [self.uploadFileURL absoluteString];
 1333|      0|  metadata[kGTMSessionIdentifierUploadFileLengthMetadataKey] = @([self fullUploadLength]);
 1334|      0|
 1335|      0|  if (self.uploadLocationURL) {
 1336|      0|    metadata[kGTMSessionIdentifierUploadLocationURLMetadataKey] =
 1337|      0|        [self.uploadLocationURL absoluteString];
 1338|      0|  }
 1339|      0|  if (self.uploadMIMEType) {
 1340|      0|    metadata[kGTMSessionIdentifierUploadMIMETypeMetadataKey] = self.uploadMIMEType;
 1341|      0|  }
 1342|      0|  metadata[kGTMSessionIdentifierUploadChunkSizeMetadataKey] = @(self.chunkSize);
 1343|      0|  metadata[kGTMSessionIdentifierUploadCurrentOffsetMetadataKey] = @(self.currentOffset);
 1344|      0|  metadata[kGTMSessionIdentifierUploadAllowsCellularAccess] = @(self.request.allowsCellularAccess);
 1345|      0|
 1346|      0|  return metadata;
 1347|      0|}
 1348|       |
 1349|       |- (GTMSessionFetcher *)uploadFetcherWithProperties:(NSDictionary *)properties
 1350|      0|                                      isQueryFetch:(BOOL)isQueryFetch {
 1351|      0|  GTMSessionCheckNotSynchronized(self);
 1352|      0|
 1353|      0|  // Common code to make a request for a query command or for a chunk upload.
 1354|      0|  NSURL *uploadLocationURL = self.uploadLocationURL;
 1355|      0|  NSMutableURLRequest *chunkRequest = [NSMutableURLRequest requestWithURL:uploadLocationURL];
 1356|      0|  [chunkRequest setHTTPMethod:@"PUT"];
 1357|      0|
 1358|      0|  // copy the user-agent from the original connection
 1359|      0|  // n.b. that self.request is nil for upload fetchers created with an existing upload location
 1360|      0|  // URL.
 1361|      0|  NSURLRequest *origRequest = self.request;
 1362|      0|
 1363|      0|  chunkRequest.allowsCellularAccess = origRequest.allowsCellularAccess;
 1364|      0|  if (!origRequest) {
 1365|      0|    chunkRequest.allowsCellularAccess = _allowsCellularAccess;
 1366|      0|  }
 1367|      0|  NSString *userAgent = [origRequest valueForHTTPHeaderField:@"User-Agent"];
 1368|      0|  if (userAgent.length > 0) {
 1369|      0|    [chunkRequest setValue:userAgent forHTTPHeaderField:@"User-Agent"];
 1370|      0|  }
 1371|      0|
 1372|      0|  [chunkRequest setValue:kGTMSessionXGoogUploadProtocolResumable
 1373|      0|      forHTTPHeaderField:kGTMSessionHeaderXGoogUploadProtocol];
 1374|      0|
 1375|      0|  // To avoid timeouts when debugging, copy the timeout of the initial fetcher.
 1376|      0|  NSTimeInterval origTimeout = [origRequest timeoutInterval];
 1377|      0|  [chunkRequest setTimeoutInterval:origTimeout];
 1378|      0|
 1379|      0|  //
 1380|      0|  // Make a new chunk fetcher.
 1381|      0|  //
 1382|      0|  GTMSessionFetcher *chunkFetcher = [GTMSessionFetcher fetcherWithRequest:chunkRequest];
 1383|      0|  chunkFetcher.callbackQueue = self.callbackQueue;
 1384|      0|  chunkFetcher.sessionUserInfo = self.sessionUserInfo;
 1385|      0|  chunkFetcher.configurationBlock = self.configurationBlock;
 1386|      0|  chunkFetcher.allowedInsecureSchemes = self.allowedInsecureSchemes;
 1387|      0|  chunkFetcher.allowLocalhostRequest = self.allowLocalhostRequest;
 1388|      0|  chunkFetcher.allowInvalidServerCertificates = self.allowInvalidServerCertificates;
 1389|      0|  chunkFetcher.useUploadTask = !isQueryFetch;
 1390|      0|
 1391|      0|  if (self.uploadFileURL && !isQueryFetch && self.useBackgroundSession) {
 1392|      0|    [chunkFetcher createSessionIdentifierWithMetadata:[self uploadSessionIdentifierMetadata]];
 1393|      0|  }
 1394|      0|
 1395|      0|  // Give the chunk fetcher the same properties as the previous chunk fetcher
 1396|      0|  chunkFetcher.properties = [properties mutableCopy];
 1397|      0|  [chunkFetcher setProperty:[NSValue valueWithNonretainedObject:self]
 1398|      0|                     forKey:kGTMSessionUploadFetcherChunkParentKey];
 1399|      0|
 1400|      0|  // copy other fetcher settings to the new fetcher
 1401|      0|  chunkFetcher.retryEnabled = self.retryEnabled;
 1402|      0|  chunkFetcher.maxRetryInterval = self.maxRetryInterval;
 1403|      0|
 1404|      0|  if ([self isRetryEnabled]) {
 1405|      0|    // We interpose our own retry method both so we can change the request to ask the server to
 1406|      0|    // tell us where to resume the chunk.
 1407|      0|    chunkFetcher.retryBlock = ^(BOOL suggestedWillRetry, NSError *chunkError,
 1408|      0|                                GTMSessionFetcherRetryResponse response) {
 1409|      0|      void (^finish)(BOOL) = ^(BOOL shouldRetry){
 1410|      0|        // We'll retry by sending an offset query.
 1411|      0|        if (shouldRetry) {
 1412|      0|          self.shouldInitiateOffsetQuery = !isQueryFetch;
 1413|      0|
 1414|      0|          // We don't know what our actual offset is anymore, but the server will tell us.
 1415|      0|          self.currentOffset = 0;
 1416|      0|        }
 1417|      0|        // We don't actually want to retry this specific fetcher.
 1418|      0|        response(NO);
 1419|      0|      };
 1420|      0|
 1421|      0|      GTMSessionFetcherRetryBlock retryBlock = self.retryBlock;
 1422|      0|      if (retryBlock) {
 1423|      0|        // Ask the client, then call the finish block above.
 1424|      0|        retryBlock(suggestedWillRetry, chunkError, finish);
 1425|      0|      } else {
 1426|      0|        finish(suggestedWillRetry);
 1427|      0|      }
 1428|      0|    };
 1429|      0|  }
 1430|      0|
 1431|      0|  return chunkFetcher;
 1432|      0|}
 1433|       |
 1434|       |- (void)chunkFetcher:(GTMSessionFetcher *)chunkFetcher
 1435|       |    finishedWithData:(NSData *)data
 1436|      0|               error:(NSError *)error {
 1437|      0|  BOOL hasDestroyedOldChunkFetcher = NO;
 1438|      0|  self.fetcherInFlight = nil;
 1439|      0|
 1440|      0|  NSDictionary *responseHeaders = [chunkFetcher responseHeaders];
 1441|      0|  GTMSessionUploadFetcherStatus uploadStatus =
 1442|      0|      [[self class] uploadStatusFromResponseHeaders:responseHeaders];
 1443|      0|  GTMSESSION_ASSERT_DEBUG(uploadStatus != kStatusUnknown
 1444|      0|                          || error != nil
 1445|      0|                          || self.wasCreatedFromBackgroundSession,
 1446|      0|      @"chunk fetcher completion has kStatusUnknown upload status for headers %@ fetcher %@",
 1447|      0|      responseHeaders, self);
 1448|      0|  BOOL isUploadStatusStopped = (uploadStatus == kStatusFinal || uploadStatus == kStatusCancelled);
 1449|      0|
 1450|      0|  // Check if the fetcher was actually querying. If it failed, do not retry,
 1451|      0|  // as it would enter an infinite retry loop.
 1452|      0|  NSString *uploadCommand =
 1453|      0|      chunkFetcher.request.allHTTPHeaderFields[kGTMSessionHeaderXGoogUploadCommand];
 1454|      0|  BOOL isQueryFetch = [uploadCommand isEqual:@"query"];
 1455|      0|
 1456|      0|  // TODO
 1457|      0|  // Maybe here we can check to see if the request had x goog content length set. (the file length one).
 1458|      0|  int64_t previousContentLength =
 1459|      0|      [[chunkFetcher.request valueForHTTPHeaderField:@"Content-Length"] longLongValue];
 1460|      0|  // The Content-Length header may not be present if the chunk fetcher was recreated from
 1461|      0|  // a background session.
 1462|      0|  BOOL hasKnownChunkSize = (previousContentLength > 0);
 1463|      0|  BOOL needsQuery = (!hasKnownChunkSize && !isUploadStatusStopped);
 1464|      0|
 1465|      0|  if (error || (needsQuery && !isQueryFetch)) {
 1466|      0|    NSInteger status = error.code;
 1467|      0|
 1468|      0|    // Status 4xx indicates a bad offset in the Google upload protocol. However, do not retry status
 1469|      0|    // 404 per spec, nor if the upload size appears to have been zero (since the server will just
 1470|      0|    // keep asking us to retry.)
 1471|      0|    if (self.shouldInitiateOffsetQuery ||
 1472|      0|        (needsQuery && !isQueryFetch) ||
 1473|      0|        ([error.domain isEqual:kGTMSessionFetcherStatusDomain] &&
 1474|      0|         status >= 400 && status <= 499 &&
 1475|      0|         status != 404 &&
 1476|      0|         uploadStatus == kStatusActive &&
 1477|      0|         previousContentLength > 0)) {
 1478|      0|      self.shouldInitiateOffsetQuery = NO;
 1479|      0|      [self destroyChunkFetcher];
 1480|      0|      hasDestroyedOldChunkFetcher = YES;
 1481|      0|      [self sendQueryForUploadOffsetWithFetcherProperties:chunkFetcher.properties];
 1482|      0|    } else {
 1483|      0|      // Some unexpected status has occurred; handle it as we would a regular
 1484|      0|      // object fetcher failure.
 1485|      0|      [self invokeFinalCallbackWithData:data
 1486|      0|                                  error:error
 1487|      0|               shouldInvalidateLocation:NO];
 1488|      0|    }
 1489|      0|  } else {
 1490|      0|    // The chunk has uploaded successfully.
 1491|      0|    int64_t newOffset = self.currentOffset + previousContentLength;
 1492|      0|#if DEBUG
 1493|      0|    // Verify that if we think all of the uploading data has been sent, the server responded with
 1494|      0|    // the "final" upload status.
 1495|      0|    BOOL hasUploadAllData = (newOffset == [self fullUploadLength]);
 1496|      0|    BOOL isFinalStatus = (uploadStatus == kStatusFinal);
 1497|      0|    #pragma unused(hasUploadAllData,isFinalStatus)
 1498|      0|    GTMSESSION_ASSERT_DEBUG(hasUploadAllData == isFinalStatus || !hasKnownChunkSize,
 1499|      0|                            @"uploadStatus:%@  newOffset:%lld (%lld + %lld)  fullUploadLength:%lld"
 1500|      0|                            @" chunkFetcher:%@ requestHeaders:%@ responseHeaders:%@",
 1501|      0|                            [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadStatus],
 1502|      0|                            newOffset, self.currentOffset, previousContentLength,
 1503|      0|                            [self fullUploadLength],
 1504|      0|                            chunkFetcher, chunkFetcher.request.allHTTPHeaderFields,
 1505|      0|                            responseHeaders);
 1506|      0|#endif
 1507|      0|    if (isUploadStatusStopped || (_currentOffset > _uploadFileLength && _uploadFileLength > 0)) {
 1508|      0|      // This was the last chunk.
 1509|      0|      if (error == nil && uploadStatus == kStatusCancelled) {
 1510|      0|        // Report cancelled status as an error.
 1511|      0|        NSDictionary *userInfo = nil;
 1512|      0|        if (data.length > 0) {
 1513|      0|          userInfo = @{ kGTMSessionFetcherStatusDataKey : data };
 1514|      0|        }
 1515|      0|        data = nil;
 1516|      0|        error = [self prematureFailureErrorWithUserInfo:userInfo];
 1517|      0|      } else {
 1518|      0|        // The upload is in final status.
 1519|      0|        //
 1520|      0|        // Take the chunk fetcher's data as the superclass data.
 1521|      0|        self.downloadedData = data;
 1522|      0|        self.statusCode = chunkFetcher.statusCode;
 1523|      0|      }
 1524|      0|
 1525|      0|      // we're done
 1526|      0|      [self invokeFinalCallbackWithData:data
 1527|      0|                                  error:error
 1528|      0|               shouldInvalidateLocation:YES];
 1529|      0|    } else {
 1530|      0|      // Start the next chunk.
 1531|      0|      self.currentOffset = newOffset;
 1532|      0|
 1533|      0|      // We want to destroy this chunk fetcher before creating the next one, but
 1534|      0|      // we want to pass on its properties
 1535|      0|      NSDictionary *props = [chunkFetcher properties];
 1536|      0|
 1537|      0|      // We no longer need to be able to cancel this chunkFetcher.  Destroy it
 1538|      0|      // before we create a new chunk fetcher.
 1539|      0|      [self destroyChunkFetcher];
 1540|      0|      hasDestroyedOldChunkFetcher = YES;
 1541|      0|
 1542|      0|      [self uploadNextChunkWithOffset:newOffset
 1543|      0|                    fetcherProperties:props];
 1544|      0|    }
 1545|      0|  }
 1546|      0|  if (!hasDestroyedOldChunkFetcher) {
 1547|      0|    [self destroyChunkFetcher];
 1548|      0|  }
 1549|      0|}
 1550|       |
 1551|      0|- (void)destroyChunkFetcher {
 1552|      0|  @synchronized(self) {
 1553|      0|    GTMSessionMonitorSynchronized(self);
 1554|      0|
 1555|      0|    if (_fetcherInFlight == _chunkFetcher) {
 1556|      0|      _fetcherInFlight = nil;
 1557|      0|    }
 1558|      0|
 1559|      0|    [_chunkFetcher stopFetching];
 1560|      0|
 1561|      0|    NSURL *chunkFileURL = _chunkFetcher.bodyFileURL;
 1562|      0|    BOOL wasTemporaryUploadFile = ![chunkFileURL isEqual:_uploadFileURL];
 1563|      0|    if (wasTemporaryUploadFile) {
 1564|      0|      NSError *error;
 1565|      0|      [[NSFileManager defaultManager] removeItemAtURL:chunkFileURL
 1566|      0|                                                error:&error];
 1567|      0|      if (error) {
 1568|      0|        GTMSESSION_LOG_DEBUG(@"removingItemAtURL failed: %@\n%@", error, chunkFileURL);
 1569|      0|      }
 1570|      0|    }
 1571|      0|
 1572|      0|    _recentChunkReponseHeaders = _chunkFetcher.responseHeaders;
 1573|      0|
 1574|      0|    // To avoid retain cycles, remove all properties except the parent identifier.
 1575|      0|    _chunkFetcher.properties =
 1576|      0|        @{ kGTMSessionUploadFetcherChunkParentKey : [NSValue valueWithNonretainedObject:self] };
 1577|      0|
 1578|      0|    _chunkFetcher.retryBlock = nil;
 1579|      0|    _chunkFetcher.sendProgressBlock = nil;
 1580|      0|    _chunkFetcher = nil;
 1581|      0|  }  // @synchronized(self)
 1582|      0|}
 1583|       |
 1584|       |// This method calculates the proper values to pass to the client's send progress block.
 1585|       |//
 1586|       |// The actual total bytes sent include the initial body sent, plus the
 1587|       |// offset into the batched data prior to the current chunk fetcher
 1588|       |
 1589|       |- (void)invokeDelegateWithDidSendBytes:(int64_t)bytesSent
 1590|       |                        totalBytesSent:(int64_t)totalBytesSent
 1591|      0|              totalBytesExpectedToSend:(int64_t)totalBytesExpected {
 1592|      0|  GTMSessionCheckNotSynchronized(self);
 1593|      0|
 1594|      0|  // Ensure the chunk fetcher survives the callback in case the user pauses the upload process.
 1595|      0|  __block GTMSessionFetcher *holdFetcher = self.chunkFetcher;
 1596|      0|
 1597|      0|  [self invokeOnCallbackQueue:self.delegateCallbackQueue
 1598|      0|             afterUserStopped:NO
 1599|      0|                        block:^{
 1600|      0|      GTMSessionFetcherSendProgressBlock sendProgressBlock = self.sendProgressBlock;
 1601|      0|      if (sendProgressBlock) {
 1602|      0|        sendProgressBlock(bytesSent, totalBytesSent, totalBytesExpected);
 1603|      0|      }
 1604|      0|      holdFetcher = nil;
 1605|      0|  }];
 1606|      0|}
 1607|       |
 1608|      0|- (void)retrieveUploadChunkGranularityFromResponseHeaders:(NSDictionary *)responseHeaders {
 1609|      0|  GTMSessionCheckNotSynchronized(self);
 1610|      0|
 1611|      0|  // Standard granularity for Google uploads is 256K.
 1612|      0|  NSString *chunkGranularityHeader =
 1613|      0|      [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadChunkGranularity];
 1614|      0|  self.uploadGranularity = chunkGranularityHeader.longLongValue;
 1615|      0|}
 1616|       |
 1617|       |#pragma mark -
 1618|       |
 1619|      0|- (BOOL)isPaused {
 1620|      0|  @synchronized(self) {
 1621|      0|    GTMSessionMonitorSynchronized(self);
 1622|      0|
 1623|      0|    return _isPaused;
 1624|      0|  }  // @synchronized(self)
 1625|      0|}
 1626|       |
 1627|      0|- (void)pauseFetching {
 1628|      0|  @synchronized(self) {
 1629|      0|    GTMSessionMonitorSynchronized(self);
 1630|      0|
 1631|      0|    _isPaused = YES;
 1632|      0|  }  // @synchronized(self)
 1633|      0|
 1634|      0|  // Pausing just means stopping the current chunk from uploading;
 1635|      0|  // when we resume, we will send a query request to the server to
 1636|      0|  // figure out what bytes to resume sending.
 1637|      0|  //
 1638|      0|  // We won't try to cancel the initial data upload, but rather will check
 1639|      0|  // for being paused in beginChunkFetches.
 1640|      0|  [self destroyChunkFetcher];
 1641|      0|}
 1642|       |
 1643|      0|- (void)resumeFetching {
 1644|      0|  BOOL wasPaused;
 1645|      0|
 1646|      0|  @synchronized(self) {
 1647|      0|    GTMSessionMonitorSynchronized(self);
 1648|      0|
 1649|      0|    wasPaused = _isPaused;
 1650|      0|    _isPaused = NO;
 1651|      0|  }  // @synchronized(self)
 1652|      0|
 1653|      0|  if (wasPaused) {
 1654|      0|    [self sendQueryForUploadOffsetWithFetcherProperties:self.properties];
 1655|      0|  }
 1656|      0|}
 1657|       |
 1658|      0|- (void)stopFetching {
 1659|      0|  // Overrides the superclass
 1660|      0|  [self destroyChunkFetcher];
 1661|      0|
 1662|      0|  // If we think the server is waiting for more data, then tell it there won't be more.
 1663|      0|  if (self.uploadLocationURL) {
 1664|      0|    [self sendCancelUploadWithFetcherProperties:[self properties]];
 1665|      0|    self.uploadLocationURL = nil;
 1666|      0|  } else {
 1667|      0|    [self invokeOnCallbackQueue:self.callbackQueue
 1668|      0|               afterUserStopped:YES
 1669|      0|                          block:^{
 1670|      0|      // Repeated calls to stopFetching may cause this path to be reached despite having sent a real
 1671|      0|      // cancel request, check here to ensure that the cancellation handler invocation which fires
 1672|      0|      // will definitely be for the real request sent previously.
 1673|      0|      @synchronized(self) {
 1674|      0|        if (self->_isCancelInFlight) {
 1675|      0|          return;
 1676|      0|        }
 1677|      0|      }
 1678|      0|      [self triggerCancellationHandlerForFetch:nil data:nil error:nil];
 1679|      0|    }];
 1680|      0|  }
 1681|      0|
 1682|      0|  [super stopFetching];
 1683|      0|}
 1684|       |
 1685|       |// Fires the cancellation handler, returning whether there was a handler to be fired.
 1686|       |- (BOOL)triggerCancellationHandlerForFetch:(GTMSessionFetcher *)fetcher
 1687|       |                                      data:(NSData *)data
 1688|      0|                                     error:(NSError *)error {
 1689|      0|  GTMSessionUploadFetcherCancellationHandler handler = self.cancellationHandler;
 1690|      0|  if (handler) {
 1691|      0|    handler(fetcher, data, error);
 1692|      0|    self.cancellationHandler = nil;
 1693|      0|    return YES;
 1694|      0|  }
 1695|      0|  return NO;
 1696|      0|}
 1697|       |
 1698|       |#pragma mark -
 1699|       |
 1700|       |- (int64_t)updateChunkFetcher:(GTMSessionFetcher *)chunkFetcher
 1701|      0|             forChunkAtOffset:(int64_t)offset {
 1702|      0|  BOOL isUploadingFileURL = (self.uploadFileURL != nil);
 1703|      0|
 1704|      0|  // Upload another chunk, meeting server-required granularity.
 1705|      0|  int64_t chunkSize = self.chunkSize;
 1706|      0|
 1707|      0|  int64_t fullUploadLength = [self fullUploadLength];
 1708|      0|  BOOL isFileLengthKnown = fullUploadLength >= 0;
 1709|      0|
 1710|      0|  BOOL isUploadingFullFile = (offset == 0 && isFileLengthKnown && chunkSize >= fullUploadLength);
 1711|      0|  if (!isUploadingFileURL || !isUploadingFullFile) {
 1712|      0|    // We're not uploading the entire file and given the file URL.  Since we'll be
 1713|      0|    // allocating a subdata block for a chunk, we need to bound it to something that
 1714|      0|    // won't blow the process's memory.
 1715|      0|    if (chunkSize > kGTMSessionUploadFetcherMaximumDemandBufferSize) {
 1716|      0|      chunkSize = kGTMSessionUploadFetcherMaximumDemandBufferSize;
 1717|      0|    }
 1718|      0|  }
 1719|      0|
 1720|      0|  int64_t granularity = self.uploadGranularity;
 1721|      0|  if (granularity > 0) {
 1722|      0|    if (chunkSize < granularity) {
 1723|      0|      chunkSize = granularity;
 1724|      0|    } else {
 1725|      0|      chunkSize = chunkSize - (chunkSize % granularity);
 1726|      0|    }
 1727|      0|  }
 1728|      0|
 1729|      0|  GTMSESSION_ASSERT_DEBUG(offset < fullUploadLength || fullUploadLength == 0,
 1730|      0|                          @"offset %lld exceeds data length %lld", offset, fullUploadLength);
 1731|      0|
 1732|      0|  if (granularity > 0) {
 1733|      0|    offset = offset - (offset % granularity);
 1734|      0|  }
 1735|      0|
 1736|      0|  // If the chunk size is bigger than the remaining data, or else
 1737|      0|  // it's close enough in size to the remaining data that we'd rather
 1738|      0|  // avoid having a whole extra http fetch for the leftover bit, then make
 1739|      0|  // this chunk size exactly match the remaining data size
 1740|      0|  NSString *command;
 1741|      0|  int64_t thisChunkSize = chunkSize;
 1742|      0|
 1743|      0|  BOOL isChunkTooBig = (thisChunkSize >= (fullUploadLength - offset));
 1744|      0|  BOOL isChunkAlmostBigEnough = (fullUploadLength - offset - 2500 < thisChunkSize);
 1745|      0|  BOOL isFinalChunk = (isChunkTooBig || isChunkAlmostBigEnough) && isFileLengthKnown;
 1746|      0|  if (isFinalChunk) {
 1747|      0|    thisChunkSize = fullUploadLength - offset;
 1748|      0|    if (thisChunkSize > 0) {
 1749|      0|      command = @"upload, finalize";
 1750|      0|    } else {
 1751|      0|      command = @"finalize";
 1752|      0|    }
 1753|      0|  } else {
 1754|      0|    command = @"upload";
 1755|      0|  }
 1756|      0|  NSString *lengthStr = @(thisChunkSize).stringValue;
 1757|      0|  NSString *offsetStr = @(offset).stringValue;
 1758|      0|
 1759|      0|  [chunkFetcher setRequestValue:command forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
 1760|      0|  [chunkFetcher setRequestValue:lengthStr forHTTPHeaderField:@"Content-Length"];
 1761|      0|  [chunkFetcher setRequestValue:offsetStr forHTTPHeaderField:kGTMSessionHeaderXGoogUploadOffset];
 1762|      0|  if (_uploadFileLength != kGTMSessionUploadFetcherUnknownFileSize) {
 1763|      0|    [chunkFetcher setRequestValue:@([self fullUploadLength]).stringValue
 1764|      0|               forHTTPHeaderField:kGTMSessionHeaderXGoogUploadContentLength];
 1765|      0|  }
 1766|      0|
 1767|      0|  // Append the range of bytes in this chunk to the fetcher comment.
 1768|      0|  NSString *baseComment = self.comment;
 1769|      0|  [chunkFetcher setCommentWithFormat:@"%@ (%lld-%lld)",
 1770|      0|      baseComment ? baseComment : @"upload", offset, MAX(0, offset + thisChunkSize - 1)];
 1771|      0|
 1772|      0|  return thisChunkSize;
 1773|      0|}
 1774|       |
 1775|       |// Public properties.
 1776|       |@synthesize currentOffset = _currentOffset,
 1777|       |            allowsCellularAccess = _allowsCellularAccess,
 1778|       |            delegateCompletionHandler = _delegateCompletionHandler,
 1779|       |            chunkFetcher = _chunkFetcher,
 1780|       |            lastChunkRequest = _lastChunkRequest,
 1781|       |            subdataGenerating = _subdataGenerating,
 1782|       |            shouldInitiateOffsetQuery = _shouldInitiateOffsetQuery,
 1783|       |            uploadGranularity = _uploadGranularity;
 1784|       |
 1785|       |// Internal properties.
 1786|       |@dynamic fetcherInFlight;
 1787|       |@dynamic activeFetcher;
 1788|       |@dynamic statusCode;
 1789|       |@dynamic delegateCallbackQueue;
 1790|       |
 1791|      0|+ (void)removePointer:(void *)pointer fromPointerArray:(NSPointerArray *)pointerArray {
 1792|      0|  for (NSUInteger index = 0, count = pointerArray.count; index < count; ++index) {
 1793|      0|    void *pointerAtIndex = [pointerArray pointerAtIndex:index];
 1794|      0|    if (pointerAtIndex == pointer) {
 1795|      0|      [pointerArray removePointerAtIndex:index];
 1796|      0|      return;
 1797|      0|    }
 1798|      0|  }
 1799|      0|}
 1800|       |
 1801|      0|- (BOOL)useBackgroundSession {
 1802|      0|  @synchronized(self) {
 1803|      0|    GTMSessionMonitorSynchronized(self);
 1804|      0|
 1805|      0|    return _useBackgroundSessionOnChunkFetchers;
 1806|      0|  }  // @synchronized(self
 1807|      0|}
 1808|       |
 1809|      0|- (void)setUseBackgroundSession:(BOOL)useBackgroundSession {
 1810|      0|  @synchronized(self) {
 1811|      0|    GTMSessionMonitorSynchronized(self);
 1812|      0|
 1813|      0|    if (_useBackgroundSessionOnChunkFetchers != useBackgroundSession) {
 1814|      0|      _useBackgroundSessionOnChunkFetchers = useBackgroundSession;
 1815|      0|      NSPointerArray *uploadFetcherPointerArrayForBackgroundSessions =
 1816|      0|          [[self class] uploadFetcherPointerArrayForBackgroundSessions];
 1817|      0|      @synchronized(uploadFetcherPointerArrayForBackgroundSessions) {
 1818|      0|        if (_useBackgroundSessionOnChunkFetchers) {
 1819|      0|          [uploadFetcherPointerArrayForBackgroundSessions addPointer:(__bridge void *)self];
 1820|      0|        } else {
 1821|      0|          [[self class] removePointer:(__bridge void *)self
 1822|      0|                     fromPointerArray:uploadFetcherPointerArrayForBackgroundSessions];
 1823|      0|        }
 1824|      0|      }  // @synchronized(uploadFetcherPointerArrayForBackgroundSessions)
 1825|      0|    }
 1826|      0|  }  // @synchronized(self)
 1827|      0|}
 1828|       |
 1829|      0|- (BOOL)canFetchWithBackgroundSession {
 1830|      0|  // The initial upload fetcher is always a foreground session; the
 1831|      0|  // useBackgroundSession property will apply only to chunk fetchers,
 1832|      0|  // not to queries.
 1833|      0|  return NO;
 1834|      0|}
 1835|       |
 1836|      0|- (NSDictionary *)responseHeaders {
 1837|      0|  GTMSessionCheckNotSynchronized(self);
 1838|      0|  // Overrides the superclass
 1839|      0|
 1840|      0|  // If asked for the fetcher's response, use the most recent chunk fetcher's response,
 1841|      0|  // since the original request's response lacks useful information like the actual
 1842|      0|  // Content-Type.
 1843|      0|  NSDictionary *dict = self.chunkFetcher.responseHeaders;
 1844|      0|  if (dict) {
 1845|      0|    return dict;
 1846|      0|  }
 1847|      0|
 1848|      0|  @synchronized(self) {
 1849|      0|    GTMSessionMonitorSynchronized(self);
 1850|      0|
 1851|      0|    if (_recentChunkReponseHeaders) {
 1852|      0|      return _recentChunkReponseHeaders;
 1853|      0|    }
 1854|      0|  }  // @synchronized(self
 1855|      0|
 1856|      0|  // No chunk fetcher yet completed, so return whatever we have from the initial fetch.
 1857|      0|  return [super responseHeaders];
 1858|      0|}
 1859|       |
 1860|      0|- (NSInteger)statusCodeUnsynchronized {
 1861|      0|  GTMSessionCheckSynchronized(self);
 1862|      0|
 1863|      0|  if (_recentChunkStatusCode != -1) {
 1864|      0|    // Overrides the superclass to indicate status appropriate to the initial
 1865|      0|    // or latest chunk fetch
 1866|      0|    return _recentChunkStatusCode;
 1867|      0|  } else {
 1868|      0|    return [super statusCodeUnsynchronized];
 1869|      0|  }
 1870|      0|}
 1871|       |
 1872|       |
 1873|      0|- (void)setStatusCode:(NSInteger)val {
 1874|      0|  @synchronized(self) {
 1875|      0|    GTMSessionMonitorSynchronized(self);
 1876|      0|
 1877|      0|    _recentChunkStatusCode = val;
 1878|      0|  }
 1879|      0|}
 1880|       |
 1881|      0|- (int64_t)initialBodyLength {
 1882|      0|  @synchronized(self) {
 1883|      0|    GTMSessionMonitorSynchronized(self);
 1884|      0|
 1885|      0|    return _initialBodyLength;
 1886|      0|  }
 1887|      0|}
 1888|       |
 1889|      0|- (void)setInitialBodyLength:(int64_t)length {
 1890|      0|  @synchronized(self) {
 1891|      0|    GTMSessionMonitorSynchronized(self);
 1892|      0|
 1893|      0|    _initialBodyLength = length;
 1894|      0|  }
 1895|      0|}
 1896|       |
 1897|      0|- (int64_t)initialBodySent {
 1898|      0|  @synchronized(self) {
 1899|      0|    GTMSessionMonitorSynchronized(self);
 1900|      0|
 1901|      0|    return _initialBodySent;
 1902|      0|  }
 1903|      0|}
 1904|       |
 1905|      0|- (void)setInitialBodySent:(int64_t)length {
 1906|      0|  @synchronized(self) {
 1907|      0|    GTMSessionMonitorSynchronized(self);
 1908|      0|
 1909|      0|    _initialBodySent = length;
 1910|      0|  }
 1911|      0|}
 1912|       |
 1913|      0|- (NSURL *)uploadLocationURL {
 1914|      0|  @synchronized(self) {
 1915|      0|    GTMSessionMonitorSynchronized(self);
 1916|      0|
 1917|      0|    return _uploadLocationURL;
 1918|      0|  }
 1919|      0|}
 1920|       |
 1921|      0|- (void)setUploadLocationURL:(NSURL *)locationURL {
 1922|      0|  @synchronized(self) {
 1923|      0|    GTMSessionMonitorSynchronized(self);
 1924|      0|
 1925|      0|    _uploadLocationURL = locationURL;
 1926|      0|  }
 1927|      0|}
 1928|       |
 1929|      0|- (GTMSessionFetcher *)activeFetcher {
 1930|      0|  GTMSessionFetcher *result = self.fetcherInFlight;
 1931|      0|  if (result) return result;
 1932|      0|
 1933|      0|  return self;
 1934|      0|}
 1935|       |
 1936|      0|- (BOOL)isFetching {
 1937|      0|  // If there is an active chunk fetcher, then the upload fetcher is considered
 1938|      0|  // to still be fetching.
 1939|      0|  if (self.fetcherInFlight != nil) return YES;
 1940|      0|
 1941|      0|  return [super isFetching];
 1942|      0|}
 1943|       |
 1944|      0|- (BOOL)waitForCompletionWithTimeout:(NSTimeInterval)timeoutInSeconds {
 1945|      0|  NSDate *timeoutDate = [NSDate dateWithTimeIntervalSinceNow:timeoutInSeconds];
 1946|      0|
 1947|      0|  while (self.fetcherInFlight || self.subdataGenerating) {
 1948|      0|    if ([timeoutDate timeIntervalSinceNow] < 0) return NO;
 1949|      0|
 1950|      0|    if (self.subdataGenerating) {
 1951|      0|      // Allow time for subdata generation.
 1952|      0|      NSDate *stopDate = [NSDate dateWithTimeIntervalSinceNow:0.001];
 1953|      0|      [[NSRunLoop currentRunLoop] runUntilDate:stopDate];
 1954|      0|    } else {
 1955|      0|      // Wait for any chunk or query fetchers that still have pending callbacks or
 1956|      0|      // notifications.
 1957|      0|      BOOL timedOut;
 1958|      0|
 1959|      0|      if (self.fetcherInFlight == self) {
 1960|      0|        timedOut = ![super waitForCompletionWithTimeout:timeoutInSeconds];
 1961|      0|      } else {
 1962|      0|        timedOut = ![self.fetcherInFlight waitForCompletionWithTimeout:timeoutInSeconds];
 1963|      0|      }
 1964|      0|      if (timedOut) return NO;
 1965|      0|    }
 1966|      0|  }
 1967|      0|  return YES;
 1968|      0|}
 1969|       |
 1970|       |@end
 1971|       |
 1972|       |@implementation GTMSessionFetcher (GTMSessionUploadFetcherMethods)
 1973|       |
 1974|      0|- (GTMSessionUploadFetcher *)parentUploadFetcher {
 1975|      0|  NSValue *property = [self propertyForKey:kGTMSessionUploadFetcherChunkParentKey];
 1976|      0|  if (!property) return nil;
 1977|      0|
 1978|      0|  GTMSessionUploadFetcher *uploadFetcher = property.nonretainedObjectValue;
 1979|      0|
 1980|      0|  GTMSESSION_ASSERT_DEBUG([uploadFetcher isKindOfClass:[GTMSessionUploadFetcher class]],
 1981|      0|                          @"Unexpected parent upload fetcher class: %@", [uploadFetcher class]);
 1982|      0|  return uploadFetcher;
 1983|      0|}
 1984|       |
 1985|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORAssert.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORAssert.h"
   18|       |
   19|      0|GDTCORAssertionBlock GDTCORAssertionBlockToRunInstead(void) {
   20|      0|  // This class is only compiled in by unit tests, and this should fail quickly in optimized builds.
   21|      0|  Class GDTCORAssertClass = NSClassFromString(@"GDTCORAssertHelper");
   22|      0|  if (__builtin_expect(!!GDTCORAssertClass, 0)) {
   23|      0|    SEL assertionBlockSEL = NSSelectorFromString(@"assertionBlock");
   24|      0|    if (assertionBlockSEL) {
   25|      0|      IMP assertionBlockIMP = [GDTCORAssertClass methodForSelector:assertionBlockSEL];
   26|      0|      if (assertionBlockIMP) {
   27|      0|        GDTCORAssertionBlock assertionBlock = ((GDTCORAssertionBlock(*)(id, SEL))assertionBlockIMP)(
   28|      0|            GDTCORAssertClass, assertionBlockSEL);
   29|      0|        if (assertionBlock) {
   30|      0|          return assertionBlock;
   31|      0|        }
   32|      0|      }
   33|      0|    }
   34|      0|  }
   35|      0|  return NULL;
   36|      0|}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORClock.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORClock.h"
   18|       |
   19|       |#import <sys/sysctl.h>
   20|       |
   21|       |// Using a monotonic clock is necessary because CFAbsoluteTimeGetCurrent(), NSDate, and related all
   22|       |// are subject to drift. That it to say, multiple consecutive calls do not always result in a
   23|       |// time that is in the future. Clocks may be adjusted by the user, NTP, or any number of external
   24|       |// factors. This class attempts to determine the wall-clock time at the time of the event by
   25|       |// capturing the kernel start and time since boot to determine a wallclock time in UTC.
   26|       |//
   27|       |// Timezone offsets at the time of a snapshot are also captured in order to provide local-time
   28|       |// details. Other classes in this library depend on comparing times at some time in the future to
   29|       |// a time captured in the past, and this class needs to provide a mechanism to do that.
   30|       |//
   31|       |// TL;DR: This class attempts to accomplish two things: 1. Provide accurate event times. 2. Provide
   32|       |// a monotonic clock mechanism to accurately check if some clock snapshot was before or after
   33|       |// by using a shared reference point (kernel boot time).
   34|       |//
   35|       |// Note: Much of the mach time stuff doesn't work properly in the simulator. So this class can be
   36|       |// difficult to unit test.
   37|       |
   38|       |/** Returns the kernel boottime property from sysctl.
   39|       | *
   40|       | * Inspired by https://stackoverflow.com/a/40497811
   41|       | *
   42|       | * @return The KERN_BOOTTIME property from sysctl, in nanoseconds.
   43|       | */
   44|     39|static int64_t KernelBootTimeInNanoseconds() {
   45|     39|  // Caching the result is not possible because clock drift would not be accounted for.
   46|     39|  struct timeval boottime;
   47|     39|  int mib[2] = {CTL_KERN, KERN_BOOTTIME};
   48|     39|  size_t size = sizeof(boottime);
   49|     39|  int rc = sysctl(mib, 2, &boottime, &size, NULL, 0);
   50|     39|  if (rc != 0) {
   51|      0|    return 0;
   52|      0|  }
   53|     39|  return (int64_t)boottime.tv_sec * NSEC_PER_MSEC + (int64_t)boottime.tv_usec;
   54|     39|}
   55|       |
   56|       |/** Returns value of gettimeofday, in nanoseconds.
   57|       | *
   58|       | * Inspired by https://stackoverflow.com/a/40497811
   59|       | *
   60|       | * @return The value of gettimeofday, in nanoseconds.
   61|       | */
   62|     13|static int64_t UptimeInNanoseconds() {
   63|     13|  int64_t before_now;
   64|     13|  int64_t after_now;
   65|     13|  struct timeval now;
   66|     13|
   67|     13|  before_now = KernelBootTimeInNanoseconds();
   68|     13|  // Addresses a race condition in which the system time has updated, but the boottime has not.
   69|     13|  do {
   70|     13|    gettimeofday(&now, NULL);
   71|     13|    after_now = KernelBootTimeInNanoseconds();
   72|     13|  } while (after_now != before_now);
   73|     13|  return (int64_t)now.tv_sec * NSEC_PER_MSEC + (int64_t)now.tv_usec - before_now;
   74|     13|}
   75|       |
   76|       |// TODO: Consider adding a 'trustedTime' property that can be populated by the response from a BE.
   77|       |@implementation GDTCORClock
   78|       |
   79|     13|- (instancetype)init {
   80|     13|  self = [super init];
   81|     13|  if (self) {
   82|     13|    _kernelBootTime = KernelBootTimeInNanoseconds();
   83|     13|    _uptime = UptimeInNanoseconds();
   84|     13|    _timeMillis =
   85|     13|        (int64_t)((CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970) * NSEC_PER_USEC);
   86|     13|    CFTimeZoneRef timeZoneRef = CFTimeZoneCopySystem();
   87|     13|    _timezoneOffsetSeconds = CFTimeZoneGetSecondsFromGMT(timeZoneRef, 0);
   88|     13|    CFRelease(timeZoneRef);
   89|     13|  }
   90|     13|  return self;
   91|     13|}
   92|       |
   93|     13|+ (GDTCORClock *)snapshot {
   94|     13|  return [[GDTCORClock alloc] init];
   95|     13|}
   96|       |
   97|      6|+ (instancetype)clockSnapshotInTheFuture:(uint64_t)millisInTheFuture {
   98|      6|  GDTCORClock *snapshot = [self snapshot];
   99|      6|  snapshot->_timeMillis += millisInTheFuture;
  100|      6|  return snapshot;
  101|      6|}
  102|       |
  103|      0|- (BOOL)isAfter:(GDTCORClock *)otherClock {
  104|      0|  // These clocks are trivially comparable when they share a kernel boot time.
  105|      0|  if (_kernelBootTime == otherClock->_kernelBootTime) {
  106|      0|    int64_t timeDiff = (_timeMillis + _timezoneOffsetSeconds) -
  107|      0|                       (otherClock->_timeMillis + otherClock->_timezoneOffsetSeconds);
  108|      0|    return timeDiff > 0;
  109|      0|  } else {
  110|      0|    int64_t kernelBootTimeDiff = otherClock->_kernelBootTime - _kernelBootTime;
  111|      0|    // This isn't a great solution, but essentially, if the other clock's boot time is 'later', NO
  112|      0|    // is returned. This can be altered by changing the system time and rebooting.
  113|      0|    return kernelBootTimeDiff < 0 ? YES : NO;
  114|      0|  }
  115|      0|}
  116|       |
  117|    461|- (NSUInteger)hash {
  118|    461|  return [@(_kernelBootTime) hash] ^ [@(_uptime) hash] ^ [@(_timeMillis) hash] ^
  119|    461|         [@(_timezoneOffsetSeconds) hash];
  120|    461|}
  121|       |
  122|      0|- (BOOL)isEqual:(id)object {
  123|      0|  return [self hash] == [object hash];
  124|      0|}
  125|       |
  126|       |#pragma mark - NSSecureCoding
  127|       |
  128|       |/** NSKeyedCoder key for timeMillis property. */
  129|       |static NSString *const kGDTCORClockTimeMillisKey = @"GDTCORClockTimeMillis";
  130|       |
  131|       |/** NSKeyedCoder key for timezoneOffsetMillis property. */
  132|       |static NSString *const kGDTCORClockTimezoneOffsetSeconds = @"GDTCORClockTimezoneOffsetSeconds";
  133|       |
  134|       |/** NSKeyedCoder key for _kernelBootTime ivar. */
  135|       |static NSString *const kGDTCORClockKernelBootTime = @"GDTCORClockKernelBootTime";
  136|       |
  137|       |/** NSKeyedCoder key for _uptime ivar. */
  138|       |static NSString *const kGDTCORClockUptime = @"GDTCORClockUptime";
  139|       |
  140|     56|+ (BOOL)supportsSecureCoding {
  141|     56|  return YES;
  142|     56|}
  143|       |
  144|     56|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  145|     56|  self = [super init];
  146|     56|  if (self) {
  147|     56|    // TODO: If the kernelBootTime is more recent, we need to change the kernel boot time and
  148|     56|    // uptimeMillis ivars
  149|     56|    _timeMillis = [aDecoder decodeInt64ForKey:kGDTCORClockTimeMillisKey];
  150|     56|    _timezoneOffsetSeconds = [aDecoder decodeInt64ForKey:kGDTCORClockTimezoneOffsetSeconds];
  151|     56|    _kernelBootTime = [aDecoder decodeInt64ForKey:kGDTCORClockKernelBootTime];
  152|     56|    _uptime = [aDecoder decodeInt64ForKey:kGDTCORClockUptime];
  153|     56|  }
  154|     56|  return self;
  155|     56|}
  156|       |
  157|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  158|      0|  [aCoder encodeInt64:_timeMillis forKey:kGDTCORClockTimeMillisKey];
  159|      0|  [aCoder encodeInt64:_timezoneOffsetSeconds forKey:kGDTCORClockTimezoneOffsetSeconds];
  160|      0|  [aCoder encodeInt64:_kernelBootTime forKey:kGDTCORClockKernelBootTime];
  161|      0|  [aCoder encodeInt64:_uptime forKey:kGDTCORClockUptime];
  162|      0|}
  163|       |
  164|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORConsoleLogger.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORConsoleLogger.h"
   18|       |
   19|       |/** The console logger prefix. */
   20|       |static NSString *kGDTCORConsoleLogger = @"[GoogleDataTransport]";
   21|       |
   22|      0|NSString *GDTCORMessageCodeEnumToString(GDTCORMessageCode code) {
   23|      0|  return [[NSString alloc] initWithFormat:@"I-GDTCOR%06ld", (long)code];
   24|      0|}
   25|       |
   26|      0|void GDTCORLog(GDTCORMessageCode code, NSString *format, ...) {
   27|      0|// Don't log anything in not debug builds.
   28|      0|#if !NDEBUG
   29|      0|  NSString *logFormat = [NSString stringWithFormat:@"%@[%@] %@", kGDTCORConsoleLogger,
   30|      0|                                                   GDTCORMessageCodeEnumToString(code), format];
   31|      0|  va_list args;
   32|      0|  va_start(args, format);
   33|      0|  NSLogv(logFormat, args);
   34|      0|  va_end(args);
   35|      0|#endif  // !NDEBUG
   36|      0|}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORDataFuture.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCORDataFuture.h>
   18|       |
   19|       |@implementation GDTCORDataFuture
   20|       |
   21|      2|- (instancetype)initWithFileURL:(NSURL *)fileURL {
   22|      2|  self = [super init];
   23|      2|  if (self) {
   24|      2|    _fileURL = fileURL;
   25|      2|  }
   26|      2|  return self;
   27|      2|}
   28|       |
   29|      0|- (BOOL)isEqual:(id)object {
   30|      0|  return [self hash] == [object hash];
   31|      0|}
   32|       |
   33|    459|- (NSUInteger)hash {
   34|    459|  // In reality, only one of these should be populated.
   35|    459|  return [_fileURL hash] ^ [_originalData hash];
   36|    459|}
   37|       |
   38|       |#pragma mark - NSSecureCoding
   39|       |
   40|       |/** Coding key for _fileURL ivar. */
   41|       |static NSString *kGDTCORDataFutureFileURLKey = @"GDTCORDataFutureFileURLKey";
   42|       |
   43|       |/** Coding key for _data ivar. */
   44|       |static NSString *kGDTCORDataFutureDataKey = @"GDTCORDataFutureDataKey";
   45|       |
   46|     56|+ (BOOL)supportsSecureCoding {
   47|     56|  return YES;
   48|     56|}
   49|       |
   50|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   51|      0|  [aCoder encodeObject:_fileURL forKey:kGDTCORDataFutureFileURLKey];
   52|      0|  [aCoder encodeObject:_originalData forKey:kGDTCORDataFutureDataKey];
   53|      0|}
   54|       |
   55|     56|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   56|     56|  self = [self init];
   57|     56|  if (self) {
   58|     56|    _fileURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:kGDTCORDataFutureFileURLKey];
   59|     56|    _originalData = [aDecoder decodeObjectOfClass:[NSData class] forKey:kGDTCORDataFutureDataKey];
   60|     56|  }
   61|     56|  return self;
   62|     56|}
   63|       |
   64|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCOREvent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCOREvent.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORAssert.h>
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |#import <GoogleDataTransport/GDTCORStoredEvent.h>
   22|       |
   23|       |#import "GDTCORLibrary/Private/GDTCOREvent_Private.h"
   24|       |
   25|       |@implementation GDTCOREvent
   26|       |
   27|      4|- (nullable instancetype)initWithMappingID:(NSString *)mappingID target:(NSInteger)target {
   28|      4|  GDTCORAssert(mappingID.length > 0, @"Please give a valid mapping ID");
   29|      4|  GDTCORAssert(target > 0, @"A target cannot be negative or 0");
   30|      4|  if (mappingID == nil || mappingID.length == 0 || target <= 0) {
   31|      0|    return nil;
   32|      0|  }
   33|      4|  self = [super init];
   34|      4|  if (self) {
   35|      4|    _mappingID = mappingID;
   36|      4|    _target = target;
   37|      4|    _qosTier = GDTCOREventQosDefault;
   38|      4|  }
   39|      4|  GDTCORLogDebug("Event %@ created. mappingID: %@ target:%ld qos:%ld", self, _mappingID,
   40|      4|                 (long)_target, (long)_qosTier);
   41|      4|  return self;
   42|      4|}
   43|       |
   44|      2|- (instancetype)copy {
   45|      2|  GDTCOREvent *copy = [[GDTCOREvent alloc] initWithMappingID:_mappingID target:_target];
   46|      2|  copy.dataObject = _dataObject;
   47|      2|  copy.dataObjectTransportBytes = _dataObjectTransportBytes;
   48|      2|  copy.qosTier = _qosTier;
   49|      2|  copy.clockSnapshot = _clockSnapshot;
   50|      2|  copy.customPrioritizationParams = _customPrioritizationParams;
   51|      2|  GDTCORLogDebug("Copying event %@ to event %@", self, copy);
   52|      2|  return copy;
   53|      2|}
   54|       |
   55|      2|- (NSUInteger)hash {
   56|      2|  // This loses some precision, but it's probably fine.
   57|      2|  NSUInteger mappingIDHash = [_mappingID hash];
   58|      2|  NSUInteger timeHash = [_clockSnapshot hash];
   59|      2|  NSUInteger dataObjectTransportBytesHash = [_dataObjectTransportBytes hash];
   60|      2|  return mappingIDHash ^ _target ^ dataObjectTransportBytesHash ^ _qosTier ^ timeHash;
   61|      2|}
   62|       |
   63|      0|- (BOOL)isEqual:(id)object {
   64|      0|  return [self hash] == [object hash];
   65|      0|}
   66|       |
   67|      4|- (void)setDataObject:(id<GDTCOREventDataObject>)dataObject {
   68|      4|  // If you're looking here because of a performance issue in -transportBytes slowing the assignment
   69|      4|  // of -dataObject, one way to address this is to add a queue to this class,
   70|      4|  // dispatch_(barrier_ if concurrent)async here, and implement the getter with a dispatch_sync.
   71|      4|  if (dataObject != _dataObject) {
   72|      4|    _dataObject = dataObject;
   73|      4|    _dataObjectTransportBytes = [dataObject transportBytes];
   74|      4|  }
   75|      4|}
   76|       |
   77|      2|- (GDTCORStoredEvent *)storedEventWithDataFuture:(GDTCORDataFuture *)dataFuture {
   78|      2|  return [[GDTCORStoredEvent alloc] initWithEvent:self dataFuture:dataFuture];
   79|      2|}
   80|       |
   81|       |#pragma mark - NSSecureCoding and NSCoding Protocols
   82|       |
   83|       |/** NSCoding key for mappingID property. */
   84|       |static NSString *mappingIDKey = @"_mappingID";
   85|       |
   86|       |/** NSCoding key for target property. */
   87|       |static NSString *targetKey = @"_target";
   88|       |
   89|       |/** NSCoding key for dataObjectTransportBytes property. */
   90|       |static NSString *dataObjectTransportBytesKey = @"_dataObjectTransportBytesKey";
   91|       |
   92|       |/** NSCoding key for qosTier property. */
   93|       |static NSString *qosTierKey = @"_qosTier";
   94|       |
   95|       |/** NSCoding key for clockSnapshot property. */
   96|       |static NSString *clockSnapshotKey = @"_clockSnapshot";
   97|       |
   98|      0|+ (BOOL)supportsSecureCoding {
   99|      0|  return YES;
  100|      0|}
  101|       |
  102|      0|- (id)initWithCoder:(NSCoder *)aDecoder {
  103|      0|  NSString *mappingID = [aDecoder decodeObjectOfClass:[NSObject class] forKey:mappingIDKey];
  104|      0|  NSInteger target = [aDecoder decodeIntegerForKey:targetKey];
  105|      0|  self = [self initWithMappingID:mappingID target:target];
  106|      0|  if (self) {
  107|      0|    _dataObjectTransportBytes = [aDecoder decodeObjectOfClass:[NSData class]
  108|      0|                                                       forKey:dataObjectTransportBytesKey];
  109|      0|    _qosTier = [aDecoder decodeIntegerForKey:qosTierKey];
  110|      0|    _clockSnapshot = [aDecoder decodeObjectOfClass:[GDTCORClock class] forKey:clockSnapshotKey];
  111|      0|  }
  112|      0|  return self;
  113|      0|}
  114|       |
  115|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  116|      0|  [aCoder encodeObject:_mappingID forKey:mappingIDKey];
  117|      0|  [aCoder encodeInteger:_target forKey:targetKey];
  118|      0|  [aCoder encodeObject:_dataObjectTransportBytes forKey:dataObjectTransportBytesKey];
  119|      0|  [aCoder encodeInteger:_qosTier forKey:qosTierKey];
  120|      0|  [aCoder encodeObject:_clockSnapshot forKey:clockSnapshotKey];
  121|      0|}
  122|       |
  123|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORLifecycle.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORLifecycle.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |#import <GoogleDataTransport/GDTCOREvent.h>
   21|       |
   22|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   23|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   24|       |#import "GDTCORLibrary/Private/GDTCORTransformer_Private.h"
   25|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   26|       |
   27|       |@implementation GDTCORLifecycle
   28|       |
   29|      1|+ (void)load {
   30|      1|  [self sharedInstance];
   31|      1|}
   32|       |
   33|       |/** Creates/returns the singleton instance of this class.
   34|       | *
   35|       | * @return The singleton instance of this class.
   36|       | */
   37|      1|+ (instancetype)sharedInstance {
   38|      1|  static GDTCORLifecycle *sharedInstance;
   39|      1|  static dispatch_once_t onceToken;
   40|      1|  dispatch_once(&onceToken, ^{
   41|      1|    sharedInstance = [[GDTCORLifecycle alloc] init];
   42|      1|  });
   43|      1|  return sharedInstance;
   44|      1|}
   45|       |
   46|      1|- (instancetype)init {
   47|      1|  self = [super init];
   48|      1|  if (self) {
   49|      1|    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
   50|      1|    [notificationCenter addObserver:self
   51|      1|                           selector:@selector(applicationDidEnterBackground:)
   52|      1|                               name:kGDTCORApplicationDidEnterBackgroundNotification
   53|      1|                             object:nil];
   54|      1|    [notificationCenter addObserver:self
   55|      1|                           selector:@selector(applicationWillEnterForeground:)
   56|      1|                               name:kGDTCORApplicationWillEnterForegroundNotification
   57|      1|                             object:nil];
   58|      1|
   59|      1|    NSString *name = kGDTCORApplicationWillTerminateNotification;
   60|      1|    [notificationCenter addObserver:self
   61|      1|                           selector:@selector(applicationWillTerminate:)
   62|      1|                               name:name
   63|      1|                             object:nil];
   64|      1|  }
   65|      1|  return self;
   66|      1|}
   67|       |
   68|      0|- (void)dealloc {
   69|      0|  [[NSNotificationCenter defaultCenter] removeObserver:self];
   70|      0|}
   71|       |
   72|      0|- (void)applicationDidEnterBackground:(NSNotification *)notification {
   73|      0|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
   74|      0|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   75|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORTransformer that the app is backgrounding.");
   76|      0|    [[GDTCORTransformer sharedInstance] appWillBackground:application];
   77|      0|  }
   78|      0|  if ([[GDTCORStorage sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   79|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORStorage that the app is backgrounding.");
   80|      0|    [[GDTCORStorage sharedInstance] appWillBackground:application];
   81|      0|  }
   82|      0|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   83|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORUploadCoordinator that the app is backgrounding.");
   84|      0|    [[GDTCORUploadCoordinator sharedInstance] appWillBackground:application];
   85|      0|  }
   86|      0|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   87|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORRegistrar that the app is backgrounding.");
   88|      0|    [[GDTCORRegistrar sharedInstance] appWillBackground:application];
   89|      0|  }
   90|      0|}
   91|       |
   92|      2|- (void)applicationWillEnterForeground:(NSNotification *)notification {
   93|      2|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
   94|      2|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   95|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORTransformer that the app is foregrounding.");
   96|      0|    [[GDTCORTransformer sharedInstance] appWillForeground:application];
   97|      0|  }
   98|      2|  if ([[GDTCORStorage sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   99|      2|    GDTCORLogDebug("%@", @"Signaling GDTCORStorage that the app is foregrounding.");
  100|      2|    [[GDTCORStorage sharedInstance] appWillForeground:application];
  101|      2|  }
  102|      2|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
  103|      2|    GDTCORLogDebug("%@", @"Signaling GDTCORUploadCoordinator that the app is foregrounding.");
  104|      2|    [[GDTCORUploadCoordinator sharedInstance] appWillForeground:application];
  105|      2|  }
  106|      2|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
  107|      2|    GDTCORLogDebug("%@", @"Signaling GDTCORRegistrar that the app is foregrounding.");
  108|      2|    [[GDTCORRegistrar sharedInstance] appWillForeground:application];
  109|      2|  }
  110|      2|}
  111|       |
  112|      0|- (void)applicationWillTerminate:(NSNotification *)notification {
  113|      0|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
  114|      0|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  115|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORTransformer that the app is terminating.");
  116|      0|    [[GDTCORTransformer sharedInstance] appWillTerminate:application];
  117|      0|  }
  118|      0|  if ([[GDTCORStorage sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  119|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORStorage that the app is terminating.");
  120|      0|    [[GDTCORStorage sharedInstance] appWillTerminate:application];
  121|      0|  }
  122|      0|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  123|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORUploadCoordinator that the app is terminating.");
  124|      0|    [[GDTCORUploadCoordinator sharedInstance] appWillTerminate:application];
  125|      0|  }
  126|      0|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  127|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORRegistrar that the app is terminating.");
  128|      0|    [[GDTCORRegistrar sharedInstance] appWillTerminate:application];
  129|      0|  }
  130|      0|}
  131|       |
  132|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORPlatform.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORAssert.h>
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |
   22|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   23|       |
   24|       |#ifdef GDTCOR_VERSION
   25|       |#define STR(x) STR_EXPAND(x)
   26|       |#define STR_EXPAND(x) #x
   27|       |NSString *const kGDTCORVersion = @STR(GDTCOR_VERSION);
   28|       |#else
   29|       |NSString *const kGDTCORVersion = @"Unknown";
   30|       |#endif  // GDTCOR_VERSION
   31|       |
   32|       |const GDTCORBackgroundIdentifier GDTCORBackgroundIdentifierInvalid = 0;
   33|       |
   34|       |NSString *const kGDTCORApplicationDidEnterBackgroundNotification =
   35|       |    @"GDTCORApplicationDidEnterBackgroundNotification";
   36|       |
   37|       |NSString *const kGDTCORApplicationWillEnterForegroundNotification =
   38|       |    @"GDTCORApplicationWillEnterForegroundNotification";
   39|       |
   40|       |NSString *const kGDTCORApplicationWillTerminateNotification =
   41|       |    @"GDTCORApplicationWillTerminateNotification";
   42|       |#if !TARGET_OS_WATCH
   43|      3|BOOL GDTCORReachabilityFlagsContainWWAN(SCNetworkReachabilityFlags flags) {
   44|      3|#if TARGET_OS_IOS
   45|      3|  return (flags & kSCNetworkReachabilityFlagsIsWWAN) == kSCNetworkReachabilityFlagsIsWWAN;
   46|       |#else
   47|       |  return NO;
   48|       |#endif  // TARGET_OS_IOS
   49|       |}
   50|       |#endif  // !TARGET_OS_WATCH
   51|       |
   52|       |@interface GDTCORApplication ()
   53|       |/**
   54|       | Private flag to match the existing `readonly` public flag. This will be accurate for all platforms,
   55|       | since we handle each platform's lifecycle notifications separately.
   56|       | */
   57|       |@property(atomic, readwrite) BOOL isRunningInBackground;
   58|       |
   59|       |@end
   60|       |
   61|       |@implementation GDTCORApplication
   62|       |
   63|      1|+ (void)load {
   64|      1|  GDTCORLogDebug(
   65|      1|      "%@", @"GDT is initializing. Please note that if you quit the app via the "
   66|      1|             "debugger and not through a lifecycle event, event data will remain on disk but "
   67|      1|             "storage won't have a reference to them since the singleton wasn't saved to disk.");
   68|      1|#if TARGET_OS_IOS || TARGET_OS_TV
   69|      1|  // If this asserts, please file a bug at https://github.com/firebase/firebase-ios-sdk/issues.
   70|      1|  GDTCORFatalAssert(
   71|      1|      GDTCORBackgroundIdentifierInvalid == UIBackgroundTaskInvalid,
   72|      1|      @"GDTCORBackgroundIdentifierInvalid and UIBackgroundTaskInvalid should be the same.");
   73|      1|#endif
   74|      1|  [self sharedApplication];
   75|      1|}
   76|       |
   77|     17|+ (nullable GDTCORApplication *)sharedApplication {
   78|     17|  static GDTCORApplication *application;
   79|     17|  static dispatch_once_t onceToken;
   80|     17|  dispatch_once(&onceToken, ^{
   81|      1|    application = [[GDTCORApplication alloc] init];
   82|      1|  });
   83|     17|  return application;
   84|     17|}
   85|       |
   86|      1|- (instancetype)init {
   87|      1|  self = [super init];
   88|      1|  if (self) {
   89|      1|    // This class will be instantiated in the foreground.
   90|      1|    _isRunningInBackground = NO;
   91|      1|
   92|      1|#if TARGET_OS_IOS || TARGET_OS_TV
   93|      1|    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
   94|      1|    [notificationCenter addObserver:self
   95|      1|                           selector:@selector(iOSApplicationDidEnterBackground:)
   96|      1|                               name:UIApplicationDidEnterBackgroundNotification
   97|      1|                             object:nil];
   98|      1|    [notificationCenter addObserver:self
   99|      1|                           selector:@selector(iOSApplicationWillEnterForeground:)
  100|      1|                               name:UIApplicationWillEnterForegroundNotification
  101|      1|                             object:nil];
  102|      1|
  103|      1|    NSString *name = UIApplicationWillTerminateNotification;
  104|      1|    [notificationCenter addObserver:self
  105|      1|                           selector:@selector(iOSApplicationWillTerminate:)
  106|      1|                               name:name
  107|      1|                             object:nil];
  108|      1|
  109|      1|#if defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  110|      1|    if (@available(iOS 13, tvOS 13.0, *)) {
  111|      1|      [notificationCenter addObserver:self
  112|      1|                             selector:@selector(iOSApplicationWillEnterForeground:)
  113|      1|                                 name:UISceneWillEnterForegroundNotification
  114|      1|                               object:nil];
  115|      1|      [notificationCenter addObserver:self
  116|      1|                             selector:@selector(iOSApplicationDidEnterBackground:)
  117|      1|                                 name:UISceneWillDeactivateNotification
  118|      1|                               object:nil];
  119|      1|    }
  120|      1|#endif  // defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  121|      1|
  122|       |#elif TARGET_OS_OSX
  123|       |    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  124|       |    [notificationCenter addObserver:self
  125|       |                           selector:@selector(macOSApplicationWillTerminate:)
  126|       |                               name:NSApplicationWillTerminateNotification
  127|       |                             object:nil];
  128|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  129|       |  }
  130|      1|  return self;
  131|      1|}
  132|       |
  133|       |- (GDTCORBackgroundIdentifier)beginBackgroundTaskWithName:(NSString *)name
  134|      5|                                        expirationHandler:(void (^)(void))handler {
  135|      5|  GDTCORBackgroundIdentifier bgID =
  136|      5|      [[self sharedApplicationForBackgroundTask] beginBackgroundTaskWithName:name
  137|      5|                                                           expirationHandler:handler];
  138|      5|#if !NDEBUG
  139|      5|  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  140|      5|    GDTCORLogDebug("Creating background task with name:%@ bgID:%ld", name, (long)bgID);
  141|      5|  }
  142|      5|#endif  // !NDEBUG
  143|      5|  return bgID;
  144|      5|}
  145|       |
  146|      4|- (void)endBackgroundTask:(GDTCORBackgroundIdentifier)bgID {
  147|      4|  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  148|      4|    GDTCORLogDebug("Ending background task with ID:%ld was successful", (long)bgID);
  149|      4|    [[self sharedApplicationForBackgroundTask] endBackgroundTask:bgID];
  150|      4|    return;
  151|      4|  }
  152|      4|}
  153|       |
  154|       |#pragma mark - App environment helpers
  155|       |
  156|      9|- (BOOL)isAppExtension {
  157|      9|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  158|      9|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  159|      9|  return appExtension;
  160|       |#elif TARGET_OS_OSX
  161|       |  return NO;
  162|       |#endif
  163|       |}
  164|       |
  165|       |/** Returns a UIApplication instance if on the appropriate platform.
  166|       | *
  167|       | * @return The shared UIApplication if on the appropriate platform.
  168|       | */
  169|       |#if TARGET_OS_IOS || TARGET_OS_TV
  170|      9|- (nullable UIApplication *)sharedApplicationForBackgroundTask {
  171|       |#else
  172|       |- (nullable id)sharedApplicationForBackgroundTask {
  173|       |#endif
  174|      9|  if ([self isAppExtension]) {
  175|      0|    return nil;
  176|      0|  }
  177|      9|  id sharedApplication = nil;
  178|      9|  Class uiApplicationClass = NSClassFromString(@"UIApplication");
  179|      9|  if (uiApplicationClass &&
  180|      9|      [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  181|      9|    sharedApplication = [uiApplicationClass sharedApplication];
  182|      9|  }
  183|      9|  return sharedApplication;
  184|      9|}
  185|       |
  186|       |#pragma mark - UIApplicationDelegate
  187|       |
  188|       |#if TARGET_OS_IOS || TARGET_OS_TV
  189|      0|- (void)iOSApplicationDidEnterBackground:(NSNotification *)notif {
  190|      0|  _isRunningInBackground = YES;
  191|      0|
  192|      0|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  193|      0|  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is backgrounding.");
  194|      0|  [notifCenter postNotificationName:kGDTCORApplicationDidEnterBackgroundNotification object:nil];
  195|      0|}
  196|       |
  197|      2|- (void)iOSApplicationWillEnterForeground:(NSNotification *)notif {
  198|      2|  _isRunningInBackground = NO;
  199|      2|
  200|      2|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  201|      2|  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is foregrounding.");
  202|      2|  [notifCenter postNotificationName:kGDTCORApplicationWillEnterForegroundNotification object:nil];
  203|      2|}
  204|       |
  205|      0|- (void)iOSApplicationWillTerminate:(NSNotification *)notif {
  206|      0|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  207|      0|  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is terminating.");
  208|      0|  [notifCenter postNotificationName:kGDTCORApplicationWillTerminateNotification object:nil];
  209|      0|}
  210|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  211|       |
  212|       |#pragma mark - NSApplicationDelegate
  213|       |
  214|       |#if TARGET_OS_OSX
  215|       |- (void)macOSApplicationWillTerminate:(NSNotification *)notif {
  216|       |  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  217|       |  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is terminating.");
  218|       |  [notifCenter postNotificationName:kGDTCORApplicationWillTerminateNotification object:nil];
  219|       |}
  220|       |#endif  // TARGET_OS_OSX
  221|       |
  222|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORReachability.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORReachability.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORReachability_Private.h"
   19|       |#if !TARGET_OS_WATCH
   20|       |
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |
   23|       |#import <netinet/in.h>
   24|       |
   25|       |/** Sets the _callbackFlag ivar whenever the network changes.
   26|       | *
   27|       | * @param reachability The reachability object calling back.
   28|       | * @param flags The new flag values.
   29|       | * @param info Any data that might be passed in by the callback.
   30|       | */
   31|       |static void GDTCORReachabilityCallback(SCNetworkReachabilityRef reachability,
   32|       |                                       SCNetworkReachabilityFlags flags,
   33|       |                                       void *info);
   34|       |
   35|       |@implementation GDTCORReachability {
   36|       |  /** The reachability object. */
   37|       |  SCNetworkReachabilityRef _reachabilityRef;
   38|       |
   39|       |  /** The queue on which callbacks and all work will occur. */
   40|       |  dispatch_queue_t _reachabilityQueue;
   41|       |
   42|       |  /** Flags specified by reachability callbacks. */
   43|       |  SCNetworkConnectionFlags _callbackFlags;
   44|       |}
   45|       |
   46|      1|+ (void)load {
   47|      1|  [self sharedInstance];
   48|      1|}
   49|       |
   50|      7|+ (instancetype)sharedInstance {
   51|      7|  static GDTCORReachability *sharedInstance;
   52|      7|  static dispatch_once_t onceToken;
   53|      7|  dispatch_once(&onceToken, ^{
   54|      1|    sharedInstance = [[GDTCORReachability alloc] init];
   55|      1|  });
   56|      7|  return sharedInstance;
   57|      7|}
   58|       |
   59|      3|+ (SCNetworkReachabilityFlags)currentFlags {
   60|      3|  __block SCNetworkReachabilityFlags currentFlags;
   61|      3|  dispatch_sync([GDTCORReachability sharedInstance] -> _reachabilityQueue, ^{
   62|      3|    GDTCORReachability *reachability = [GDTCORReachability sharedInstance];
   63|      3|    currentFlags = reachability->_flags ? reachability->_flags : reachability->_callbackFlags;
   64|      3|    GDTCORLogDebug("Initial reachability flags determined: %d", currentFlags);
   65|      3|  });
   66|      3|  return currentFlags;
   67|      3|}
   68|       |
   69|      1|- (instancetype)init {
   70|      1|  self = [super init];
   71|      1|  if (self) {
   72|      1|    struct sockaddr_in zeroAddress;
   73|      1|    bzero(&zeroAddress, sizeof(zeroAddress));
   74|      1|    zeroAddress.sin_len = sizeof(zeroAddress);
   75|      1|    zeroAddress.sin_family = AF_INET;
   76|      1|
   77|      1|    _reachabilityQueue =
   78|      1|        dispatch_queue_create("com.google.GDTCORReachability", DISPATCH_QUEUE_SERIAL);
   79|      1|    _reachabilityRef = SCNetworkReachabilityCreateWithAddress(
   80|      1|        kCFAllocatorDefault, (const struct sockaddr *)&zeroAddress);
   81|      1|    Boolean success = SCNetworkReachabilitySetDispatchQueue(_reachabilityRef, _reachabilityQueue);
   82|      1|    if (!success) {
   83|      0|      GDTCORLogWarning(GDTCORMCWReachabilityFailed, @"%@", @"The reachability queue wasn't set.");
   84|      0|    }
   85|      1|    success = SCNetworkReachabilitySetCallback(_reachabilityRef, GDTCORReachabilityCallback, NULL);
   86|      1|    if (!success) {
   87|      0|      GDTCORLogWarning(GDTCORMCWReachabilityFailed, @"%@",
   88|      0|                       @"The reachability callback wasn't set.");
   89|      0|    }
   90|      1|
   91|      1|    // Get the initial set of flags.
   92|      1|    dispatch_async(_reachabilityQueue, ^{
   93|      1|      Boolean valid = SCNetworkReachabilityGetFlags(self->_reachabilityRef, &self->_flags);
   94|      1|      if (!valid) {
   95|      0|        GDTCORLogDebug("%@", @"Determining reachability failed.");
   96|      0|        self->_flags = 0;
   97|      0|      }
   98|      1|    });
   99|      1|  }
  100|      1|  return self;
  101|      1|}
  102|       |
  103|      0|- (void)setCallbackFlags:(SCNetworkReachabilityFlags)flags {
  104|      0|  if (_callbackFlags != flags) {
  105|      0|    self->_callbackFlags = flags;
  106|      0|  }
  107|      0|}
  108|       |
  109|       |@end
  110|       |
  111|       |static void GDTCORReachabilityCallback(SCNetworkReachabilityRef reachability,
  112|       |                                       SCNetworkReachabilityFlags flags,
  113|      0|                                       void *info) {
  114|      0|  GDTCORLogDebug("Reachability changed, new flags: %d", flags);
  115|      0|  [[GDTCORReachability sharedInstance] setCallbackFlags:flags];
  116|      0|}
  117|       |
  118|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORRegistrar.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORRegistrar.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |
   22|       |@implementation GDTCORRegistrar {
   23|       |  /** Backing ivar for targetToUploader property. */
   24|       |  NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *_targetToUploader;
   25|       |
   26|       |  /** Backing ivar for targetToPrioritizer property. */
   27|       |  NSMutableDictionary<NSNumber *, id<GDTCORPrioritizer>> *_targetToPrioritizer;
   28|       |}
   29|       |
   30|     13|+ (instancetype)sharedInstance {
   31|     13|  static GDTCORRegistrar *sharedInstance;
   32|     13|  static dispatch_once_t onceToken;
   33|     13|  dispatch_once(&onceToken, ^{
   34|      1|    sharedInstance = [[GDTCORRegistrar alloc] init];
   35|      1|  });
   36|     13|  return sharedInstance;
   37|     13|}
   38|       |
   39|      1|- (instancetype)init {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _registrarQueue = dispatch_queue_create("com.google.GDTCORRegistrar", DISPATCH_QUEUE_SERIAL);
   43|      1|    _targetToPrioritizer = [[NSMutableDictionary alloc] init];
   44|      1|    _targetToUploader = [[NSMutableDictionary alloc] init];
   45|      1|  }
   46|      1|  return self;
   47|      1|}
   48|       |
   49|      3|- (void)registerUploader:(id<GDTCORUploader>)backend target:(GDTCORTarget)target {
   50|      3|  __weak GDTCORRegistrar *weakSelf = self;
   51|      3|  dispatch_async(_registrarQueue, ^{
   52|      3|    GDTCORRegistrar *strongSelf = weakSelf;
   53|      3|    if (strongSelf) {
   54|      3|      GDTCORLogDebug("Registered an uploader: %@ for target:%ld", backend, (long)target);
   55|      3|      strongSelf->_targetToUploader[@(target)] = backend;
   56|      3|    }
   57|      3|  });
   58|      3|}
   59|       |
   60|      3|- (void)registerPrioritizer:(id<GDTCORPrioritizer>)prioritizer target:(GDTCORTarget)target {
   61|      3|  __weak GDTCORRegistrar *weakSelf = self;
   62|      3|  dispatch_async(_registrarQueue, ^{
   63|      3|    GDTCORRegistrar *strongSelf = weakSelf;
   64|      3|    if (strongSelf) {
   65|      3|      GDTCORLogDebug("Registered a prioritizer: %@ for target:%ld", prioritizer, (long)target);
   66|      3|      strongSelf->_targetToPrioritizer[@(target)] = prioritizer;
   67|      3|    }
   68|      3|  });
   69|      3|}
   70|       |
   71|     12|- (NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *)targetToUploader {
   72|     12|  __block NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *targetToUploader;
   73|     12|  __weak GDTCORRegistrar *weakSelf = self;
   74|     12|  dispatch_sync(_registrarQueue, ^{
   75|     12|    GDTCORRegistrar *strongSelf = weakSelf;
   76|     12|    if (strongSelf) {
   77|     12|      targetToUploader = strongSelf->_targetToUploader;
   78|     12|    }
   79|     12|  });
   80|     12|  return targetToUploader;
   81|     12|}
   82|       |
   83|     13|- (NSMutableDictionary<NSNumber *, id<GDTCORPrioritizer>> *)targetToPrioritizer {
   84|     13|  __block NSMutableDictionary<NSNumber *, id<GDTCORPrioritizer>> *targetToPrioritizer;
   85|     13|  __weak GDTCORRegistrar *weakSelf = self;
   86|     13|  dispatch_sync(_registrarQueue, ^{
   87|     13|    GDTCORRegistrar *strongSelf = weakSelf;
   88|     13|    if (strongSelf) {
   89|     13|      targetToPrioritizer = strongSelf->_targetToPrioritizer;
   90|     13|    }
   91|     13|  });
   92|     13|  return targetToPrioritizer;
   93|     13|}
   94|       |
   95|       |#pragma mark - GDTCORLifecycleProtocol
   96|       |
   97|      0|- (void)appWillBackground:(nonnull GDTCORApplication *)app {
   98|      0|  dispatch_async(_registrarQueue, ^{
   99|      0|    for (id<GDTCORUploader> uploader in [self->_targetToUploader allValues]) {
  100|      0|      if ([uploader respondsToSelector:@selector(appWillBackground:)]) {
  101|      0|        [uploader appWillBackground:app];
  102|      0|      }
  103|      0|    }
  104|      0|    for (id<GDTCORPrioritizer> prioritizer in [self->_targetToPrioritizer allValues]) {
  105|      0|      if ([prioritizer respondsToSelector:@selector(appWillBackground:)]) {
  106|      0|        [prioritizer appWillBackground:app];
  107|      0|      }
  108|      0|    }
  109|      0|  });
  110|      0|}
  111|       |
  112|      2|- (void)appWillForeground:(nonnull GDTCORApplication *)app {
  113|      2|  dispatch_async(_registrarQueue, ^{
  114|      6|    for (id<GDTCORUploader> uploader in [self->_targetToUploader allValues]) {
  115|      6|      if ([uploader respondsToSelector:@selector(appWillForeground:)]) {
  116|      0|        [uploader appWillForeground:app];
  117|      0|      }
  118|      6|    }
  119|      6|    for (id<GDTCORPrioritizer> prioritizer in [self->_targetToPrioritizer allValues]) {
  120|      6|      if ([prioritizer respondsToSelector:@selector(appWillForeground:)]) {
  121|      0|        [prioritizer appWillForeground:app];
  122|      0|      }
  123|      6|    }
  124|      2|  });
  125|      2|}
  126|       |
  127|      0|- (void)appWillTerminate:(nonnull GDTCORApplication *)app {
  128|      0|  dispatch_sync(_registrarQueue, ^{
  129|      0|    for (id<GDTCORUploader> uploader in [self->_targetToUploader allValues]) {
  130|      0|      if ([uploader respondsToSelector:@selector(appWillTerminate:)]) {
  131|      0|        [uploader appWillTerminate:app];
  132|      0|      }
  133|      0|    }
  134|      0|    for (id<GDTCORPrioritizer> prioritizer in [self->_targetToPrioritizer allValues]) {
  135|      0|      if ([prioritizer respondsToSelector:@selector(appWillTerminate:)]) {
  136|      0|        [prioritizer appWillTerminate:app];
  137|      0|      }
  138|      0|    }
  139|      0|  });
  140|      0|}
  141|       |
  142|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORStorage.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORStorage.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORAssert.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |#import <GoogleDataTransport/GDTCORLifecycle.h>
   23|       |#import <GoogleDataTransport/GDTCORPrioritizer.h>
   24|       |#import <GoogleDataTransport/GDTCORStoredEvent.h>
   25|       |
   26|       |#import "GDTCORLibrary/Private/GDTCOREvent_Private.h"
   27|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   28|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   29|       |
   30|       |/** Creates and/or returns a singleton NSString that is the shared storage path.
   31|       | *
   32|       | * @return The SDK event storage path.
   33|       | */
   34|      5|static NSString *GDTCORStoragePath() {
   35|      5|  static NSString *storagePath;
   36|      5|  static dispatch_once_t onceToken;
   37|      5|  dispatch_once(&onceToken, ^{
   38|      1|    NSString *cachePath =
   39|      1|        NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
   40|      1|    storagePath = [NSString stringWithFormat:@"%@/google-sdks-events", cachePath];
   41|      1|    GDTCORLogDebug("Events will be saved to %@", storagePath);
   42|      1|  });
   43|      5|  return storagePath;
   44|      5|}
   45|       |
   46|       |@implementation GDTCORStorage
   47|       |
   48|      2|+ (NSString *)archivePath {
   49|      2|  static NSString *archivePath;
   50|      2|  static dispatch_once_t onceToken;
   51|      2|  dispatch_once(&onceToken, ^{
   52|      1|    archivePath = [GDTCORStoragePath() stringByAppendingPathComponent:@"GDTCORStorageArchive"];
   53|      1|  });
   54|      2|  return archivePath;
   55|      2|}
   56|       |
   57|     14|+ (instancetype)sharedInstance {
   58|     14|  static GDTCORStorage *sharedStorage;
   59|     14|  static dispatch_once_t onceToken;
   60|     14|  dispatch_once(&onceToken, ^{
   61|      1|    sharedStorage = [[GDTCORStorage alloc] init];
   62|      1|  });
   63|     14|  return sharedStorage;
   64|     14|}
   65|       |
   66|      1|- (instancetype)init {
   67|      1|  self = [super init];
   68|      1|  if (self) {
   69|      1|    _storageQueue = dispatch_queue_create("com.google.GDTCORStorage", DISPATCH_QUEUE_SERIAL);
   70|      1|    _targetToEventSet = [[NSMutableDictionary alloc] init];
   71|      1|    _storedEvents = [[NSMutableOrderedSet alloc] init];
   72|      1|    _uploadCoordinator = [GDTCORUploadCoordinator sharedInstance];
   73|      1|  }
   74|      1|  return self;
   75|      1|}
   76|       |
   77|       |- (void)storeEvent:(GDTCOREvent *)event
   78|      2|        onComplete:(void (^)(BOOL wasWritten, NSError *error))completion {
   79|      2|  GDTCORLogDebug("Saving event: %@", event);
   80|      2|  if (event == nil) {
   81|      0|    GDTCORLogDebug("%@", @"The event was nil, so it was not saved.");
   82|      0|    return;
   83|      0|  }
   84|      2|  if (!completion) {
   85|      0|    completion = ^(BOOL wasWritten, NSError *error) {
   86|      0|    };
   87|      0|  }
   88|      2|
   89|      2|  [self createEventDirectoryIfNotExists];
   90|      2|
   91|      2|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
   92|      2|  bgID = [[GDTCORApplication sharedApplication]
   93|      2|      beginBackgroundTaskWithName:@"GDTStorage"
   94|      2|                expirationHandler:^{
   95|      0|                  // End the background task if it's still valid.
   96|      0|                  [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
   97|      0|                  bgID = GDTCORBackgroundIdentifierInvalid;
   98|      0|                }];
   99|      2|
  100|      2|  dispatch_async(_storageQueue, ^{
  101|      2|    // Check that a backend implementation is available for this target.
  102|      2|    NSInteger target = event.target;
  103|      2|
  104|      2|    // Check that a prioritizer is available for this target.
  105|      2|    id<GDTCORPrioritizer> prioritizer =
  106|      2|        [GDTCORRegistrar sharedInstance].targetToPrioritizer[@(target)];
  107|      2|    GDTCORAssert(prioritizer, @"There's no prioritizer registered for the given target. Are you "
  108|      2|                              @"sure you've added the support library for the backend you need?");
  109|      2|
  110|      2|    // Write the transport bytes to disk, get a filename.
  111|      2|    GDTCORAssert(event.dataObjectTransportBytes, @"The event should have been serialized to bytes");
  112|      2|    NSError *error = nil;
  113|      2|    NSURL *eventFile = [self saveEventBytesToDisk:event.dataObjectTransportBytes
  114|      2|                                        eventHash:event.hash
  115|      2|                                            error:&error];
  116|      2|    GDTCORLogDebug("Event saved to disk: %@", eventFile);
  117|      2|    GDTCORDataFuture *dataFuture = [[GDTCORDataFuture alloc] initWithFileURL:eventFile];
  118|      2|    GDTCORStoredEvent *storedEvent = [event storedEventWithDataFuture:dataFuture];
  119|      2|    completion(eventFile != nil, error);
  120|      2|
  121|      2|    // Add event to tracking collections.
  122|      2|    [self addEventToTrackingCollections:storedEvent];
  123|      2|
  124|      2|    // Have the prioritizer prioritize the event.
  125|      2|    [prioritizer prioritizeEvent:storedEvent];
  126|      2|
  127|      2|    // Check the QoS, if it's high priority, notify the target that it has a high priority event.
  128|      2|    if (event.qosTier == GDTCOREventQoSFast) {
  129|      0|      [self.uploadCoordinator forceUploadForTarget:target];
  130|      0|    }
  131|      2|
  132|      2|    // Write state to disk if we're in the background.
  133|      2|    if ([[GDTCORApplication sharedApplication] isRunningInBackground]) {
  134|      0|      GDTCORLogDebug("%@", @"Saving storage state because the app is running in the background");
  135|      0|      if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  136|      0|        NSError *error;
  137|      0|        NSData *data = [NSKeyedArchiver archivedDataWithRootObject:self
  138|      0|                                             requiringSecureCoding:YES
  139|      0|                                                             error:&error];
  140|      0|        [data writeToFile:[GDTCORStorage archivePath] atomically:YES];
  141|      0|      } else {
  142|      0|#if !TARGET_OS_MACCATALYST && !TARGET_OS_WATCH
  143|      0|        [NSKeyedArchiver archiveRootObject:self toFile:[GDTCORStorage archivePath]];
  144|      0|#endif
  145|      0|      }
  146|      0|    }
  147|      2|
  148|      2|    // Cancel or end the associated background task if it's still valid.
  149|      2|    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  150|      2|    bgID = GDTCORBackgroundIdentifierInvalid;
  151|      2|    GDTCORLogDebug("Event %@ is stored. There are %ld events stored on disk", event,
  152|      2|                   (unsigned long)self->_storedEvents.count);
  153|      2|  });
  154|      2|}
  155|       |
  156|      5|- (void)removeEvents:(NSSet<GDTCORStoredEvent *> *)events {
  157|      5|  NSSet<GDTCORStoredEvent *> *eventsToRemove = [events copy];
  158|      5|  dispatch_async(_storageQueue, ^{
  159|      5|    for (GDTCORStoredEvent *event in eventsToRemove) {
  160|      0|      // Remove from disk, first and foremost.
  161|      0|      NSError *error;
  162|      0|      if (event.dataFuture.fileURL) {
  163|      0|        NSURL *fileURL = event.dataFuture.fileURL;
  164|      0|        [[NSFileManager defaultManager] removeItemAtURL:fileURL error:&error];
  165|      0|        GDTCORAssert(error == nil, @"There was an error removing an event file: %@", error);
  166|      0|        GDTCORLogDebug("Removed event from disk: %@", fileURL);
  167|      0|      }
  168|      0|
  169|      0|      // Remove from the tracking collections.
  170|      0|      [self.storedEvents removeObject:event];
  171|      0|      [self.targetToEventSet[event.target] removeObject:event];
  172|      0|    }
  173|      5|  });
  174|      5|}
  175|       |
  176|       |#pragma mark - Private helper methods
  177|       |
  178|       |/** Creates the storage directory if it does not exist. */
  179|      2|- (void)createEventDirectoryIfNotExists {
  180|      2|  NSError *error;
  181|      2|  BOOL result = [[NSFileManager defaultManager] createDirectoryAtPath:GDTCORStoragePath()
  182|      2|                                          withIntermediateDirectories:YES
  183|      2|                                                           attributes:0
  184|      2|                                                                error:&error];
  185|      2|  if (!result || error) {
  186|      0|    GDTCORLogError(GDTCORMCEDirectoryCreationError, @"Error creating the directory: %@", error);
  187|      0|  }
  188|      2|}
  189|       |
  190|       |/** Saves the event's dataObjectTransportBytes to a file using NSData mechanisms.
  191|       | *
  192|       | * @note This method should only be called from a method within a block on _storageQueue to maintain
  193|       | * thread safety.
  194|       | *
  195|       | * @param transportBytes The transport bytes of the event.
  196|       | * @param eventHash The hash value of the event.
  197|       | * @return The filename
  198|       | */
  199|       |- (NSURL *)saveEventBytesToDisk:(NSData *)transportBytes
  200|       |                      eventHash:(NSUInteger)eventHash
  201|      2|                          error:(NSError **)error {
  202|      2|  NSString *storagePath = GDTCORStoragePath();
  203|      2|  NSString *event = [NSString stringWithFormat:@"event-%lu", (unsigned long)eventHash];
  204|      2|  NSURL *eventFilePath = [NSURL fileURLWithPath:[storagePath stringByAppendingPathComponent:event]];
  205|      2|
  206|      2|  GDTCORAssert(![[NSFileManager defaultManager] fileExistsAtPath:eventFilePath.path],
  207|      2|               @"An event shouldn't already exist at this path: %@", eventFilePath.path);
  208|      2|
  209|      2|  BOOL writingSuccess = [transportBytes writeToURL:eventFilePath
  210|      2|                                           options:NSDataWritingAtomic
  211|      2|                                             error:error];
  212|      2|  if (!writingSuccess) {
  213|      0|    GDTCORLogError(GDTCORMCEFileWriteError, @"An event file could not be written: %@",
  214|      0|                   eventFilePath);
  215|      0|  }
  216|      2|
  217|      2|  return eventFilePath;
  218|      2|}
  219|       |
  220|       |/** Adds the event to internal tracking collections.
  221|       | *
  222|       | * @note This method should only be called from a method within a block on _storageQueue to maintain
  223|       | * thread safety.
  224|       | *
  225|       | * @param event The event to track.
  226|       | */
  227|      2|- (void)addEventToTrackingCollections:(GDTCORStoredEvent *)event {
  228|      2|  [_storedEvents addObject:event];
  229|      2|  NSMutableSet<GDTCORStoredEvent *> *events = self.targetToEventSet[event.target];
  230|      2|  events = events ? events : [[NSMutableSet alloc] init];
  231|      2|  [events addObject:event];
  232|      2|  _targetToEventSet[event.target] = events;
  233|      2|}
  234|       |
  235|       |#pragma mark - GDTCORLifecycleProtocol
  236|       |
  237|      2|- (void)appWillForeground:(GDTCORApplication *)app {
  238|      2|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  239|      2|    NSError *error;
  240|      2|    NSData *data = [NSData dataWithContentsOfFile:[GDTCORStorage archivePath]];
  241|      2|    if (data) {
  242|      2|      [NSKeyedUnarchiver unarchivedObjectOfClass:[GDTCORStorage class] fromData:data error:&error];
  243|      2|    }
  244|      2|  } else {
  245|      0|#if !TARGET_OS_MACCATALYST && !TARGET_OS_WATCH
  246|      0|    [NSKeyedUnarchiver unarchiveObjectWithFile:[GDTCORStorage archivePath]];
  247|      0|#endif
  248|      0|  }
  249|      2|}
  250|       |
  251|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  252|      0|  dispatch_async(_storageQueue, ^{
  253|      0|    // Immediately request a background task to run until the end of the current queue of work, and
  254|      0|    // cancel it once the work is done.
  255|      0|    __block GDTCORBackgroundIdentifier bgID =
  256|      0|        [app beginBackgroundTaskWithName:@"GDTStorage"
  257|      0|                       expirationHandler:^{
  258|      0|                         [app endBackgroundTask:bgID];
  259|      0|                         bgID = GDTCORBackgroundIdentifierInvalid;
  260|      0|                       }];
  261|      0|
  262|      0|    if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  263|      0|      NSError *error;
  264|      0|      NSData *data = [NSKeyedArchiver archivedDataWithRootObject:self
  265|      0|                                           requiringSecureCoding:YES
  266|      0|                                                           error:&error];
  267|      0|      [data writeToFile:[GDTCORStorage archivePath] atomically:YES];
  268|      0|    } else {
  269|      0|#if !TARGET_OS_MACCATALYST && !TARGET_OS_WATCH
  270|      0|      [NSKeyedArchiver archiveRootObject:self toFile:[GDTCORStorage archivePath]];
  271|      0|#endif
  272|      0|    }
  273|      0|
  274|      0|    // End the background task if it's still valid.
  275|      0|    [app endBackgroundTask:bgID];
  276|      0|    bgID = GDTCORBackgroundIdentifierInvalid;
  277|      0|  });
  278|      0|}
  279|       |
  280|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  281|      0|  dispatch_sync(_storageQueue, ^{
  282|      0|    if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  283|      0|      NSError *error;
  284|      0|      NSData *data = [NSKeyedArchiver archivedDataWithRootObject:self
  285|      0|                                           requiringSecureCoding:YES
  286|      0|                                                           error:&error];
  287|      0|      [data writeToFile:[GDTCORStorage archivePath] atomically:YES];
  288|      0|    } else {
  289|      0|#if !TARGET_OS_MACCATALYST && !TARGET_OS_WATCH
  290|      0|      [NSKeyedArchiver archiveRootObject:self toFile:[GDTCORStorage archivePath]];
  291|      0|#endif
  292|      0|    }
  293|      0|  });
  294|      0|}
  295|       |
  296|       |#pragma mark - NSSecureCoding
  297|       |
  298|       |/** The NSKeyedCoder key for the storedEvents property. */
  299|       |static NSString *const kGDTCORStorageStoredEventsKey = @"GDTCORStorageStoredEventsKey";
  300|       |
  301|       |/** The NSKeyedCoder key for the targetToEventSet property. */
  302|       |static NSString *const kGDTCORStorageTargetToEventSetKey = @"GDTCORStorageTargetToEventSetKey";
  303|       |
  304|       |/** The NSKeyedCoder key for the uploadCoordinator property. */
  305|       |static NSString *const kGDTCORStorageUploadCoordinatorKey = @"GDTCORStorageUploadCoordinatorKey";
  306|       |
  307|      2|+ (BOOL)supportsSecureCoding {
  308|      2|  return YES;
  309|      2|}
  310|       |
  311|      2|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  312|      2|  // Create the singleton and populate its ivars.
  313|      2|  GDTCORStorage *sharedInstance = [self.class sharedInstance];
  314|      2|  dispatch_sync(sharedInstance.storageQueue, ^{
  315|      2|    NSSet *classes =
  316|      2|        [NSSet setWithObjects:[NSMutableOrderedSet class], [GDTCORStoredEvent class], nil];
  317|      2|    sharedInstance->_storedEvents = [aDecoder decodeObjectOfClasses:classes
  318|      2|                                                             forKey:kGDTCORStorageStoredEventsKey];
  319|      2|    classes = [NSSet setWithObjects:[NSMutableDictionary class], [NSMutableSet class],
  320|      2|                                    [GDTCORStoredEvent class], nil];
  321|      2|    sharedInstance->_targetToEventSet =
  322|      2|        [aDecoder decodeObjectOfClasses:classes forKey:kGDTCORStorageTargetToEventSetKey];
  323|      2|    sharedInstance->_uploadCoordinator =
  324|      2|        [aDecoder decodeObjectOfClass:[GDTCORUploadCoordinator class]
  325|      2|                               forKey:kGDTCORStorageUploadCoordinatorKey];
  326|      2|  });
  327|      2|  return sharedInstance;
  328|      2|}
  329|       |
  330|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  331|      0|  GDTCORStorage *sharedInstance = [self.class sharedInstance];
  332|      0|  NSMutableOrderedSet<GDTCORStoredEvent *> *storedEvents = sharedInstance->_storedEvents;
  333|      0|  if (storedEvents) {
  334|      0|    [aCoder encodeObject:storedEvents forKey:kGDTCORStorageStoredEventsKey];
  335|      0|  }
  336|      0|  NSMutableDictionary<NSNumber *, NSMutableSet<GDTCORStoredEvent *> *> *targetToEventSet =
  337|      0|      sharedInstance->_targetToEventSet;
  338|      0|  if (targetToEventSet) {
  339|      0|    [aCoder encodeObject:targetToEventSet forKey:kGDTCORStorageTargetToEventSetKey];
  340|      0|  }
  341|      0|  GDTCORUploadCoordinator *uploadCoordinator = sharedInstance->_uploadCoordinator;
  342|      0|  if (uploadCoordinator) {
  343|      0|    [aCoder encodeObject:uploadCoordinator forKey:kGDTCORStorageUploadCoordinatorKey];
  344|      0|  }
  345|      0|}
  346|       |
  347|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORStoredEvent.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCORStoredEvent.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORClock.h>
   20|       |
   21|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   22|       |
   23|       |@implementation GDTCORStoredEvent
   24|       |
   25|       |- (instancetype)initWithEvent:(GDTCOREvent *)event
   26|      2|                   dataFuture:(nonnull GDTCORDataFuture *)dataFuture {
   27|      2|  self = [super init];
   28|      2|  if (self) {
   29|      2|    _dataFuture = dataFuture;
   30|      2|    _mappingID = event.mappingID;
   31|      2|    _target = @(event.target);
   32|      2|    _qosTier = event.qosTier;
   33|      2|    _clockSnapshot = event.clockSnapshot;
   34|      2|    _customPrioritizationParams = event.customPrioritizationParams;
   35|      2|  }
   36|      2|  return self;
   37|      2|}
   38|       |
   39|       |#pragma mark - NSSecureCoding
   40|       |
   41|       |/** Coding key for the dataFuture ivar. */
   42|       |static NSString *kDataFutureKey = @"GDTCORStoredEventDataFutureKey";
   43|       |
   44|       |/** Coding key for mappingID ivar. */
   45|       |static NSString *kMappingIDKey = @"GDTCORStoredEventMappingIDKey";
   46|       |
   47|       |/** Coding key for target ivar. */
   48|       |static NSString *kTargetKey = @"GDTCORStoredEventTargetKey";
   49|       |
   50|       |/** Coding key for qosTier ivar. */
   51|       |static NSString *kQosTierKey = @"GDTCORStoredEventQosTierKey";
   52|       |
   53|       |/** Coding key for clockSnapshot ivar. */
   54|       |static NSString *kClockSnapshotKey = @"GDTCORStoredEventClockSnapshotKey";
   55|       |
   56|       |/** Coding key for customPrioritizationParams ivar. */
   57|       |static NSString *kCustomPrioritizationParamsKey = @"GDTCORStoredEventcustomPrioritizationParamsKey";
   58|       |
   59|     56|+ (BOOL)supportsSecureCoding {
   60|     56|  return YES;
   61|     56|}
   62|       |
   63|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   64|      0|  [aCoder encodeObject:_dataFuture forKey:kDataFutureKey];
   65|      0|  [aCoder encodeObject:_mappingID forKey:kMappingIDKey];
   66|      0|  [aCoder encodeObject:_target forKey:kTargetKey];
   67|      0|  [aCoder encodeObject:@(_qosTier) forKey:kQosTierKey];
   68|      0|  [aCoder encodeObject:_clockSnapshot forKey:kClockSnapshotKey];
   69|      0|  [aCoder encodeObject:_customPrioritizationParams forKey:kCustomPrioritizationParamsKey];
   70|      0|}
   71|       |
   72|     56|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   73|     56|  self = [self init];
   74|     56|  if (self) {
   75|     56|    _dataFuture = [aDecoder decodeObjectOfClass:[GDTCORDataFuture class] forKey:kDataFutureKey];
   76|     56|    _mappingID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kMappingIDKey];
   77|     56|    _target = [aDecoder decodeObjectOfClass:[NSNumber class] forKey:kTargetKey];
   78|     56|    NSNumber *qosTier = [aDecoder decodeObjectOfClass:[NSNumber class] forKey:kQosTierKey];
   79|     56|    _qosTier = [qosTier intValue];
   80|     56|    _clockSnapshot = [aDecoder decodeObjectOfClass:[GDTCORClock class] forKey:kClockSnapshotKey];
   81|     56|    _customPrioritizationParams = [aDecoder decodeObjectOfClass:[NSDictionary class]
   82|     56|                                                         forKey:kCustomPrioritizationParamsKey];
   83|     56|  }
   84|     56|  return self;
   85|     56|}
   86|       |
   87|    126|- (BOOL)isEqual:(GDTCORStoredEvent *)other {
   88|    126|  return [self hash] == [other hash];
   89|    126|}
   90|       |
   91|    459|- (NSUInteger)hash {
   92|    459|  return [_dataFuture hash] ^ [_mappingID hash] ^ [_target hash] ^ [_clockSnapshot hash] ^ _qosTier;
   93|    459|}
   94|       |
   95|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORTransformer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORTransformer.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORTransformer_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORAssert.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |#import <GoogleDataTransport/GDTCOREvent.h>
   23|       |#import <GoogleDataTransport/GDTCOREventTransformer.h>
   24|       |#import <GoogleDataTransport/GDTCORLifecycle.h>
   25|       |
   26|       |#import "GDTCORLibrary/Private/GDTCORStorage.h"
   27|       |
   28|       |@implementation GDTCORTransformer
   29|       |
   30|      3|+ (instancetype)sharedInstance {
   31|      3|  static GDTCORTransformer *eventTransformer;
   32|      3|  static dispatch_once_t onceToken;
   33|      3|  dispatch_once(&onceToken, ^{
   34|      1|    eventTransformer = [[self alloc] init];
   35|      1|  });
   36|      3|  return eventTransformer;
   37|      3|}
   38|       |
   39|      1|- (instancetype)init {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _eventWritingQueue =
   43|      1|        dispatch_queue_create("com.google.GDTCORTransformer", DISPATCH_QUEUE_SERIAL);
   44|      1|    _storageInstance = [GDTCORStorage sharedInstance];
   45|      1|  }
   46|      1|  return self;
   47|      1|}
   48|       |
   49|       |- (void)transformEvent:(GDTCOREvent *)event
   50|       |      withTransformers:(NSArray<id<GDTCOREventTransformer>> *)transformers
   51|      2|            onComplete:(nonnull void (^)(BOOL wasWritten, NSError *error))completion {
   52|      2|  GDTCORAssert(event, @"You can't write a nil event");
   53|      2|  if (!completion) {
   54|      0|    completion = ^(BOOL wasWritten, NSError *_Nullable error) {
   55|      0|    };
   56|      0|  }
   57|      2|
   58|      2|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
   59|      2|  bgID = [[GDTCORApplication sharedApplication]
   60|      2|      beginBackgroundTaskWithName:@"GDTTransformer"
   61|      2|                expirationHandler:^{
   62|      0|                  [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
   63|      0|                  bgID = GDTCORBackgroundIdentifierInvalid;
   64|      0|                }];
   65|      2|  dispatch_async(_eventWritingQueue, ^{
   66|      2|    GDTCOREvent *transformedEvent = event;
   67|      2|    for (id<GDTCOREventTransformer> transformer in transformers) {
   68|      0|      if ([transformer respondsToSelector:@selector(transform:)]) {
   69|      0|        GDTCORLogDebug("Applying a transformer to event %@", event);
   70|      0|        transformedEvent = [transformer transform:transformedEvent];
   71|      0|        if (!transformedEvent) {
   72|      0|          completion(NO, nil);
   73|      0|          return;
   74|      0|        }
   75|      0|      } else {
   76|      0|        GDTCORLogError(GDTCORMCETransformerDoesntImplementTransform,
   77|      0|                       @"Transformer doesn't implement transform: %@", transformer);
   78|      0|        completion(NO, nil);
   79|      0|        return;
   80|      0|      }
   81|      0|    }
   82|      2|    [self.storageInstance storeEvent:transformedEvent onComplete:completion];
   83|      2|
   84|      2|    // The work is done, cancel the background task if it's valid.
   85|      2|    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
   86|      2|    bgID = GDTCORBackgroundIdentifierInvalid;
   87|      2|  });
   88|      2|}
   89|       |
   90|       |#pragma mark - GDTCORLifecycleProtocol
   91|       |
   92|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
   93|      0|  // Flush the queue immediately.
   94|      0|  dispatch_sync(_eventWritingQueue, ^{
   95|      0|                });
   96|      0|}
   97|       |
   98|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORTransport.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCORTransport.h>
   18|       |#import "GDTCORLibrary/Private/GDTCORTransport_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORAssert.h>
   21|       |#import <GoogleDataTransport/GDTCORClock.h>
   22|       |#import <GoogleDataTransport/GDTCOREvent.h>
   23|       |
   24|       |#import "GDTCORLibrary/Private/GDTCORTransformer.h"
   25|       |
   26|       |@implementation GDTCORTransport
   27|       |
   28|       |- (nullable instancetype)initWithMappingID:(NSString *)mappingID
   29|       |                              transformers:
   30|       |                                  (nullable NSArray<id<GDTCOREventTransformer>> *)transformers
   31|      1|                                    target:(NSInteger)target {
   32|      1|  GDTCORAssert(mappingID.length > 0, @"A mapping ID cannot be nil or empty");
   33|      1|  GDTCORAssert(target > 0, @"A target cannot be negative or 0");
   34|      1|  if (mappingID == nil || mappingID.length == 0 || target <= 0) {
   35|      0|    return nil;
   36|      0|  }
   37|      1|  self = [super init];
   38|      1|  if (self) {
   39|      1|    _mappingID = mappingID;
   40|      1|    _transformers = transformers;
   41|      1|    _target = target;
   42|      1|    _transformerInstance = [GDTCORTransformer sharedInstance];
   43|      1|  }
   44|      1|  GDTCORLogDebug("Transport object created. mappingID:%@ transformers:%@ target:%ld", _mappingID,
   45|      1|                 _transformers, (long)_target);
   46|      1|  return self;
   47|      1|}
   48|       |
   49|       |- (void)sendTelemetryEvent:(GDTCOREvent *)event
   50|      2|                onComplete:(void (^)(BOOL wasWritten, NSError *_Nullable error))completion {
   51|      2|  event.qosTier = GDTCOREventQoSTelemetry;
   52|      2|  [self sendEvent:event
   53|      2|       onComplete:^(BOOL wasWritten, NSError *error) {
   54|      2|         GDTCORLogDebug("Telemetry event sent: %@", event);
   55|      2|         if (completion) {
   56|      2|           completion(wasWritten, nil);
   57|      2|         }
   58|      2|       }];
   59|      2|}
   60|       |
   61|       |- (void)sendDataEvent:(GDTCOREvent *)event
   62|      0|           onComplete:(void (^)(BOOL wasWritten, NSError *_Nullable error))completion {
   63|      0|  GDTCORAssert(event.qosTier != GDTCOREventQoSTelemetry, @"Use -sendTelemetryEvent, please.");
   64|      0|  [self sendEvent:event
   65|      0|       onComplete:^(BOOL wasWritten, NSError *error) {
   66|      0|         GDTCORLogDebug("Data event sent: %@", event);
   67|      0|         if (completion) {
   68|      0|           completion(wasWritten, nil);
   69|      0|         }
   70|      0|       }];
   71|      0|}
   72|       |
   73|      2|- (void)sendTelemetryEvent:(GDTCOREvent *)event {
   74|      2|  [self sendTelemetryEvent:event
   75|      2|                onComplete:^(BOOL wasWritten, NSError *_Nullable error){
   76|      2|                }];
   77|      2|}
   78|       |
   79|      0|- (void)sendDataEvent:(GDTCOREvent *)event {
   80|      0|  [self sendDataEvent:event
   81|      0|           onComplete:^(BOOL wasWritten, NSError *_Nullable error){
   82|      0|           }];
   83|      0|}
   84|       |
   85|      2|- (GDTCOREvent *)eventForTransport {
   86|      2|  return [[GDTCOREvent alloc] initWithMappingID:_mappingID target:_target];
   87|      2|}
   88|       |
   89|       |#pragma mark - Private helper methods
   90|       |
   91|       |/** Sends the given event through the transport pipeline.
   92|       | *
   93|       | * @param event The event to send.
   94|       | * @param completion A block that will be called when the event has been written or dropped.
   95|       | */
   96|       |- (void)sendEvent:(GDTCOREvent *)event
   97|      2|       onComplete:(void (^)(BOOL wasWritten, NSError *error))completion {
   98|      2|  // TODO: Determine if sending an event before registration is allowed.
   99|      2|  GDTCORAssert(event, @"You can't send a nil event");
  100|      2|  GDTCOREvent *copiedEvent = [event copy];
  101|      2|  copiedEvent.clockSnapshot = [GDTCORClock snapshot];
  102|      2|  [self.transformerInstance transformEvent:copiedEvent
  103|      2|                          withTransformers:_transformers
  104|      2|                                onComplete:completion];
  105|      2|}
  106|       |
  107|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORUploadCoordinator.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORAssert.h>
   20|       |#import <GoogleDataTransport/GDTCORClock.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |
   23|       |#import "GDTCORLibrary/Private/GDTCORReachability.h"
   24|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   25|       |#import "GDTCORLibrary/Private/GDTCORStorage.h"
   26|       |
   27|       |@implementation GDTCORUploadCoordinator
   28|       |
   29|     13|+ (instancetype)sharedInstance {
   30|     13|  static GDTCORUploadCoordinator *sharedUploader;
   31|     13|  static dispatch_once_t onceToken;
   32|     13|  dispatch_once(&onceToken, ^{
   33|      1|    sharedUploader = [[GDTCORUploadCoordinator alloc] init];
   34|      1|    [sharedUploader startTimer];
   35|      1|  });
   36|     13|  return sharedUploader;
   37|     13|}
   38|       |
   39|      1|- (instancetype)init {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _coordinationQueue =
   43|      1|        dispatch_queue_create("com.google.GDTCORUploadCoordinator", DISPATCH_QUEUE_SERIAL);
   44|      1|    _registrar = [GDTCORRegistrar sharedInstance];
   45|      1|    _timerInterval = 30 * NSEC_PER_SEC;
   46|      1|    _timerLeeway = 5 * NSEC_PER_SEC;
   47|      1|    _targetToInFlightPackages = [[NSMutableDictionary alloc] init];
   48|      1|  }
   49|      1|  return self;
   50|      1|}
   51|       |
   52|      0|- (void)forceUploadForTarget:(GDTCORTarget)target {
   53|      0|  dispatch_async(_coordinationQueue, ^{
   54|      0|    GDTCORLogDebug("Forcing an upload of target %ld", (long)target);
   55|      0|    GDTCORUploadConditions conditions = [self uploadConditions];
   56|      0|    conditions |= GDTCORUploadConditionHighPriority;
   57|      0|    [self uploadTargets:@[ @(target) ] conditions:conditions];
   58|      0|  });
   59|      0|}
   60|       |
   61|       |#pragma mark - Property overrides
   62|       |
   63|       |// GDTCORStorage and GDTCORUploadCoordinator +sharedInstance methods call each other, so this breaks
   64|       |// the loop.
   65|      5|- (GDTCORStorage *)storage {
   66|      5|  if (!_storage) {
   67|      1|    _storage = [GDTCORStorage sharedInstance];
   68|      1|  }
   69|      5|  return _storage;
   70|      5|}
   71|       |
   72|       |#pragma mark - Private helper methods
   73|       |
   74|       |/** Starts a timer that checks whether or not events can be uploaded at regular intervals. It will
   75|       | * check the next-upload clocks of all targets to determine if an upload attempt can be made.
   76|       | */
   77|      3|- (void)startTimer {
   78|      3|  dispatch_sync(_coordinationQueue, ^{
   79|      3|    self->_timer =
   80|      3|        dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self->_coordinationQueue);
   81|      3|    dispatch_source_set_timer(self->_timer, DISPATCH_TIME_NOW, self->_timerInterval,
   82|      3|                              self->_timerLeeway);
   83|      3|    dispatch_source_set_event_handler(self->_timer, ^{
   84|      3|      if (![[GDTCORApplication sharedApplication] isRunningInBackground]) {
   85|      3|        GDTCORUploadConditions conditions = [self uploadConditions];
   86|      3|        GDTCORLogDebug("%@", @"Upload timer fired");
   87|      3|        [self uploadTargets:[self.registrar.targetToUploader allKeys] conditions:conditions];
   88|      3|      }
   89|      3|    });
   90|      3|    GDTCORLogDebug("%@", @"Upload timer started");
   91|      3|    dispatch_resume(self->_timer);
   92|      3|  });
   93|      3|}
   94|       |
   95|       |/** Stops the currently running timer. */
   96|      0|- (void)stopTimer {
   97|      0|  if (_timer) {
   98|      0|    dispatch_source_cancel(_timer);
   99|      0|  }
  100|      0|}
  101|       |
  102|       |/** Triggers the uploader implementations for the given targets to upload.
  103|       | *
  104|       | * @param targets An array of targets to trigger.
  105|       | * @param conditions The set of upload conditions.
  106|       | */
  107|      3|- (void)uploadTargets:(NSArray<NSNumber *> *)targets conditions:(GDTCORUploadConditions)conditions {
  108|      3|  dispatch_async(_coordinationQueue, ^{
  109|      3|    if ((conditions & GDTCORUploadConditionNoNetwork) == GDTCORUploadConditionNoNetwork) {
  110|      0|      return;
  111|      0|    }
  112|      9|    for (NSNumber *target in targets) {
  113|      9|      // Don't trigger uploads for targets that have an in-flight package already.
  114|      9|      if (self->_targetToInFlightPackages[target]) {
  115|      0|        GDTCORLogDebug("Target %@ will not upload, there's an upload in flight", target);
  116|      0|        continue;
  117|      0|      }
  118|      9|      // Ask the uploader if they can upload and do so, if it can.
  119|      9|      id<GDTCORUploader> uploader = self.registrar.targetToUploader[target];
  120|      9|      if ([uploader readyToUploadTarget:target.intValue conditions:conditions]) {
  121|      6|        id<GDTCORPrioritizer> prioritizer = self.registrar.targetToPrioritizer[target];
  122|      6|        GDTCORUploadPackage *package = [prioritizer uploadPackageWithTarget:target.intValue
  123|      6|                                                                 conditions:conditions];
  124|      6|        if (package.events.count) {
  125|      1|          self->_targetToInFlightPackages[target] = package;
  126|      1|          GDTCORLogDebug("Package of %ld events is being handed over to an uploader",
  127|      1|                         (long)package.events.count);
  128|      1|          [uploader uploadPackage:package];
  129|      5|        } else {
  130|      5|          [package completeDelivery];
  131|      5|        }
  132|      6|      }
  133|      9|      GDTCORLogDebug("Target %@ is not ready to upload", target);
  134|      9|    }
  135|      3|  });
  136|      3|}
  137|       |
  138|       |/** Returns the current upload conditions after making determinations about the network connection.
  139|       | *
  140|       | * @return The current upload conditions.
  141|       | */
  142|      3|- (GDTCORUploadConditions)uploadConditions {
  143|       |#if TARGET_OS_WATCH
  144|       |  return GDTCORUploadConditionNoNetwork;
  145|       |#else
  146|       |  SCNetworkReachabilityFlags currentFlags = [GDTCORReachability currentFlags];
  147|      3|  BOOL reachable =
  148|      3|      (currentFlags & kSCNetworkReachabilityFlagsReachable) == kSCNetworkReachabilityFlagsReachable;
  149|      3|  BOOL connectionRequired = (currentFlags & kSCNetworkReachabilityFlagsConnectionRequired) ==
  150|      3|                            kSCNetworkReachabilityFlagsConnectionRequired;
  151|      3|  BOOL networkConnected = reachable && !connectionRequired;
  152|      3|
  153|      3|  if (!networkConnected) {
  154|      0|    return GDTCORUploadConditionNoNetwork;
  155|      0|  }
  156|      3|
  157|      3|  BOOL isWWAN = GDTCORReachabilityFlagsContainWWAN(currentFlags);
  158|      3|  if (isWWAN) {
  159|      0|    return GDTCORUploadConditionMobileData;
  160|      3|  } else {
  161|      3|    return GDTCORUploadConditionWifiData;
  162|      3|  }
  163|      3|#endif
  164|      3|}
  165|       |
  166|       |#pragma mark - NSSecureCoding support
  167|       |
  168|       |/** The NSKeyedCoder key for the targetToInFlightPackages property. */
  169|       |static NSString *const ktargetToInFlightPackagesKey =
  170|       |    @"GDTCORUploadCoordinatortargetToInFlightPackages";
  171|       |
  172|      2|+ (BOOL)supportsSecureCoding {
  173|      2|  return YES;
  174|      2|}
  175|       |
  176|      2|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  177|      2|  GDTCORUploadCoordinator *sharedCoordinator = [GDTCORUploadCoordinator sharedInstance];
  178|      2|  dispatch_sync(sharedCoordinator->_coordinationQueue, ^{
  179|      2|    @try {
  180|      2|      sharedCoordinator->_targetToInFlightPackages =
  181|      2|          [aDecoder decodeObjectOfClass:[NSMutableDictionary class]
  182|      2|                                 forKey:ktargetToInFlightPackagesKey];
  183|      2|
  184|      2|    } @catch (NSException *exception) {
  185|      2|      sharedCoordinator->_targetToInFlightPackages = [NSMutableDictionary dictionary];
  186|      2|    }
  187|      2|  });
  188|      2|  return sharedCoordinator;
  189|      2|}
  190|       |
  191|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  192|      0|  dispatch_sync(_coordinationQueue, ^{
  193|      0|    // All packages that have been given to uploaders need to be tracked so that their expiration
  194|      0|    // timers can be called.
  195|      0|    if (self->_targetToInFlightPackages.count > 0) {
  196|      0|      [aCoder encodeObject:self->_targetToInFlightPackages forKey:ktargetToInFlightPackagesKey];
  197|      0|    }
  198|      0|  });
  199|      0|}
  200|       |
  201|       |#pragma mark - GDTCORLifecycleProtocol
  202|       |
  203|      2|- (void)appWillForeground:(GDTCORApplication *)app {
  204|      2|  // Not entirely thread-safe, but it should be fine.
  205|      2|  [self startTimer];
  206|      2|}
  207|       |
  208|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  209|      0|  // Should be thread-safe. If it ends up not being, put this in a dispatch_sync.
  210|      0|  [self stopTimer];
  211|      0|}
  212|       |
  213|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  214|      0|  dispatch_sync(_coordinationQueue, ^{
  215|      0|    [self stopTimer];
  216|      0|  });
  217|      0|}
  218|       |
  219|       |#pragma mark - GDTCORUploadPackageProtocol
  220|       |
  221|      5|- (void)packageDelivered:(GDTCORUploadPackage *)package successful:(BOOL)successful {
  222|      5|  if (!_coordinationQueue) {
  223|      0|    return;
  224|      0|  }
  225|      5|  dispatch_async(_coordinationQueue, ^{
  226|      5|    NSNumber *targetNumber = @(package.target);
  227|      5|    NSMutableDictionary<NSNumber *, GDTCORUploadPackage *> *targetToInFlightPackages =
  228|      5|        self->_targetToInFlightPackages;
  229|      5|    GDTCORRegistrar *registrar = self->_registrar;
  230|      5|    if (targetToInFlightPackages) {
  231|      3|      [targetToInFlightPackages removeObjectForKey:targetNumber];
  232|      3|    }
  233|      5|    if (registrar) {
  234|      5|      id<GDTCORPrioritizer> prioritizer = registrar.targetToPrioritizer[targetNumber];
  235|      5|      if (!prioritizer) {
  236|      0|        GDTCORLogError(GDTCORMCEPrioritizerError,
  237|      0|                       @"A prioritizer should be registered for this target: %@", targetNumber);
  238|      0|      }
  239|      5|      if ([prioritizer respondsToSelector:@selector(packageDelivered:successful:)]) {
  240|      5|        [prioritizer packageDelivered:package successful:successful];
  241|      5|      }
  242|      5|    }
  243|      5|    if (package.events != nil) {
  244|      5|      [self.storage removeEvents:package.events];
  245|      5|    }
  246|      5|  });
  247|      5|}
  248|       |
  249|      0|- (void)packageExpired:(GDTCORUploadPackage *)package {
  250|      0|  if (!_coordinationQueue) {
  251|      0|    return;
  252|      0|  }
  253|      0|  dispatch_async(_coordinationQueue, ^{
  254|      0|    NSNumber *targetNumber = @(package.target);
  255|      0|    NSMutableDictionary<NSNumber *, GDTCORUploadPackage *> *targetToInFlightPackages =
  256|      0|        self->_targetToInFlightPackages;
  257|      0|    GDTCORRegistrar *registrar = self->_registrar;
  258|      0|    if (targetToInFlightPackages) {
  259|      0|      [targetToInFlightPackages removeObjectForKey:targetNumber];
  260|      0|    }
  261|      0|    if (registrar) {
  262|      0|      id<GDTCORPrioritizer> prioritizer = registrar.targetToPrioritizer[targetNumber];
  263|      0|      id<GDTCORUploader> uploader = registrar.targetToUploader[targetNumber];
  264|      0|      if ([prioritizer respondsToSelector:@selector(packageExpired:)]) {
  265|      0|        [prioritizer packageExpired:package];
  266|      0|      }
  267|      0|      if ([uploader respondsToSelector:@selector(packageExpired:)]) {
  268|      0|        [uploader packageExpired:package];
  269|      0|      }
  270|      0|    }
  271|      0|  });
  272|      0|}
  273|       |
  274|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORUploadPackage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCORUploadPackage.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORClock.h>
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |#import <GoogleDataTransport/GDTCORStoredEvent.h>
   22|       |
   23|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   24|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   25|       |#import "GDTCORLibrary/Private/GDTCORUploadPackage_Private.h"
   26|       |
   27|       |@implementation GDTCORUploadPackage {
   28|       |  /** If YES, the package's -completeDelivery method has been called. */
   29|       |  BOOL _isDelivered;
   30|       |
   31|       |  /** If YES, is being handled by the handler. */
   32|       |  BOOL _isHandled;
   33|       |
   34|       |  /** A timer that will regularly check to see whether this package has expired or not. */
   35|       |  NSTimer *_expirationTimer;
   36|       |}
   37|       |
   38|      6|- (instancetype)initWithTarget:(GDTCORTarget)target {
   39|      6|  self = [super init];
   40|      6|  if (self) {
   41|      6|    _target = target;
   42|      6|    _storage = [GDTCORStorage sharedInstance];
   43|      6|    _deliverByTime = [GDTCORClock clockSnapshotInTheFuture:180000];
   44|      6|    _handler = [GDTCORUploadCoordinator sharedInstance];
   45|      6|    _expirationTimer = [NSTimer scheduledTimerWithTimeInterval:5.0
   46|      6|                                                        target:self
   47|      6|                                                      selector:@selector(checkIfPackageIsExpired:)
   48|      6|                                                      userInfo:nil
   49|      6|                                                       repeats:YES];
   50|      6|  }
   51|      6|  GDTCORLogDebug("Upload package created %@", self);
   52|      6|  return self;
   53|      6|}
   54|       |
   55|      0|- (instancetype)copy {
   56|      0|  GDTCORUploadPackage *newPackage = [[GDTCORUploadPackage alloc] initWithTarget:_target];
   57|      0|  newPackage->_events = [_events copy];
   58|      0|  GDTCORLogDebug("Copying UploadPackage %@ to %@", self, newPackage);
   59|      0|  return newPackage;
   60|      0|}
   61|       |
   62|      0|- (NSUInteger)hash {
   63|      0|  return [_events hash];
   64|      0|}
   65|       |
   66|      0|- (BOOL)isEqual:(id)object {
   67|      0|  return [self hash] == [object hash];
   68|      0|}
   69|       |
   70|      5|- (void)dealloc {
   71|      5|  [_expirationTimer invalidate];
   72|      5|}
   73|       |
   74|      0|- (void)setStorage:(GDTCORStorage *)storage {
   75|      0|  if (storage != _storage) {
   76|      0|    _storage = storage;
   77|      0|  }
   78|      0|}
   79|       |
   80|      5|- (void)completeDelivery {
   81|      5|  if (_isDelivered) {
   82|      0|    GDTCORLogError(GDTCORMCEDeliverTwice, @"%@",
   83|      0|                   @"It's an API violation to call -completeDelivery twice.");
   84|      0|  }
   85|      5|  _isDelivered = YES;
   86|      5|  if (!_isHandled && _handler &&
   87|      5|      [_handler respondsToSelector:@selector(packageDelivered:successful:)]) {
   88|      5|    [_expirationTimer invalidate];
   89|      5|    _isHandled = YES;
   90|      5|    [_handler packageDelivered:self successful:YES];
   91|      5|  }
   92|      5|  GDTCORLogDebug("Upload package delivered: %@", self);
   93|      5|}
   94|       |
   95|      0|- (void)retryDeliveryInTheFuture {
   96|      0|  if (!_isHandled && _handler &&
   97|      0|      [_handler respondsToSelector:@selector(packageDelivered:successful:)]) {
   98|      0|    [_expirationTimer invalidate];
   99|      0|    _isHandled = YES;
  100|      0|    [_handler packageDelivered:self successful:NO];
  101|      0|  }
  102|      0|  GDTCORLogDebug("Upload package will retry in the future: %@", self);
  103|      0|}
  104|       |
  105|      0|- (void)checkIfPackageIsExpired:(NSTimer *)timer {
  106|      0|  if ([[GDTCORClock snapshot] isAfter:_deliverByTime]) {
  107|      0|    if (_handler && [_handler respondsToSelector:@selector(packageExpired:)]) {
  108|      0|      _isHandled = YES;
  109|      0|      [_expirationTimer invalidate];
  110|      0|      GDTCORLogDebug("Upload package expired: %@", self);
  111|      0|      [_handler packageExpired:self];
  112|      0|    }
  113|      0|  }
  114|      0|}
  115|       |
  116|       |#pragma mark - NSSecureCoding
  117|       |
  118|       |/** The keyed archiver key for the events property. */
  119|       |static NSString *const kEventsKey = @"GDTCORUploadPackageEventsKey";
  120|       |
  121|       |/** The keyed archiver key for the _isHandled property. */
  122|       |static NSString *const kDeliverByTimeKey = @"GDTCORUploadPackageDeliveryByTimeKey";
  123|       |
  124|       |/** The keyed archiver key for the _isHandled ivar. */
  125|       |static NSString *const kIsHandledKey = @"GDTCORUploadPackageIsHandledKey";
  126|       |
  127|       |/** The keyed archiver key for the handler property. */
  128|       |static NSString *const kHandlerKey = @"GDTCORUploadPackageHandlerKey";
  129|       |
  130|       |/** The keyed archiver key for the target property. */
  131|       |static NSString *const kTargetKey = @"GDTCORUploadPackageTargetKey";
  132|       |
  133|      0|+ (BOOL)supportsSecureCoding {
  134|      0|  return YES;
  135|      0|}
  136|       |
  137|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
  138|      0|  [aCoder encodeObject:_events forKey:kEventsKey];
  139|      0|  [aCoder encodeObject:_deliverByTime forKey:kDeliverByTimeKey];
  140|      0|  [aCoder encodeBool:_isHandled forKey:kIsHandledKey];
  141|      0|  [aCoder encodeObject:_handler forKey:kHandlerKey];
  142|      0|  [aCoder encodeInteger:_target forKey:kTargetKey];
  143|      0|}
  144|       |
  145|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
  146|      0|  GDTCORTarget target = [aDecoder decodeIntegerForKey:kTargetKey];
  147|      0|  self = [self initWithTarget:target];
  148|      0|  if (self) {
  149|      0|    NSSet *classes = [NSSet setWithObjects:[NSSet class], [GDTCORStoredEvent class], nil];
  150|      0|    _events = [aDecoder decodeObjectOfClasses:classes forKey:kEventsKey];
  151|      0|    _deliverByTime = [aDecoder decodeObjectOfClass:[GDTCORClock class] forKey:kDeliverByTimeKey];
  152|      0|    _isHandled = [aDecoder decodeBoolForKey:kIsHandledKey];
  153|      0|    // _handler isn't technically NSSecureCoding, because we don't know the class of this object.
  154|      0|    // but it gets decoded anyway.
  155|      0|  }
  156|      0|  return self;
  157|      0|}
  158|       |
  159|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/Public/GDTCORAssert.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |
   21|       |/** A block type that could be run instead of normal assertion logging. No return type, no params.
   22|       | */
   23|       |typedef void (^GDTCORAssertionBlock)(void);
   24|       |
   25|       |/** Returns the result of executing a soft-linked method present in unit tests that allows a block
   26|       | * to be run instead of normal assertion logging. This helps ameliorate issues with catching
   27|       | * exceptions that occur on a dispatch_queue.
   28|       | *
   29|       | * @return A block that can be run instead of normal assert printing.
   30|       | */
   31|       |FOUNDATION_EXPORT GDTCORAssertionBlock _Nullable GDTCORAssertionBlockToRunInstead(void);
   32|       |
   33|       |#if defined(NS_BLOCK_ASSERTIONS)
   34|       |
   35|       |#define GDTCORAssert(condition, ...) \
   36|       |  do {                               \
   37|       |  } while (0);
   38|       |
   39|       |#define GDTCORFatalAssert(condition, ...) \
   40|       |  do {                                    \
   41|       |  } while (0);
   42|       |
   43|       |#else  // defined(NS_BLOCK_ASSERTIONS)
   44|       |
   45|       |/** Asserts using a console log, unless a block was specified to be run instead.
   46|       | *
   47|       | * @param condition The condition you'd expect to be YES.
   48|       | */
   49|       |#define GDTCORAssert(condition, ...)                                                             \
   50|     20|  do {                                                                                           \
   51|     20|    if (__builtin_expect(!(condition), 0)) {                                                     \
   52|      0|      GDTCORAssertionBlock assertionBlock = GDTCORAssertionBlockToRunInstead();                  \
   53|      0|      if (assertionBlock) {                                                                      \
   54|      0|        assertionBlock();                                                                        \
   55|      0|      } else {                                                                                   \
   56|      0|        __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS                                                      \
   57|      0|        NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__];                    \
   58|      0|        __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>";                 \
   59|      0|        GDTCORLogError(GDTCORMCEGeneralError, @"Assertion failed (%@:%d): %@,", __assert_file__, \
   60|      0|                       __LINE__, ##__VA_ARGS__);                                                 \
   61|      0|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS                                                       \
   62|      0|      }                                                                                          \
   63|      0|    }                                                                                            \
   64|     20|  } while (0);
   65|       |
   66|       |/** Asserts by logging to the console and throwing an exception if NS_BLOCK_ASSERTIONS is not
   67|       | * defined.
   68|       | *
   69|       | * @param condition The condition you'd expect to be YES.
   70|       | */
   71|       |#define GDTCORFatalAssert(condition, ...)                                               \
   72|      1|  do {                                                                                  \
   73|      1|    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS                                                 \
   74|      1|    if (__builtin_expect(!(condition), 0)) {                                            \
   75|      0|      NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__];             \
   76|      0|      __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>";          \
   77|      0|      GDTCORLogError(GDTCORMCEFatalAssertion,                                           \
   78|      0|                     @"Fatal assertion encountered, please open an issue at "           \
   79|      0|                      "https://github.com/firebase/firebase-ios-sdk/issues "            \
   80|      0|                      "(%@:%d): %@,",                                                   \
   81|      0|                     __assert_file__, __LINE__, ##__VA_ARGS__);                         \
   82|      0|      [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd                   \
   83|      0|                                                          object:self                   \
   84|      0|                                                            file:__assert_file__        \
   85|      0|                                                      lineNumber:__LINE__               \
   86|      0|                                                     description:@"%@", ##__VA_ARGS__]; \
   87|      0|    }                                                                                   \
   88|      1|    __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS                                                  \
   89|      1|  } while (0);
   90|       |
   91|       |#endif  // defined(NS_BLOCK_ASSERTIONS)

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/Public/GDTCORConsoleLogger.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |// Set this to 1 to have the library print out as much as possible about what GDT is doing.
   20|       |#define GDT_VERBOSE_LOGGING 0
   21|       |
   22|       |/** A list of message codes to print in the logger that help to correspond printed messages with
   23|       | * code locations.
   24|       | *
   25|       | * Prefixes:
   26|       | * - MCW => MessageCodeWarning
   27|       | * - MCE => MessageCodeError
   28|       | */
   29|       |typedef NS_ENUM(NSInteger, GDTCORMessageCode) {
   30|       |
   31|       |  /** For warning messages concerning transportBytes: not being implemented by a data object. */
   32|       |  GDTCORMCWDataObjectMissingBytesImpl = 1,
   33|       |
   34|       |  /** For warning messages concerning a failed event upload. */
   35|       |  GDTCORMCWUploadFailed = 2,
   36|       |
   37|       |  /** For warning messages concerning a forced event upload. */
   38|       |  GDTCORMCWForcedUpload = 3,
   39|       |
   40|       |  /** For warning messages concerning a failed reachability call. */
   41|       |  GDTCORMCWReachabilityFailed = 4,
   42|       |
   43|       |  /** For error messages concerning transform: not being implemented by an event transformer. */
   44|       |  GDTCORMCETransformerDoesntImplementTransform = 1000,
   45|       |
   46|       |  /** For error messages concerning the creation of a directory failing. */
   47|       |  GDTCORMCEDirectoryCreationError = 1001,
   48|       |
   49|       |  /** For error messages concerning the writing of a event file. */
   50|       |  GDTCORMCEFileWriteError = 1002,
   51|       |
   52|       |  /** For error messages concerning the lack of a prioritizer for a given backend. */
   53|       |  GDTCORMCEPrioritizerError = 1003,
   54|       |
   55|       |  /** For error messages concerning a package delivery API violation. */
   56|       |  GDTCORMCEDeliverTwice = 1004,
   57|       |
   58|       |  /** For error messages concerning an error in an implementation of -transportBytes. */
   59|       |  GDTCORMCETransportBytesError = 1005,
   60|       |
   61|       |  /** For general purpose error messages in a dependency. */
   62|       |  GDTCORMCEGeneralError = 1006,
   63|       |
   64|       |  /** For fatal errors. Please go to https://github.com/firebase/firebase-ios-sdk/issues and open
   65|       |   * an issue if you encounter an error with this code.
   66|       |   */
   67|       |  GDTCORMCEFatalAssertion = 1007
   68|       |};
   69|       |
   70|       |/** */
   71|       |FOUNDATION_EXPORT
   72|       |void GDTCORLog(GDTCORMessageCode code, NSString *_Nonnull format, ...);
   73|       |
   74|       |/** Returns the string that represents some message code.
   75|       | *
   76|       | * @param code The code to convert to a string.
   77|       | * @return The string representing the message code.
   78|       | */
   79|       |FOUNDATION_EXPORT NSString *_Nonnull GDTCORMessageCodeEnumToString(GDTCORMessageCode code);
   80|       |
   81|       |// A define to wrap GULLogWarning with slightly more convenient usage.
   82|       |#define GDTCORLogWarning(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
   83|      0|  GDTCORLog(MESSAGE_CODE, MESSAGE_FORMAT, __VA_ARGS__);
   84|       |
   85|       |// A define to wrap GULLogError with slightly more convenient usage and a failing assert.
   86|       |#define GDTCORLogError(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
   87|      0|  GDTCORLog(MESSAGE_CODE, MESSAGE_FORMAT, __VA_ARGS__);
   88|       |
   89|       |// A define to wrap NSLog for verbose console logs only useful for local debugging.
   90|       |#if GDT_VERBOSE_LOGGING == 1
   91|       |#define GDTCORLogDebug(FORMAT, ...) NSLog(@"GDT: " FORMAT, __VA_ARGS__);
   92|       |#else
   93|       |#define GDTCORLogDebug(...)
   94|       |#endif  // GDT_VERBOSE_LOGGING == 1

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTCompressionHelper.m:
    1|       |/*
    2|       | * Copyright 2020 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTCompressionHelper.h"
   18|       |
   19|       |#import <zlib.h>
   20|       |
   21|       |@implementation GDTCCTCompressionHelper
   22|       |
   23|      1|+ (nullable NSData *)gzippedData:(NSData *)data {
   24|      1|#if defined(__LP64__) && __LP64__
   25|      1|  // Don't support > 32bit length for 64 bit, see note in header.
   26|      1|  if (data.length > UINT_MAX) {
   27|      0|    return nil;
   28|      0|  }
   29|      1|#endif
   30|      1|
   31|      1|  const uint kChunkSize = 1024;
   32|      1|
   33|      1|  const void *bytes = [data bytes];
   34|      1|  NSUInteger length = [data length];
   35|      1|
   36|      1|  int level = Z_DEFAULT_COMPRESSION;
   37|      1|  if (!bytes || !length) {
   38|      0|    return nil;
   39|      0|  }
   40|      1|
   41|      1|  z_stream strm;
   42|      1|  bzero(&strm, sizeof(z_stream));
   43|      1|
   44|      1|  int memLevel = 8;          // Default.
   45|      1|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
   46|      1|
   47|      1|  int retCode;
   48|      1|  if (deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel, Z_DEFAULT_STRATEGY) != Z_OK) {
   49|      0|    return nil;
   50|      0|  }
   51|      1|
   52|      1|  // Hint the size at 1/4 the input size.
   53|      1|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
   54|      1|  unsigned char output[kChunkSize];
   55|      1|
   56|      1|  // Setup the input.
   57|      1|  strm.avail_in = (unsigned int)length;
   58|      1|  strm.next_in = (unsigned char *)bytes;
   59|      1|
   60|      1|  // Collect the data.
   61|      1|  do {
   62|      1|    // update what we're passing in
   63|      1|    strm.avail_out = kChunkSize;
   64|      1|    strm.next_out = output;
   65|      1|    retCode = deflate(&strm, Z_FINISH);
   66|      1|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   67|      0|      deflateEnd(&strm);
   68|      0|      return nil;
   69|      0|    }
   70|      1|    // Collect what we got.
   71|      1|    unsigned gotBack = kChunkSize - strm.avail_out;
   72|      1|    if (gotBack > 0) {
   73|      1|      [result appendBytes:output length:gotBack];
   74|      1|    }
   75|      1|
   76|      1|  } while (retCode == Z_OK);
   77|      1|
   78|      1|  // If the loop exits, it used all input and the stream ended.
   79|      1|  NSAssert(strm.avail_in == 0,
   80|      1|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
   81|      1|  NSAssert(retCode == Z_STREAM_END,
   82|      1|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
   83|      1|
   84|      1|  // Clean up.
   85|      1|  deflateEnd(&strm);
   86|      1|
   87|      1|  return result;
   88|      1|}
   89|       |
   90|      1|+ (BOOL)isGzipped:(NSData *)data {
   91|      1|  const UInt8 *bytes = (const UInt8 *)data.bytes;
   92|      1|  return (data.length >= 2 && bytes[0] == 0x1f && bytes[1] == 0x8b);
   93|      1|}
   94|       |
   95|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTNanopbHelpers.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   18|       |
   19|       |#if TARGET_OS_IOS || TARGET_OS_TV
   20|       |#import <UIKit/UIKit.h>
   21|       |#elif TARGET_OS_OSX
   22|       |#import <AppKit/AppKit.h>
   23|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
   24|       |
   25|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   26|       |
   27|       |#import <nanopb/pb.h>
   28|       |#import <nanopb/pb_decode.h>
   29|       |#import <nanopb/pb_encode.h>
   30|       |
   31|       |#import "GDTCCTLibrary/Private/GDTCCTPrioritizer.h"
   32|       |
   33|       |#pragma mark - General purpose encoders
   34|       |
   35|      7|pb_bytes_array_t *GDTCCTEncodeString(NSString *string) {
   36|      7|  NSData *stringBytes = [string dataUsingEncoding:NSUTF8StringEncoding];
   37|      7|  return GDTCCTEncodeData(stringBytes);
   38|      7|}
   39|       |
   40|      8|pb_bytes_array_t *GDTCCTEncodeData(NSData *data) {
   41|      8|  pb_bytes_array_t *pbBytes = malloc(PB_BYTES_ARRAY_T_ALLOCSIZE(data.length));
   42|      8|  if (pbBytes != NULL) {
   43|      8|    memcpy(pbBytes->bytes, [data bytes], data.length);
   44|      8|    pbBytes->size = (pb_size_t)data.length;
   45|      8|  }
   46|      8|  return pbBytes;
   47|      8|}
   48|       |
   49|       |#pragma mark - CCT object constructors
   50|       |
   51|      1|NSData *_Nullable GDTCCTEncodeBatchedLogRequest(gdt_cct_BatchedLogRequest *batchedLogRequest) {
   52|      1|  pb_ostream_t sizestream = PB_OSTREAM_SIZING;
   53|      1|  // Encode 1 time to determine the size.
   54|      1|  if (!pb_encode(&sizestream, gdt_cct_BatchedLogRequest_fields, batchedLogRequest)) {
   55|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"Error in nanopb encoding for size: %s",
   56|      0|                   PB_GET_ERROR(&sizestream));
   57|      0|  }
   58|      1|
   59|      1|  // Encode a 2nd time to actually get the bytes from it.
   60|      1|  size_t bufferSize = sizestream.bytes_written;
   61|      1|  CFMutableDataRef dataRef = CFDataCreateMutable(CFAllocatorGetDefault(), bufferSize);
   62|      1|  CFDataSetLength(dataRef, bufferSize);
   63|      1|  pb_ostream_t ostream = pb_ostream_from_buffer((void *)CFDataGetBytePtr(dataRef), bufferSize);
   64|      1|  if (!pb_encode(&ostream, gdt_cct_BatchedLogRequest_fields, batchedLogRequest)) {
   65|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"Error in nanopb encoding for bytes: %s",
   66|      0|                   PB_GET_ERROR(&ostream));
   67|      0|  }
   68|      1|
   69|      1|  return CFBridgingRelease(dataRef);
   70|      1|}
   71|       |
   72|       |gdt_cct_BatchedLogRequest GDTCCTConstructBatchedLogRequest(
   73|      1|    NSDictionary<NSString *, NSSet<GDTCORStoredEvent *> *> *logMappingIDToLogSet) {
   74|      1|  gdt_cct_BatchedLogRequest batchedLogRequest = gdt_cct_BatchedLogRequest_init_default;
   75|      1|  NSUInteger numberOfLogRequests = logMappingIDToLogSet.count;
   76|      1|  gdt_cct_LogRequest *logRequests = malloc(sizeof(gdt_cct_LogRequest) * numberOfLogRequests);
   77|      1|  if (logRequests == NULL) {
   78|      0|    return batchedLogRequest;
   79|      0|  }
   80|      1|
   81|      1|  __block int i = 0;
   82|      1|  [logMappingIDToLogSet enumerateKeysAndObjectsUsingBlock:^(
   83|      1|                            NSString *_Nonnull logMappingID,
   84|      1|                            NSSet<GDTCORStoredEvent *> *_Nonnull logSet, BOOL *_Nonnull stop) {
   85|      1|    int32_t logSource = [logMappingID intValue];
   86|      1|    gdt_cct_LogRequest logRequest = GDTCCTConstructLogRequest(logSource, logSet);
   87|      1|    logRequests[i] = logRequest;
   88|      1|    i++;
   89|      1|  }];
   90|      1|
   91|      1|  batchedLogRequest.log_request = logRequests;
   92|      1|  batchedLogRequest.log_request_count = (pb_size_t)numberOfLogRequests;
   93|      1|  return batchedLogRequest;
   94|      1|}
   95|       |
   96|       |gdt_cct_LogRequest GDTCCTConstructLogRequest(int32_t logSource,
   97|      1|                                             NSSet<GDTCORStoredEvent *> *_Nonnull logSet) {
   98|      1|  if (logSet.count == 0) {
   99|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"%@",
  100|      0|                   @"An empty event set can't be serialized to proto.");
  101|      0|    gdt_cct_LogRequest logRequest = gdt_cct_LogRequest_init_default;
  102|      0|    return logRequest;
  103|      0|  }
  104|      1|  gdt_cct_LogRequest logRequest = gdt_cct_LogRequest_init_default;
  105|      1|  logRequest.log_source = logSource;
  106|      1|  logRequest.has_log_source = 1;
  107|      1|  logRequest.client_info = GDTCCTConstructClientInfo();
  108|      1|  logRequest.has_client_info = 1;
  109|      1|  logRequest.log_event = malloc(sizeof(gdt_cct_LogEvent) * logSet.count);
  110|      1|  if (logRequest.log_event == NULL) {
  111|      0|    return logRequest;
  112|      0|  }
  113|      1|  int i = 0;
  114|      1|  for (GDTCORStoredEvent *log in logSet) {
  115|      1|    gdt_cct_LogEvent logEvent = GDTCCTConstructLogEvent(log);
  116|      1|    logRequest.log_event[i] = logEvent;
  117|      1|    i++;
  118|      1|  }
  119|      1|  logRequest.log_event_count = (pb_size_t)logSet.count;
  120|      1|
  121|      1|  GDTCORClock *currentTime = [GDTCORClock snapshot];
  122|      1|  logRequest.request_time_ms = currentTime.timeMillis;
  123|      1|  logRequest.has_request_time_ms = 1;
  124|      1|  logRequest.request_uptime_ms = currentTime.uptime;
  125|      1|  logRequest.has_request_uptime_ms = 1;
  126|      1|
  127|      1|  return logRequest;
  128|      1|}
  129|       |
  130|      1|gdt_cct_LogEvent GDTCCTConstructLogEvent(GDTCORStoredEvent *event) {
  131|      1|  gdt_cct_LogEvent logEvent = gdt_cct_LogEvent_init_default;
  132|      1|  logEvent.event_time_ms = event.clockSnapshot.timeMillis;
  133|      1|  logEvent.has_event_time_ms = 1;
  134|      1|  logEvent.event_uptime_ms = event.clockSnapshot.uptime;
  135|      1|  logEvent.has_event_uptime_ms = 1;
  136|      1|  logEvent.timezone_offset_seconds = event.clockSnapshot.timezoneOffsetSeconds;
  137|      1|  logEvent.has_timezone_offset_seconds = 1;
  138|      1|  // TODO: Read network_connection_info from the custom params dict.
  139|      1|
  140|      1|  NSError *error;
  141|      1|  NSData *extensionBytes = [NSData dataWithContentsOfURL:event.dataFuture.fileURL
  142|      1|                                                 options:0
  143|      1|                                                   error:&error];
  144|      1|  if (error) {
  145|      0|    GDTCORLogError(GDTCORMCEGeneralError,
  146|      0|                   @"There was an error reading extension bytes from disk: %@", error);
  147|      0|    return logEvent;
  148|      0|  }
  149|      1|  logEvent.source_extension = GDTCCTEncodeData(extensionBytes);  // read bytes from the file.
  150|      1|  return logEvent;
  151|      1|}
  152|       |
  153|      1|gdt_cct_ClientInfo GDTCCTConstructClientInfo() {
  154|      1|  gdt_cct_ClientInfo clientInfo = gdt_cct_ClientInfo_init_default;
  155|      1|  clientInfo.client_type = gdt_cct_ClientInfo_ClientType_IOS_FIREBASE;
  156|      1|  clientInfo.has_client_type = 1;
  157|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  158|      1|  clientInfo.ios_client_info = GDTCCTConstructiOSClientInfo();
  159|      1|  clientInfo.has_ios_client_info = 1;
  160|       |#elif TARGET_OS_OSX
  161|       |  // TODO(mikehaney24): Expand the proto to include macOS client info.
  162|       |#endif
  163|       |  return clientInfo;
  164|      1|}
  165|       |
  166|      1|gdt_cct_IosClientInfo GDTCCTConstructiOSClientInfo() {
  167|      1|  gdt_cct_IosClientInfo iOSClientInfo = gdt_cct_IosClientInfo_init_default;
  168|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  169|      1|  UIDevice *device = [UIDevice currentDevice];
  170|      1|  NSBundle *bundle = [NSBundle mainBundle];
  171|      1|  NSLocale *locale = [NSLocale currentLocale];
  172|      1|  iOSClientInfo.os_full_version = GDTCCTEncodeString(device.systemVersion);
  173|      1|  NSArray *versionComponents = [device.systemVersion componentsSeparatedByString:@"."];
  174|      1|  iOSClientInfo.os_major_version = GDTCCTEncodeString(versionComponents[0]);
  175|      1|  NSString *version = [bundle objectForInfoDictionaryKey:(NSString *)kCFBundleVersionKey];
  176|      1|  if (version) {
  177|      1|    iOSClientInfo.application_build = GDTCCTEncodeString(version);
  178|      1|  }
  179|      1|  NSString *countryCode = [locale objectForKey:NSLocaleCountryCode];
  180|      1|  if (countryCode) {
  181|      1|    iOSClientInfo.country = GDTCCTEncodeString([locale objectForKey:NSLocaleCountryCode]);
  182|      1|  }
  183|      1|  iOSClientInfo.model = GDTCCTEncodeString(device.model);
  184|      1|  NSString *languageCode = bundle.preferredLocalizations.firstObject;
  185|      1|  iOSClientInfo.language_code =
  186|      1|      languageCode ? GDTCCTEncodeString(languageCode) : GDTCCTEncodeString(@"en");
  187|      1|  iOSClientInfo.application_bundle_id = GDTCCTEncodeString(bundle.bundleIdentifier);
  188|      1|#endif
  189|      1|  return iOSClientInfo;
  190|      1|}
  191|       |
  192|       |#pragma mark - CCT Object decoders
  193|       |
  194|      0|gdt_cct_LogResponse GDTCCTDecodeLogResponse(NSData *data, NSError **error) {
  195|      0|  gdt_cct_LogResponse response = gdt_cct_LogResponse_init_default;
  196|      0|  pb_istream_t istream = pb_istream_from_buffer([data bytes], [data length]);
  197|      0|  if (!pb_decode(&istream, gdt_cct_LogResponse_fields, &response)) {
  198|      0|    NSString *nanopb_error = [NSString stringWithFormat:@"%s", PB_GET_ERROR(&istream)];
  199|      0|    NSDictionary *userInfo = @{@"nanopb error:" : nanopb_error};
  200|      0|    if (error != NULL) {
  201|      0|      *error = [NSError errorWithDomain:NSURLErrorDomain code:-1 userInfo:userInfo];
  202|      0|    }
  203|      0|    response = (gdt_cct_LogResponse)gdt_cct_LogResponse_init_default;
  204|      0|  }
  205|      0|  return response;
  206|      0|}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTPrioritizer.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTPrioritizer.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |#import <GoogleDataTransport/GDTCOREvent.h>
   21|       |#import <GoogleDataTransport/GDTCORRegistrar.h>
   22|       |#import <GoogleDataTransport/GDTCORStoredEvent.h>
   23|       |#import <GoogleDataTransport/GDTCORTargets.h>
   24|       |
   25|       |const static int64_t kMillisPerDay = 8.64e+7;
   26|       |
   27|       |@implementation GDTCCTPrioritizer
   28|       |
   29|      1|+ (void)load {
   30|      1|  GDTCCTPrioritizer *prioritizer = [GDTCCTPrioritizer sharedInstance];
   31|      1|  [[GDTCORRegistrar sharedInstance] registerPrioritizer:prioritizer target:kGDTCORTargetCCT];
   32|      1|  [[GDTCORRegistrar sharedInstance] registerPrioritizer:prioritizer target:kGDTCORTargetFLL];
   33|      1|  [[GDTCORRegistrar sharedInstance] registerPrioritizer:prioritizer target:kGDTCORTargetCSH];
   34|      1|}
   35|       |
   36|      4|+ (instancetype)sharedInstance {
   37|      4|  static GDTCCTPrioritizer *sharedInstance;
   38|      4|  static dispatch_once_t onceToken;
   39|      4|  dispatch_once(&onceToken, ^{
   40|      1|    sharedInstance = [[GDTCCTPrioritizer alloc] init];
   41|      1|  });
   42|      4|  return sharedInstance;
   43|      4|}
   44|       |
   45|      1|- (instancetype)init {
   46|      1|  self = [super init];
   47|      1|  if (self) {
   48|      1|    _queue = dispatch_queue_create("com.google.GDTCCTPrioritizer", DISPATCH_QUEUE_SERIAL);
   49|      1|    _CCTEvents = [[NSMutableSet alloc] init];
   50|      1|    _FLLEvents = [[NSMutableSet alloc] init];
   51|      1|    _CSHEvents = [[NSMutableSet alloc] init];
   52|      1|  }
   53|      1|  return self;
   54|      1|}
   55|       |
   56|       |#pragma mark - GDTCORPrioritizer Protocol
   57|       |
   58|      2|- (void)prioritizeEvent:(GDTCORStoredEvent *)event {
   59|      2|  dispatch_async(_queue, ^{
   60|      2|    switch (event.target.intValue) {
   61|      2|      case kGDTCORTargetCCT:
   62|      0|        [self.CCTEvents addObject:event];
   63|      0|        break;
   64|      2|
   65|      2|      case kGDTCORTargetFLL:
   66|      2|        [self.FLLEvents addObject:event];
   67|      2|        break;
   68|      2|
   69|      2|      case kGDTCORTargetCSH:
   70|      0|        [self.CSHEvents addObject:event];
   71|      0|        break;
   72|      2|
   73|      2|      default:
   74|      0|        GDTCORLogDebug("GDTCCTPrioritizer doesn't support target %d", event.target.intValue);
   75|      0|        break;
   76|      2|    }
   77|      2|  });
   78|      2|}
   79|       |
   80|       |- (GDTCORUploadPackage *)uploadPackageWithTarget:(GDTCORTarget)target
   81|      6|                                      conditions:(GDTCORUploadConditions)conditions {
   82|      6|  GDTCORUploadPackage *package = [[GDTCORUploadPackage alloc] initWithTarget:target];
   83|      6|  dispatch_sync(_queue, ^{
   84|      6|    NSSet<GDTCORStoredEvent *> *eventsThatWillBeSent = [self eventsForTarget:target
   85|      6|                                                                  conditions:conditions];
   86|      6|    package.events = eventsThatWillBeSent;
   87|      6|  });
   88|      6|  GDTCORLogDebug("CCT: %lu events are in the upload package", (unsigned long)package.events.count);
   89|      6|  return package;
   90|      6|}
   91|       |
   92|       |#pragma mark - Private helper methods
   93|       |
   94|       |/** The different possible quality of service specifiers. High values indicate high priority. */
   95|       |typedef NS_ENUM(NSInteger, GDTCCTQoSTier) {
   96|       |  /** The QoS tier wasn't set, and won't ever be sent. */
   97|       |  GDTCCTQoSDefault = 0,
   98|       |
   99|       |  /** This event is internal telemetry data that should not be sent on its own if possible. */
  100|       |  GDTCCTQoSTelemetry = 1,
  101|       |
  102|       |  /** This event should be sent, but in a batch only roughly once per day. */
  103|       |  GDTCCTQoSDaily = 2,
  104|       |
  105|       |  /** This event should only be uploaded on wifi. */
  106|       |  GDTCCTQoSWifiOnly = 5,
  107|       |};
  108|       |
  109|       |/** Converts a GDTCOREventQoS to a GDTCCTQoS tier.
  110|       | *
  111|       | * @param qosTier The GDTCOREventQoS value.
  112|       | * @return A static NSNumber that represents the CCT QoS tier.
  113|       | */
  114|       |FOUNDATION_STATIC_INLINE
  115|      1|NSNumber *GDTCCTQosTierFromGDTCOREventQosTier(GDTCOREventQoS qosTier) {
  116|      1|  switch (qosTier) {
  117|      1|    case GDTCOREventQoSWifiOnly:
  118|      0|      return @(GDTCCTQoSWifiOnly);
  119|      1|      break;
  120|      1|
  121|      1|    case GDTCOREventQoSTelemetry:
  122|      1|      // falls through.
  123|      1|    case GDTCOREventQoSDaily:
  124|      1|      return @(GDTCCTQoSDaily);
  125|      1|      break;
  126|      1|
  127|      1|    default:
  128|      0|      return @(GDTCCTQoSDefault);
  129|      1|      break;
  130|      1|  }
  131|      1|}
  132|       |
  133|       |/** Constructs a set of events for upload to CCT, FLL, or CSH backends. These backends are
  134|       | * request-proto and batching compatible, so they construct event batches the same way.
  135|       | *
  136|       | * @param conditions The set of conditions the upload package should be made under.
  137|       | * @param target The target backend.
  138|       | * @return A set of events for the target.
  139|       | */
  140|       |- (NSSet<GDTCORStoredEvent *> *)eventsForTarget:(GDTCORTarget)target
  141|      6|                                     conditions:(GDTCORUploadConditions)conditions {
  142|      6|  GDTCORClock __strong **timeOfLastDailyUpload = NULL;
  143|      6|  NSSet<GDTCORStoredEvent *> *eventsToFilter;
  144|      6|  switch (target) {
  145|      6|    case kGDTCORTargetCCT:
  146|      2|      eventsToFilter = self.CCTEvents;
  147|      2|      timeOfLastDailyUpload = &self->_CCTTimeOfLastDailyUpload;
  148|      2|      break;
  149|      6|
  150|      6|    case kGDTCORTargetFLL:
  151|      2|      eventsToFilter = self.FLLEvents;
  152|      2|      timeOfLastDailyUpload = &self->_FLLOfLastDailyUpload;
  153|      2|      break;
  154|      6|
  155|      6|    case kGDTCORTargetCSH:
  156|      2|      // This backend doesn't batch and uploads all events as soon as possible without respect to
  157|      2|      // any upload condition.
  158|      2|      return self.CSHEvents;
  159|      6|      break;
  160|      6|
  161|      6|    default:
  162|      0|      // Return an empty set.
  163|      0|      return [[NSSet alloc] init];
  164|      6|      break;
  165|      4|  }
  166|      4|
  167|      4|  NSMutableSet<GDTCORStoredEvent *> *eventsThatWillBeSent = [[NSMutableSet alloc] init];
  168|      4|  // A high priority event effectively flushes all events to be sent.
  169|      4|  if ((conditions & GDTCORUploadConditionHighPriority) == GDTCORUploadConditionHighPriority) {
  170|      0|    GDTCORLogDebug("%@", @"CCT: A high priority event is flushing all events.");
  171|      0|    return eventsToFilter;
  172|      0|  }
  173|      4|
  174|      4|  // If on wifi, upload logs that are ok to send on wifi.
  175|      4|  if ((conditions & GDTCORUploadConditionWifiData) == GDTCORUploadConditionWifiData) {
  176|      4|    [eventsThatWillBeSent unionSet:[self logEventsOkToSendOnWifi:eventsToFilter]];
  177|      4|    GDTCORLogDebug("%@", @"CCT: events ok to send on wifi are being added to the upload package");
  178|      4|  } else {
  179|      0|    [eventsThatWillBeSent unionSet:[self logEventsOkToSendOnMobileData:eventsToFilter]];
  180|      0|    GDTCORLogDebug("%@", @"CCT: events ok to send on mobile are being added to the upload package");
  181|      0|  }
  182|      4|
  183|      4|  // If it's been > 24h since the last daily upload, upload logs with the daily QoS.
  184|      4|  if (*timeOfLastDailyUpload) {
  185|      2|    int64_t millisSinceLastUpload =
  186|      2|        [GDTCORClock snapshot].timeMillis - (*timeOfLastDailyUpload).timeMillis;
  187|      2|    if (millisSinceLastUpload > kMillisPerDay) {
  188|      0|      [eventsThatWillBeSent unionSet:[self logEventsOkToSendDaily:eventsToFilter]];
  189|      0|      GDTCORLogDebug("%@", @"CCT: events ok to send daily are being added to the upload package");
  190|      0|    }
  191|      2|  } else {
  192|      2|    *timeOfLastDailyUpload = [GDTCORClock snapshot];
  193|      2|    [eventsThatWillBeSent unionSet:[self logEventsOkToSendDaily:eventsToFilter]];
  194|      2|    GDTCORLogDebug("%@", @"CCT: events ok to send daily are being added to the upload package");
  195|      2|  }
  196|      4|  return eventsThatWillBeSent;
  197|      4|}
  198|       |
  199|       |/** Returns a set of logs that are ok to upload whilst on mobile data.
  200|       | *
  201|       | * @note This should be called from a thread safe method.
  202|       | * @return A set of logs that are ok to upload whilst on mobile data.
  203|       | */
  204|      0|- (NSSet<GDTCORStoredEvent *> *)logEventsOkToSendOnMobileData:(NSSet<GDTCORStoredEvent *> *)events {
  205|      0|  return [events objectsPassingTest:^BOOL(GDTCORStoredEvent *_Nonnull event, BOOL *_Nonnull stop) {
  206|      0|    return [GDTCCTQosTierFromGDTCOREventQosTier(event.qosTier) isEqual:@(GDTCCTQoSDefault)];
  207|      0|  }];
  208|      0|}
  209|       |
  210|       |/** Returns a set of logs that are ok to upload whilst on wifi.
  211|       | *
  212|       | * @note This should be called from a thread safe method.
  213|       | * @return A set of logs that are ok to upload whilst on wifi.
  214|       | */
  215|      4|- (NSSet<GDTCORStoredEvent *> *)logEventsOkToSendOnWifi:(NSSet<GDTCORStoredEvent *> *)events {
  216|      4|  return [events objectsPassingTest:^BOOL(GDTCORStoredEvent *_Nonnull event, BOOL *_Nonnull stop) {
  217|      1|    NSNumber *qosTier = GDTCCTQosTierFromGDTCOREventQosTier(event.qosTier);
  218|      1|    return [qosTier isEqual:@(GDTCCTQoSDefault)] || [qosTier isEqual:@(GDTCCTQoSWifiOnly)] ||
  219|      1|           [qosTier isEqual:@(GDTCCTQoSDaily)];
  220|      1|  }];
  221|      4|}
  222|       |
  223|       |/** Returns a set of logs that only should have a single upload attempt per day.
  224|       | *
  225|       | * @note This should be called from a thread safe method.
  226|       | * @return A set of logs that are ok to upload only once per day.
  227|       | */
  228|      2|- (NSSet<GDTCORStoredEvent *> *)logEventsOkToSendDaily:(NSSet<GDTCORStoredEvent *> *)events {
  229|      2|  return [events objectsPassingTest:^BOOL(GDTCORStoredEvent *_Nonnull event, BOOL *_Nonnull stop) {
  230|      0|    return [GDTCCTQosTierFromGDTCOREventQosTier(event.qosTier) isEqual:@(GDTCCTQoSDaily)];
  231|      0|  }];
  232|      2|}
  233|       |
  234|       |#pragma mark - GDTCORUploadPackageProtocol
  235|       |
  236|      5|- (void)packageDelivered:(GDTCORUploadPackage *)package successful:(BOOL)successful {
  237|      5|  dispatch_async(_queue, ^{
  238|      5|    NSSet<GDTCORStoredEvent *> *events = [package.events copy];
  239|      5|    for (GDTCORStoredEvent *event in events) {
  240|      0|      // We don't know what collection the event was contained in, so attempt removal from all.
  241|      0|      [self.CCTEvents removeObject:event];
  242|      0|      [self.FLLEvents removeObject:event];
  243|      0|      [self.CSHEvents removeObject:event];
  244|      0|    }
  245|      5|  });
  246|      5|}
  247|       |
  248|      0|- (void)packageExpired:(GDTCORUploadPackage *)package {
  249|      0|  [self packageDelivered:package successful:YES];
  250|      0|}
  251|       |
  252|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTUploader.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTUploader.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   21|       |#import <GoogleDataTransport/GDTCORRegistrar.h>
   22|       |
   23|       |#import <nanopb/pb.h>
   24|       |#import <nanopb/pb_decode.h>
   25|       |#import <nanopb/pb_encode.h>
   26|       |
   27|       |#import "GDTCCTLibrary/Private/GDTCCTCompressionHelper.h"
   28|       |#import "GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   29|       |#import "GDTCCTLibrary/Private/GDTCCTPrioritizer.h"
   30|       |
   31|       |#import "GDTCCTLibrary/Protogen/nanopb/cct.nanopb.h"
   32|       |
   33|       |#ifdef GDTCCTSUPPORT_VERSION
   34|       |#define STR(x) STR_EXPAND(x)
   35|       |#define STR_EXPAND(x) #x
   36|       |static NSString *const kGDTCCTSupportSDKVersion = @STR(GDTCCTSUPPORT_VERSION);
   37|       |#else
   38|       |static NSString *const kGDTCCTSupportSDKVersion = @"UNKNOWN";
   39|       |#endif  // GDTCCTSUPPORT_VERSION
   40|       |
   41|       |#if !NDEBUG
   42|       |NSNotificationName const GDTCCTUploadCompleteNotification = @"com.GDTCCTUploader.UploadComplete";
   43|       |#endif  // #if !NDEBUG
   44|       |
   45|       |@interface GDTCCTUploader () <NSURLSessionDelegate>
   46|       |
   47|       |// Redeclared as readwrite.
   48|       |@property(nullable, nonatomic, readwrite) NSURLSessionUploadTask *currentTask;
   49|       |
   50|       |@end
   51|       |
   52|       |@implementation GDTCCTUploader
   53|       |
   54|      1|+ (void)load {
   55|      1|  GDTCCTUploader *uploader = [GDTCCTUploader sharedInstance];
   56|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetCCT];
   57|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetFLL];
   58|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetCSH];
   59|      1|}
   60|       |
   61|      1|+ (instancetype)sharedInstance {
   62|      1|  static GDTCCTUploader *sharedInstance;
   63|      1|  static dispatch_once_t onceToken;
   64|      1|  dispatch_once(&onceToken, ^{
   65|      1|    sharedInstance = [[GDTCCTUploader alloc] init];
   66|      1|  });
   67|      1|  return sharedInstance;
   68|      1|}
   69|       |
   70|      1|- (instancetype)init {
   71|      1|  self = [super init];
   72|      1|  if (self) {
   73|      1|    _uploaderQueue = dispatch_queue_create("com.google.GDTCCTUploader", DISPATCH_QUEUE_SERIAL);
   74|      1|    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
   75|      1|    _uploaderSession = [NSURLSession sessionWithConfiguration:config
   76|      1|                                                     delegate:self
   77|      1|                                                delegateQueue:nil];
   78|      1|  }
   79|      1|  return self;
   80|      1|}
   81|       |
   82|       |/**
   83|       | *
   84|       | */
   85|      1|- (nullable NSURL *)serverURLForTarget:(GDTCORTarget)target {
   86|      1|  // These strings should be interleaved to construct the real URL. This is just to (hopefully)
   87|      1|  // fool github URL scanning bots.
   88|      1|  static NSURL *CCTServerURL;
   89|      1|  static dispatch_once_t CCTOnceToken;
   90|      1|  dispatch_once(&CCTOnceToken, ^{
   91|      1|    const char *p1 = "hts/frbslgiggolai.o/0clgbth";
   92|      1|    const char *p2 = "tp:/ieaeogn.ogepscmvc/o/ac";
   93|      1|    const char URL[54] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
   94|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
   95|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
   96|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
   97|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
   98|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], '\0'};
   99|      1|    CCTServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
  100|      1|  });
  101|      1|
  102|      1|  static NSURL *FLLServerURL;
  103|      1|  static dispatch_once_t FLLOnceToken;
  104|      1|  dispatch_once(&FLLOnceToken, ^{
  105|      1|    const char *p1 = "hts/frbslgigp.ogepscmv/ieo/eaybtho";
  106|      1|    const char *p2 = "tp:/ieaeogn-agolai.o/1frlglgc/aclg";
  107|      1|    const char URL[69] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
  108|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
  109|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
  110|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
  111|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
  112|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], p2[26],
  113|      1|                          p1[27], p2[27], p1[28], p2[28], p1[29], p2[29], p1[30], p2[30], p1[31],
  114|      1|                          p2[31], p1[32], p2[32], p1[33], p2[33], '\0'};
  115|      1|    FLLServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
  116|      1|  });
  117|      1|
  118|      1|  static NSURL *CSHServerURL;
  119|      1|  static dispatch_once_t CSHOnceToken;
  120|      1|  dispatch_once(&CSHOnceToken, ^{
  121|      1|    // These strings should be interleaved to construct the real URL. This is just to (hopefully)
  122|      1|    // fool github URL scanning bots.
  123|      1|    const char *p1 = "hts/cahyiseot-agolai.o/1frlglgc/aclg";
  124|      1|    const char *p2 = "tp:/rsltcrprsp.ogepscmv/ieo/eaybtho";
  125|      1|    const char URL[72] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
  126|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
  127|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
  128|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
  129|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
  130|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], p2[26],
  131|      1|                          p1[27], p2[27], p1[28], p2[28], p1[29], p2[29], p1[30], p2[30], p1[31],
  132|      1|                          p2[31], p1[32], p2[32], p1[33], p2[33], p1[34], p2[34], p1[35], '\0'};
  133|      1|    CSHServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
  134|      1|  });
  135|      1|
  136|      1|#if !NDEBUG
  137|      1|  if (_testServerURL) {
  138|      0|    return _testServerURL;
  139|      0|  }
  140|      1|#endif  // !NDEBUG
  141|      1|
  142|      1|  switch (target) {
  143|      1|    case kGDTCORTargetCCT:
  144|      0|      return CCTServerURL;
  145|      1|
  146|      1|    case kGDTCORTargetFLL:
  147|      1|      return FLLServerURL;
  148|      1|
  149|      1|    case kGDTCORTargetCSH:
  150|      0|      return CSHServerURL;
  151|      1|
  152|      1|    default:
  153|      0|      GDTCORLogDebug("GDTCCTUploader doesn't support target %ld", (long)target);
  154|      0|      return nil;
  155|      1|      break;
  156|      1|  }
  157|      1|}
  158|       |
  159|      1|- (NSString *)FLLAndCSHAPIKey {
  160|      1|  static NSString *defaultServerKey;
  161|      1|  static dispatch_once_t onceToken;
  162|      1|  dispatch_once(&onceToken, ^{
  163|      1|    // These strings should be interleaved to construct the real key.
  164|      1|    const char *p1 = "AzSBG0honD6A-PxV5nBc";
  165|      1|    const char *p2 = "Iay44Iwtu2vV0AOrz1C";
  166|      1|    const char defaultKey[40] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],
  167|      1|                                 p1[4],  p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],
  168|      1|                                 p1[8],  p2[8],  p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11],
  169|      1|                                 p1[12], p2[12], p1[13], p2[13], p1[14], p2[14], p1[15], p2[15],
  170|      1|                                 p1[16], p2[16], p1[17], p2[17], p1[18], p2[18], p1[19], '\0'};
  171|      1|    defaultServerKey = [NSString stringWithUTF8String:defaultKey];
  172|      1|  });
  173|      1|  return defaultServerKey;
  174|      1|}
  175|       |
  176|      1|- (void)uploadPackage:(GDTCORUploadPackage *)package {
  177|      1|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
  178|      1|  bgID = [[GDTCORApplication sharedApplication]
  179|      1|      beginBackgroundTaskWithName:@"GDTCCTUploader-upload"
  180|      1|                expirationHandler:^{
  181|      0|                  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  182|      0|                    // Cancel the upload and complete delivery.
  183|      0|                    [self.currentTask cancel];
  184|      0|                    [self.currentUploadPackage completeDelivery];
  185|      0|
  186|      0|                    // End the background task.
  187|      0|                    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  188|      0|                  }
  189|      0|                }];
  190|      1|
  191|      1|  dispatch_async(_uploaderQueue, ^{
  192|      1|    if (self->_currentTask || self->_currentUploadPackage) {
  193|      0|      GDTCORLogWarning(GDTCORMCWUploadFailed, @"%@",
  194|      0|                       @"An upload shouldn't be initiated with another in progress.");
  195|      0|      return;
  196|      0|    }
  197|      1|    GDTCORTarget target = package.target;
  198|      1|    id completionHandler = ^(NSData *_Nullable data, NSURLResponse *_Nullable response,
  199|      1|                             NSError *_Nullable error) {
  200|      0|      GDTCORLogDebug("%@", @"CCT: request completed");
  201|      0|      if (error) {
  202|      0|        GDTCORLogWarning(GDTCORMCWUploadFailed, @"There was an error uploading events: %@", error);
  203|      0|      }
  204|      0|      NSError *decodingError;
  205|      0|      if (data) {
  206|      0|        gdt_cct_LogResponse logResponse = GDTCCTDecodeLogResponse(data, &decodingError);
  207|      0|        if (!decodingError && logResponse.has_next_request_wait_millis) {
  208|      0|          GDTCORLogDebug(
  209|      0|              "CCT: The backend responded asking to not upload for %lld millis from now.",
  210|      0|              logResponse.next_request_wait_millis);
  211|      0|          GDTCORClock *futureUploadTime =
  212|      0|              [GDTCORClock clockSnapshotInTheFuture:logResponse.next_request_wait_millis];
  213|      0|          switch (target) {
  214|      0|            case kGDTCORTargetCCT:
  215|      0|              self->_CCTNextUploadTime = futureUploadTime;
  216|      0|              break;
  217|      0|
  218|      0|            case kGDTCORTargetFLL:
  219|      0|              // Falls through.
  220|      0|            case kGDTCORTargetCSH:
  221|      0|              self->_FLLNextUploadTime = futureUploadTime;
  222|      0|            default:
  223|      0|              break;
  224|      0|          }
  225|      0|        } else {
  226|      0|          GDTCORLogDebug("%@", @"CCT: The backend response failed to parse, so the next request "
  227|      0|                               @"won't occur until 15 minutes from now");
  228|      0|          // 15 minutes from now.
  229|      0|          GDTCORClock *futureUploadTime = [GDTCORClock clockSnapshotInTheFuture:15 * 60 * 1000];
  230|      0|          switch (target) {
  231|      0|            case kGDTCORTargetCCT:
  232|      0|              self->_CCTNextUploadTime = futureUploadTime;
  233|      0|              break;
  234|      0|
  235|      0|            case kGDTCORTargetFLL:
  236|      0|              // Falls through.
  237|      0|            case kGDTCORTargetCSH:
  238|      0|              self->_FLLNextUploadTime = futureUploadTime;
  239|      0|              break;
  240|      0|
  241|      0|            default:
  242|      0|              break;
  243|      0|          }
  244|      0|        }
  245|      0|        pb_release(gdt_cct_LogResponse_fields, &logResponse);
  246|      0|      }
  247|      0|
  248|      0|      // Only retry if one of these codes is returned.
  249|      0|      if (((NSHTTPURLResponse *)response).statusCode == 429 ||
  250|      0|          ((NSHTTPURLResponse *)response).statusCode == 503) {
  251|      0|        [package retryDeliveryInTheFuture];
  252|      0|      } else {
  253|      0|#if !NDEBUG
  254|      0|        // Post a notification when in DEBUG mode to state how many packages were uploaded. Useful
  255|      0|        // for validation during tests.
  256|      0|        [[NSNotificationCenter defaultCenter] postNotificationName:GDTCCTUploadCompleteNotification
  257|      0|                                                            object:@(package.events.count)];
  258|      0|#endif  // #if !NDEBUG
  259|      0|        GDTCORLogDebug("%@", @"CCT: package delivered");
  260|      0|        [package completeDelivery];
  261|      0|      }
  262|      0|
  263|      0|      // End the background task if there was one.
  264|      0|      if (bgID != GDTCORBackgroundIdentifierInvalid) {
  265|      0|        [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  266|      0|        bgID = GDTCORBackgroundIdentifierInvalid;
  267|      0|      }
  268|      0|      self.currentTask = nil;
  269|      0|      self.currentUploadPackage = nil;
  270|      0|    };
  271|      1|    self->_currentUploadPackage = package;
  272|      1|    NSData *requestProtoData =
  273|      1|        [self constructRequestProtoFromPackage:(GDTCORUploadPackage *)package];
  274|      1|    NSData *gzippedData = [GDTCCTCompressionHelper gzippedData:requestProtoData];
  275|      1|    BOOL usingGzipData = gzippedData != nil && gzippedData.length < requestProtoData.length;
  276|      1|    NSData *dataToSend = usingGzipData ? gzippedData : requestProtoData;
  277|      1|    NSURLRequest *request = [self constructRequestForTarget:target data:dataToSend];
  278|      1|    GDTCORLogDebug("CTT: request created: %@", request);
  279|      1|    self.currentTask = [self.uploaderSession uploadTaskWithRequest:request
  280|      1|                                                          fromData:dataToSend
  281|      1|                                                 completionHandler:completionHandler];
  282|      1|    GDTCORLogDebug("%@", @"CCT: The upload task is about to begin.");
  283|      1|    [self.currentTask resume];
  284|      1|  });
  285|      1|}
  286|       |
  287|      9|- (BOOL)readyToUploadTarget:(GDTCORTarget)target conditions:(GDTCORUploadConditions)conditions {
  288|      9|  __block BOOL result = NO;
  289|      9|  dispatch_sync(_uploaderQueue, ^{
  290|      9|    if (target == kGDTCORTargetCSH && [GDTCCTPrioritizer sharedInstance].CSHEvents.count > 0) {
  291|      0|      result = YES;
  292|      0|      return;
  293|      0|    }
  294|      9|    if (self->_currentUploadPackage) {
  295|      3|      result = NO;
  296|      3|      GDTCORLogDebug("%@", @"CCT: can't upload because a package is in flight");
  297|      3|      return;
  298|      3|    }
  299|      6|    if (self->_currentTask) {
  300|      0|      result = NO;
  301|      0|      GDTCORLogDebug("%@", @"CCT: can't upload because a task is in progress");
  302|      0|      return;
  303|      0|    }
  304|      6|    if ((conditions & GDTCORUploadConditionHighPriority) == GDTCORUploadConditionHighPriority) {
  305|      0|      result = YES;
  306|      0|      GDTCORLogDebug("%@", @"CCT: a high priority event is allowing an upload");
  307|      0|      return;
  308|      0|    }
  309|      6|    switch (target) {
  310|      6|      case kGDTCORTargetCCT:
  311|      2|        if (self->_CCTNextUploadTime) {
  312|      0|          result = [[GDTCORClock snapshot] isAfter:self->_CCTNextUploadTime];
  313|      0|        }
  314|      2|        break;
  315|      6|
  316|      6|      case kGDTCORTargetFLL:
  317|      2|        if (self->_FLLNextUploadTime) {
  318|      0|          result = [[GDTCORClock snapshot] isAfter:self->_FLLNextUploadTime];
  319|      0|        }
  320|      2|        break;
  321|      6|
  322|      6|      default:
  323|      2|        // The CSH backend should be handled above.
  324|      2|        break;
  325|      6|    }
  326|      6|    if (result) {
  327|      0|      GDTCORLogDebug("CCT: can upload to target %ld because the request wait time has transpired",
  328|      0|                     (long)target);
  329|      6|    } else {
  330|      6|      GDTCORLogDebug("CCT: can't upload to target %ld because the backend asked to wait",
  331|      6|                     (long)target);
  332|      6|    }
  333|      6|    result = YES;
  334|      6|    GDTCORLogDebug("CCT: can upload to target %ld because nothing is preventing it", (long)target);
  335|      6|  });
  336|      9|  return result;
  337|      9|}
  338|       |
  339|       |#pragma mark - Private helper methods
  340|       |
  341|       |/** Constructs data given an upload package.
  342|       | *
  343|       | * @param package The upload package used to construct the request proto bytes.
  344|       | * @return Proto bytes representing a gdt_cct_LogRequest object.
  345|       | */
  346|      1|- (nonnull NSData *)constructRequestProtoFromPackage:(GDTCORUploadPackage *)package {
  347|      1|  // Segment the log events by log type.
  348|      1|  NSMutableDictionary<NSString *, NSMutableSet<GDTCORStoredEvent *> *> *logMappingIDToLogSet =
  349|      1|      [[NSMutableDictionary alloc] init];
  350|      1|  [package.events
  351|      1|      enumerateObjectsUsingBlock:^(GDTCORStoredEvent *_Nonnull event, BOOL *_Nonnull stop) {
  352|      1|        NSMutableSet *logSet = logMappingIDToLogSet[event.mappingID];
  353|      1|        logSet = logSet ? logSet : [[NSMutableSet alloc] init];
  354|      1|        [logSet addObject:event];
  355|      1|        logMappingIDToLogSet[event.mappingID] = logSet;
  356|      1|      }];
  357|      1|
  358|      1|  gdt_cct_BatchedLogRequest batchedLogRequest =
  359|      1|      GDTCCTConstructBatchedLogRequest(logMappingIDToLogSet);
  360|      1|
  361|      1|  NSData *data = GDTCCTEncodeBatchedLogRequest(&batchedLogRequest);
  362|      1|  pb_release(gdt_cct_BatchedLogRequest_fields, &batchedLogRequest);
  363|      1|  return data ? data : [[NSData alloc] init];
  364|      1|}
  365|       |
  366|       |/** Constructs a request to FLL given a URL and request body data.
  367|       | *
  368|       | * @param target The target backend to send the request to.
  369|       | * @param data The request body data.
  370|       | * @return A new NSURLRequest ready to be sent to FLL.
  371|       | */
  372|      1|- (NSURLRequest *)constructRequestForTarget:(GDTCORTarget)target data:(NSData *)data {
  373|      1|  NSURL *URL = [self serverURLForTarget:target];
  374|      1|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
  375|      1|  NSString *targetString;
  376|      1|  switch (target) {
  377|      1|    case kGDTCORTargetCCT:
  378|      0|      targetString = @"cct";
  379|      0|      break;
  380|      1|
  381|      1|    case kGDTCORTargetFLL:
  382|      1|      targetString = @"fll";
  383|      1|      break;
  384|      1|
  385|      1|    case kGDTCORTargetCSH:
  386|      0|      targetString = @"csh";
  387|      0|      break;
  388|      1|
  389|      1|    default:
  390|      0|      targetString = @"unknown";
  391|      0|      break;
  392|      1|  }
  393|      1|  NSString *userAgent =
  394|      1|      [NSString stringWithFormat:@"datatransport/%@ %@support/%@ apple/", kGDTCORVersion,
  395|      1|                                 targetString, kGDTCCTSupportSDKVersion];
  396|      1|  if (target == kGDTCORTargetFLL || target == kGDTCORTargetCSH) {
  397|      1|    [request setValue:[self FLLAndCSHAPIKey] forHTTPHeaderField:@"X-Goog-Api-Key"];
  398|      1|  }
  399|      1|  if ([GDTCCTCompressionHelper isGzipped:data]) {
  400|      1|    [request setValue:@"gzip" forHTTPHeaderField:@"Content-Encoding"];
  401|      1|  }
  402|      1|  [request setValue:@"application/x-protobuf" forHTTPHeaderField:@"Content-Type"];
  403|      1|  [request setValue:@"gzip" forHTTPHeaderField:@"Accept-Encoding"];
  404|      1|  [request setValue:userAgent forHTTPHeaderField:@"User-Agent"];
  405|      1|  request.HTTPMethod = @"POST";
  406|      1|  [request setHTTPBody:data];
  407|      1|  return request;
  408|      1|}
  409|       |
  410|       |#pragma mark - GDTCORUploadPackageProtocol
  411|       |
  412|      0|- (void)packageExpired:(GDTCORUploadPackage *)package {
  413|      0|  dispatch_async(_uploaderQueue, ^{
  414|      0|    [self.currentTask cancel];
  415|      0|    self.currentTask = nil;
  416|      0|    self.currentUploadPackage = nil;
  417|      0|  });
  418|      0|}
  419|       |
  420|       |#pragma mark - GDTCORLifecycleProtocol
  421|       |
  422|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  423|      0|  dispatch_sync(_uploaderQueue, ^{
  424|      0|    [self.currentTask cancel];
  425|      0|    [self.currentUploadPackage completeDelivery];
  426|      0|  });
  427|      0|}
  428|       |
  429|       |#pragma mark - NSURLSessionDelegate
  430|       |
  431|       |- (void)URLSession:(NSURLSession *)session
  432|       |                          task:(NSURLSessionTask *)task
  433|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  434|       |                    newRequest:(NSURLRequest *)request
  435|      0|             completionHandler:(void (^)(NSURLRequest *_Nullable))completionHandler {
  436|      0|  if (!completionHandler) {
  437|      0|    return;
  438|      0|  }
  439|      0|  if (response.statusCode == 302 || response.statusCode == 301) {
  440|      0|    if ([request.URL isEqual:[self serverURLForTarget:kGDTCORTargetFLL]]) {
  441|      0|      NSURLRequest *newRequest = [self constructRequestForTarget:kGDTCORTargetCCT
  442|      0|                                                            data:task.originalRequest.HTTPBody];
  443|      0|      completionHandler(newRequest);
  444|      0|    }
  445|      0|  } else {
  446|      0|    completionHandler(request);
  447|      0|  }
  448|      0|}
  449|       |
  450|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/Protogen/nanopb/cct.nanopb.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |/* Automatically generated nanopb header */
   18|       |/* Generated by nanopb-0.3.9.3 */
   19|       |
   20|       |#ifndef PB_GDT_CCT_CCT_NANOPB_H_INCLUDED
   21|       |#define PB_GDT_CCT_CCT_NANOPB_H_INCLUDED
   22|       |#include <nanopb/pb.h>
   23|       |
   24|       |/* @@protoc_insertion_point(includes) */
   25|       |#if PB_PROTO_HEADER_VERSION != 30
   26|       |#error Regenerate this file with the current version of nanopb generator.
   27|       |#endif
   28|       |
   29|       |
   30|       |/* Enum definitions */
   31|       |typedef enum _gdt_cct_NetworkConnectionInfo_NetworkType {
   32|       |    gdt_cct_NetworkConnectionInfo_NetworkType_NONE = -1,
   33|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE = 0,
   34|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIFI = 1,
   35|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_MMS = 2,
   36|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_SUPL = 3,
   37|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_DUN = 4,
   38|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_HIPRI = 5,
   39|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIMAX = 6,
   40|       |    gdt_cct_NetworkConnectionInfo_NetworkType_BLUETOOTH = 7,
   41|       |    gdt_cct_NetworkConnectionInfo_NetworkType_DUMMY = 8,
   42|       |    gdt_cct_NetworkConnectionInfo_NetworkType_ETHERNET = 9,
   43|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_FOTA = 10,
   44|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_IMS = 11,
   45|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_CBS = 12,
   46|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIFI_P2P = 13,
   47|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_IA = 14,
   48|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_EMERGENCY = 15,
   49|       |    gdt_cct_NetworkConnectionInfo_NetworkType_PROXY = 16,
   50|       |    gdt_cct_NetworkConnectionInfo_NetworkType_VPN = 17
   51|       |} gdt_cct_NetworkConnectionInfo_NetworkType;
   52|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_MIN gdt_cct_NetworkConnectionInfo_NetworkType_NONE
   53|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_MAX gdt_cct_NetworkConnectionInfo_NetworkType_VPN
   54|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_ARRAYSIZE ((gdt_cct_NetworkConnectionInfo_NetworkType)(gdt_cct_NetworkConnectionInfo_NetworkType_VPN+1))
   55|       |
   56|       |typedef enum _gdt_cct_NetworkConnectionInfo_MobileSubtype {
   57|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE = 0,
   58|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_GPRS = 1,
   59|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EDGE = 2,
   60|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_UMTS = 3,
   61|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_CDMA = 4,
   62|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_0 = 5,
   63|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_A = 6,
   64|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_RTT = 7,
   65|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSDPA = 8,
   66|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSUPA = 9,
   67|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSPA = 10,
   68|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_IDEN = 11,
   69|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_B = 12,
   70|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE = 13,
   71|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EHRPD = 14,
   72|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSPAP = 15,
   73|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_GSM = 16,
   74|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_TD_SCDMA = 17,
   75|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_IWLAN = 18,
   76|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE_CA = 19,
   77|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED = 100
   78|       |} gdt_cct_NetworkConnectionInfo_MobileSubtype;
   79|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_MIN gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE
   80|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_MAX gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED
   81|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_ARRAYSIZE ((gdt_cct_NetworkConnectionInfo_MobileSubtype)(gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED+1))
   82|       |
   83|       |typedef enum _gdt_cct_ClientInfo_ClientType {
   84|       |    gdt_cct_ClientInfo_ClientType_CLIENT_UNKNOWN = 0,
   85|       |    gdt_cct_ClientInfo_ClientType_IOS_FIREBASE = 15
   86|       |} gdt_cct_ClientInfo_ClientType;
   87|      2|#define _gdt_cct_ClientInfo_ClientType_MIN gdt_cct_ClientInfo_ClientType_CLIENT_UNKNOWN
   88|       |#define _gdt_cct_ClientInfo_ClientType_MAX gdt_cct_ClientInfo_ClientType_IOS_FIREBASE
   89|       |#define _gdt_cct_ClientInfo_ClientType_ARRAYSIZE ((gdt_cct_ClientInfo_ClientType)(gdt_cct_ClientInfo_ClientType_IOS_FIREBASE+1))
   90|       |
   91|       |typedef enum _gdt_cct_QosTierConfiguration_QosTier {
   92|       |    gdt_cct_QosTierConfiguration_QosTier_DEFAULT = 0,
   93|       |    gdt_cct_QosTierConfiguration_QosTier_UNMETERED_ONLY = 1,
   94|       |    gdt_cct_QosTierConfiguration_QosTier_UNMETERED_OR_DAILY = 2,
   95|       |    gdt_cct_QosTierConfiguration_QosTier_FAST_IF_RADIO_AWAKE = 3,
   96|       |    gdt_cct_QosTierConfiguration_QosTier_NEVER = 4
   97|       |} gdt_cct_QosTierConfiguration_QosTier;
   98|       |#define _gdt_cct_QosTierConfiguration_QosTier_MIN gdt_cct_QosTierConfiguration_QosTier_DEFAULT
   99|       |#define _gdt_cct_QosTierConfiguration_QosTier_MAX gdt_cct_QosTierConfiguration_QosTier_NEVER
  100|       |#define _gdt_cct_QosTierConfiguration_QosTier_ARRAYSIZE ((gdt_cct_QosTierConfiguration_QosTier)(gdt_cct_QosTierConfiguration_QosTier_NEVER+1))
  101|       |
  102|       |/* Struct definitions */
  103|       |typedef struct _gdt_cct_BatchedLogRequest {
  104|       |    pb_size_t log_request_count;
  105|       |    struct _gdt_cct_LogRequest *log_request;
  106|       |/* @@protoc_insertion_point(struct:gdt_cct_BatchedLogRequest) */
  107|       |} gdt_cct_BatchedLogRequest;
  108|       |
  109|       |typedef struct _gdt_cct_IosClientInfo {
  110|       |    pb_bytes_array_t *os_major_version;
  111|       |    pb_bytes_array_t *os_full_version;
  112|       |    pb_bytes_array_t *application_build;
  113|       |    pb_bytes_array_t *country;
  114|       |    pb_bytes_array_t *model;
  115|       |    pb_bytes_array_t *language_code;
  116|       |    pb_bytes_array_t *application_bundle_id;
  117|       |/* @@protoc_insertion_point(struct:gdt_cct_IosClientInfo) */
  118|       |} gdt_cct_IosClientInfo;
  119|       |
  120|       |typedef struct _gdt_cct_ClientInfo {
  121|       |    bool has_client_type;
  122|       |    gdt_cct_ClientInfo_ClientType client_type;
  123|       |    bool has_ios_client_info;
  124|       |    gdt_cct_IosClientInfo ios_client_info;
  125|       |/* @@protoc_insertion_point(struct:gdt_cct_ClientInfo) */
  126|       |} gdt_cct_ClientInfo;
  127|       |
  128|       |typedef struct _gdt_cct_NetworkConnectionInfo {
  129|       |    bool has_network_type;
  130|       |    gdt_cct_NetworkConnectionInfo_NetworkType network_type;
  131|       |    bool has_mobile_subtype;
  132|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype mobile_subtype;
  133|       |/* @@protoc_insertion_point(struct:gdt_cct_NetworkConnectionInfo) */
  134|       |} gdt_cct_NetworkConnectionInfo;
  135|       |
  136|       |typedef struct _gdt_cct_QosTierConfiguration {
  137|       |    bool has_qos_tier;
  138|       |    gdt_cct_QosTierConfiguration_QosTier qos_tier;
  139|       |    bool has_log_source;
  140|       |    int32_t log_source;
  141|       |/* @@protoc_insertion_point(struct:gdt_cct_QosTierConfiguration) */
  142|       |} gdt_cct_QosTierConfiguration;
  143|       |
  144|       |typedef struct _gdt_cct_QosTiersOverride {
  145|       |    pb_size_t qos_tier_configuration_count;
  146|       |    struct _gdt_cct_QosTierConfiguration *qos_tier_configuration;
  147|       |    bool has_qos_tier_fingerprint;
  148|       |    int64_t qos_tier_fingerprint;
  149|       |/* @@protoc_insertion_point(struct:gdt_cct_QosTiersOverride) */
  150|       |} gdt_cct_QosTiersOverride;
  151|       |
  152|       |typedef struct _gdt_cct_LogEvent {
  153|       |    bool has_event_time_ms;
  154|       |    int64_t event_time_ms;
  155|       |    pb_bytes_array_t *source_extension;
  156|       |    bool has_event_code;
  157|       |    int32_t event_code;
  158|       |    bool has_timezone_offset_seconds;
  159|       |    int64_t timezone_offset_seconds;
  160|       |    bool has_event_uptime_ms;
  161|       |    int64_t event_uptime_ms;
  162|       |    bool has_network_connection_info;
  163|       |    gdt_cct_NetworkConnectionInfo network_connection_info;
  164|       |/* @@protoc_insertion_point(struct:gdt_cct_LogEvent) */
  165|       |} gdt_cct_LogEvent;
  166|       |
  167|       |typedef struct _gdt_cct_LogRequest {
  168|       |    bool has_client_info;
  169|       |    gdt_cct_ClientInfo client_info;
  170|       |    bool has_log_source;
  171|       |    int32_t log_source;
  172|       |    pb_size_t log_event_count;
  173|       |    struct _gdt_cct_LogEvent *log_event;
  174|       |    bool has_request_time_ms;
  175|       |    int64_t request_time_ms;
  176|       |    bool has_request_uptime_ms;
  177|       |    int64_t request_uptime_ms;
  178|       |    bool has_qos_tier;
  179|       |    gdt_cct_QosTierConfiguration_QosTier qos_tier;
  180|       |/* @@protoc_insertion_point(struct:gdt_cct_LogRequest) */
  181|       |} gdt_cct_LogRequest;
  182|       |
  183|       |typedef struct _gdt_cct_LogResponse {
  184|       |    bool has_next_request_wait_millis;
  185|       |    int64_t next_request_wait_millis;
  186|       |    bool has_qos_tier;
  187|       |    gdt_cct_QosTiersOverride qos_tier;
  188|       |/* @@protoc_insertion_point(struct:gdt_cct_LogResponse) */
  189|       |} gdt_cct_LogResponse;
  190|       |
  191|       |/* Default values for struct fields */
  192|       |extern const gdt_cct_NetworkConnectionInfo_NetworkType gdt_cct_NetworkConnectionInfo_network_type_default;
  193|       |extern const gdt_cct_NetworkConnectionInfo_MobileSubtype gdt_cct_NetworkConnectionInfo_mobile_subtype_default;
  194|       |extern const gdt_cct_QosTierConfiguration_QosTier gdt_cct_LogRequest_qos_tier_default;
  195|       |extern const int32_t gdt_cct_QosTierConfiguration_log_source_default;
  196|       |
  197|       |/* Initializer values for message structs */
  198|      1|#define gdt_cct_LogEvent_init_default            {false, 0, NULL, false, 0, false, 0, false, 0, false, gdt_cct_NetworkConnectionInfo_init_default}
  199|      1|#define gdt_cct_NetworkConnectionInfo_init_default {false, gdt_cct_NetworkConnectionInfo_NetworkType_NONE, false, gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE}
  200|      3|#define gdt_cct_IosClientInfo_init_default       {NULL, NULL, NULL, NULL, NULL, NULL, NULL}
  201|      2|#define gdt_cct_ClientInfo_init_default          {false, _gdt_cct_ClientInfo_ClientType_MIN, false, gdt_cct_IosClientInfo_init_default}
  202|      1|#define gdt_cct_BatchedLogRequest_init_default   {0, NULL}
  203|      1|#define gdt_cct_LogRequest_init_default          {false, gdt_cct_ClientInfo_init_default, false, 0, 0, NULL, false, 0, false, 0, false, gdt_cct_QosTierConfiguration_QosTier_DEFAULT}
  204|       |#define gdt_cct_QosTierConfiguration_init_default {false, _gdt_cct_QosTierConfiguration_QosTier_MIN, false, 0}
  205|      0|#define gdt_cct_QosTiersOverride_init_default    {0, NULL, false, 0}
  206|      0|#define gdt_cct_LogResponse_init_default         {false, 0, false, gdt_cct_QosTiersOverride_init_default}
  207|       |#define gdt_cct_LogEvent_init_zero               {false, 0, NULL, false, 0, false, 0, false, 0, false, gdt_cct_NetworkConnectionInfo_init_zero}
  208|       |#define gdt_cct_NetworkConnectionInfo_init_zero  {false, _gdt_cct_NetworkConnectionInfo_NetworkType_MIN, false, _gdt_cct_NetworkConnectionInfo_MobileSubtype_MIN}
  209|       |#define gdt_cct_IosClientInfo_init_zero          {NULL, NULL, NULL, NULL, NULL, NULL, NULL}
  210|       |#define gdt_cct_ClientInfo_init_zero             {false, _gdt_cct_ClientInfo_ClientType_MIN, false, gdt_cct_IosClientInfo_init_zero}
  211|       |#define gdt_cct_BatchedLogRequest_init_zero      {0, NULL}
  212|       |#define gdt_cct_LogRequest_init_zero             {false, gdt_cct_ClientInfo_init_zero, false, 0, 0, NULL, false, 0, false, 0, false, _gdt_cct_QosTierConfiguration_QosTier_MIN}
  213|       |#define gdt_cct_QosTierConfiguration_init_zero   {false, _gdt_cct_QosTierConfiguration_QosTier_MIN, false, 0}
  214|       |#define gdt_cct_QosTiersOverride_init_zero       {0, NULL, false, 0}
  215|       |#define gdt_cct_LogResponse_init_zero            {false, 0, false, gdt_cct_QosTiersOverride_init_zero}
  216|       |
  217|       |/* Field tags (for use in manual encoding/decoding) */
  218|       |#define gdt_cct_BatchedLogRequest_log_request_tag 1
  219|       |#define gdt_cct_IosClientInfo_os_major_version_tag 3
  220|       |#define gdt_cct_IosClientInfo_os_full_version_tag 4
  221|       |#define gdt_cct_IosClientInfo_application_build_tag 5
  222|       |#define gdt_cct_IosClientInfo_country_tag        6
  223|       |#define gdt_cct_IosClientInfo_model_tag          7
  224|       |#define gdt_cct_IosClientInfo_language_code_tag  8
  225|       |#define gdt_cct_IosClientInfo_application_bundle_id_tag 11
  226|       |#define gdt_cct_ClientInfo_client_type_tag       1
  227|       |#define gdt_cct_ClientInfo_ios_client_info_tag   4
  228|       |#define gdt_cct_NetworkConnectionInfo_network_type_tag 1
  229|       |#define gdt_cct_NetworkConnectionInfo_mobile_subtype_tag 2
  230|       |#define gdt_cct_QosTierConfiguration_qos_tier_tag 2
  231|       |#define gdt_cct_QosTierConfiguration_log_source_tag 3
  232|       |#define gdt_cct_QosTiersOverride_qos_tier_configuration_tag 1
  233|       |#define gdt_cct_QosTiersOverride_qos_tier_fingerprint_tag 2
  234|       |#define gdt_cct_LogEvent_event_time_ms_tag       1
  235|       |#define gdt_cct_LogEvent_event_code_tag          11
  236|       |#define gdt_cct_LogEvent_event_uptime_ms_tag     17
  237|       |#define gdt_cct_LogEvent_source_extension_tag    6
  238|       |#define gdt_cct_LogEvent_timezone_offset_seconds_tag 15
  239|       |#define gdt_cct_LogEvent_network_connection_info_tag 23
  240|       |#define gdt_cct_LogRequest_request_time_ms_tag   4
  241|       |#define gdt_cct_LogRequest_request_uptime_ms_tag 8
  242|       |#define gdt_cct_LogRequest_client_info_tag       1
  243|       |#define gdt_cct_LogRequest_log_source_tag        2
  244|       |#define gdt_cct_LogRequest_log_event_tag         3
  245|       |#define gdt_cct_LogRequest_qos_tier_tag          9
  246|       |#define gdt_cct_LogResponse_next_request_wait_millis_tag 1
  247|       |#define gdt_cct_LogResponse_qos_tier_tag         3
  248|       |
  249|       |/* Struct field encoding specification for nanopb */
  250|       |extern const pb_field_t gdt_cct_LogEvent_fields[7];
  251|       |extern const pb_field_t gdt_cct_NetworkConnectionInfo_fields[3];
  252|       |extern const pb_field_t gdt_cct_IosClientInfo_fields[8];
  253|       |extern const pb_field_t gdt_cct_ClientInfo_fields[3];
  254|       |extern const pb_field_t gdt_cct_BatchedLogRequest_fields[2];
  255|       |extern const pb_field_t gdt_cct_LogRequest_fields[7];
  256|       |extern const pb_field_t gdt_cct_QosTierConfiguration_fields[3];
  257|       |extern const pb_field_t gdt_cct_QosTiersOverride_fields[3];
  258|       |extern const pb_field_t gdt_cct_LogResponse_fields[3];
  259|       |
  260|       |/* Maximum encoded size of messages (where known) */
  261|       |/* gdt_cct_LogEvent_size depends on runtime parameters */
  262|       |#define gdt_cct_NetworkConnectionInfo_size       13
  263|       |/* gdt_cct_IosClientInfo_size depends on runtime parameters */
  264|       |/* gdt_cct_ClientInfo_size depends on runtime parameters */
  265|       |/* gdt_cct_BatchedLogRequest_size depends on runtime parameters */
  266|       |/* gdt_cct_LogRequest_size depends on runtime parameters */
  267|       |#define gdt_cct_QosTierConfiguration_size        13
  268|       |/* gdt_cct_QosTiersOverride_size depends on runtime parameters */
  269|       |/* gdt_cct_LogResponse_size depends on runtime parameters */
  270|       |
  271|       |/* Message IDs (where set with "msgid" option) */
  272|       |#ifdef PB_MSGID
  273|       |
  274|       |#define CCT_MESSAGES \
  275|       |
  276|       |
  277|       |#endif
  278|       |
  279|       |/* @@protoc_insertion_point(eof) */
  280|       |
  281|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/AppDelegateSwizzler/GULAppDelegateSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <TargetConditionals.h>
   16|       |
   17|       |#import <GoogleUtilities/GULAppDelegateSwizzler.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import <GoogleUtilities/GULMutableDictionary.h>
   21|       |#import "GoogleUtilities/AppDelegateSwizzler/Internal/GULAppDelegateSwizzler_Private.h"
   22|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   23|       |
   24|       |#import <objc/runtime.h>
   25|       |
   26|       |// Implementations need to be typed before calling the implementation directly to cast the
   27|       |// arguments and the return types correctly. Otherwise, it will crash the app.
   28|       |typedef BOOL (*GULRealOpenURLSourceApplicationAnnotationIMP)(
   29|       |    id, SEL, GULApplication *, NSURL *, NSString *, id);
   30|       |
   31|       |typedef BOOL (*GULRealOpenURLOptionsIMP)(
   32|       |    id, SEL, GULApplication *, NSURL *, NSDictionary<NSString *, id> *);
   33|       |
   34|       |#pragma clang diagnostic push
   35|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
   36|       |typedef void (*GULRealHandleEventsForBackgroundURLSessionIMP)(
   37|       |    id, SEL, GULApplication *, NSString *, void (^)());
   38|       |#pragma clang diagnostic pop
   39|       |
   40|       |// This is needed to for the library to be warning free on iOS versions < 8.
   41|       |#pragma clang diagnostic push
   42|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   43|       |typedef BOOL (*GULRealContinueUserActivityIMP)(
   44|       |    id, SEL, GULApplication *, NSUserActivity *, void (^)(NSArray *restorableObjects));
   45|       |#pragma clang diagnostic pop
   46|       |
   47|       |typedef void (*GULRealDidRegisterForRemoteNotificationsIMP)(id, SEL, GULApplication *, NSData *);
   48|       |
   49|       |typedef void (*GULRealDidFailToRegisterForRemoteNotificationsIMP)(id,
   50|       |                                                                  SEL,
   51|       |                                                                  GULApplication *,
   52|       |                                                                  NSError *);
   53|       |
   54|       |typedef void (*GULRealDidReceiveRemoteNotificationIMP)(id, SEL, GULApplication *, NSDictionary *);
   55|       |
   56|       |// TODO: Since we don't support iOS 7 anymore, see if we can remove the check below.
   57|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
   58|       |#pragma clang diagnostic push
   59|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   60|       |typedef void (*GULRealDidReceiveRemoteNotificationWithCompletionIMP)(
   61|       |    id, SEL, GULApplication *, NSDictionary *, void (^)(UIBackgroundFetchResult));
   62|       |#pragma clang diagnostic pop
   63|       |#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
   64|       |
   65|       |typedef void (^GULAppDelegateInterceptorCallback)(id<GULApplicationDelegate>);
   66|       |
   67|       |// The strings below are the keys for associated objects.
   68|       |static char const *const kGULRealIMPBySelectorKey = "GUL_realIMPBySelector";
   69|       |static char const *const kGULRealClassKey = "GUL_realClass";
   70|       |
   71|       |static NSString *const kGULAppDelegateKeyPath = @"delegate";
   72|       |
   73|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/AppDelegateSwizzler]";
   74|       |
   75|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   76|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   77|       |
   78|       |/** Plist key that allows Firebase developers to disable App and Scene Delegate Proxying. */
   79|       |static NSString *const kGULFirebaseAppDelegateProxyEnabledPlistKey =
   80|       |    @"FirebaseAppDelegateProxyEnabled";
   81|       |
   82|       |/** Plist key that allows developers not using Firebase to disable App and Scene Delegate Proxying.
   83|       | */
   84|       |static NSString *const kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey =
   85|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   86|       |
   87|       |/** The prefix of the App Delegate. */
   88|       |static NSString *const kGULAppDelegatePrefix = @"GUL_";
   89|       |
   90|       |/** The original instance of App Delegate. */
   91|       |static id<GULApplicationDelegate> gOriginalAppDelegate;
   92|       |
   93|       |/** The original App Delegate class */
   94|       |static Class gOriginalAppDelegateClass;
   95|       |
   96|       |/** The subclass of the original App Delegate. */
   97|       |static Class gAppDelegateSubclass;
   98|       |
   99|       |/** Remote notification methods selectors
  100|       | *
  101|       | *  We have to opt out of referencing APNS related App Delegate methods directly to prevent
  102|       | *  an Apple review warning email about missing Push Notification Entitlement
  103|       | *  (like here: https://github.com/firebase/firebase-ios-sdk/issues/2807). From our experience, the
  104|       | *  warning is triggered when any of the symbols is present in the application sent to review, even
  105|       | *  if the code is never executed. Because GULAppDelegateSwizzler may be used by applications that
  106|       | *  are not using APNS we have to refer to the methods indirectly using selector constructed from
  107|       | *  string.
  108|       | *
  109|       | *  NOTE: None of the methods is proxied unless it is explicitly requested by calling the method
  110|       | *  +[GULAppDelegateSwizzler proxyOriginalDelegateIncludingAPNSMethods]
  111|       | */
  112|       |static NSString *const kGULDidRegisterForRemoteNotificationsSEL =
  113|       |    @"application:didRegisterForRemoteNotificationsWithDeviceToken:";
  114|       |static NSString *const kGULDidFailToRegisterForRemoteNotificationsSEL =
  115|       |    @"application:didFailToRegisterForRemoteNotificationsWithError:";
  116|       |static NSString *const kGULDidReceiveRemoteNotificationSEL =
  117|       |    @"application:didReceiveRemoteNotification:";
  118|       |static NSString *const kGULDidReceiveRemoteNotificationWithCompletionSEL =
  119|       |    @"application:didReceiveRemoteNotification:fetchCompletionHandler:";
  120|       |
  121|       |/**
  122|       | * This class is necessary to store the delegates in an NSArray without retaining them.
  123|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
  124|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
  125|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
  126|       | * automatically is set to nil by the runtime when the object is dealloced.
  127|       | */
  128|       |@interface GULZeroingWeakContainer : NSObject
  129|       |
  130|       |/** Stores a weak object. */
  131|       |@property(nonatomic, weak) id object;
  132|       |
  133|       |@end
  134|       |
  135|       |@implementation GULZeroingWeakContainer
  136|       |@end
  137|       |
  138|       |@interface GULAppDelegateObserver : NSObject
  139|       |@end
  140|       |
  141|       |@implementation GULAppDelegateObserver {
  142|       |  BOOL _isObserving;
  143|       |}
  144|       |
  145|      2|+ (GULAppDelegateObserver *)sharedInstance {
  146|      2|  static GULAppDelegateObserver *instance;
  147|      2|  static dispatch_once_t once;
  148|      2|  dispatch_once(&once, ^{
  149|      1|    instance = [[GULAppDelegateObserver alloc] init];
  150|      1|  });
  151|      2|  return instance;
  152|      2|}
  153|       |
  154|      2|- (void)observeUIApplication {
  155|      2|  if (_isObserving) {
  156|      0|    return;
  157|      0|  }
  158|      2|  [[GULAppDelegateSwizzler sharedApplication]
  159|      2|      addObserver:self
  160|      2|       forKeyPath:kGULAppDelegateKeyPath
  161|      2|          options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
  162|      2|          context:nil];
  163|      2|  _isObserving = YES;
  164|      2|}
  165|       |
  166|       |- (void)observeValueForKeyPath:(NSString *)keyPath
  167|       |                      ofObject:(id)object
  168|       |                        change:(NSDictionary *)change
  169|      1|                       context:(void *)context {
  170|      1|  if ([keyPath isEqual:kGULAppDelegateKeyPath]) {
  171|      1|    id newValue = change[NSKeyValueChangeNewKey];
  172|      1|    id oldValue = change[NSKeyValueChangeOldKey];
  173|      1|    if ([newValue isEqual:oldValue]) {
  174|      0|      return;
  175|      0|    }
  176|      1|    // Free the stored app delegate instance because it has been changed to a different instance to
  177|      1|    // avoid keeping it alive forever.
  178|      1|    if ([oldValue isEqual:gOriginalAppDelegate]) {
  179|      1|      gOriginalAppDelegate = nil;
  180|      1|      // Remove the observer. Parse it to NSObject to avoid warning.
  181|      1|      [[GULAppDelegateSwizzler sharedApplication] removeObserver:self
  182|      1|                                                      forKeyPath:kGULAppDelegateKeyPath];
  183|      1|      _isObserving = NO;
  184|      1|    }
  185|      1|  }
  186|      1|}
  187|       |
  188|       |@end
  189|       |
  190|       |@implementation GULAppDelegateSwizzler
  191|       |
  192|       |static dispatch_once_t sProxyAppDelegateOnceToken;
  193|       |static dispatch_once_t sProxyAppDelegateRemoteNotificationOnceToken;
  194|       |
  195|       |#pragma mark - Public methods
  196|       |
  197|      3|+ (BOOL)isAppDelegateProxyEnabled {
  198|      3|  NSDictionary *infoDictionary = [NSBundle mainBundle].infoDictionary;
  199|      3|
  200|      3|  id isFirebaseProxyEnabledPlistValue = infoDictionary[kGULFirebaseAppDelegateProxyEnabledPlistKey];
  201|      3|  id isGoogleProxyEnabledPlistValue =
  202|      3|      infoDictionary[kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey];
  203|      3|
  204|      3|  // Enabled by default.
  205|      3|  BOOL isFirebaseAppDelegateProxyEnabled = YES;
  206|      3|  BOOL isGoogleUtilitiesAppDelegateProxyEnabled = YES;
  207|      3|
  208|      3|  if ([isFirebaseProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  209|      0|    isFirebaseAppDelegateProxyEnabled = [isFirebaseProxyEnabledPlistValue boolValue];
  210|      0|  }
  211|      3|
  212|      3|  if ([isGoogleProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  213|      0|    isGoogleUtilitiesAppDelegateProxyEnabled = [isGoogleProxyEnabledPlistValue boolValue];
  214|      0|  }
  215|      3|
  216|      3|  // Only deactivate the proxy if it is explicitly disabled by app developers using either one of
  217|      3|  // the plist flags.
  218|      3|  return isFirebaseAppDelegateProxyEnabled && isGoogleUtilitiesAppDelegateProxyEnabled;
  219|      3|}
  220|       |
  221|       |+ (GULAppDelegateInterceptorID)registerAppDelegateInterceptor:
  222|      2|    (id<GULApplicationDelegate>)interceptor {
  223|      2|  NSAssert(interceptor, @"AppDelegateProxy cannot add nil interceptor");
  224|      2|  NSAssert([interceptor conformsToProtocol:@protocol(GULApplicationDelegate)],
  225|      2|           @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  226|      2|
  227|      2|  if (!interceptor) {
  228|      0|    GULLogError(kGULLoggerSwizzler, NO,
  229|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  230|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling000],
  231|      0|                @"AppDelegateProxy cannot add nil interceptor.");
  232|      0|    return nil;
  233|      0|  }
  234|      2|  if (![interceptor conformsToProtocol:@protocol(GULApplicationDelegate)]) {
  235|      0|    GULLogError(kGULLoggerSwizzler, NO,
  236|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  237|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling001],
  238|      0|                @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  239|      0|    return nil;
  240|      0|  }
  241|      2|
  242|      2|  // The ID should be the same given the same interceptor object.
  243|      2|  NSString *interceptorID = [NSString stringWithFormat:@"%@%p", kGULAppDelegatePrefix, interceptor];
  244|      2|  if (!interceptorID.length) {
  245|      0|    GULLogError(kGULLoggerSwizzler, NO,
  246|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  247|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling002],
  248|      0|                @"AppDelegateProxy cannot create Interceptor ID.");
  249|      0|    return nil;
  250|      0|  }
  251|      2|  GULZeroingWeakContainer *weakObject = [[GULZeroingWeakContainer alloc] init];
  252|      2|  weakObject.object = interceptor;
  253|      2|  [GULAppDelegateSwizzler interceptors][interceptorID] = weakObject;
  254|      2|  return interceptorID;
  255|      2|}
  256|       |
  257|      0|+ (void)unregisterAppDelegateInterceptorWithID:(GULAppDelegateInterceptorID)interceptorID {
  258|      0|  NSAssert(interceptorID, @"AppDelegateProxy cannot unregister nil interceptor ID.");
  259|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  260|      0|           @"AppDelegateProxy cannot unregister empty interceptor ID.");
  261|      0|
  262|      0|  if (!interceptorID) {
  263|      0|    GULLogError(kGULLoggerSwizzler, NO,
  264|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  265|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling003],
  266|      0|                @"AppDelegateProxy cannot unregister empty interceptor ID.");
  267|      0|    return;
  268|      0|  }
  269|      0|
  270|      0|  GULZeroingWeakContainer *weakContainer = [GULAppDelegateSwizzler interceptors][interceptorID];
  271|      0|  if (!weakContainer.object) {
  272|      0|    GULLogError(kGULLoggerSwizzler, NO,
  273|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  274|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling004],
  275|      0|                @"AppDelegateProxy cannot unregister interceptor that was not registered. "
  276|      0|                 "Interceptor ID %@",
  277|      0|                interceptorID);
  278|      0|    return;
  279|      0|  }
  280|      0|
  281|      0|  [[GULAppDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  282|      0|}
  283|       |
  284|      2|+ (void)proxyOriginalDelegate {
  285|      2|  if ([GULAppEnvironmentUtil isAppExtension]) {
  286|      0|    return;
  287|      0|  }
  288|      2|
  289|      2|  dispatch_once(&sProxyAppDelegateOnceToken, ^{
  290|      1|    id<GULApplicationDelegate> originalDelegate =
  291|      1|        [GULAppDelegateSwizzler sharedApplication].delegate;
  292|      1|    [GULAppDelegateSwizzler proxyAppDelegate:originalDelegate];
  293|      1|  });
  294|      2|}
  295|       |
  296|      1|+ (void)proxyOriginalDelegateIncludingAPNSMethods {
  297|      1|  if ([GULAppEnvironmentUtil isAppExtension]) {
  298|      0|    return;
  299|      0|  }
  300|      1|
  301|      1|  [self proxyOriginalDelegate];
  302|      1|
  303|      1|  dispatch_once(&sProxyAppDelegateRemoteNotificationOnceToken, ^{
  304|      1|    id<GULApplicationDelegate> appDelegate = [GULAppDelegateSwizzler sharedApplication].delegate;
  305|      1|
  306|      1|    NSMutableDictionary *realImplementationsBySelector =
  307|      1|        [objc_getAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey) mutableCopy];
  308|      1|
  309|      1|    [self proxyRemoteNotificationsMethodsWithAppDelegateSubClass:gAppDelegateSubclass
  310|      1|                                                       realClass:gOriginalAppDelegateClass
  311|      1|                                                     appDelegate:appDelegate
  312|      1|                                   realImplementationsBySelector:realImplementationsBySelector];
  313|      1|
  314|      1|    objc_setAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey,
  315|      1|                             [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN);
  316|      1|    [self reassignAppDelegate];
  317|      1|  });
  318|      1|}
  319|       |
  320|       |#pragma mark - Create proxy
  321|       |
  322|     11|+ (GULApplication *)sharedApplication {
  323|     11|  if ([GULAppEnvironmentUtil isAppExtension]) {
  324|      0|    return nil;
  325|      0|  }
  326|     11|  id sharedApplication = nil;
  327|     11|  Class uiApplicationClass = NSClassFromString(kGULApplicationClassName);
  328|     11|  if (uiApplicationClass &&
  329|     11|      [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  330|     11|    sharedApplication = [uiApplicationClass sharedApplication];
  331|     11|  }
  332|     11|  return sharedApplication;
  333|     11|}
  334|       |
  335|       |#pragma mark - Override default methods
  336|       |
  337|       |/** Creates a new subclass of the class of the given object and sets the isa value of the given
  338|       | *  object to the new subclass. Additionally this copies methods to that new subclass that allow us
  339|       | *  to intercept UIApplicationDelegate methods. This is better known as isa swizzling.
  340|       | *
  341|       | *  @param appDelegate The object to which you want to isa swizzle. This has to conform to the
  342|       | *      UIApplicationDelegate subclass.
  343|       | *  @return Returns the new subclass.
  344|       | */
  345|      1|+ (nullable Class)createSubclassWithObject:(id<GULApplicationDelegate>)appDelegate {
  346|      1|  Class realClass = [appDelegate class];
  347|      1|
  348|      1|  // Create GUL_<RealAppDelegate>_<UUID>
  349|      1|  NSString *classNameWithPrefix =
  350|      1|      [kGULAppDelegatePrefix stringByAppendingString:NSStringFromClass(realClass)];
  351|      1|  NSString *newClassName =
  352|      1|      [NSString stringWithFormat:@"%@-%@", classNameWithPrefix, [NSUUID UUID].UUIDString];
  353|      1|
  354|      1|  if (NSClassFromString(newClassName)) {
  355|      0|    GULLogError(kGULLoggerSwizzler, NO,
  356|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  357|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling005],
  358|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  359|      0|                @"%@, subclass: %@",
  360|      0|                NSStringFromClass(realClass), newClassName);
  361|      0|    return nil;
  362|      0|  }
  363|      1|
  364|      1|  // Register the new class as subclass of the real one. Do not allocate more than the real class
  365|      1|  // size.
  366|      1|  Class appDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  367|      1|  if (appDelegateSubClass == Nil) {
  368|      0|    GULLogError(kGULLoggerSwizzler, NO,
  369|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  370|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling006],
  371|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  372|      0|                @"%@, subclass: Nil",
  373|      0|                NSStringFromClass(realClass));
  374|      0|    return nil;
  375|      0|  }
  376|      1|
  377|      1|  NSMutableDictionary<NSString *, NSValue *> *realImplementationsBySelector =
  378|      1|      [[NSMutableDictionary alloc] init];
  379|      1|
  380|      1|  // For application:continueUserActivity:restorationHandler:
  381|      1|  SEL continueUserActivitySEL = @selector(application:continueUserActivity:restorationHandler:);
  382|      1|  [self proxyDestinationSelector:continueUserActivitySEL
  383|      1|      implementationsFromSourceSelector:continueUserActivitySEL
  384|      1|                              fromClass:[GULAppDelegateSwizzler class]
  385|      1|                                toClass:appDelegateSubClass
  386|      1|                              realClass:realClass
  387|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  388|      1|
  389|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  390|      1|  // Add the following methods from GULAppDelegate class, and store the real implementation so it
  391|      1|  // can forward to the real one.
  392|      1|  // For application:openURL:options:
  393|      1|  SEL applicationOpenURLOptionsSEL = @selector(application:openURL:options:);
  394|      1|  if ([appDelegate respondsToSelector:applicationOpenURLOptionsSEL]) {
  395|      0|    // Only add the application:openURL:options: method if the original AppDelegate implements it.
  396|      0|    // This fixes a bug if an app only implements application:openURL:sourceApplication:annotation:
  397|      0|    // (if we add the `options` method, iOS sees that one exists and does not call the
  398|      0|    // `sourceApplication` method, which in this case is the only one the app implements).
  399|      0|
  400|      0|    [self proxyDestinationSelector:applicationOpenURLOptionsSEL
  401|      0|        implementationsFromSourceSelector:applicationOpenURLOptionsSEL
  402|      0|                                fromClass:[GULAppDelegateSwizzler class]
  403|      0|                                  toClass:appDelegateSubClass
  404|      0|                                realClass:realClass
  405|      0|         storeDestinationImplementationTo:realImplementationsBySelector];
  406|      0|  }
  407|      1|
  408|      1|  // For application:handleEventsForBackgroundURLSession:completionHandler:
  409|      1|  SEL handleEventsForBackgroundURLSessionSEL = @selector(application:
  410|      1|                                 handleEventsForBackgroundURLSession:completionHandler:);
  411|      1|  [self proxyDestinationSelector:handleEventsForBackgroundURLSessionSEL
  412|      1|      implementationsFromSourceSelector:handleEventsForBackgroundURLSessionSEL
  413|      1|                              fromClass:[GULAppDelegateSwizzler class]
  414|      1|                                toClass:appDelegateSubClass
  415|      1|                              realClass:realClass
  416|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  417|      1|#endif  // TARGET_OS_IOS || TARGET_OS_TV
  418|      1|
  419|      1|#if TARGET_OS_IOS
  420|      1|  // For application:openURL:sourceApplication:annotation:
  421|      1|  SEL openURLSourceApplicationAnnotationSEL = @selector(application:
  422|      1|                                                            openURL:sourceApplication:annotation:);
  423|      1|
  424|      1|  [self proxyDestinationSelector:openURLSourceApplicationAnnotationSEL
  425|      1|      implementationsFromSourceSelector:openURLSourceApplicationAnnotationSEL
  426|      1|                              fromClass:[GULAppDelegateSwizzler class]
  427|      1|                                toClass:appDelegateSubClass
  428|      1|                              realClass:realClass
  429|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  430|      1|#endif  // TARGET_OS_IOS
  431|      1|
  432|      1|  // Override the description too so the custom class name will not show up.
  433|      1|  [GULAppDelegateSwizzler addInstanceMethodWithDestinationSelector:@selector(description)
  434|      1|                              withImplementationFromSourceSelector:@selector(fakeDescription)
  435|      1|                                                         fromClass:[self class]
  436|      1|                                                           toClass:appDelegateSubClass];
  437|      1|
  438|      1|  // Store original implementations to a fake property of the original delegate.
  439|      1|  objc_setAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey,
  440|      1|                           [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  441|      1|  objc_setAssociatedObject(appDelegate, &kGULRealClassKey, realClass,
  442|      1|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  443|      1|
  444|      1|  // The subclass size has to be exactly the same size with the original class size. The subclass
  445|      1|  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  446|      1|  // that can lead to overwriting the isa of an object in the next frame.
  447|      1|  if (class_getInstanceSize(realClass) != class_getInstanceSize(appDelegateSubClass)) {
  448|      0|    GULLogError(kGULLoggerSwizzler, NO,
  449|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  450|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling007],
  451|      0|                @"Cannot create subclass of App Delegate, because the created subclass is not the "
  452|      0|                @"same size. %@",
  453|      0|                NSStringFromClass(realClass));
  454|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  455|      0|    return nil;
  456|      0|  }
  457|      1|
  458|      1|  // Make the newly created class to be the subclass of the real App Delegate class.
  459|      1|  objc_registerClassPair(appDelegateSubClass);
  460|      1|  if (object_setClass(appDelegate, appDelegateSubClass)) {
  461|      1|    GULLogDebug(kGULLoggerSwizzler, NO,
  462|      1|                [NSString stringWithFormat:@"I-SWZ%06ld",
  463|      1|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling008],
  464|      1|                @"Successfully created App Delegate Proxy automatically. To disable the "
  465|      1|                @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  466|      1|                [GULAppDelegateSwizzler correctAppDelegateProxyKey]);
  467|      1|  }
  468|      1|
  469|      1|  return appDelegateSubClass;
  470|      1|}
  471|       |
  472|       |+ (void)proxyRemoteNotificationsMethodsWithAppDelegateSubClass:(Class)appDelegateSubClass
  473|       |                                                     realClass:(Class)realClass
  474|       |                                                   appDelegate:(id)appDelegate
  475|       |                                 realImplementationsBySelector:
  476|      1|                                     (NSMutableDictionary *)realImplementationsBySelector {
  477|      1|  if (realClass == nil || appDelegateSubClass == nil || appDelegate == nil ||
  478|      1|      realImplementationsBySelector == nil) {
  479|      0|    // The App Delegate has not been swizzled.
  480|      0|    return;
  481|      0|  }
  482|      1|
  483|      1|  // For application:didRegisterForRemoteNotificationsWithDeviceToken:
  484|      1|  SEL didRegisterForRemoteNotificationsSEL =
  485|      1|      NSSelectorFromString(kGULDidRegisterForRemoteNotificationsSEL);
  486|      1|  SEL didRegisterForRemoteNotificationsDonorSEL = @selector(application:
  487|      1|                 donor_didRegisterForRemoteNotificationsWithDeviceToken:);
  488|      1|
  489|      1|  [self proxyDestinationSelector:didRegisterForRemoteNotificationsSEL
  490|      1|      implementationsFromSourceSelector:didRegisterForRemoteNotificationsDonorSEL
  491|      1|                              fromClass:[GULAppDelegateSwizzler class]
  492|      1|                                toClass:appDelegateSubClass
  493|      1|                              realClass:realClass
  494|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  495|      1|
  496|      1|  // For application:didFailToRegisterForRemoteNotificationsWithError:
  497|      1|  SEL didFailToRegisterForRemoteNotificationsSEL =
  498|      1|      NSSelectorFromString(kGULDidFailToRegisterForRemoteNotificationsSEL);
  499|      1|  SEL didFailToRegisterForRemoteNotificationsDonorSEL = @selector(application:
  500|      1|                       donor_didFailToRegisterForRemoteNotificationsWithError:);
  501|      1|
  502|      1|  [self proxyDestinationSelector:didFailToRegisterForRemoteNotificationsSEL
  503|      1|      implementationsFromSourceSelector:didFailToRegisterForRemoteNotificationsDonorSEL
  504|      1|                              fromClass:[GULAppDelegateSwizzler class]
  505|      1|                                toClass:appDelegateSubClass
  506|      1|                              realClass:realClass
  507|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  508|      1|
  509|      1|  // For application:didReceiveRemoteNotification:
  510|      1|  SEL didReceiveRemoteNotificationSEL = NSSelectorFromString(kGULDidReceiveRemoteNotificationSEL);
  511|      1|  SEL didReceiveRemoteNotificationDonotSEL = @selector(application:
  512|      1|                                donor_didReceiveRemoteNotification:);
  513|      1|
  514|      1|  [self proxyDestinationSelector:didReceiveRemoteNotificationSEL
  515|      1|      implementationsFromSourceSelector:didReceiveRemoteNotificationDonotSEL
  516|      1|                              fromClass:[GULAppDelegateSwizzler class]
  517|      1|                                toClass:appDelegateSubClass
  518|      1|                              realClass:realClass
  519|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  520|      1|
  521|      1|  // For application:didReceiveRemoteNotification:fetchCompletionHandler:
  522|      1|#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  523|      1|  if ([GULAppEnvironmentUtil isIOS7OrHigher]) {
  524|      1|    SEL didReceiveRemoteNotificationWithCompletionSEL =
  525|      1|        NSSelectorFromString(kGULDidReceiveRemoteNotificationWithCompletionSEL);
  526|      1|    SEL didReceiveRemoteNotificationWithCompletionDonorSEL =
  527|      1|        @selector(application:donor_didReceiveRemoteNotification:fetchCompletionHandler:);
  528|      1|    if ([appDelegate respondsToSelector:didReceiveRemoteNotificationWithCompletionSEL]) {
  529|      0|      // Only add the application:didReceiveRemoteNotification:fetchCompletionHandler: method if
  530|      0|      // the original AppDelegate implements it.
  531|      0|      // This fixes a bug if an app only implements application:didReceiveRemoteNotification:
  532|      0|      // (if we add the method with completion, iOS sees that one exists and does not call
  533|      0|      // the method without the completion, which in this case is the only one the app implements).
  534|      0|
  535|      0|      [self proxyDestinationSelector:didReceiveRemoteNotificationWithCompletionSEL
  536|      0|          implementationsFromSourceSelector:didReceiveRemoteNotificationWithCompletionDonorSEL
  537|      0|                                  fromClass:[GULAppDelegateSwizzler class]
  538|      0|                                    toClass:appDelegateSubClass
  539|      0|                                  realClass:realClass
  540|      0|           storeDestinationImplementationTo:realImplementationsBySelector];
  541|      0|    }
  542|      1|  }
  543|      1|#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  544|      1|}
  545|       |
  546|       |/// We have to do this to invalidate the cache that caches the original respondsToSelector of
  547|       |/// openURL handlers. Without this, it won't call the default implementations because the system
  548|       |/// checks and caches them.
  549|       |/// Register KVO only once. Otherwise, the observing method will be called as many times as
  550|       |/// being registered.
  551|      2|+ (void)reassignAppDelegate {
  552|      2|#if !TARGET_OS_WATCH
  553|      2|  id<GULApplicationDelegate> delegate = [self sharedApplication].delegate;
  554|      2|  [self sharedApplication].delegate = nil;
  555|      2|  [self sharedApplication].delegate = delegate;
  556|      2|  gOriginalAppDelegate = delegate;
  557|      2|  [[GULAppDelegateObserver sharedInstance] observeUIApplication];
  558|      2|#endif
  559|      2|}
  560|       |
  561|       |#pragma mark - Helper methods
  562|       |
  563|      2|+ (GULMutableDictionary *)interceptors {
  564|      2|  static dispatch_once_t onceToken;
  565|      2|  static GULMutableDictionary *sInterceptors;
  566|      2|  dispatch_once(&onceToken, ^{
  567|      1|    sInterceptors = [[GULMutableDictionary alloc] init];
  568|      1|  });
  569|      2|  return sInterceptors;
  570|      2|}
  571|       |
  572|      0|+ (nullable NSValue *)originalImplementationForSelector:(SEL)selector object:(id)object {
  573|      0|  NSDictionary *realImplementationBySelector =
  574|      0|      objc_getAssociatedObject(object, &kGULRealIMPBySelectorKey);
  575|      0|  return realImplementationBySelector[NSStringFromSelector(selector)];
  576|      0|}
  577|       |
  578|       |+ (void)proxyDestinationSelector:(SEL)destinationSelector
  579|       |    implementationsFromSourceSelector:(SEL)sourceSelector
  580|       |                            fromClass:(Class)sourceClass
  581|       |                              toClass:(Class)destinationClass
  582|       |                            realClass:(Class)realClass
  583|       |     storeDestinationImplementationTo:
  584|      6|         (NSMutableDictionary<NSString *, NSValue *> *)destinationImplementationsBySelector {
  585|      6|  [self addInstanceMethodWithDestinationSelector:destinationSelector
  586|      6|            withImplementationFromSourceSelector:sourceSelector
  587|      6|                                       fromClass:sourceClass
  588|      6|                                         toClass:destinationClass];
  589|      6|  IMP sourceImplementation =
  590|      6|      [GULAppDelegateSwizzler implementationOfMethodSelector:destinationSelector
  591|      6|                                                   fromClass:realClass];
  592|      6|  NSValue *sourceImplementationPointer = [NSValue valueWithPointer:sourceImplementation];
  593|      6|
  594|      6|  NSString *destinationSelectorString = NSStringFromSelector(destinationSelector);
  595|      6|  destinationImplementationsBySelector[destinationSelectorString] = sourceImplementationPointer;
  596|      6|}
  597|       |
  598|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  599|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  600|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  601|       | *  identified by methodSelector.
  602|       | *
  603|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  604|       | *      one on the toClass.
  605|       | *  @param fromClass The class from which a method is sourced.
  606|       | *  @param toClass The class to which the method is added. If the class already has a method with
  607|       | *      the same selector, this has no effect.
  608|       | */
  609|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  610|       |                            fromClass:(Class)fromClass
  611|      0|                              toClass:(Class)toClass {
  612|      0|  [self addInstanceMethodWithDestinationSelector:methodSelector
  613|      0|            withImplementationFromSourceSelector:methodSelector
  614|      0|                                       fromClass:fromClass
  615|      0|                                         toClass:toClass];
  616|      0|}
  617|       |
  618|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  619|       | *  destinationSelector on the toClass. After this method is called, performing
  620|       | *  [toClassInstance destinationSelector] will be similar to calling
  621|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  622|       | *  identified by destinationSelector.
  623|       | *
  624|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  625|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  626|       | *  @param fromClass The class from which a method is sourced.
  627|       | *  @param toClass The class to which the method is added. If the class already has a method with
  628|       | *      the same selector, this has no effect.
  629|       | */
  630|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  631|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  632|       |                                       fromClass:(Class)fromClass
  633|      7|                                         toClass:(Class)toClass {
  634|      7|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  635|      7|  IMP methodIMP = method_getImplementation(method);
  636|      7|  const char *types = method_getTypeEncoding(method);
  637|      7|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  638|      0|    GULLogWarning(kGULLoggerSwizzler, NO,
  639|      0|                  [NSString stringWithFormat:@"I-SWZ%06ld",
  640|      0|                                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzling009],
  641|      0|                  @"Cannot copy method to destination selector %@ as it already exists",
  642|      0|                  NSStringFromSelector(destinationSelector));
  643|      0|  }
  644|      7|}
  645|       |
  646|       |/** Gets the IMP of the instance method on the class identified by the selector.
  647|       | *
  648|       | *  @param selector The selector of which the IMP is to be fetched.
  649|       | *  @param aClass The class from which the IMP is to be fetched.
  650|       | *  @return The IMP of the instance method identified by selector and aClass.
  651|       | */
  652|      6|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  653|      6|  Method aMethod = class_getInstanceMethod(aClass, selector);
  654|      6|  return method_getImplementation(aMethod);
  655|      6|}
  656|       |
  657|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  658|       | *  GULAppDelegateInterceptorCallback with the interceptor.
  659|       | *
  660|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  661|       | *  @param callback the GULAppDelegateInterceptorCallback.
  662|       | */
  663|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  664|      0|                                    callback:(GULAppDelegateInterceptorCallback)callback {
  665|      0|  if (!callback) {
  666|      0|    return;
  667|      0|  }
  668|      0|
  669|      0|  NSDictionary *interceptors = [GULAppDelegateSwizzler interceptors].dictionary;
  670|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  671|      0|    GULZeroingWeakContainer *interceptorContainer = obj;
  672|      0|    id interceptor = interceptorContainer.object;
  673|      0|    if (!interceptor) {
  674|      0|      GULLogWarning(
  675|      0|          kGULLoggerSwizzler, NO,
  676|      0|          [NSString
  677|      0|              stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeAppDelegateSwizzling010],
  678|      0|          @"AppDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  679|      0|      [[GULAppDelegateSwizzler interceptors] removeObjectForKey:key];
  680|      0|      return;
  681|      0|    }
  682|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  683|      0|      callback(interceptor);
  684|      0|    }
  685|      0|  }];
  686|      0|}
  687|       |
  688|       |// The methods below are donor methods which are added to the dynamic subclass of the App Delegate.
  689|       |// They are called within the scope of the real App Delegate so |self| does not refer to the
  690|       |// GULAppDelegateSwizzler instance but the real App Delegate instance.
  691|       |
  692|       |#pragma mark - [Donor Methods] Overridden instance description method
  693|       |
  694|      0|- (NSString *)fakeDescription {
  695|      0|  Class realClass = objc_getAssociatedObject(self, &kGULRealClassKey);
  696|      0|  return [NSString stringWithFormat:@"<%@: %p>", realClass, self];
  697|      0|}
  698|       |
  699|       |#pragma mark - [Donor Methods] URL overridden handler methods
  700|       |#if TARGET_OS_IOS || TARGET_OS_TV
  701|       |
  702|       |- (BOOL)application:(GULApplication *)application
  703|       |            openURL:(NSURL *)url
  704|      0|            options:(NSDictionary<NSString *, id> *)options {
  705|      0|  SEL methodSelector = @selector(application:openURL:options:);
  706|      0|  // Call the real implementation if the real App Delegate has any.
  707|      0|  NSValue *openURLIMPPointer =
  708|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  709|      0|  GULRealOpenURLOptionsIMP openURLOptionsIMP = [openURLIMPPointer pointerValue];
  710|      0|
  711|      0|  __block BOOL returnedValue = NO;
  712|      0|
  713|      0|// This is needed to for the library to be warning free on iOS versions < 9.
  714|      0|#pragma clang diagnostic push
  715|      0|#pragma clang diagnostic ignored "-Wunguarded-availability"
  716|      0|  [GULAppDelegateSwizzler
  717|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  718|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  719|      0|                                    returnedValue |= [interceptor application:application
  720|      0|                                                                      openURL:url
  721|      0|                                                                      options:options];
  722|      0|                                  }];
  723|      0|#pragma clang diagnostic pop
  724|      0|  if (openURLOptionsIMP) {
  725|      0|    returnedValue |= openURLOptionsIMP(self, methodSelector, application, url, options);
  726|      0|  }
  727|      0|  return returnedValue;
  728|      0|}
  729|       |
  730|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  731|       |
  732|       |#if TARGET_OS_IOS
  733|       |
  734|       |- (BOOL)application:(GULApplication *)application
  735|       |              openURL:(NSURL *)url
  736|       |    sourceApplication:(NSString *)sourceApplication
  737|      0|           annotation:(id)annotation {
  738|      0|  SEL methodSelector = @selector(application:openURL:sourceApplication:annotation:);
  739|      0|
  740|      0|  // Call the real implementation if the real App Delegate has any.
  741|      0|  NSValue *openURLSourceAppAnnotationIMPPointer =
  742|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  743|      0|  GULRealOpenURLSourceApplicationAnnotationIMP openURLSourceApplicationAnnotationIMP =
  744|      0|      [openURLSourceAppAnnotationIMPPointer pointerValue];
  745|      0|
  746|      0|  __block BOOL returnedValue = NO;
  747|      0|  [GULAppDelegateSwizzler
  748|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  749|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  750|      0|#pragma clang diagnostic push
  751|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  752|      0|                                    returnedValue |= [interceptor application:application
  753|      0|                                                                      openURL:url
  754|      0|                                                            sourceApplication:sourceApplication
  755|      0|                                                                   annotation:annotation];
  756|      0|#pragma clang diagnostic pop
  757|      0|                                  }];
  758|      0|  if (openURLSourceApplicationAnnotationIMP) {
  759|      0|    returnedValue |= openURLSourceApplicationAnnotationIMP(self, methodSelector, application, url,
  760|      0|                                                           sourceApplication, annotation);
  761|      0|  }
  762|      0|  return returnedValue;
  763|      0|}
  764|       |
  765|       |#endif  // TARGET_OS_IOS
  766|       |
  767|       |#pragma mark - [Donor Methods] Network overridden handler methods
  768|       |
  769|       |#if TARGET_OS_IOS || TARGET_OS_TV
  770|       |
  771|       |#pragma clang diagnostic push
  772|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
  773|       |- (void)application:(GULApplication *)application
  774|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
  775|      0|                      completionHandler:(void (^)())completionHandler API_AVAILABLE(ios(7.0)) {
  776|      0|#pragma clang diagnostic pop
  777|      0|  SEL methodSelector = @selector(application:
  778|      0|         handleEventsForBackgroundURLSession:completionHandler:);
  779|      0|  NSValue *handleBackgroundSessionPointer =
  780|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  781|      0|  GULRealHandleEventsForBackgroundURLSessionIMP handleBackgroundSessionIMP =
  782|      0|      [handleBackgroundSessionPointer pointerValue];
  783|      0|
  784|      0|  // Notify interceptors.
  785|      0|  [GULAppDelegateSwizzler
  786|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  787|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  788|      0|                                    [interceptor application:application
  789|      0|                                        handleEventsForBackgroundURLSession:identifier
  790|      0|                                                          completionHandler:completionHandler];
  791|      0|                                  }];
  792|      0|  // Call the real implementation if the real App Delegate has any.
  793|      0|  if (handleBackgroundSessionIMP) {
  794|      0|    handleBackgroundSessionIMP(self, methodSelector, application, identifier, completionHandler);
  795|      0|  }
  796|      0|}
  797|       |
  798|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  799|       |
  800|       |#pragma mark - [Donor Methods] User Activities overridden handler methods
  801|       |
  802|       |// This is needed to for the library to be warning free on iOS versions < 8.
  803|       |#pragma clang diagnostic push
  804|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  805|       |- (BOOL)application:(GULApplication *)application
  806|       |    continueUserActivity:(NSUserActivity *)userActivity
  807|      0|      restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler {
  808|      0|  SEL methodSelector = @selector(application:continueUserActivity:restorationHandler:);
  809|      0|  NSValue *continueUserActivityIMPPointer =
  810|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  811|      0|  GULRealContinueUserActivityIMP continueUserActivityIMP =
  812|      0|      continueUserActivityIMPPointer.pointerValue;
  813|      0|
  814|      0|  __block BOOL returnedValue = NO;
  815|      0|#if !TARGET_OS_WATCH
  816|      0|  [GULAppDelegateSwizzler
  817|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  818|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  819|      0|                                    returnedValue |= [interceptor application:application
  820|      0|                                                         continueUserActivity:userActivity
  821|      0|                                                           restorationHandler:restorationHandler];
  822|      0|                                  }];
  823|      0|#endif
  824|      0|  // Call the real implementation if the real App Delegate has any.
  825|      0|  if (continueUserActivityIMP) {
  826|      0|    returnedValue |= continueUserActivityIMP(self, methodSelector, application, userActivity,
  827|      0|                                             restorationHandler);
  828|      0|  }
  829|      0|  return returnedValue;
  830|      0|}
  831|       |#pragma clang diagnostic pop
  832|       |
  833|       |#pragma mark - [Donor Methods] Remote Notifications
  834|       |
  835|       |- (void)application:(GULApplication *)application
  836|      0|    donor_didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
  837|      0|  SEL methodSelector = NSSelectorFromString(kGULDidRegisterForRemoteNotificationsSEL);
  838|      0|
  839|      0|  NSValue *didRegisterForRemoteNotificationsIMPPointer =
  840|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  841|      0|  GULRealDidRegisterForRemoteNotificationsIMP didRegisterForRemoteNotificationsIMP =
  842|      0|      [didRegisterForRemoteNotificationsIMPPointer pointerValue];
  843|      0|
  844|      0|  // Notify interceptors.
  845|      0|  [GULAppDelegateSwizzler
  846|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  847|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  848|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  849|      0|                                        appDelegateInvocationForSelector:methodSelector];
  850|      0|                                    [invocation setTarget:interceptor];
  851|      0|                                    [invocation setSelector:methodSelector];
  852|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  853|      0|                                    [invocation setArgument:(void *)(&deviceToken) atIndex:3];
  854|      0|                                    [invocation invoke];
  855|      0|                                  }];
  856|      0|  // Call the real implementation if the real App Delegate has any.
  857|      0|  if (didRegisterForRemoteNotificationsIMP) {
  858|      0|    didRegisterForRemoteNotificationsIMP(self, methodSelector, application, deviceToken);
  859|      0|  }
  860|      0|}
  861|       |
  862|       |- (void)application:(GULApplication *)application
  863|      0|    donor_didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
  864|      0|  SEL methodSelector = NSSelectorFromString(kGULDidFailToRegisterForRemoteNotificationsSEL);
  865|      0|  NSValue *didFailToRegisterForRemoteNotificationsIMPPointer =
  866|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  867|      0|  GULRealDidFailToRegisterForRemoteNotificationsIMP didFailToRegisterForRemoteNotificationsIMP =
  868|      0|      [didFailToRegisterForRemoteNotificationsIMPPointer pointerValue];
  869|      0|
  870|      0|  // Notify interceptors.
  871|      0|  [GULAppDelegateSwizzler
  872|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  873|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  874|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  875|      0|                                        appDelegateInvocationForSelector:methodSelector];
  876|      0|                                    [invocation setTarget:interceptor];
  877|      0|                                    [invocation setSelector:methodSelector];
  878|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  879|      0|                                    [invocation setArgument:(void *)(&error) atIndex:3];
  880|      0|                                    [invocation invoke];
  881|      0|                                  }];
  882|      0|  // Call the real implementation if the real App Delegate has any.
  883|      0|  if (didFailToRegisterForRemoteNotificationsIMP) {
  884|      0|    didFailToRegisterForRemoteNotificationsIMP(self, methodSelector, application, error);
  885|      0|  }
  886|      0|}
  887|       |
  888|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  889|       |#pragma clang diagnostic push
  890|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  891|       |- (void)application:(GULApplication *)application
  892|       |    donor_didReceiveRemoteNotification:(NSDictionary *)userInfo
  893|      0|                fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  894|      0|  SEL methodSelector = NSSelectorFromString(kGULDidReceiveRemoteNotificationWithCompletionSEL);
  895|      0|  NSValue *didReceiveRemoteNotificationWithCompletionIMPPointer =
  896|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  897|      0|  GULRealDidReceiveRemoteNotificationWithCompletionIMP
  898|      0|      didReceiveRemoteNotificationWithCompletionIMP =
  899|      0|          [didReceiveRemoteNotificationWithCompletionIMPPointer pointerValue];
  900|      0|
  901|      0|  // Notify interceptors.
  902|      0|  [GULAppDelegateSwizzler
  903|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  904|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  905|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  906|      0|                                        appDelegateInvocationForSelector:methodSelector];
  907|      0|                                    [invocation setTarget:interceptor];
  908|      0|                                    [invocation setSelector:methodSelector];
  909|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  910|      0|                                    [invocation setArgument:(void *)(&userInfo) atIndex:3];
  911|      0|                                    [invocation setArgument:(void *)(&completionHandler) atIndex:4];
  912|      0|                                    [invocation invoke];
  913|      0|                                  }];
  914|      0|  // Call the real implementation if the real App Delegate has any.
  915|      0|  if (didReceiveRemoteNotificationWithCompletionIMP) {
  916|      0|    didReceiveRemoteNotificationWithCompletionIMP(self, methodSelector, application, userInfo,
  917|      0|                                                  completionHandler);
  918|      0|  }
  919|      0|}
  920|       |#pragma clang diagnostic pop
  921|       |#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  922|       |
  923|       |- (void)application:(GULApplication *)application
  924|      0|    donor_didReceiveRemoteNotification:(NSDictionary *)userInfo {
  925|      0|  SEL methodSelector = NSSelectorFromString(kGULDidReceiveRemoteNotificationSEL);
  926|      0|  NSValue *didReceiveRemoteNotificationIMPPointer =
  927|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  928|      0|  GULRealDidReceiveRemoteNotificationIMP didReceiveRemoteNotificationIMP =
  929|      0|      [didReceiveRemoteNotificationIMPPointer pointerValue];
  930|      0|
  931|      0|  // Notify interceptors.
  932|      0|#pragma clang diagnostic push
  933|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  934|      0|  [GULAppDelegateSwizzler
  935|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  936|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  937|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  938|      0|                                        appDelegateInvocationForSelector:methodSelector];
  939|      0|                                    [invocation setTarget:interceptor];
  940|      0|                                    [invocation setSelector:methodSelector];
  941|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  942|      0|                                    [invocation setArgument:(void *)(&userInfo) atIndex:3];
  943|      0|                                    [invocation invoke];
  944|      0|                                  }];
  945|      0|#pragma clang diagnostic pop
  946|      0|  // Call the real implementation if the real App Delegate has any.
  947|      0|  if (didReceiveRemoteNotificationIMP) {
  948|      0|    didReceiveRemoteNotificationIMP(self, methodSelector, application, userInfo);
  949|      0|  }
  950|      0|}
  951|       |
  952|      0|+ (nullable NSInvocation *)appDelegateInvocationForSelector:(SEL)selector {
  953|      0|  struct objc_method_description methodDescription =
  954|      0|      protocol_getMethodDescription(@protocol(GULApplicationDelegate), selector, NO, YES);
  955|      0|  if (methodDescription.types == NULL) {
  956|      0|    return nil;
  957|      0|  }
  958|      0|
  959|      0|  NSMethodSignature *signature = [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
  960|      0|  return [NSInvocation invocationWithMethodSignature:signature];
  961|      0|}
  962|       |
  963|      1|+ (void)proxyAppDelegate:(id<GULApplicationDelegate>)appDelegate {
  964|      1|  if (![appDelegate conformsToProtocol:@protocol(GULApplicationDelegate)]) {
  965|      0|    GULLogNotice(
  966|      0|        kGULLoggerSwizzler, NO,
  967|      0|        [NSString
  968|      0|            stringWithFormat:@"I-SWZ%06ld",
  969|      0|                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzlingInvalidAppDelegate],
  970|      0|        @"App Delegate does not conform to UIApplicationDelegate protocol. %@",
  971|      0|        [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  972|      0|    return;
  973|      0|  }
  974|      1|
  975|      1|  id<GULApplicationDelegate> originalDelegate = appDelegate;
  976|      1|  // Do not create a subclass if it is not enabled.
  977|      1|  if (![GULAppDelegateSwizzler isAppDelegateProxyEnabled]) {
  978|      0|    GULLogNotice(kGULLoggerSwizzler, NO,
  979|      0|                 [NSString stringWithFormat:@"I-SWZ%06ld",
  980|      0|                                            (long)kGULSwizzlerMessageCodeAppDelegateSwizzling011],
  981|      0|                 @"App Delegate Proxy is disabled. %@",
  982|      0|                 [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  983|      0|    return;
  984|      0|  }
  985|      1|  // Do not accept nil delegate.
  986|      1|  if (!originalDelegate) {
  987|      0|    GULLogError(kGULLoggerSwizzler, NO,
  988|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  989|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling012],
  990|      0|                @"Cannot create App Delegate Proxy because App Delegate instance is nil. %@",
  991|      0|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  992|      0|    return;
  993|      0|  }
  994|      1|
  995|      1|  @try {
  996|      1|    gOriginalAppDelegateClass = [originalDelegate class];
  997|      1|    gAppDelegateSubclass = [self createSubclassWithObject:originalDelegate];
  998|      1|    [self reassignAppDelegate];
  999|      1|  } @catch (NSException *exception) {
 1000|      1|    GULLogError(kGULLoggerSwizzler, NO,
 1001|      1|                [NSString stringWithFormat:@"I-SWZ%06ld",
 1002|      1|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling013],
 1003|      1|                @"Cannot create App Delegate Proxy. %@",
 1004|      1|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
 1005|      1|    return;
 1006|      1|  }
 1007|      1|}
 1008|       |
 1009|       |#pragma mark - Methods to print correct debug logs
 1010|       |
 1011|      1|+ (NSString *)correctAppDelegateProxyKey {
 1012|      1|  return NSClassFromString(@"FIRCore") ? kGULFirebaseAppDelegateProxyEnabledPlistKey
 1013|      1|                                       : kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey;
 1014|      1|}
 1015|       |
 1016|      0|+ (NSString *)correctAlternativeWhenAppDelegateProxyNotCreated {
 1017|      0|  return NSClassFromString(@"FIRCore")
 1018|      0|             ? @"To log deep link campaigns manually, call the methods in "
 1019|      0|               @"FIRAnalytics+AppDelegate.h."
 1020|      0|             : @"";
 1021|      0|}
 1022|       |
 1023|       |#pragma mark - Private Methods for Testing
 1024|       |
 1025|      0|+ (void)clearInterceptors {
 1026|      0|  [[self interceptors] removeAllObjects];
 1027|      0|}
 1028|       |
 1029|      0|+ (void)resetProxyOriginalDelegateOnceToken {
 1030|      0|  sProxyAppDelegateOnceToken = 0;
 1031|      0|  sProxyAppDelegateRemoteNotificationOnceToken = 0;
 1032|      0|}
 1033|       |
 1034|      0|+ (id<GULApplicationDelegate>)originalDelegate {
 1035|      0|  return gOriginalAppDelegate;
 1036|      0|}
 1037|       |
 1038|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Environment/GULHeartbeatDateStorage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleUtilities/GULHeartbeatDateStorage.h>
   18|       |#import <GoogleUtilities/GULSecureCoding.h>
   19|       |
   20|       |@interface GULHeartbeatDateStorage ()
   21|       |/** The storage to store the date of the last sent heartbeat. */
   22|       |@property(nonatomic, readonly) NSFileCoordinator *fileCoordinator;
   23|       |@end
   24|       |
   25|       |@implementation GULHeartbeatDateStorage
   26|       |
   27|      3|- (instancetype)initWithFileName:(NSString *)fileName {
   28|      3|  if (fileName == nil) {
   29|      0|    return nil;
   30|      0|  }
   31|      3|
   32|      3|  self = [super init];
   33|      3|  if (self) {
   34|      3|    _fileCoordinator = [[NSFileCoordinator alloc] initWithFilePresenter:nil];
   35|      3|    NSURL *directoryURL = [[self class] directoryPathURL];
   36|      3|    [[self class] checkAndCreateDirectory:directoryURL fileCoordinator:_fileCoordinator];
   37|      3|    _fileURL = [directoryURL URLByAppendingPathComponent:fileName];
   38|      3|  }
   39|      3|  return self;
   40|      3|}
   41|       |
   42|       |/** Returns the URL path of the Application Support folder.
   43|       | * @return the URL path of Application Support.
   44|       | */
   45|      3|+ (NSURL *)directoryPathURL {
   46|      3|  NSArray<NSString *> *paths =
   47|      3|      NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   48|      3|  NSArray<NSString *> *components = @[ paths.lastObject, @"Google/FIRApp" ];
   49|      3|  NSString *directoryString = [NSString pathWithComponents:components];
   50|      3|  NSURL *directoryURL = [NSURL fileURLWithPath:directoryString];
   51|      3|  return directoryURL;
   52|      3|}
   53|       |
   54|       |/** Checks and creates a directory for the directory specified by the
   55|       | * directory url
   56|       | * @param directoryPathURL The path to the directory which needs to be created.
   57|       | * @param fileCoordinator The fileCoordinator object to coordinate writes to the directory.
   58|       | */
   59|       |+ (void)checkAndCreateDirectory:(NSURL *)directoryPathURL
   60|      3|                fileCoordinator:(NSFileCoordinator *)fileCoordinator {
   61|      3|  NSError *fileCoordinatorError = nil;
   62|      3|  [fileCoordinator
   63|      3|      coordinateWritingItemAtURL:directoryPathURL
   64|      3|                         options:0
   65|      3|                           error:&fileCoordinatorError
   66|      3|                      byAccessor:^(NSURL *writingDirectoryURL) {
   67|      3|                        NSError *error;
   68|      3|                        if (![writingDirectoryURL checkResourceIsReachableAndReturnError:&error]) {
   69|      0|                          // If fail creating the Application Support directory, log warning.
   70|      0|                          NSError *error;
   71|      0|                          [[NSFileManager defaultManager] createDirectoryAtURL:writingDirectoryURL
   72|      0|                                                   withIntermediateDirectories:YES
   73|      0|                                                                    attributes:nil
   74|      0|                                                                         error:&error];
   75|      0|                        }
   76|      3|                      }];
   77|      3|}
   78|       |
   79|      4|- (nullable NSMutableDictionary *)heartbeatDictionaryWithFileURL:(NSURL *)readingFileURL {
   80|      4|  NSError *error;
   81|      4|  NSMutableDictionary *dict;
   82|      4|  NSData *objectData = [NSData dataWithContentsOfURL:readingFileURL options:0 error:&error];
   83|      4|  if (objectData == nil || error != nil) {
   84|      0|    dict = [NSMutableDictionary dictionary];
   85|      4|  } else {
   86|      4|    dict = [GULSecureCoding
   87|      4|        unarchivedObjectOfClasses:[NSSet setWithArray:@[ NSDictionary.class, NSDate.class ]]
   88|      4|                         fromData:objectData
   89|      4|                            error:&error];
   90|      4|    if (dict == nil || error != nil) {
   91|      0|      dict = [NSMutableDictionary dictionary];
   92|      0|    }
   93|      4|  }
   94|      4|  return dict;
   95|      4|}
   96|       |
   97|      4|- (nullable NSDate *)heartbeatDateForTag:(NSString *)tag {
   98|      4|  __block NSMutableDictionary *dict;
   99|      4|  NSError *error;
  100|      4|  [self.fileCoordinator coordinateReadingItemAtURL:self.fileURL
  101|      4|                                           options:0
  102|      4|                                             error:&error
  103|      4|                                        byAccessor:^(NSURL *readingURL) {
  104|      4|                                          dict = [self heartbeatDictionaryWithFileURL:readingURL];
  105|      4|                                        }];
  106|      4|  return dict[tag];
  107|      4|}
  108|       |
  109|      0|- (BOOL)setHearbeatDate:(NSDate *)date forTag:(NSString *)tag {
  110|      0|  NSError *error;
  111|      0|  __block BOOL isSuccess = false;
  112|      0|  [self.fileCoordinator coordinateReadingItemAtURL:self.fileURL
  113|      0|                                           options:0
  114|      0|                                  writingItemAtURL:self.fileURL
  115|      0|                                           options:0
  116|      0|                                             error:&error
  117|      0|                                        byAccessor:^(NSURL *readingURL, NSURL *writingURL) {
  118|      0|                                          NSMutableDictionary *dictionary =
  119|      0|                                              [self heartbeatDictionaryWithFileURL:readingURL];
  120|      0|                                          dictionary[tag] = date;
  121|      0|                                          NSError *error;
  122|      0|                                          isSuccess = [self writeDictionary:dictionary
  123|      0|                                                              forWritingURL:writingURL
  124|      0|                                                                      error:&error];
  125|      0|                                        }];
  126|      0|  return isSuccess;
  127|      0|}
  128|       |
  129|       |- (BOOL)writeDictionary:(NSMutableDictionary *)dictionary
  130|       |          forWritingURL:(NSURL *)writingFileURL
  131|      0|                  error:(NSError **)outError {
  132|      0|  NSData *data = [GULSecureCoding archivedDataWithRootObject:dictionary error:outError];
  133|      0|  if (*outError != nil) {
  134|      0|    return false;
  135|      0|  } else {
  136|      0|    return [data writeToURL:writingFileURL atomically:YES];
  137|      0|  }
  138|      0|}
  139|       |
  140|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Environment/GULSecureCoding.m:
    1|       |// Copyright 2019 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Environment/Public/GULSecureCoding.h"
   16|       |
   17|       |NSString *const kGULSecureCodingError = @"GULSecureCodingError";
   18|       |
   19|       |@implementation GULSecureCoding
   20|       |
   21|       |+ (nullable id)unarchivedObjectOfClasses:(NSSet<Class> *)classes
   22|       |                                fromData:(NSData *)data
   23|      4|                                   error:(NSError **)outError {
   24|      4|  id object;
   25|      4|#if __has_builtin(__builtin_available)
   26|      4|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
   27|      4|    object = [NSKeyedUnarchiver unarchivedObjectOfClasses:classes fromData:data error:outError];
   28|      4|  } else
   29|      0|#endif  // __has_builtin(__builtin_available)
   30|      0|  {
   31|      0|    @try {
   32|      0|#pragma clang diagnostic push
   33|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   34|      0|      NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   35|      0|#pragma clang diagnostic pop
   36|      0|      unarchiver.requiresSecureCoding = YES;
   37|      0|
   38|      0|      object = [unarchiver decodeObjectOfClasses:classes forKey:NSKeyedArchiveRootObjectKey];
   39|      0|    } @catch (NSException *exception) {
   40|      0|      if (outError) {
   41|      0|        *outError = [self archivingErrorWithException:exception];
   42|      0|      }
   43|      0|    }
   44|      0|
   45|      0|    if (object == nil && outError && *outError == nil) {
   46|      0|      NSString *failureReason = @"NSKeyedUnarchiver failed to unarchive data.";
   47|      0|      *outError = [NSError errorWithDomain:kGULSecureCodingError
   48|      0|                                      code:-1
   49|      0|                                  userInfo:@{NSLocalizedFailureReasonErrorKey : failureReason}];
   50|      0|    }
   51|      0|  }
   52|      4|
   53|      4|  return object;
   54|      4|}
   55|       |
   56|       |+ (nullable id)unarchivedObjectOfClass:(Class)class
   57|       |                              fromData:(NSData *)data
   58|      0|                                 error:(NSError **)outError {
   59|      0|  return [self unarchivedObjectOfClasses:[NSSet setWithObject:class] fromData:data error:outError];
   60|      0|}
   61|       |
   62|      0|+ (nullable NSData *)archivedDataWithRootObject:(id<NSCoding>)object error:(NSError **)outError {
   63|      0|  NSData *archiveData;
   64|      0|#if __has_builtin(__builtin_available)
   65|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
   66|      0|    archiveData = [NSKeyedArchiver archivedDataWithRootObject:object
   67|      0|                                        requiringSecureCoding:YES
   68|      0|                                                        error:outError];
   69|      0|  } else
   70|      0|#endif  // __has_builtin(__builtin_available)
   71|      0|  {
   72|      0|    @try {
   73|      0|      NSMutableData *data = [NSMutableData data];
   74|      0|#pragma clang diagnostic push
   75|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   76|      0|      NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
   77|      0|#pragma clang diagnostic pop
   78|      0|      archiver.requiresSecureCoding = YES;
   79|      0|
   80|      0|      [archiver encodeObject:object forKey:NSKeyedArchiveRootObjectKey];
   81|      0|      [archiver finishEncoding];
   82|      0|
   83|      0|      archiveData = [data copy];
   84|      0|    } @catch (NSException *exception) {
   85|      0|      if (outError) {
   86|      0|        *outError = [self archivingErrorWithException:exception];
   87|      0|      }
   88|      0|    }
   89|      0|  }
   90|      0|
   91|      0|  return archiveData;
   92|      0|}
   93|       |
   94|      0|+ (NSError *)archivingErrorWithException:(NSException *)exception {
   95|      0|  NSString *failureReason = [NSString
   96|      0|      stringWithFormat:@"NSKeyedArchiver exception with name: %@, reason: %@, userInfo: %@",
   97|      0|                       exception.name, exception.reason, exception.userInfo];
   98|      0|  NSDictionary *errorUserInfo = @{NSLocalizedFailureReasonErrorKey : failureReason};
   99|      0|
  100|      0|  return [NSError errorWithDomain:kGULSecureCodingError code:-1 userInfo:errorUserInfo];
  101|      0|}
  102|       |
  103|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Environment/third_party/GULAppEnvironmentUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Environment/third_party/GULAppEnvironmentUtil.h"
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |#import <dlfcn.h>
   19|       |#import <mach-o/dyld.h>
   20|       |#import <sys/utsname.h>
   21|       |
   22|       |#if TARGET_OS_IOS
   23|       |#import <UIKit/UIKit.h>
   24|       |#endif
   25|       |
   26|       |/// The encryption info struct and constants are missing from the iPhoneSimulator SDK, but not from
   27|       |/// the iPhoneOS or Mac OS X SDKs. Since one doesn't ever ship a Simulator binary, we'll just
   28|       |/// provide the definitions here.
   29|       |#if TARGET_OS_SIMULATOR && !defined(LC_ENCRYPTION_INFO)
   30|       |#define LC_ENCRYPTION_INFO 0x21
   31|       |struct encryption_info_command {
   32|       |  uint32_t cmd;
   33|       |  uint32_t cmdsize;
   34|       |  uint32_t cryptoff;
   35|       |  uint32_t cryptsize;
   36|       |  uint32_t cryptid;
   37|       |};
   38|       |#endif
   39|       |
   40|       |@implementation GULAppEnvironmentUtil
   41|       |
   42|       |/// A key for the Info.plist to enable or disable checking if the App Store is running in a sandbox.
   43|       |/// This will affect your data integrity when using Firebase Analytics, as it will disable some
   44|       |/// necessary checks.
   45|       |static NSString *const kFIRAppStoreReceiptURLCheckEnabledKey =
   46|       |    @"FirebaseAppStoreReceiptURLCheckEnabled";
   47|       |
   48|       |/// The file name of the sandbox receipt. This is available on iOS >= 8.0
   49|       |static NSString *const kFIRAIdentitySandboxReceiptFileName = @"sandboxReceipt";
   50|       |
   51|       |/// The following copyright from Landon J. Fuller applies to the isAppEncrypted function.
   52|       |///
   53|       |/// Copyright (c) 2017 Landon J. Fuller <landon@landonf.org>
   54|       |/// All rights reserved.
   55|       |///
   56|       |/// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
   57|       |/// and associated documentation files (the "Software"), to deal in the Software without
   58|       |/// restriction, including without limitation the rights to use, copy, modify, merge, publish,
   59|       |/// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
   60|       |/// Software is furnished to do so, subject to the following conditions:
   61|       |///
   62|       |/// The above copyright notice and this permission notice shall be included in all copies or
   63|       |/// substantial portions of the Software.
   64|       |///
   65|       |/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
   66|       |/// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   67|       |/// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   68|       |/// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   69|       |/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   70|       |///
   71|       |/// Comment from <a href="http://iphonedevwiki.net/index.php/Crack_prevention">iPhone Dev Wiki
   72|       |/// Crack Prevention</a>:
   73|       |/// App Store binaries are signed by both their developer and Apple. This encrypts the binary so
   74|       |/// that decryption keys are needed in order to make the binary readable. When iOS executes the
   75|       |/// binary, the decryption keys are used to decrypt the binary into a readable state where it is
   76|       |/// then loaded into memory and executed. iOS can tell the encryption status of a binary via the
   77|       |/// cryptid structure member of LC_ENCRYPTION_INFO MachO load command. If cryptid is a non-zero
   78|       |/// value then the binary is encrypted.
   79|       |///
   80|       |/// 'Cracking' works by letting the kernel decrypt the binary then siphoning the decrypted data into
   81|       |/// a new binary file, resigning, and repackaging. This will only work on jailbroken devices as
   82|       |/// codesignature validation has been removed. Resigning takes place because while the codesignature
   83|       |/// doesn't have to be valid thanks to the jailbreak, it does have to be in place unless you have
   84|       |/// AppSync or similar to disable codesignature checks.
   85|       |///
   86|       |/// More information at <a href="http://landonf.org/2009/02/index.html">Landon Fuller's blog</a>
   87|      1|static BOOL IsAppEncrypted() {
   88|      1|  const struct mach_header *executableHeader = NULL;
   89|      2|  for (uint32_t i = 0; i < _dyld_image_count(); i++) {
   90|      2|    const struct mach_header *header = _dyld_get_image_header(i);
   91|      2|    if (header && header->filetype == MH_EXECUTE) {
   92|      1|      executableHeader = header;
   93|      1|      break;
   94|      1|    }
   95|      2|  }
   96|      1|
   97|      1|  if (!executableHeader) {
   98|      0|    return NO;
   99|      0|  }
  100|      1|
  101|      1|  BOOL is64bit = (executableHeader->magic == MH_MAGIC_64);
  102|      1|  uintptr_t cursor = (uintptr_t)executableHeader +
  103|      1|                     (is64bit ? sizeof(struct mach_header_64) : sizeof(struct mach_header));
  104|      1|  const struct segment_command *segmentCommand = NULL;
  105|      1|  uint32_t i = 0;
  106|      1|
  107|     44|  while (i++ < executableHeader->ncmds) {
  108|     43|    segmentCommand = (struct segment_command *)cursor;
  109|     43|
  110|     43|    if (!segmentCommand) {
  111|      0|      continue;
  112|      0|    }
  113|     43|
  114|     43|    if ((!is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO) ||
  115|     43|        (is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO_64)) {
  116|      0|      if (is64bit) {
  117|      0|        struct encryption_info_command_64 *cryptCmd =
  118|      0|            (struct encryption_info_command_64 *)segmentCommand;
  119|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  120|      0|      } else {
  121|      0|        struct encryption_info_command *cryptCmd = (struct encryption_info_command *)segmentCommand;
  122|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  123|      0|      }
  124|     43|    }
  125|     43|    cursor += segmentCommand->cmdsize;
  126|     43|  }
  127|      1|
  128|      1|  return NO;
  129|      1|}
  130|       |
  131|      0|static BOOL HasSCInfoFolder() {
  132|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  133|      0|  NSString *bundlePath = [NSBundle mainBundle].bundlePath;
  134|      0|  NSString *scInfoPath = [bundlePath stringByAppendingPathComponent:@"SC_Info"];
  135|      0|  return [[NSFileManager defaultManager] fileExistsAtPath:scInfoPath];
  136|       |#elif TARGET_OS_OSX
  137|       |  return NO;
  138|       |#endif
  139|       |}
  140|       |
  141|      0|static BOOL HasEmbeddedMobileProvision() {
  142|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  143|      0|  return [[NSBundle mainBundle] pathForResource:@"embedded" ofType:@"mobileprovision"].length > 0;
  144|       |#elif TARGET_OS_OSX
  145|       |  return NO;
  146|       |#endif
  147|       |}
  148|       |
  149|      2|+ (BOOL)isFromAppStore {
  150|      2|  static dispatch_once_t isEncryptedOnce;
  151|      2|  static BOOL isEncrypted = NO;
  152|      2|
  153|      2|  dispatch_once(&isEncryptedOnce, ^{
  154|      1|    isEncrypted = IsAppEncrypted();
  155|      1|  });
  156|      2|
  157|      2|  if ([GULAppEnvironmentUtil isSimulator]) {
  158|      2|    return NO;
  159|      2|  }
  160|      0|
  161|      0|  // If an app contain the sandboxReceipt file, it means its coming from TestFlight
  162|      0|  // This must be checked before the SCInfo Folder check below since TestFlight apps may
  163|      0|  // also have an SCInfo folder.
  164|      0|  if ([GULAppEnvironmentUtil isAppStoreReceiptSandbox]) {
  165|      0|    return NO;
  166|      0|  }
  167|      0|
  168|      0|  if (HasSCInfoFolder()) {
  169|      0|    // When iTunes downloads a .ipa, it also gets a customized .sinf file which is added to the
  170|      0|    // main SC_Info directory.
  171|      0|    return YES;
  172|      0|  }
  173|      0|
  174|      0|  // For iOS >= 8.0, iTunesMetadata.plist is moved outside of the sandbox. Any attempt to read
  175|      0|  // the iTunesMetadata.plist outside of the sandbox will be rejected by Apple.
  176|      0|  // If the app does not contain the embedded.mobileprovision which is stripped out by Apple when
  177|      0|  // the app is submitted to store, then it is highly likely that it is from Apple Store.
  178|      0|  return isEncrypted && !HasEmbeddedMobileProvision();
  179|      0|}
  180|       |
  181|      0|+ (BOOL)isAppStoreReceiptSandbox {
  182|      0|  // Since checking the App Store's receipt URL can be memory intensive, check the option in the
  183|      0|  // Info.plist if developers opted out of this check.
  184|      0|  id enableSandboxCheck =
  185|      0|      [[NSBundle mainBundle] objectForInfoDictionaryKey:kFIRAppStoreReceiptURLCheckEnabledKey];
  186|      0|  if (enableSandboxCheck && [enableSandboxCheck isKindOfClass:[NSNumber class]] &&
  187|      0|      ![enableSandboxCheck boolValue]) {
  188|      0|    return NO;
  189|      0|  }
  190|      0|// The #else is for pre Xcode 9 where @available is not yet implemented.
  191|      0|#if __has_builtin(__builtin_available)
  192|      0|  if (@available(iOS 7.0, *)) {
  193|       |#else
  194|       |  if ([[UIDevice currentDevice].systemVersion integerValue] >= 7) {
  195|       |#endif
  196|       |    NSURL *appStoreReceiptURL = [NSBundle mainBundle].appStoreReceiptURL;
  197|      0|    NSString *appStoreReceiptFileName = appStoreReceiptURL.lastPathComponent;
  198|      0|    return [appStoreReceiptFileName isEqualToString:kFIRAIdentitySandboxReceiptFileName];
  199|      0|  }
  200|      0|  return NO;
  201|      0|}
  202|       |
  203|      2|+ (BOOL)isSimulator {
  204|      2|#if TARGET_OS_IOS || TARGET_OS_TV
  205|      2|  NSString *platform = [GULAppEnvironmentUtil deviceModel];
  206|      2|  return [platform isEqual:@"x86_64"] || [platform isEqual:@"i386"];
  207|       |#elif TARGET_OS_OSX
  208|       |  return NO;
  209|       |#endif
  210|      0|  return NO;
  211|      2|}
  212|       |
  213|      2|+ (NSString *)deviceModel {
  214|      2|  static dispatch_once_t once;
  215|      2|  static NSString *deviceModel;
  216|      2|
  217|      2|  dispatch_once(&once, ^{
  218|      1|    struct utsname systemInfo;
  219|      1|    if (uname(&systemInfo) == 0) {
  220|      1|      deviceModel = [NSString stringWithUTF8String:systemInfo.machine];
  221|      1|    }
  222|      1|  });
  223|      2|  return deviceModel;
  224|      2|}
  225|       |
  226|      3|+ (NSString *)systemVersion {
  227|      3|#if TARGET_OS_IOS
  228|      3|  return [UIDevice currentDevice].systemVersion;
  229|       |#elif TARGET_OS_OSX || TARGET_OS_TV || TARGET_OS_WATCH
  230|       |  // Assemble the systemVersion, excluding the patch version if it's 0.
  231|       |  NSOperatingSystemVersion osVersion = [NSProcessInfo processInfo].operatingSystemVersion;
  232|       |  NSMutableString *versionString = [[NSMutableString alloc]
  233|       |      initWithFormat:@"%ld.%ld", (long)osVersion.majorVersion, (long)osVersion.minorVersion];
  234|       |  if (osVersion.patchVersion != 0) {
  235|       |    [versionString appendFormat:@".%ld", (long)osVersion.patchVersion];
  236|       |  }
  237|       |  return versionString;
  238|       |#endif
  239|       |}
  240|       |
  241|     17|+ (BOOL)isAppExtension {
  242|     17|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  243|     17|  // Documented by <a href="https://goo.gl/RRB2Up">Apple</a>
  244|     17|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  245|     17|  return appExtension;
  246|       |#elif TARGET_OS_OSX
  247|       |  return NO;
  248|       |#endif
  249|       |}
  250|       |
  251|      1|+ (BOOL)isIOS7OrHigher {
  252|      1|#if __has_builtin(__builtin_available)
  253|      1|  if (@available(iOS 7.0, *)) {
  254|       |#else
  255|       |  if ([[UIDevice currentDevice].systemVersion integerValue] >= 7) {
  256|       |#endif
  257|       |      return YES;
  258|      1|    }
  259|      0|
  260|      0|    return NO;
  261|      0|}
  262|       |
  263|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Logger/GULLogger.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Logger/Private/GULLogger.h"
   16|       |
   17|       |#include <asl.h>
   18|       |
   19|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   20|       |#import <GoogleUtilities/GULLoggerLevel.h>
   21|       |
   22|       |/// ASL client facility name used by GULLogger.
   23|       |const char *kGULLoggerASLClientFacilityName = "com.google.utilities.logger";
   24|       |
   25|       |static dispatch_once_t sGULLoggerOnceToken;
   26|       |
   27|       |static aslclient sGULLoggerClient;
   28|       |
   29|       |static dispatch_queue_t sGULClientQueue;
   30|       |
   31|       |static BOOL sGULLoggerDebugMode;
   32|       |
   33|       |static GULLoggerLevel sGULLoggerMaximumLevel;
   34|       |
   35|       |// Allow clients to register a version to include in the log.
   36|       |static const char *sVersion = "";
   37|       |
   38|       |static GULLoggerService kGULLoggerLogger = @"[GULLogger]";
   39|       |
   40|       |#ifdef DEBUG
   41|       |/// The regex pattern for the message code.
   42|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   43|       |static NSRegularExpression *sMessageCodeRegex;
   44|       |#endif
   45|       |
   46|     51|void GULLoggerInitializeASL(void) {
   47|     51|  dispatch_once(&sGULLoggerOnceToken, ^{
   48|      1|    NSInteger majorOSVersion = [[GULAppEnvironmentUtil systemVersion] integerValue];
   49|      1|    uint32_t aslOptions = ASL_OPT_STDERR;
   50|      1|#if TARGET_OS_SIMULATOR
   51|      1|    // The iOS 11 simulator doesn't need the ASL_OPT_STDERR flag.
   52|      1|    if (majorOSVersion >= 11) {
   53|      1|      aslOptions = 0;
   54|      1|    }
   55|       |#else
   56|       |    // Devices running iOS 10 or higher don't need the ASL_OPT_STDERR flag.
   57|       |    if (majorOSVersion >= 10) {
   58|       |      aslOptions = 0;
   59|       |    }
   60|       |#endif  // TARGET_OS_SIMULATOR
   61|       |
   62|      1|#pragma clang diagnostic push
   63|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"  // asl is deprecated
   64|      1|    // Initialize the ASL client handle.
   65|      1|    sGULLoggerClient = asl_open(NULL, kGULLoggerASLClientFacilityName, aslOptions);
   66|      1|    sGULLoggerMaximumLevel = GULLoggerLevelNotice;
   67|      1|
   68|      1|    // Set the filter used by system/device log. Initialize in default mode.
   69|      1|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(ASL_LEVEL_NOTICE));
   70|      1|
   71|      1|    sGULClientQueue = dispatch_queue_create("GULLoggingClientQueue", DISPATCH_QUEUE_SERIAL);
   72|      1|    dispatch_set_target_queue(sGULClientQueue,
   73|      1|                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));
   74|      1|#ifdef DEBUG
   75|      1|    sMessageCodeRegex = [NSRegularExpression regularExpressionWithPattern:kMessageCodePattern
   76|      1|                                                                  options:0
   77|      1|                                                                    error:NULL];
   78|      1|#endif
   79|      1|  });
   80|     51|}
   81|       |
   82|      0|void GULLoggerEnableSTDERR(void) {
   83|      0|  asl_add_log_file(sGULLoggerClient, STDERR_FILENO);
   84|      0|}
   85|       |
   86|      0|void GULLoggerForceDebug(void) {
   87|      0|  // We should enable debug mode if we're not running from App Store.
   88|      0|  if (![GULAppEnvironmentUtil isFromAppStore]) {
   89|      0|    sGULLoggerDebugMode = YES;
   90|      0|    GULSetLoggerLevel(GULLoggerLevelDebug);
   91|      0|  }
   92|      0|}
   93|       |
   94|      0|__attribute__((no_sanitize("thread"))) void GULSetLoggerLevel(GULLoggerLevel loggerLevel) {
   95|      0|  if (loggerLevel < GULLoggerLevelMin || loggerLevel > GULLoggerLevelMax) {
   96|      0|    GULLogError(kGULLoggerLogger, NO, @"I-COR000023", @"Invalid logger level, %ld",
   97|      0|                (long)loggerLevel);
   98|      0|    return;
   99|      0|  }
  100|      0|  GULLoggerInitializeASL();
  101|      0|  // We should not raise the logger level if we are running from App Store.
  102|      0|  if (loggerLevel >= GULLoggerLevelNotice && [GULAppEnvironmentUtil isFromAppStore]) {
  103|      0|    return;
  104|      0|  }
  105|      0|
  106|      0|  sGULLoggerMaximumLevel = loggerLevel;
  107|      0|  dispatch_async(sGULClientQueue, ^{
  108|      0|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(loggerLevel));
  109|      0|  });
  110|      0|}
  111|       |
  112|       |/**
  113|       | * Check if the level is high enough to be loggable.
  114|       | */
  115|     34|__attribute__((no_sanitize("thread"))) BOOL GULIsLoggableLevel(GULLoggerLevel loggerLevel) {
  116|     34|  GULLoggerInitializeASL();
  117|     34|  if (sGULLoggerDebugMode) {
  118|      0|    return YES;
  119|      0|  }
  120|     34|  return (BOOL)(loggerLevel <= sGULLoggerMaximumLevel);
  121|     34|}
  122|       |
  123|       |#ifdef DEBUG
  124|      0|void GULResetLogger() {
  125|      0|  sGULLoggerOnceToken = 0;
  126|      0|}
  127|       |
  128|      0|aslclient getGULLoggerClient() {
  129|      0|  return sGULLoggerClient;
  130|      0|}
  131|       |
  132|      0|dispatch_queue_t getGULClientQueue() {
  133|      0|  return sGULClientQueue;
  134|      0|}
  135|       |
  136|      0|BOOL getGULLoggerDebugMode() {
  137|      0|  return sGULLoggerDebugMode;
  138|      0|}
  139|       |#endif
  140|       |
  141|      1|void GULLoggerRegisterVersion(const char *version) {
  142|      1|  sVersion = version;
  143|      1|}
  144|       |
  145|       |void GULLogBasic(GULLoggerLevel level,
  146|       |                 GULLoggerService service,
  147|       |                 BOOL forceLog,
  148|       |                 NSString *messageCode,
  149|       |                 NSString *message,
  150|     16|                 va_list args_ptr) {
  151|     16|  GULLoggerInitializeASL();
  152|     16|  if (!(level <= sGULLoggerMaximumLevel || sGULLoggerDebugMode || forceLog)) {
  153|     11|    return;
  154|     11|  }
  155|      5|
  156|      5|#ifdef DEBUG
  157|      5|  NSCAssert(messageCode.length == 11, @"Incorrect message code length.");
  158|      5|  NSRange messageCodeRange = NSMakeRange(0, messageCode.length);
  159|      5|  NSUInteger numberOfMatches = [sMessageCodeRegex numberOfMatchesInString:messageCode
  160|      5|                                                                  options:0
  161|      5|                                                                    range:messageCodeRange];
  162|      5|  NSCAssert(numberOfMatches == 1, @"Incorrect message code format.");
  163|      5|#endif
  164|      5|  NSString *logMsg;
  165|      5|  if (args_ptr == NULL) {
  166|      5|    logMsg = message;
  167|      5|  } else {
  168|      0|    logMsg = [[NSString alloc] initWithFormat:message arguments:args_ptr];
  169|      0|  }
  170|      5|  logMsg = [NSString stringWithFormat:@"%s - %@[%@] %@", sVersion, service, messageCode, logMsg];
  171|      5|  dispatch_async(sGULClientQueue, ^{
  172|      5|    asl_log(sGULLoggerClient, NULL, (int)level, "%s", logMsg.UTF8String);
  173|      5|  });
  174|      5|}
  175|       |#pragma clang diagnostic pop
  176|       |
  177|       |/**
  178|       | * Generates the logging functions using macros.
  179|       | *
  180|       | * Calling GULLogError({service}, @"I-XYZ000001", @"Configure %@ failed.", @"blah") shows:
  181|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [{service}][I-XYZ000001] Configure blah failed.
  182|       | * Calling GULLogDebug({service}, @"I-XYZ000001", @"Configure succeed.") shows:
  183|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [{service}][I-XYZ000001] Configure succeed.
  184|       | */
  185|       |#define GUL_LOGGING_FUNCTION(level)                                                     \
  186|       |  void GULLog##level(GULLoggerService service, BOOL force, NSString *messageCode,       \
  187|      6|                     NSString *message, ...) {                                          \
  188|      6|    va_list args_ptr;                                                                   \
  189|      6|    va_start(args_ptr, message);                                                        \
  190|      6|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  191|      6|    va_end(args_ptr);                                                                   \
  192|      6|  }
  ------------------
  | Unexecuted instantiation: GULLogError
  ------------------
  | Unexecuted instantiation: GULLogWarning
  ------------------
  | Unexecuted instantiation: GULLogNotice
  ------------------
  | Unexecuted instantiation: GULLogInfo
  ------------------
  | GULLogDebug:
  |  187|      6|                     NSString *message, ...) {                                          \
  |  188|      6|    va_list args_ptr;                                                                   \
  |  189|      6|    va_start(args_ptr, message);                                                        \
  |  190|      6|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  |  191|      6|    va_end(args_ptr);                                                                   \
  |  192|      6|  }
  ------------------
  193|       |
  194|       |GUL_LOGGING_FUNCTION(Error)
  195|       |GUL_LOGGING_FUNCTION(Warning)
  196|       |GUL_LOGGING_FUNCTION(Notice)
  197|       |GUL_LOGGING_FUNCTION(Info)
  198|       |GUL_LOGGING_FUNCTION(Debug)
  199|       |
  200|       |#undef GUL_MAKE_LOGGER
  201|       |
  202|       |#pragma mark - GULLoggerWrapper
  203|       |
  204|       |@implementation GULLoggerWrapper
  205|       |
  206|       |+ (void)logWithLevel:(GULLoggerLevel)level
  207|       |         withService:(GULLoggerService)service
  208|       |            withCode:(NSString *)messageCode
  209|       |         withMessage:(NSString *)message
  210|      0|            withArgs:(va_list)args {
  211|      0|  GULLogBasic(level, service, NO, messageCode, message, args);
  212|      0|}
  213|       |
  214|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/MethodSwizzler/GULSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/MethodSwizzler/Private/GULSwizzler.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |#ifdef DEBUG
   20|       |#import <GoogleUtilities/GULLogger.h>
   21|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   22|       |
   23|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/MethodSwizzler]";
   24|       |#endif
   25|       |
   26|      4|dispatch_queue_t GetGULSwizzlingQueue(void) {
   27|      4|  static dispatch_queue_t queue;
   28|      4|  static dispatch_once_t onceToken;
   29|      4|  dispatch_once(&onceToken, ^{
   30|      1|    queue = dispatch_queue_create("com.google.GULSwizzler", DISPATCH_QUEUE_SERIAL);
   31|      1|  });
   32|      4|  return queue;
   33|      4|}
   34|       |
   35|       |@implementation GULSwizzler
   36|       |
   37|       |+ (void)swizzleClass:(Class)aClass
   38|       |            selector:(SEL)selector
   39|       |     isClassSelector:(BOOL)isClassSelector
   40|      2|           withBlock:(nullable id)block {
   41|      2|  dispatch_sync(GetGULSwizzlingQueue(), ^{
   42|      2|    NSAssert(selector, @"The selector cannot be NULL");
   43|      2|    NSAssert(aClass, @"The class cannot be Nil");
   44|      2|    Class resolvedClass = aClass;
   45|      2|    Method method = nil;
   46|      2|    if (isClassSelector) {
   47|      0|      method = class_getClassMethod(aClass, selector);
   48|      0|      resolvedClass = object_getClass(aClass);
   49|      2|    } else {
   50|      2|      method = class_getInstanceMethod(aClass, selector);
   51|      2|    }
   52|      2|    NSAssert(method, @"You're attempting to swizzle a method that doesn't exist. (%@, %@)",
   53|      2|             NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   54|      2|    IMP newImp = imp_implementationWithBlock(block);
   55|      2|#ifdef DEBUG
   56|      2|    IMP currentImp = class_getMethodImplementation(resolvedClass, selector);
   57|      2|    Class class = NSClassFromString(@"GULSwizzlingCache");
   58|      2|    if (class) {
   59|      0|      SEL cacheSelector = NSSelectorFromString(@"cacheCurrentIMP:forNewIMP:forClass:withSelector:");
   60|      0|      NSMethodSignature *methodSignature = [class methodSignatureForSelector:cacheSelector];
   61|      0|      if (methodSignature != nil) {
   62|      0|        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:methodSignature];
   63|      0|        [inv setSelector:cacheSelector];
   64|      0|        [inv setTarget:class];
   65|      0|        [inv setArgument:&(currentImp) atIndex:2];
   66|      0|        [inv setArgument:&(newImp) atIndex:3];
   67|      0|        [inv setArgument:&(resolvedClass) atIndex:4];
   68|      0|        [inv setArgument:(void *_Nonnull) & (selector) atIndex:5];
   69|      0|        [inv invoke];
   70|      0|      }
   71|      0|    }
   72|      2|#endif
   73|      2|
   74|      2|    const char *typeEncoding = method_getTypeEncoding(method);
   75|      2|    __unused IMP originalImpOfClass =
   76|      2|        class_replaceMethod(resolvedClass, selector, newImp, typeEncoding);
   77|      2|
   78|      2|#ifdef DEBUG
   79|      2|    // If !originalImpOfClass, then the IMP came from a superclass.
   80|      2|    if (originalImpOfClass) {
   81|      2|      SEL selector = NSSelectorFromString(@"originalIMPOfCurrentIMP:");
   82|      2|      NSMethodSignature *methodSignature = [class methodSignatureForSelector:selector];
   83|      2|      if (methodSignature != nil) {
   84|      0|        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:methodSignature];
   85|      0|        [inv setSelector:selector];
   86|      0|        [inv setTarget:class];
   87|      0|        [inv setArgument:&(currentImp) atIndex:2];
   88|      0|        [inv invoke];
   89|      0|        IMP testOriginal;
   90|      0|        [inv getReturnValue:&testOriginal];
   91|      0|        if (originalImpOfClass != testOriginal) {
   92|      0|          GULLogWarning(kGULLoggerSwizzler, NO,
   93|      0|                        [NSString stringWithFormat:@"I-SWZ%06ld",
   94|      0|                                                   (long)kGULSwizzlerMessageCodeMethodSwizzling000],
   95|      0|                        @"Swizzling class: %@ SEL:%@ after it has been previously been swizzled.",
   96|      0|                        NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   97|      0|        }
   98|      0|      }
   99|      2|    }
  100|      2|#endif
  101|      2|  });
  102|      2|}
  103|       |
  104|       |+ (nullable IMP)currentImplementationForClass:(Class)aClass
  105|       |                                     selector:(SEL)selector
  106|      2|                              isClassSelector:(BOOL)isClassSelector {
  107|      2|  NSAssert(selector, @"The selector cannot be NULL");
  108|      2|  NSAssert(aClass, @"The class cannot be Nil");
  109|      2|  if (selector == NULL || aClass == nil) {
  110|      0|    return nil;
  111|      0|  }
  112|      2|  __block IMP currentIMP = nil;
  113|      2|  dispatch_sync(GetGULSwizzlingQueue(), ^{
  114|      2|    Method method = nil;
  115|      2|    if (isClassSelector) {
  116|      0|      method = class_getClassMethod(aClass, selector);
  117|      2|    } else {
  118|      2|      method = class_getInstanceMethod(aClass, selector);
  119|      2|    }
  120|      2|    NSAssert(method, @"The Method for this class/selector combo doesn't exist (%@, %@).",
  121|      2|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  122|      2|    if (method == nil) {
  123|      0|      return;
  124|      0|    }
  125|      2|    currentIMP = method_getImplementation(method);
  126|      2|    NSAssert(currentIMP, @"The IMP for this class/selector combo doesn't exist (%@, %@).",
  127|      2|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  128|      2|  });
  129|      2|  return currentIMP;
  130|      2|}
  131|       |
  132|      0|+ (BOOL)selector:(SEL)selector existsInClass:(Class)aClass isClassSelector:(BOOL)isClassSelector {
  133|      0|  Method method = isClassSelector ? class_getClassMethod(aClass, selector)
  134|      0|                                  : class_getInstanceMethod(aClass, selector);
  135|      0|  return method != nil;
  136|      0|}
  137|       |
  138|      0|+ (NSArray<id> *)ivarObjectsForObject:(id)object {
  139|      0|  NSMutableArray *array = [NSMutableArray array];
  140|      0|  unsigned int count;
  141|      0|  Ivar *vars = class_copyIvarList([object class], &count);
  142|      0|  for (NSUInteger i = 0; i < count; i++) {
  143|      0|    const char *typeEncoding = ivar_getTypeEncoding(vars[i]);
  144|      0|    // Check to see if the ivar is an object.
  145|      0|    if (strncmp(typeEncoding, "@", 1) == 0) {
  146|      0|      id ivarObject = object_getIvar(object, vars[i]);
  147|      0|      [array addObject:ivarObject];
  148|      0|    }
  149|      0|  }
  150|      0|  free(vars);
  151|      0|  return array;
  152|      0|}
  153|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/NSData+zlib/GULNSData+zlib.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/NSData+zlib/GULNSData+zlib.h"
   16|       |
   17|       |#import <zlib.h>
   18|       |
   19|      0|#define kChunkSize 1024
   20|      0|#define Z_DEFAULT_COMPRESSION (-1)
   21|       |
   22|       |NSString *const GULNSDataZlibErrorDomain = @"com.google.GULNSDataZlibErrorDomain";
   23|       |NSString *const GULNSDataZlibErrorKey = @"GULNSDataZlibErrorKey";
   24|       |NSString *const GULNSDataZlibRemainingBytesKey = @"GULNSDataZlibRemainingBytesKey";
   25|       |
   26|       |@implementation NSData (GULGzip)
   27|       |
   28|      0|+ (NSData *)gul_dataByInflatingGzippedData:(NSData *)data error:(NSError **)error {
   29|      0|  const void *bytes = [data bytes];
   30|      0|  NSUInteger length = [data length];
   31|      0|  if (!bytes || !length) {
   32|      0|    return nil;
   33|      0|  }
   34|      0|
   35|      0|#if defined(__LP64__) && __LP64__
   36|      0|  // Don't support > 32bit length for 64 bit, see note in header.
   37|      0|  if (length > UINT_MAX) {
   38|      0|    return nil;
   39|      0|  }
   40|      0|#endif
   41|      0|
   42|      0|  z_stream strm;
   43|      0|  bzero(&strm, sizeof(z_stream));
   44|      0|
   45|      0|  // Setup the input.
   46|      0|  strm.avail_in = (unsigned int)length;
   47|      0|  strm.next_in = (unsigned char *)bytes;
   48|      0|
   49|      0|  int windowBits = 15;  // 15 to enable any window size
   50|      0|  windowBits += 32;     // and +32 to enable zlib or gzip header detection.
   51|      0|
   52|      0|  int retCode;
   53|      0|  if ((retCode = inflateInit2(&strm, windowBits)) != Z_OK) {
   54|      0|    if (error) {
   55|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   56|      0|                                                           forKey:GULNSDataZlibErrorKey];
   57|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   58|      0|                                   code:GULNSDataZlibErrorInternal
   59|      0|                               userInfo:userInfo];
   60|      0|    }
   61|      0|    return nil;
   62|      0|  }
   63|      0|
   64|      0|  // Hint the size at 4x the input size.
   65|      0|  NSMutableData *result = [NSMutableData dataWithCapacity:(length * 4)];
   66|      0|  unsigned char output[kChunkSize];
   67|      0|
   68|      0|  // Loop to collect the data.
   69|      0|  do {
   70|      0|    // Update what we're passing in.
   71|      0|    strm.avail_out = kChunkSize;
   72|      0|    strm.next_out = output;
   73|      0|    retCode = inflate(&strm, Z_NO_FLUSH);
   74|      0|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   75|      0|      if (error) {
   76|      0|        NSMutableDictionary *userInfo =
   77|      0|            [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   78|      0|                                               forKey:GULNSDataZlibErrorKey];
   79|      0|        if (strm.msg) {
   80|      0|          NSString *message = [NSString stringWithUTF8String:strm.msg];
   81|      0|          if (message) {
   82|      0|            [userInfo setObject:message forKey:NSLocalizedDescriptionKey];
   83|      0|          }
   84|      0|        }
   85|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   86|      0|                                     code:GULNSDataZlibErrorInternal
   87|      0|                                 userInfo:userInfo];
   88|      0|      }
   89|      0|      inflateEnd(&strm);
   90|      0|      return nil;
   91|      0|    }
   92|      0|    // Collect what we got.
   93|      0|    unsigned gotBack = kChunkSize - strm.avail_out;
   94|      0|    if (gotBack > 0) {
   95|      0|      [result appendBytes:output length:gotBack];
   96|      0|    }
   97|      0|
   98|      0|  } while (retCode == Z_OK);
   99|      0|
  100|      0|  // Make sure there wasn't more data tacked onto the end of a valid compressed stream.
  101|      0|  if (strm.avail_in != 0) {
  102|      0|    if (error) {
  103|      0|      NSDictionary *userInfo =
  104|      0|          [NSDictionary dictionaryWithObject:[NSNumber numberWithUnsignedInt:strm.avail_in]
  105|      0|                                      forKey:GULNSDataZlibRemainingBytesKey];
  106|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  107|      0|                                   code:GULNSDataZlibErrorDataRemaining
  108|      0|                               userInfo:userInfo];
  109|      0|    }
  110|      0|    result = nil;
  111|      0|  }
  112|      0|  // The only way out of the loop was by hitting the end of the stream.
  113|      0|  NSAssert(retCode == Z_STREAM_END,
  114|      0|           @"Thought we finished inflate w/o getting a result of stream end, code %d", retCode);
  115|      0|
  116|      0|  // Clean up.
  117|      0|  inflateEnd(&strm);
  118|      0|
  119|      0|  return result;
  120|      0|}
  121|       |
  122|      0|+ (NSData *)gul_dataByGzippingData:(NSData *)data error:(NSError **)error {
  123|      0|  const void *bytes = [data bytes];
  124|      0|  NSUInteger length = [data length];
  125|      0|
  126|      0|  int level = Z_DEFAULT_COMPRESSION;
  127|      0|  if (!bytes || !length) {
  128|      0|    return nil;
  129|      0|  }
  130|      0|
  131|      0|#if defined(__LP64__) && __LP64__
  132|      0|  // Don't support > 32bit length for 64 bit, see note in header.
  133|      0|  if (length > UINT_MAX) {
  134|      0|    if (error) {
  135|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  136|      0|                                   code:GULNSDataZlibErrorGreaterThan32BitsToCompress
  137|      0|                               userInfo:nil];
  138|      0|    }
  139|      0|    return nil;
  140|      0|  }
  141|      0|#endif
  142|      0|
  143|      0|  z_stream strm;
  144|      0|  bzero(&strm, sizeof(z_stream));
  145|      0|
  146|      0|  int memLevel = 8;          // Default.
  147|      0|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
  148|      0|
  149|      0|  int retCode;
  150|      0|  if ((retCode = deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel,
  151|      0|                              Z_DEFAULT_STRATEGY)) != Z_OK) {
  152|      0|    if (error) {
  153|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  154|      0|                                                           forKey:GULNSDataZlibErrorKey];
  155|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  156|      0|                                   code:GULNSDataZlibErrorInternal
  157|      0|                               userInfo:userInfo];
  158|      0|    }
  159|      0|    return nil;
  160|      0|  }
  161|      0|
  162|      0|  // Hint the size at 1/4 the input size.
  163|      0|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
  164|      0|  unsigned char output[kChunkSize];
  165|      0|
  166|      0|  // Setup the input.
  167|      0|  strm.avail_in = (unsigned int)length;
  168|      0|  strm.next_in = (unsigned char *)bytes;
  169|      0|
  170|      0|  // Collect the data.
  171|      0|  do {
  172|      0|    // update what we're passing in
  173|      0|    strm.avail_out = kChunkSize;
  174|      0|    strm.next_out = output;
  175|      0|    retCode = deflate(&strm, Z_FINISH);
  176|      0|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
  177|      0|      if (error) {
  178|      0|        NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  179|      0|                                                             forKey:GULNSDataZlibErrorKey];
  180|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  181|      0|                                     code:GULNSDataZlibErrorInternal
  182|      0|                                 userInfo:userInfo];
  183|      0|      }
  184|      0|      deflateEnd(&strm);
  185|      0|      return nil;
  186|      0|    }
  187|      0|    // Collect what we got.
  188|      0|    unsigned gotBack = kChunkSize - strm.avail_out;
  189|      0|    if (gotBack > 0) {
  190|      0|      [result appendBytes:output length:gotBack];
  191|      0|    }
  192|      0|
  193|      0|  } while (retCode == Z_OK);
  194|      0|
  195|      0|  // If the loop exits, it used all input and the stream ended.
  196|      0|  NSAssert(strm.avail_in == 0,
  197|      0|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
  198|      0|  NSAssert(retCode == Z_STREAM_END,
  199|      0|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
  200|      0|
  201|      0|  // Clean up.
  202|      0|  deflateEnd(&strm);
  203|      0|
  204|      0|  return result;
  205|      0|}
  206|       |
  207|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Network/GULMutableDictionary.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Network/Private/GULMutableDictionary.h"
   16|       |
   17|       |@implementation GULMutableDictionary {
   18|       |  /// The mutable dictionary.
   19|       |  NSMutableDictionary *_objects;
   20|       |
   21|       |  /// Serial synchronization queue. All reads should use dispatch_sync, while writes use
   22|       |  /// dispatch_async.
   23|       |  dispatch_queue_t _queue;
   24|       |}
   25|       |
   26|     22|- (instancetype)init {
   27|     22|  self = [super init];
   28|     22|
   29|     22|  if (self) {
   30|     22|    _objects = [[NSMutableDictionary alloc] init];
   31|     22|    _queue = dispatch_queue_create("GULMutableDictionary", DISPATCH_QUEUE_SERIAL);
   32|     22|  }
   33|     22|
   34|     22|  return self;
   35|     22|}
   36|       |
   37|      0|- (NSString *)description {
   38|      0|  __block NSString *description;
   39|      0|  dispatch_sync(_queue, ^{
   40|      0|    description = self->_objects.description;
   41|      0|  });
   42|      0|  return description;
   43|      0|}
   44|       |
   45|      0|- (id)objectForKey:(id)key {
   46|      0|  __block id object;
   47|      0|  dispatch_sync(_queue, ^{
   48|      0|    object = [self->_objects objectForKey:key];
   49|      0|  });
   50|      0|  return object;
   51|      0|}
   52|       |
   53|      0|- (void)setObject:(id)object forKey:(id<NSCopying>)key {
   54|      0|  dispatch_async(_queue, ^{
   55|      0|    [self->_objects setObject:object forKey:key];
   56|      0|  });
   57|      0|}
   58|       |
   59|      0|- (void)removeObjectForKey:(id)key {
   60|      0|  dispatch_async(_queue, ^{
   61|      0|    [self->_objects removeObjectForKey:key];
   62|      0|  });
   63|      0|}
   64|       |
   65|      2|- (void)removeAllObjects {
   66|      2|  dispatch_async(_queue, ^{
   67|      2|    [self->_objects removeAllObjects];
   68|      2|  });
   69|      2|}
   70|       |
   71|      1|- (NSUInteger)count {
   72|      1|  __block NSUInteger count;
   73|      1|  dispatch_sync(_queue, ^{
   74|      1|    count = self->_objects.count;
   75|      1|  });
   76|      1|  return count;
   77|      1|}
   78|       |
   79|     26|- (id)objectForKeyedSubscript:(id<NSCopying>)key {
   80|     26|  __block id object;
   81|     26|  dispatch_sync(_queue, ^{
   82|     26|    object = self->_objects[key];
   83|     26|  });
   84|     26|  return object;
   85|     26|}
   86|       |
   87|     45|- (void)setObject:(id)obj forKeyedSubscript:(id<NSCopying>)key {
   88|     45|  dispatch_async(_queue, ^{
   89|     45|    self->_objects[key] = obj;
   90|     45|  });
   91|     45|}
   92|       |
   93|      6|- (NSDictionary *)dictionary {
   94|      6|  __block NSDictionary *dictionary;
   95|      6|  dispatch_sync(_queue, ^{
   96|      6|    dictionary = [self->_objects copy];
   97|      6|  });
   98|      6|  return dictionary;
   99|      6|}
  100|       |
  101|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetwork.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Network/Private/GULNetwork.h"
   16|       |#import "GoogleUtilities/Network/Private/GULNetworkMessageCode.h"
   17|       |
   18|       |#import <GoogleUtilities/GULLogger.h>
   19|       |#import <GoogleUtilities/GULNSData+zlib.h>
   20|       |#import <GoogleUtilities/GULReachabilityChecker.h>
   21|       |#import "GoogleUtilities/Network/Private/GULMutableDictionary.h"
   22|       |#import "GoogleUtilities/Network/Private/GULNetworkConstants.h"
   23|       |
   24|       |/// Constant string for request header Content-Encoding.
   25|       |static NSString *const kGULNetworkContentCompressionKey = @"Content-Encoding";
   26|       |
   27|       |/// Constant string for request header Content-Encoding value.
   28|       |static NSString *const kGULNetworkContentCompressionValue = @"gzip";
   29|       |
   30|       |/// Constant string for request header Content-Length.
   31|       |static NSString *const kGULNetworkContentLengthKey = @"Content-Length";
   32|       |
   33|       |/// Constant string for request header Content-Type.
   34|       |static NSString *const kGULNetworkContentTypeKey = @"Content-Type";
   35|       |
   36|       |/// Constant string for request header Content-Type value.
   37|       |static NSString *const kGULNetworkContentTypeValue = @"application/x-www-form-urlencoded";
   38|       |
   39|       |/// Constant string for GET request method.
   40|       |static NSString *const kGULNetworkGETRequestMethod = @"GET";
   41|       |
   42|       |/// Constant string for POST request method.
   43|       |static NSString *const kGULNetworkPOSTRequestMethod = @"POST";
   44|       |
   45|       |/// Default constant string as a prefix for network logger.
   46|       |static NSString *const kGULNetworkLogTag = @"Google/Utilities/Network";
   47|       |
   48|       |@interface GULNetwork () <GULReachabilityDelegate, GULNetworkLoggerDelegate>
   49|       |@end
   50|       |
   51|       |@implementation GULNetwork {
   52|       |  /// Network reachability.
   53|       |  GULReachabilityChecker *_reachability;
   54|       |
   55|       |  /// The dictionary of requests by session IDs { NSString : id }.
   56|       |  GULMutableDictionary *_requests;
   57|       |}
   58|       |
   59|      0|- (instancetype)init {
   60|      0|  return [self initWithReachabilityHost:kGULNetworkReachabilityHost];
   61|      0|}
   62|       |
   63|      2|- (instancetype)initWithReachabilityHost:(NSString *)reachabilityHost {
   64|      2|  self = [super init];
   65|      2|  if (self) {
   66|      2|    // Setup reachability.
   67|      2|    _reachability = [[GULReachabilityChecker alloc] initWithReachabilityDelegate:self
   68|      2|                                                                        withHost:reachabilityHost];
   69|      2|    if (![_reachability start]) {
   70|      0|      return nil;
   71|      0|    }
   72|      2|
   73|      2|    _requests = [[GULMutableDictionary alloc] init];
   74|      2|    _timeoutInterval = kGULNetworkTimeOutInterval;
   75|      2|  }
   76|      2|  return self;
   77|      2|}
   78|       |
   79|      0|- (void)dealloc {
   80|      0|  _reachability.reachabilityDelegate = nil;
   81|      0|  [_reachability stop];
   82|      0|}
   83|       |
   84|       |#pragma mark - External Methods
   85|       |
   86|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   87|      0|                            completionHandler:(GULNetworkSystemCompletionHandler)completionHandler {
   88|      0|  [GULNetworkURLSession handleEventsForBackgroundURLSessionID:sessionID
   89|      0|                                            completionHandler:completionHandler];
   90|      0|}
   91|       |
   92|       |- (NSString *)postURL:(NSURL *)url
   93|       |                   payload:(NSData *)payload
   94|       |                     queue:(dispatch_queue_t)queue
   95|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
   96|      0|         completionHandler:(GULNetworkCompletionHandler)handler {
   97|      0|  if (!url.absoluteString.length) {
   98|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
   99|      0|    return nil;
  100|      0|  }
  101|      0|
  102|      0|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  103|      0|
  104|      0|  NSMutableURLRequest *request =
  105|      0|      [[NSMutableURLRequest alloc] initWithURL:url
  106|      0|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  107|      0|                               timeoutInterval:timeOutInterval];
  108|      0|
  109|      0|  if (!request) {
  110|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  111|      0|                        queue:queue
  112|      0|                  withHandler:handler];
  113|      0|    return nil;
  114|      0|  }
  115|      0|
  116|      0|  NSError *compressError = nil;
  117|      0|  NSData *compressedData = [NSData gul_dataByGzippingData:payload error:&compressError];
  118|      0|  if (!compressedData || compressError) {
  119|      0|    if (compressError || payload.length > 0) {
  120|      0|      // If the payload is not empty but it fails to compress the payload, something has been wrong.
  121|      0|      [self handleErrorWithCode:GULErrorCodeNetworkPayloadCompression
  122|      0|                          queue:queue
  123|      0|                    withHandler:handler];
  124|      0|      return nil;
  125|      0|    }
  126|      0|    compressedData = [[NSData alloc] init];
  127|      0|  }
  128|      0|
  129|      0|  NSString *postLength = @(compressedData.length).stringValue;
  130|      0|
  131|      0|  // Set up the request with the compressed data.
  132|      0|  [request setValue:postLength forHTTPHeaderField:kGULNetworkContentLengthKey];
  133|      0|  request.HTTPBody = compressedData;
  134|      0|  request.HTTPMethod = kGULNetworkPOSTRequestMethod;
  135|      0|  [request setValue:kGULNetworkContentTypeValue forHTTPHeaderField:kGULNetworkContentTypeKey];
  136|      0|  [request setValue:kGULNetworkContentCompressionValue
  137|      0|      forHTTPHeaderField:kGULNetworkContentCompressionKey];
  138|      0|
  139|      0|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  140|      0|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  141|      0|
  142|      0|  __weak GULNetwork *weakSelf = self;
  143|      0|  NSString *requestID = [fetcher
  144|      0|      sessionIDFromAsyncPOSTRequest:request
  145|      0|                  completionHandler:^(NSHTTPURLResponse *response, NSData *data,
  146|      0|                                      NSString *sessionID, NSError *error) {
  147|      0|                    GULNetwork *strongSelf = weakSelf;
  148|      0|                    if (!strongSelf) {
  149|      0|                      return;
  150|      0|                    }
  151|      0|                    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  152|      0|                    dispatch_async(queueToDispatch, ^{
  153|      0|                      if (sessionID.length) {
  154|      0|                        [strongSelf->_requests removeObjectForKey:sessionID];
  155|      0|                      }
  156|      0|                      if (handler) {
  157|      0|                        handler(response, data, error);
  158|      0|                      }
  159|      0|                    });
  160|      0|                  }];
  161|      0|  if (!requestID) {
  162|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  163|      0|                        queue:queue
  164|      0|                  withHandler:handler];
  165|      0|    return nil;
  166|      0|  }
  167|      0|
  168|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  169|      0|                    messageCode:kGULNetworkMessageCodeNetwork000
  170|      0|                        message:@"Uploading data. Host"
  171|      0|                        context:url];
  172|      0|  _requests[requestID] = fetcher;
  173|      0|  return requestID;
  174|      0|}
  175|       |
  176|       |- (NSString *)getURL:(NSURL *)url
  177|       |                   headers:(NSDictionary *)headers
  178|       |                     queue:(dispatch_queue_t)queue
  179|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
  180|      1|         completionHandler:(GULNetworkCompletionHandler)handler {
  181|      1|  if (!url.absoluteString.length) {
  182|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
  183|      0|    return nil;
  184|      0|  }
  185|      1|
  186|      1|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  187|      1|  NSMutableURLRequest *request =
  188|      1|      [[NSMutableURLRequest alloc] initWithURL:url
  189|      1|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  190|      1|                               timeoutInterval:timeOutInterval];
  191|      1|
  192|      1|  if (!request) {
  193|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  194|      0|                        queue:queue
  195|      0|                  withHandler:handler];
  196|      0|    return nil;
  197|      0|  }
  198|      1|
  199|      1|  request.HTTPMethod = kGULNetworkGETRequestMethod;
  200|      1|  request.allHTTPHeaderFields = headers;
  201|      1|
  202|      1|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  203|      1|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  204|      1|
  205|      1|  __weak GULNetwork *weakSelf = self;
  206|      1|  NSString *requestID = [fetcher
  207|      1|      sessionIDFromAsyncGETRequest:request
  208|      1|                 completionHandler:^(NSHTTPURLResponse *response, NSData *data, NSString *sessionID,
  209|      1|                                     NSError *error) {
  210|      0|                   GULNetwork *strongSelf = weakSelf;
  211|      0|                   if (!strongSelf) {
  212|      0|                     return;
  213|      0|                   }
  214|      0|                   dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  215|      0|                   dispatch_async(queueToDispatch, ^{
  216|      0|                     if (sessionID.length) {
  217|      0|                       [strongSelf->_requests removeObjectForKey:sessionID];
  218|      0|                     }
  219|      0|                     if (handler) {
  220|      0|                       handler(response, data, error);
  221|      0|                     }
  222|      0|                   });
  223|      0|                 }];
  224|      1|
  225|      1|  if (!requestID) {
  226|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  227|      0|                        queue:queue
  228|      0|                  withHandler:handler];
  229|      0|    return nil;
  230|      0|  }
  231|      1|
  232|      1|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  233|      1|                    messageCode:kGULNetworkMessageCodeNetwork001
  234|      1|                        message:@"Downloading data. Host"
  235|      1|                        context:url];
  236|      1|  _requests[requestID] = fetcher;
  237|      1|  return requestID;
  238|      1|}
  239|       |
  240|      1|- (BOOL)hasUploadInProgress {
  241|      1|  return _requests.count > 0;
  242|      1|}
  243|       |
  244|       |#pragma mark - Network Reachability
  245|       |
  246|       |/// Tells reachability delegate to call reachabilityDidChangeToStatus: to notify the network
  247|       |/// reachability has changed.
  248|       |- (void)reachability:(GULReachabilityChecker *)reachability
  249|      2|       statusChanged:(GULReachabilityStatus)status {
  250|      2|  _networkConnected = (status == kGULReachabilityViaCellular || status == kGULReachabilityViaWifi);
  251|      2|  [_reachabilityDelegate reachabilityDidChange];
  252|      2|}
  253|       |
  254|       |#pragma mark - Network logger delegate
  255|       |
  256|      1|- (void)setLoggerDelegate:(id<GULNetworkLoggerDelegate>)loggerDelegate {
  257|      1|  // Explicitly check whether the delegate responds to the methods because conformsToProtocol does
  258|      1|  // not work correctly even though the delegate does respond to the methods.
  259|      1|  if (!loggerDelegate ||
  260|      1|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  261|      1|                                                                messageCode:message:contexts:)] ||
  262|      1|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  263|      1|                                                                messageCode:message:context:)] ||
  264|      1|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  265|      1|                                                                messageCode:message:)]) {
  266|      0|    GULLogError(kGULLoggerNetwork, NO,
  267|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork002],
  268|      0|                @"Cannot set the network logger delegate: delegate does not conform to the network "
  269|      0|                 "logger protocol.");
  270|      0|    return;
  271|      0|  }
  272|      1|  _loggerDelegate = loggerDelegate;
  273|      1|}
  274|       |
  275|       |#pragma mark - Private methods
  276|       |
  277|       |/// Handles network error and calls completion handler with the error.
  278|       |- (void)handleErrorWithCode:(NSInteger)code
  279|       |                      queue:(dispatch_queue_t)queue
  280|      0|                withHandler:(GULNetworkCompletionHandler)handler {
  281|      0|  NSDictionary *userInfo = @{kGULNetworkErrorContext : @"Failed to create network request"};
  282|      0|  NSError *error = [[NSError alloc] initWithDomain:kGULNetworkErrorDomain
  283|      0|                                              code:code
  284|      0|                                          userInfo:userInfo];
  285|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  286|      0|                    messageCode:kGULNetworkMessageCodeNetwork002
  287|      0|                        message:@"Failed to create network request. Code, error"
  288|      0|                       contexts:@[ @(code), error ]];
  289|      0|  if (handler) {
  290|      0|    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  291|      0|    dispatch_async(queueToDispatch, ^{
  292|      0|      handler(nil, nil, error);
  293|      0|    });
  294|      0|  }
  295|      0|}
  296|       |
  297|       |#pragma mark - Network logger
  298|       |
  299|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  300|       |                    messageCode:(GULNetworkMessageCode)messageCode
  301|       |                        message:(NSString *)message
  302|      0|                       contexts:(NSArray *)contexts {
  303|      0|  // Let the delegate log the message if there is a valid logger delegate. Otherwise, just log
  304|      0|  // errors/warnings/info messages to the console log.
  305|      0|  if (_loggerDelegate) {
  306|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  307|      0|                                 messageCode:messageCode
  308|      0|                                     message:message
  309|      0|                                    contexts:contexts];
  310|      0|    return;
  311|      0|  }
  312|      0|  if (_isDebugModeEnabled || logLevel == kGULNetworkLogLevelError ||
  313|      0|      logLevel == kGULNetworkLogLevelWarning || logLevel == kGULNetworkLogLevelInfo) {
  314|      0|    NSString *formattedMessage = GULStringWithLogMessage(message, logLevel, contexts);
  315|      0|    NSLog(@"%@", formattedMessage);
  316|      0|    GULLogBasic((GULLoggerLevel)logLevel, kGULLoggerNetwork, NO,
  317|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)messageCode], formattedMessage,
  318|      0|                NULL);
  319|      0|  }
  320|      0|}
  321|       |
  322|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  323|       |                    messageCode:(GULNetworkMessageCode)messageCode
  324|       |                        message:(NSString *)message
  325|      2|                        context:(id)context {
  326|      2|  if (_loggerDelegate) {
  327|      2|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  328|      2|                                 messageCode:messageCode
  329|      2|                                     message:message
  330|      2|                                     context:context];
  331|      2|    return;
  332|      2|  }
  333|      0|  NSArray *contexts = context ? @[ context ] : @[];
  334|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:contexts];
  335|      0|}
  336|       |
  337|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  338|       |                    messageCode:(GULNetworkMessageCode)messageCode
  339|      0|                        message:(NSString *)message {
  340|      0|  if (_loggerDelegate) {
  341|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message];
  342|      0|    return;
  343|      0|  }
  344|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:@[]];
  345|      0|}
  346|       |
  347|       |/// Returns a string for the given log level (e.g. kGULNetworkLogLevelError -> @"ERROR").
  348|      0|static NSString *GULLogLevelDescriptionFromLogLevel(GULNetworkLogLevel logLevel) {
  349|      0|  static NSDictionary *levelNames = nil;
  350|      0|  static dispatch_once_t onceToken;
  351|      0|  dispatch_once(&onceToken, ^{
  352|      0|    levelNames = @{
  353|      0|      @(kGULNetworkLogLevelError) : @"ERROR",
  354|      0|      @(kGULNetworkLogLevelWarning) : @"WARNING",
  355|      0|      @(kGULNetworkLogLevelInfo) : @"INFO",
  356|      0|      @(kGULNetworkLogLevelDebug) : @"DEBUG"
  357|      0|    };
  358|      0|  });
  359|      0|  return levelNames[@(logLevel)];
  360|      0|}
  361|       |
  362|       |/// Returns a formatted string to be used for console logging.
  363|       |static NSString *GULStringWithLogMessage(NSString *message,
  364|       |                                         GULNetworkLogLevel logLevel,
  365|      0|                                         NSArray *contexts) {
  366|      0|  if (!message) {
  367|      0|    message = @"(Message was nil)";
  368|      0|  } else if (!message.length) {
  369|      0|    message = @"(Message was empty)";
  370|      0|  }
  371|      0|  NSMutableString *result = [[NSMutableString alloc]
  372|      0|      initWithFormat:@"<%@/%@> %@", kGULNetworkLogTag, GULLogLevelDescriptionFromLogLevel(logLevel),
  373|      0|                     message];
  374|      0|
  375|      0|  if (!contexts.count) {
  376|      0|    return result;
  377|      0|  }
  378|      0|
  379|      0|  NSMutableArray *formattedContexts = [[NSMutableArray alloc] init];
  380|      0|  for (id item in contexts) {
  381|      0|    [formattedContexts addObject:(item != [NSNull null] ? item : @"(nil)")];
  382|      0|  }
  383|      0|
  384|      0|  [result appendString:@": "];
  385|      0|  [result appendString:[formattedContexts componentsJoinedByString:@", "]];
  386|      0|  return result;
  387|      0|}
  388|       |
  389|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetworkURLSession.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GoogleUtilities/Network/Private/GULNetworkURLSession.h"
   18|       |
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import "GoogleUtilities/Network/Private/GULMutableDictionary.h"
   21|       |#import "GoogleUtilities/Network/Private/GULNetworkConstants.h"
   22|       |#import "GoogleUtilities/Network/Private/GULNetworkMessageCode.h"
   23|       |
   24|       |@interface GULNetworkURLSession () <NSURLSessionDelegate,
   25|       |                                    NSURLSessionDataDelegate,
   26|       |                                    NSURLSessionDownloadDelegate,
   27|       |                                    NSURLSessionTaskDelegate>
   28|       |@end
   29|       |
   30|       |@implementation GULNetworkURLSession {
   31|       |  /// The handler to be called when the request completes or error has occurs.
   32|       |  GULNetworkURLSessionCompletionHandler _completionHandler;
   33|       |
   34|       |  /// Session ID generated randomly with a fixed prefix.
   35|       |  NSString *_sessionID;
   36|       |
   37|       |#pragma clang diagnostic push
   38|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   39|       |  /// The session configuration. NSURLSessionConfiguration' is only available on iOS 7.0 or newer.
   40|       |  NSURLSessionConfiguration *_sessionConfig;
   41|       |
   42|       |  /// The current NSURLSession.
   43|       |  NSURLSession *__weak _Nullable _URLSession;
   44|       |#pragma clang diagnostic pop
   45|       |
   46|       |  /// The path to the directory where all temporary files are stored before uploading.
   47|       |  NSURL *_networkDirectoryURL;
   48|       |
   49|       |  /// The downloaded data from fetching.
   50|       |  NSData *_downloadedData;
   51|       |
   52|       |  /// The path to the temporary file which stores the uploading data.
   53|       |  NSURL *_uploadingFileURL;
   54|       |
   55|       |  /// The current request.
   56|       |  NSURLRequest *_request;
   57|       |}
   58|       |
   59|       |#pragma mark - Init
   60|       |
   61|      1|- (instancetype)initWithNetworkLoggerDelegate:(id<GULNetworkLoggerDelegate>)networkLoggerDelegate {
   62|      1|  self = [super init];
   63|      1|  if (self) {
   64|      1|    // Create URL to the directory where all temporary files to upload have to be stored.
   65|      1|    NSArray *paths =
   66|      1|        NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   67|      1|    NSString *applicationSupportDirectory = paths.firstObject;
   68|      1|    NSArray *tempPathComponents = @[
   69|      1|      applicationSupportDirectory, kGULNetworkApplicationSupportSubdirectory,
   70|      1|      kGULNetworkTempDirectoryName
   71|      1|    ];
   72|      1|    _networkDirectoryURL = [NSURL fileURLWithPathComponents:tempPathComponents];
   73|      1|    _sessionID = [NSString stringWithFormat:@"%@-%@", kGULNetworkBackgroundSessionConfigIDPrefix,
   74|      1|                                            [[NSUUID UUID] UUIDString]];
   75|      1|    _loggerDelegate = networkLoggerDelegate;
   76|      1|  }
   77|      1|  return self;
   78|      1|}
   79|       |
   80|       |#pragma mark - External Methods
   81|       |
   82|       |#pragma mark - To be called from AppDelegate
   83|       |
   84|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   85|       |                            completionHandler:
   86|      0|                                (GULNetworkSystemCompletionHandler)systemCompletionHandler {
   87|      0|  // The session may not be Analytics background. Ignore those that do not have the prefix.
   88|      0|  if (![sessionID hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
   89|      0|    return;
   90|      0|  }
   91|      0|  GULNetworkURLSession *fetcher = [self fetcherWithSessionIdentifier:sessionID];
   92|      0|  if (fetcher != nil) {
   93|      0|    [fetcher addSystemCompletionHandler:systemCompletionHandler forSession:sessionID];
   94|      0|  } else {
   95|      0|    GULLogError(kGULLoggerNetwork, NO,
   96|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork003],
   97|      0|                @"Failed to retrieve background session with ID %@ after app is relaunched.",
   98|      0|                sessionID);
   99|      0|  }
  100|      0|}
  101|       |
  102|       |#pragma mark - External Methods
  103|       |
  104|       |/// Sends an async POST request using NSURLSession for iOS >= 7.0, and returns an ID of the
  105|       |/// connection.
  106|       |- (nullable NSString *)sessionIDFromAsyncPOSTRequest:(NSURLRequest *)request
  107|       |                                   completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  108|      0|    API_AVAILABLE(ios(7.0)) {
  109|      0|  // NSURLSessionUploadTask does not work with NSData in the background.
  110|      0|  // To avoid this issue, write the data to a temporary file to upload it.
  111|      0|  // Make a temporary file with the data subset.
  112|      0|  _uploadingFileURL = [self temporaryFilePathWithSessionID:_sessionID];
  113|      0|  NSError *writeError;
  114|      0|  NSURLSessionUploadTask *postRequestTask;
  115|      0|  NSURLSession *session;
  116|      0|  BOOL didWriteFile = NO;
  117|      0|
  118|      0|  // Clean up the entire temp folder to avoid temp files that remain in case the previous session
  119|      0|  // crashed and did not clean up.
  120|      0|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  121|      0|                     expiringTime:kGULNetworkTempFolderExpireTime];
  122|      0|
  123|      0|  // If there is no background network enabled, no need to write to file. This will allow default
  124|      0|  // network session which runs on the foreground.
  125|      0|  if (_backgroundNetworkEnabled && [self ensureTemporaryDirectoryExists]) {
  126|      0|    didWriteFile = [request.HTTPBody writeToFile:_uploadingFileURL.path
  127|      0|                                         options:NSDataWritingAtomic
  128|      0|                                           error:&writeError];
  129|      0|
  130|      0|    if (writeError) {
  131|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  132|      0|                                   messageCode:kGULNetworkMessageCodeURLSession000
  133|      0|                                       message:@"Failed to write request data to file"
  134|      0|                                       context:writeError];
  135|      0|    }
  136|      0|  }
  137|      0|
  138|      0|  if (didWriteFile) {
  139|      0|    // Exclude this file from backing up to iTunes. There are conflicting reports that excluding
  140|      0|    // directory from backing up does not exclude files of that directory from backing up.
  141|      0|    [self excludeFromBackupForURL:_uploadingFileURL];
  142|      0|
  143|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  144|      0|    [self populateSessionConfig:_sessionConfig withRequest:request];
  145|      0|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  146|      0|                                            delegate:self
  147|      0|                                       delegateQueue:[NSOperationQueue mainQueue]];
  148|      0|    postRequestTask = [session uploadTaskWithRequest:request fromFile:_uploadingFileURL];
  149|      0|  } else {
  150|      0|    // If we cannot write to file, just send it in the foreground.
  151|      0|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  152|      0|    [self populateSessionConfig:_sessionConfig withRequest:request];
  153|      0|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  154|      0|                                            delegate:self
  155|      0|                                       delegateQueue:[NSOperationQueue mainQueue]];
  156|      0|    postRequestTask = [session uploadTaskWithRequest:request fromData:request.HTTPBody];
  157|      0|  }
  158|      0|
  159|      0|  if (!session || !postRequestTask) {
  160|      0|    NSError *error = [[NSError alloc]
  161|      0|        initWithDomain:kGULNetworkErrorDomain
  162|      0|                  code:GULErrorCodeNetworkRequestCreation
  163|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  164|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  165|      0|    return nil;
  166|      0|  }
  167|      0|
  168|      0|  _URLSession = session;
  169|      0|
  170|      0|  // Save the session into memory.
  171|      0|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  172|      0|
  173|      0|  _request = [request copy];
  174|      0|
  175|      0|  // Store completion handler because background session does not accept handler block but custom
  176|      0|  // delegate.
  177|      0|  _completionHandler = [handler copy];
  178|      0|  [postRequestTask resume];
  179|      0|
  180|      0|  return _sessionID;
  181|      0|}
  182|       |
  183|       |/// Sends an async GET request using NSURLSession for iOS >= 7.0, and returns an ID of the session.
  184|       |- (nullable NSString *)sessionIDFromAsyncGETRequest:(NSURLRequest *)request
  185|       |                                  completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  186|      1|    API_AVAILABLE(ios(7.0)) {
  187|      1|  if (_backgroundNetworkEnabled) {
  188|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  189|      1|  } else {
  190|      1|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  191|      1|  }
  192|      1|
  193|      1|  [self populateSessionConfig:_sessionConfig withRequest:request];
  194|      1|
  195|      1|  // Do not cache the GET request.
  196|      1|  _sessionConfig.URLCache = nil;
  197|      1|
  198|      1|  NSURLSession *session = [NSURLSession sessionWithConfiguration:_sessionConfig
  199|      1|                                                        delegate:self
  200|      1|                                                   delegateQueue:[NSOperationQueue mainQueue]];
  201|      1|  NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request];
  202|      1|
  203|      1|  if (!session || !downloadTask) {
  204|      0|    NSError *error = [[NSError alloc]
  205|      0|        initWithDomain:kGULNetworkErrorDomain
  206|      0|                  code:GULErrorCodeNetworkRequestCreation
  207|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  208|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  209|      0|    return nil;
  210|      0|  }
  211|      1|
  212|      1|  _URLSession = session;
  213|      1|
  214|      1|  // Save the session into memory.
  215|      1|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  216|      1|
  217|      1|  _request = [request copy];
  218|      1|
  219|      1|  _completionHandler = [handler copy];
  220|      1|  [downloadTask resume];
  221|      1|
  222|      1|  return _sessionID;
  223|      1|}
  224|       |
  225|       |#pragma mark - NSURLSessionDataDelegate
  226|       |
  227|       |/// Called by the NSURLSession when the data task has received some of the expected data.
  228|       |/// Once the session is completed, URLSession:task:didCompleteWithError will be called and the
  229|       |/// completion handler will be called with the downloaded data.
  230|       |- (void)URLSession:(NSURLSession *)session
  231|       |          dataTask:(NSURLSessionDataTask *)dataTask
  232|      0|    didReceiveData:(NSData *)data {
  233|      0|  @synchronized(self) {
  234|      0|    NSMutableData *mutableData = [[NSMutableData alloc] init];
  235|      0|    if (_downloadedData) {
  236|      0|      mutableData = _downloadedData.mutableCopy;
  237|      0|    }
  238|      0|    [mutableData appendData:data];
  239|      0|    _downloadedData = mutableData;
  240|      0|  }
  241|      0|}
  242|       |
  243|       |#pragma mark - NSURLSessionTaskDelegate
  244|       |
  245|       |/// Called by the NSURLSession once the download task is completed. The file is saved in the
  246|       |/// provided URL so we need to read the data and store into _downloadedData. Once the session is
  247|       |/// completed, URLSession:task:didCompleteWithError will be called and the completion handler will
  248|       |/// be called with the downloaded data.
  249|       |- (void)URLSession:(NSURLSession *)session
  250|       |                 downloadTask:(NSURLSessionDownloadTask *)task
  251|      0|    didFinishDownloadingToURL:(NSURL *)url API_AVAILABLE(ios(7.0)) {
  252|      0|  if (!url.path) {
  253|      0|    [_loggerDelegate
  254|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  255|      0|                    messageCode:kGULNetworkMessageCodeURLSession001
  256|      0|                        message:@"Unable to read downloaded data from empty temp path"];
  257|      0|    _downloadedData = nil;
  258|      0|    return;
  259|      0|  }
  260|      0|
  261|      0|  NSError *error;
  262|      0|  _downloadedData = [NSData dataWithContentsOfFile:url.path options:0 error:&error];
  263|      0|
  264|      0|  if (error) {
  265|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  266|      0|                                 messageCode:kGULNetworkMessageCodeURLSession002
  267|      0|                                     message:@"Cannot read the content of downloaded data"
  268|      0|                                     context:error];
  269|      0|    _downloadedData = nil;
  270|      0|  }
  271|      0|}
  272|       |
  273|       |#if TARGET_OS_IOS || TARGET_OS_TV
  274|       |- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
  275|      0|    API_AVAILABLE(ios(7.0)) {
  276|      0|  [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  277|      0|                               messageCode:kGULNetworkMessageCodeURLSession003
  278|      0|                                   message:@"Background session finished"
  279|      0|                                   context:session.configuration.identifier];
  280|      0|  [self callSystemCompletionHandler:session.configuration.identifier];
  281|      0|}
  282|       |#endif
  283|       |
  284|       |- (void)URLSession:(NSURLSession *)session
  285|       |                    task:(NSURLSessionTask *)task
  286|      0|    didCompleteWithError:(NSError *)error API_AVAILABLE(ios(7.0)) {
  287|      0|  // Avoid any chance of recursive behavior leading to it being used repeatedly.
  288|      0|  GULNetworkURLSessionCompletionHandler handler = _completionHandler;
  289|      0|  _completionHandler = nil;
  290|      0|
  291|      0|  if (task.response) {
  292|      0|    // The following assertion should always be true for HTTP requests, see https://goo.gl/gVLxT7.
  293|      0|    NSAssert([task.response isKindOfClass:[NSHTTPURLResponse class]], @"URL response must be HTTP");
  294|      0|
  295|      0|    // The server responded so ignore the error created by the system.
  296|      0|    error = nil;
  297|      0|  } else if (!error) {
  298|      0|    error = [[NSError alloc]
  299|      0|        initWithDomain:kGULNetworkErrorDomain
  300|      0|                  code:GULErrorCodeNetworkInvalidResponse
  301|      0|              userInfo:@{kGULNetworkErrorContext : @"Network Error: Empty network response"}];
  302|      0|  }
  303|      0|
  304|      0|  [self callCompletionHandler:handler
  305|      0|                 withResponse:(NSHTTPURLResponse *)task.response
  306|      0|                         data:_downloadedData
  307|      0|                        error:error];
  308|      0|
  309|      0|  // Remove the temp file to avoid trashing devices with lots of temp files.
  310|      0|  [self removeTempItemAtURL:_uploadingFileURL];
  311|      0|
  312|      0|  // Try to clean up stale files again.
  313|      0|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  314|      0|                     expiringTime:kGULNetworkTempFolderExpireTime];
  315|      0|
  316|      0|  // This is called without checking the sessionID here since non-background sessions
  317|      0|  // won't have an ID.
  318|      0|  [session finishTasksAndInvalidate];
  319|      0|
  320|      0|  // Explicitly remove the session so it won't be reused. The weak map table should
  321|      0|  // remove the session on deallocation, but dealloc may not happen immediately after
  322|      0|  // calling `finishTasksAndInvalidate`.
  323|      0|  NSString *sessionID = session.configuration.identifier;
  324|      0|  [[self class] setSessionInFetcherMap:nil forSessionID:sessionID];
  325|      0|}
  326|       |
  327|       |- (void)URLSession:(NSURLSession *)session
  328|       |                   task:(NSURLSessionTask *)task
  329|       |    didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
  330|       |      completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
  331|       |                                  NSURLCredential *credential))completionHandler
  332|      1|    API_AVAILABLE(ios(7.0)) {
  333|      1|  // The handling is modeled after GTMSessionFetcher.
  334|      1|  if ([challenge.protectionSpace.authenticationMethod
  335|      1|          isEqualToString:NSURLAuthenticationMethodServerTrust]) {
  336|      1|    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
  337|      1|    if (serverTrust == NULL) {
  338|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  339|      0|                                   messageCode:kGULNetworkMessageCodeURLSession004
  340|      0|                                       message:@"Received empty server trust for host. Host"
  341|      0|                                       context:_request.URL];
  342|      0|      completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  343|      0|      return;
  344|      0|    }
  345|      1|    NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];
  346|      1|    if (!credential) {
  347|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  348|      0|                                   messageCode:kGULNetworkMessageCodeURLSession005
  349|      0|                                       message:@"Unable to verify server identity. Host"
  350|      0|                                       context:_request.URL];
  351|      0|      completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  352|      0|      return;
  353|      0|    }
  354|      1|
  355|      1|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  356|      1|                                 messageCode:kGULNetworkMessageCodeURLSession006
  357|      1|                                     message:@"Received SSL challenge for host. Host"
  358|      1|                                     context:_request.URL];
  359|      1|
  360|      1|    void (^callback)(BOOL) = ^(BOOL allow) {
  361|      1|      if (allow) {
  362|      1|        completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
  363|      1|      } else {
  364|      0|        [self->_loggerDelegate
  365|      0|            GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  366|      0|                        messageCode:kGULNetworkMessageCodeURLSession007
  367|      0|                            message:@"Cancelling authentication challenge for host. Host"
  368|      0|                            context:self->_request.URL];
  369|      0|        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  370|      0|      }
  371|      1|    };
  372|      1|
  373|      1|    // Retain the trust object to avoid a SecTrustEvaluate() crash on iOS 7.
  374|      1|    CFRetain(serverTrust);
  375|      1|
  376|      1|    // Evaluate the certificate chain.
  377|      1|    //
  378|      1|    // The delegate queue may be the main thread. Trust evaluation could cause some
  379|      1|    // blocking network activity, so we must evaluate async, as documented at
  380|      1|    // https://developer.apple.com/library/ios/technotes/tn2232/
  381|      1|    dispatch_queue_t evaluateBackgroundQueue =
  382|      1|        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  383|      1|
  384|      1|    dispatch_async(evaluateBackgroundQueue, ^{
  385|      1|      SecTrustResultType trustEval = kSecTrustResultInvalid;
  386|      1|      BOOL shouldAllow;
  387|      1|      OSStatus trustError;
  388|      1|
  389|      1|      @synchronized([GULNetworkURLSession class]) {
  390|      1|#pragma clang diagnostic push
  391|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  392|      1|        trustError = SecTrustEvaluate(serverTrust, &trustEval);
  393|      1|#pragma clang dianostic pop
  394|      1|      }
  395|      1|
  396|      1|      if (trustError != errSecSuccess) {
  397|      0|        [self->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  398|      0|                                           messageCode:kGULNetworkMessageCodeURLSession008
  399|      0|                                               message:@"Cannot evaluate server trust. Error, host"
  400|      0|                                              contexts:@[ @(trustError), self->_request.URL ]];
  401|      0|        shouldAllow = NO;
  402|      1|      } else {
  403|      1|        // Having a trust level "unspecified" by the user is the usual result, described at
  404|      1|        // https://developer.apple.com/library/mac/qa/qa1360
  405|      1|        shouldAllow =
  406|      1|            (trustEval == kSecTrustResultUnspecified || trustEval == kSecTrustResultProceed);
  407|      1|      }
  408|      1|
  409|      1|      // Call the call back with the permission.
  410|      1|      callback(shouldAllow);
  411|      1|
  412|      1|      CFRelease(serverTrust);
  413|      1|    });
  414|      1|    return;
  415|      1|  }
  416|      0|
  417|      0|  // Default handling for other Auth Challenges.
  418|      0|  completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  419|      0|}
  420|       |
  421|       |#pragma mark - Internal Methods
  422|       |
  423|       |/// Stores system completion handler with session ID as key.
  424|       |- (void)addSystemCompletionHandler:(GULNetworkSystemCompletionHandler)handler
  425|      0|                        forSession:(NSString *)identifier {
  426|      0|  if (!handler) {
  427|      0|    [_loggerDelegate
  428|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  429|      0|                    messageCode:kGULNetworkMessageCodeURLSession009
  430|      0|                        message:@"Cannot store nil system completion handler in network"];
  431|      0|    return;
  432|      0|  }
  433|      0|
  434|      0|  if (!identifier.length) {
  435|      0|    [_loggerDelegate
  436|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  437|      0|                    messageCode:kGULNetworkMessageCodeURLSession010
  438|      0|                        message:@"Cannot store system completion handler with empty network "
  439|      0|                                 "session identifier"];
  440|      0|    return;
  441|      0|  }
  442|      0|
  443|      0|  GULMutableDictionary *systemCompletionHandlers =
  444|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  445|      0|  if (systemCompletionHandlers[identifier]) {
  446|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  447|      0|                                 messageCode:kGULNetworkMessageCodeURLSession011
  448|      0|                                     message:@"Got multiple system handlers for a single session ID"
  449|      0|                                     context:identifier];
  450|      0|  }
  451|      0|
  452|      0|  systemCompletionHandlers[identifier] = handler;
  453|      0|}
  454|       |
  455|       |/// Calls the system provided completion handler with the session ID stored in the dictionary.
  456|       |/// The handler will be removed from the dictionary after being called.
  457|      0|- (void)callSystemCompletionHandler:(NSString *)identifier {
  458|      0|  GULMutableDictionary *systemCompletionHandlers =
  459|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  460|      0|  GULNetworkSystemCompletionHandler handler = [systemCompletionHandlers objectForKey:identifier];
  461|      0|
  462|      0|  if (handler) {
  463|      0|    [systemCompletionHandlers removeObjectForKey:identifier];
  464|      0|
  465|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  466|      0|      handler();
  467|      0|    });
  468|      0|  }
  469|      0|}
  470|       |
  471|       |/// Sets or updates the session ID of this session.
  472|      0|- (void)setSessionID:(NSString *)sessionID {
  473|      0|  _sessionID = [sessionID copy];
  474|      0|}
  475|       |
  476|       |/// Creates a background session configuration with the session ID using the supported method.
  477|       |- (NSURLSessionConfiguration *)backgroundSessionConfigWithSessionID:(NSString *)sessionID
  478|      0|    API_AVAILABLE(ios(7.0)) {
  479|      0|#if (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&         \
  480|      0|     MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10) || \
  481|      0|    TARGET_OS_TV ||                                              \
  482|      0|    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_8_0)
  483|      0|
  484|      0|  // iOS 8/10.10 builds require the new backgroundSessionConfiguration method name.
  485|      0|  return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  486|      0|
  487|       |#elif (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&        \
  488|       |       MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10) || \
  489|       |    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_0)
  490|       |
  491|       |  // Do a runtime check to avoid a deprecation warning about using
  492|       |  // +backgroundSessionConfiguration: on iOS 8.
  493|       |  if ([NSURLSessionConfiguration
  494|       |          respondsToSelector:@selector(backgroundSessionConfigurationWithIdentifier:)]) {
  495|       |    // Running on iOS 8+/OS X 10.10+.
  496|       |#pragma clang diagnostic push
  497|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  498|       |    return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  499|       |#pragma clang diagnostic pop
  500|       |  } else {
  501|       |    // Running on iOS 7/OS X 10.9.
  502|       |    return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  503|       |  }
  504|       |
  505|       |#else
  506|       |  // Building with an SDK earlier than iOS 8/OS X 10.10.
  507|       |  return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  508|       |#endif
  509|       |}
  510|       |
  511|      0|- (void)maybeRemoveTempFilesAtURL:(NSURL *)folderURL expiringTime:(NSTimeInterval)staleTime {
  512|      0|  if (!folderURL.absoluteString.length) {
  513|      0|    return;
  514|      0|  }
  515|      0|
  516|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  517|      0|  NSError *error = nil;
  518|      0|
  519|      0|  NSArray *properties = @[ NSURLCreationDateKey ];
  520|      0|  NSArray *directoryContent =
  521|      0|      [fileManager contentsOfDirectoryAtURL:folderURL
  522|      0|                 includingPropertiesForKeys:properties
  523|      0|                                    options:NSDirectoryEnumerationSkipsSubdirectoryDescendants
  524|      0|                                      error:&error];
  525|      0|  if (error && error.code != NSFileReadNoSuchFileError) {
  526|      0|    [_loggerDelegate
  527|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  528|      0|                    messageCode:kGULNetworkMessageCodeURLSession012
  529|      0|                        message:@"Cannot get files from the temporary network folder. Error"
  530|      0|                        context:error];
  531|      0|    return;
  532|      0|  }
  533|      0|
  534|      0|  if (!directoryContent.count) {
  535|      0|    return;
  536|      0|  }
  537|      0|
  538|      0|  NSTimeInterval now = [NSDate date].timeIntervalSince1970;
  539|      0|  for (NSURL *tempFile in directoryContent) {
  540|      0|    NSDate *creationDate;
  541|      0|    BOOL getCreationDate = [tempFile getResourceValue:&creationDate
  542|      0|                                               forKey:NSURLCreationDateKey
  543|      0|                                                error:NULL];
  544|      0|    if (!getCreationDate) {
  545|      0|      continue;
  546|      0|    }
  547|      0|    NSTimeInterval creationTimeInterval = creationDate.timeIntervalSince1970;
  548|      0|    if (fabs(now - creationTimeInterval) > staleTime) {
  549|      0|      [self removeTempItemAtURL:tempFile];
  550|      0|    }
  551|      0|  }
  552|      0|}
  553|       |
  554|       |/// Removes the temporary file written to disk for sending the request. It has to be cleaned up
  555|       |/// after the session is done.
  556|      0|- (void)removeTempItemAtURL:(NSURL *)fileURL {
  557|      0|  if (!fileURL.absoluteString.length) {
  558|      0|    return;
  559|      0|  }
  560|      0|
  561|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  562|      0|  NSError *error = nil;
  563|      0|
  564|      0|  if (![fileManager removeItemAtURL:fileURL error:&error] && error.code != NSFileNoSuchFileError) {
  565|      0|    [_loggerDelegate
  566|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  567|      0|                    messageCode:kGULNetworkMessageCodeURLSession013
  568|      0|                        message:@"Failed to remove temporary uploading data file. Error"
  569|      0|                        context:error.localizedDescription];
  570|      0|  }
  571|      0|}
  572|       |
  573|       |/// Gets the fetcher with the session ID.
  574|      0|+ (instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier {
  575|      0|  GULNetworkURLSession *session = [self sessionFromFetcherMapForSessionID:sessionIdentifier];
  576|      0|  if (!session && [sessionIdentifier hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
  577|      0|    session = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:nil];
  578|      0|    [session setSessionID:sessionIdentifier];
  579|      0|    [self setSessionInFetcherMap:session forSessionID:sessionIdentifier];
  580|      0|  }
  581|      0|  return session;
  582|      0|}
  583|       |
  584|       |/// Returns a map of the fetcher by session ID. Creates a map if it is not created.
  585|       |/// When reading and writing from/to the session map, don't use this method directly.
  586|       |/// To avoid thread safety issues, use one of the helper methods at the bottom of the
  587|       |/// file: setSessionInFetcherMap:forSessionID:, sessionFromFetcherMapForSessionID:
  588|      2|+ (NSMapTable<NSString *, GULNetworkURLSession *> *)sessionIDToFetcherMap {
  589|      2|  static NSMapTable *sessionIDToFetcherMap;
  590|      2|
  591|      2|  static dispatch_once_t sessionMapOnceToken;
  592|      2|  dispatch_once(&sessionMapOnceToken, ^{
  593|      1|    sessionIDToFetcherMap = [NSMapTable strongToWeakObjectsMapTable];
  594|      1|  });
  595|      2|  return sessionIDToFetcherMap;
  596|      2|}
  597|       |
  598|      2|+ (NSLock *)sessionIDToFetcherMapReadWriteLock {
  599|      2|  static NSLock *lock;
  600|      2|
  601|      2|  static dispatch_once_t onceToken;
  602|      2|  dispatch_once(&onceToken, ^{
  603|      1|    lock = [[NSLock alloc] init];
  604|      1|  });
  605|      2|  return lock;
  606|      2|}
  607|       |
  608|       |/// Returns a map of system provided completion handler by session ID. Creates a map if it is not
  609|       |/// created.
  610|      0|+ (GULMutableDictionary *)sessionIDToSystemCompletionHandlerDictionary {
  611|      0|  static GULMutableDictionary *systemCompletionHandlers;
  612|      0|
  613|      0|  static dispatch_once_t systemCompletionHandlerOnceToken;
  614|      0|  dispatch_once(&systemCompletionHandlerOnceToken, ^{
  615|      0|    systemCompletionHandlers = [[GULMutableDictionary alloc] init];
  616|      0|  });
  617|      0|  return systemCompletionHandlers;
  618|      0|}
  619|       |
  620|      0|- (NSURL *)temporaryFilePathWithSessionID:(NSString *)sessionID {
  621|      0|  NSString *tempName = [NSString stringWithFormat:@"GULUpload_temp_%@", sessionID];
  622|      0|  return [_networkDirectoryURL URLByAppendingPathComponent:tempName];
  623|      0|}
  624|       |
  625|       |/// Makes sure that the directory to store temp files exists. If not, tries to create it and returns
  626|       |/// YES. If there is anything wrong, returns NO.
  627|      0|- (BOOL)ensureTemporaryDirectoryExists {
  628|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  629|      0|  NSError *error = nil;
  630|      0|
  631|      0|  // Create a temporary directory if it does not exist or was deleted.
  632|      0|  if ([_networkDirectoryURL checkResourceIsReachableAndReturnError:&error]) {
  633|      0|    return YES;
  634|      0|  }
  635|      0|
  636|      0|  if (error && error.code != NSFileReadNoSuchFileError) {
  637|      0|    [_loggerDelegate
  638|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  639|      0|                    messageCode:kGULNetworkMessageCodeURLSession014
  640|      0|                        message:@"Error while trying to access Network temp folder. Error"
  641|      0|                        context:error];
  642|      0|  }
  643|      0|
  644|      0|  NSError *writeError = nil;
  645|      0|
  646|      0|  [fileManager createDirectoryAtURL:_networkDirectoryURL
  647|      0|        withIntermediateDirectories:YES
  648|      0|                         attributes:nil
  649|      0|                              error:&writeError];
  650|      0|  if (writeError) {
  651|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  652|      0|                                 messageCode:kGULNetworkMessageCodeURLSession015
  653|      0|                                     message:@"Cannot create temporary directory. Error"
  654|      0|                                     context:writeError];
  655|      0|    return NO;
  656|      0|  }
  657|      0|
  658|      0|  // Set the iCloud exclusion attribute on the Documents URL.
  659|      0|  [self excludeFromBackupForURL:_networkDirectoryURL];
  660|      0|
  661|      0|  return YES;
  662|      0|}
  663|       |
  664|      0|- (void)excludeFromBackupForURL:(NSURL *)url {
  665|      0|  if (!url.path) {
  666|      0|    return;
  667|      0|  }
  668|      0|
  669|      0|  // Set the iCloud exclusion attribute on the Documents URL.
  670|      0|  NSError *preventBackupError = nil;
  671|      0|  [url setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:&preventBackupError];
  672|      0|  if (preventBackupError) {
  673|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  674|      0|                                 messageCode:kGULNetworkMessageCodeURLSession016
  675|      0|                                     message:@"Cannot exclude temporary folder from iTunes backup"];
  676|      0|  }
  677|      0|}
  678|       |
  679|       |- (void)URLSession:(NSURLSession *)session
  680|       |                          task:(NSURLSessionTask *)task
  681|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  682|       |                    newRequest:(NSURLRequest *)request
  683|      0|             completionHandler:(void (^)(NSURLRequest *))completionHandler API_AVAILABLE(ios(7.0)) {
  684|      0|  NSArray *nonAllowedRedirectionCodes = @[
  685|      0|    @(kGULNetworkHTTPStatusCodeFound), @(kGULNetworkHTTPStatusCodeMovedPermanently),
  686|      0|    @(kGULNetworkHTTPStatusCodeMovedTemporarily), @(kGULNetworkHTTPStatusCodeMultipleChoices)
  687|      0|  ];
  688|      0|
  689|      0|  // Allow those not in the non allowed list to be followed.
  690|      0|  if (![nonAllowedRedirectionCodes containsObject:@(response.statusCode)]) {
  691|      0|    completionHandler(request);
  692|      0|    return;
  693|      0|  }
  694|      0|
  695|      0|  // Do not allow redirection if the response code is in the non-allowed list.
  696|      0|  NSURLRequest *newRequest = request;
  697|      0|
  698|      0|  if (response) {
  699|      0|    newRequest = nil;
  700|      0|  }
  701|      0|
  702|      0|  completionHandler(newRequest);
  703|      0|}
  704|       |
  705|       |#pragma mark - Helper Methods
  706|       |
  707|      1|+ (void)setSessionInFetcherMap:(GULNetworkURLSession *)session forSessionID:(NSString *)sessionID {
  708|      1|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  709|      1|  GULNetworkURLSession *existingSession =
  710|      1|      [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  711|      1|  if (existingSession) {
  712|      0|    if (session) {
  713|      0|      NSString *message = [NSString stringWithFormat:@"Discarding session: %@", existingSession];
  714|      0|      [existingSession->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelInfo
  715|      0|                                                    messageCode:kGULNetworkMessageCodeURLSession019
  716|      0|                                                        message:message];
  717|      0|    }
  718|      0|    [existingSession->_URLSession finishTasksAndInvalidate];
  719|      0|  }
  720|      1|  if (session) {
  721|      1|    [[[self class] sessionIDToFetcherMap] setObject:session forKey:sessionID];
  722|      1|  } else {
  723|      0|    [[[self class] sessionIDToFetcherMap] removeObjectForKey:sessionID];
  724|      0|  }
  725|      1|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  726|      1|}
  727|       |
  728|      0|+ (nullable GULNetworkURLSession *)sessionFromFetcherMapForSessionID:(NSString *)sessionID {
  729|      0|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  730|      0|  GULNetworkURLSession *session = [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  731|      0|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  732|      0|  return session;
  733|      0|}
  734|       |
  735|       |- (void)callCompletionHandler:(GULNetworkURLSessionCompletionHandler)handler
  736|       |                 withResponse:(NSHTTPURLResponse *)response
  737|       |                         data:(NSData *)data
  738|      0|                        error:(NSError *)error {
  739|      0|  if (error) {
  740|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  741|      0|                                 messageCode:kGULNetworkMessageCodeURLSession017
  742|      0|                                     message:@"Encounter network error. Code, error"
  743|      0|                                    contexts:@[ @(error.code), error ]];
  744|      0|  }
  745|      0|
  746|      0|  if (handler) {
  747|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  748|      0|      handler(response, data, self->_sessionID, error);
  749|      0|    });
  750|      0|  }
  751|      0|}
  752|       |
  753|       |// Always use the request parameters even if the default session configuration is more restrictive.
  754|       |- (void)populateSessionConfig:(NSURLSessionConfiguration *)sessionConfig
  755|      1|                  withRequest:(NSURLRequest *)request API_AVAILABLE(ios(7.0)) {
  756|      1|  sessionConfig.HTTPAdditionalHeaders = request.allHTTPHeaderFields;
  757|      1|  sessionConfig.timeoutIntervalForRequest = request.timeoutInterval;
  758|      1|  sessionConfig.timeoutIntervalForResource = request.timeoutInterval;
  759|      1|  sessionConfig.requestCachePolicy = request.cachePolicy;
  760|      1|}
  761|       |
  762|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/Reachability/GULReachabilityChecker.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GoogleUtilities/Reachability/GULReachabilityChecker+Internal.h"
   18|       |#import "GoogleUtilities/Reachability/Private/GULReachabilityChecker.h"
   19|       |#import "GoogleUtilities/Reachability/Private/GULReachabilityMessageCode.h"
   20|       |
   21|       |#import <GoogleUtilities/GULLogger.h>
   22|       |#import <GoogleUtilities/GULReachabilityChecker.h>
   23|       |
   24|       |static GULLoggerService kGULLoggerReachability = @"[GULReachability]";
   25|       |#if !TARGET_OS_WATCH
   26|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
   27|       |                                 SCNetworkReachabilityFlags flags,
   28|       |                                 void *info);
   29|       |
   30|       |static const struct GULReachabilityApi kGULDefaultReachabilityApi = {
   31|       |    SCNetworkReachabilityCreateWithName,
   32|       |    SCNetworkReachabilitySetCallback,
   33|       |    SCNetworkReachabilityScheduleWithRunLoop,
   34|       |    SCNetworkReachabilityUnscheduleFromRunLoop,
   35|       |    CFRelease,
   36|       |};
   37|       |
   38|       |static NSString *const kGULReachabilityUnknownStatus = @"Unknown";
   39|       |static NSString *const kGULReachabilityConnectedStatus = @"Connected";
   40|       |static NSString *const kGULReachabilityDisconnectedStatus = @"Disconnected";
   41|       |#endif
   42|       |@interface GULReachabilityChecker ()
   43|       |
   44|       |@property(nonatomic, assign) const struct GULReachabilityApi *reachabilityApi;
   45|       |@property(nonatomic, assign) GULReachabilityStatus reachabilityStatus;
   46|       |@property(nonatomic, copy) NSString *host;
   47|       |#if !TARGET_OS_WATCH
   48|       |@property(nonatomic, assign) SCNetworkReachabilityRef reachability;
   49|       |#endif
   50|       |
   51|       |@end
   52|       |
   53|       |@implementation GULReachabilityChecker
   54|       |
   55|       |@synthesize reachabilityApi = reachabilityApi_;
   56|       |#if !TARGET_OS_WATCH
   57|       |@synthesize reachability = reachability_;
   58|       |#endif
   59|       |
   60|      0|- (const struct GULReachabilityApi *)reachabilityApi {
   61|      0|  return reachabilityApi_;
   62|      0|}
   63|       |
   64|      0|- (void)setReachabilityApi:(const struct GULReachabilityApi *)reachabilityApi {
   65|      0|#if !TARGET_OS_WATCH
   66|      0|  if (reachability_) {
   67|      0|    GULLogError(kGULLoggerReachability, NO,
   68|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode000],
   69|      0|                @"Cannot change reachability API while reachability is running. "
   70|      0|                @"Call stop first.");
   71|      0|    return;
   72|      0|  }
   73|      0|  reachabilityApi_ = reachabilityApi;
   74|      0|#endif
   75|      0|}
   76|       |
   77|       |@synthesize reachabilityStatus = reachabilityStatus_;
   78|       |@synthesize host = host_;
   79|       |@synthesize reachabilityDelegate = reachabilityDelegate_;
   80|       |
   81|      0|- (BOOL)isActive {
   82|      0|#if !TARGET_OS_WATCH
   83|      0|  return reachability_ != nil;
   84|       |#else
   85|       |  return NO;
   86|       |#endif
   87|       |}
   88|       |
   89|      2|- (void)setReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate {
   90|      2|  if (reachabilityDelegate &&
   91|      2|      (![(NSObject *)reachabilityDelegate conformsToProtocol:@protocol(GULReachabilityDelegate)])) {
   92|      0|    GULLogError(kGULLoggerReachability, NO,
   93|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULReachabilityMessageCode005],
   94|      0|                @"Reachability delegate doesn't conform to Reachability protocol.");
   95|      0|    return;
   96|      0|  }
   97|      2|  reachabilityDelegate_ = reachabilityDelegate;
   98|      2|}
   99|       |
  100|       |- (instancetype)initWithReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate
  101|      2|                                    withHost:(NSString *)host {
  102|      2|  self = [super init];
  103|      2|
  104|      2|  if (!host || !host.length) {
  105|      0|    GULLogError(kGULLoggerReachability, NO,
  106|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode001],
  107|      0|                @"Invalid host specified");
  108|      0|    return nil;
  109|      0|  }
  110|      2|  if (self) {
  111|      2|#if !TARGET_OS_WATCH
  112|      2|    [self setReachabilityDelegate:reachabilityDelegate];
  113|      2|    reachabilityApi_ = &kGULDefaultReachabilityApi;
  114|      2|    reachabilityStatus_ = kGULReachabilityUnknown;
  115|      2|    host_ = [host copy];
  116|      2|    reachability_ = nil;
  117|      2|#endif
  118|      2|  }
  119|      2|  return self;
  120|      2|}
  121|       |
  122|      0|- (void)dealloc {
  123|      0|  reachabilityDelegate_ = nil;
  124|      0|  [self stop];
  125|      0|}
  126|       |
  127|      2|- (BOOL)start {
  128|       |#if TARGET_OS_WATCH
  129|       |  return NO;
  130|       |#else
  131|       |
  132|      2|  if (!reachability_) {
  133|      2|    reachability_ = reachabilityApi_->createWithNameFn(kCFAllocatorDefault, [host_ UTF8String]);
  134|      2|    if (!reachability_) {
  135|      0|      return NO;
  136|      0|    }
  137|      2|    SCNetworkReachabilityContext context = {
  138|      2|        0,                       /* version */
  139|      2|        (__bridge void *)(self), /* info (passed as last parameter to reachability callback) */
  140|      2|        NULL,                    /* retain */
  141|      2|        NULL,                    /* release */
  142|      2|        NULL                     /* copyDescription */
  143|      2|    };
  144|      2|    if (!reachabilityApi_->setCallbackFn(reachability_, ReachabilityCallback, &context) ||
  145|      2|        !reachabilityApi_->scheduleWithRunLoopFn(reachability_, CFRunLoopGetMain(),
  146|      2|                                                 kCFRunLoopCommonModes)) {
  147|      0|      reachabilityApi_->releaseFn(reachability_);
  148|      0|      reachability_ = nil;
  149|      0|
  150|      0|      GULLogError(kGULLoggerReachability, NO,
  151|      0|                  [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode002],
  152|      0|                  @"Failed to start reachability handle");
  153|      0|      return NO;
  154|      0|    }
  155|      2|  }
  156|      2|  GULLogDebug(kGULLoggerReachability, NO,
  157|      2|              [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode003],
  158|      2|              @"Monitoring the network status");
  159|      2|  return YES;
  160|      2|#endif
  161|      2|}
  162|       |
  163|      0|- (void)stop {
  164|      0|#if !TARGET_OS_WATCH
  165|      0|  if (reachability_) {
  166|      0|    reachabilityStatus_ = kGULReachabilityUnknown;
  167|      0|    reachabilityApi_->unscheduleFromRunLoopFn(reachability_, CFRunLoopGetMain(),
  168|      0|                                              kCFRunLoopCommonModes);
  169|      0|    reachabilityApi_->releaseFn(reachability_);
  170|      0|    reachability_ = nil;
  171|      0|  }
  172|      0|#endif
  173|      0|}
  174|       |
  175|       |#if !TARGET_OS_WATCH
  176|      2|- (GULReachabilityStatus)statusForFlags:(SCNetworkReachabilityFlags)flags {
  177|      2|  GULReachabilityStatus status = kGULReachabilityNotReachable;
  178|      2|  // If the Reachable flag is not set, we definitely don't have connectivity.
  179|      2|  if (flags & kSCNetworkReachabilityFlagsReachable) {
  180|      1|    // Reachable flag is set. Check further flags.
  181|      1|    if (!(flags & kSCNetworkReachabilityFlagsConnectionRequired)) {
  182|      1|// Connection required flag is not set, so we have connectivity.
  183|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  184|      1|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  185|      1|                                                           : kGULReachabilityViaWifi;
  186|       |#elif TARGET_OS_OSX
  187|       |      status = kGULReachabilityViaWifi;
  188|       |#endif
  189|      0|    } else if ((flags & (kSCNetworkReachabilityFlagsConnectionOnDemand |
  190|      0|                         kSCNetworkReachabilityFlagsConnectionOnTraffic)) &&
  191|      0|               !(flags & kSCNetworkReachabilityFlagsInterventionRequired)) {
  192|      0|// If the connection on demand or connection on traffic flag is set, and user intervention
  193|      0|// is not required, we have connectivity.
  194|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  195|      0|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  196|      0|                                                           : kGULReachabilityViaWifi;
  197|       |#elif TARGET_OS_OSX
  198|       |      status = kGULReachabilityViaWifi;
  199|       |#endif
  200|       |    }
  201|      1|  }
  202|      2|  return status;
  203|      2|}
  204|       |
  205|      2|- (void)reachabilityFlagsChanged:(SCNetworkReachabilityFlags)flags {
  206|      2|  GULReachabilityStatus status = [self statusForFlags:flags];
  207|      2|  if (reachabilityStatus_ != status) {
  208|      2|    NSString *reachabilityStatusString;
  209|      2|    if (status == kGULReachabilityUnknown) {
  210|      0|      reachabilityStatusString = kGULReachabilityUnknownStatus;
  211|      2|    } else {
  212|      2|      reachabilityStatusString = (status == kGULReachabilityNotReachable)
  213|      2|                                     ? kGULReachabilityDisconnectedStatus
  214|      2|                                     : kGULReachabilityConnectedStatus;
  215|      2|    }
  216|      2|
  217|      2|    GULLogDebug(kGULLoggerReachability, NO,
  218|      2|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode004],
  219|      2|                @"Network status has changed. Code:%@, status:%@", @(status),
  220|      2|                reachabilityStatusString);
  221|      2|    reachabilityStatus_ = status;
  222|      2|    [reachabilityDelegate_ reachability:self statusChanged:reachabilityStatus_];
  223|      2|  }
  224|      2|}
  225|       |
  226|       |#endif
  227|       |@end
  228|       |
  229|       |#if !TARGET_OS_WATCH
  230|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
  231|       |                                 SCNetworkReachabilityFlags flags,
  232|      2|                                 void *info) {
  233|      2|  GULReachabilityChecker *checker = (__bridge GULReachabilityChecker *)info;
  234|      2|  [checker reachabilityFlagsChanged:flags];
  235|      2|}
  236|       |#endif
  237|       |
  238|       |// This function used to be at the top of the file, but it was moved here
  239|       |// as a workaround for a suspected compiler bug. When compiled in Release mode
  240|       |// and run on an iOS device with WiFi disabled, the reachability code crashed
  241|       |// when calling SCNetworkReachabilityScheduleWithRunLoop, or shortly thereafter.
  242|       |// After unsuccessfully trying to diagnose the cause of the crash, it was
  243|       |// discovered that moving this function to the end of the file magically fixed
  244|       |// the crash. If you are going to edit this file, exercise caution and make sure
  245|       |// to test thoroughly with an iOS device under various network conditions.
  246|      0|const NSString *GULReachabilityStatusString(GULReachabilityStatus status) {
  247|      0|  switch (status) {
  248|      0|    case kGULReachabilityUnknown:
  249|      0|      return @"Reachability Unknown";
  250|      0|
  251|      0|    case kGULReachabilityNotReachable:
  252|      0|      return @"Not reachable";
  253|      0|
  254|      0|    case kGULReachabilityViaWifi:
  255|      0|      return @"Reachable via Wifi";
  256|      0|
  257|      0|    case kGULReachabilityViaCellular:
  258|      0|      return @"Reachable via Cellular Data";
  259|      0|
  260|      0|    default:
  261|      0|      return [NSString stringWithFormat:@"Invalid reachability status %d", (int)status];
  262|      0|  }
  263|      0|}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/SceneDelegateSwizzler/GULSceneDelegateSwizzler.m:
    1|       |// Copyright 2019 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "TargetConditionals.h"
   16|       |
   17|       |#import <GoogleUtilities/GULAppDelegateSwizzler.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import <GoogleUtilities/GULMutableDictionary.h>
   21|       |#import <GoogleUtilities/GULSceneDelegateSwizzler.h>
   22|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   23|       |#import "GoogleUtilities/SceneDelegateSwizzler/Internal/GULSceneDelegateSwizzler_Private.h"
   24|       |
   25|       |#import <objc/runtime.h>
   26|       |
   27|       |#if UISCENE_SUPPORTED
   28|       |API_AVAILABLE(ios(13.0), tvos(13.0))
   29|       |typedef void (*GULOpenURLContextsIMP)(id, SEL, UIScene *, NSSet<UIOpenURLContext *> *);
   30|       |
   31|       |API_AVAILABLE(ios(13.0), tvos(13.0))
   32|       |typedef void (^GULSceneDelegateInterceptorCallback)(id<UISceneDelegate>);
   33|       |
   34|       |// The strings below are the keys for associated objects.
   35|       |static char const *const kGULRealIMPBySelectorKey = "GUL_realIMPBySelector";
   36|       |static char const *const kGULRealClassKey = "GUL_realClass";
   37|       |#endif  // UISCENE_SUPPORTED
   38|       |
   39|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/SceneDelegateSwizzler]";
   40|       |
   41|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   42|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   43|       |
   44|       |/** Plist key that allows Firebase developers to disable App and Scene Delegate Proxying. */
   45|       |static NSString *const kGULFirebaseSceneDelegateProxyEnabledPlistKey =
   46|       |    @"FirebaseAppDelegateProxyEnabled";
   47|       |
   48|       |/** Plist key that allows developers not using Firebase to disable App and Scene Delegate Proxying.
   49|       | */
   50|       |static NSString *const kGULGoogleUtilitiesSceneDelegateProxyEnabledPlistKey =
   51|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   52|       |
   53|       |/** The prefix of the Scene Delegate. */
   54|       |static NSString *const kGULSceneDelegatePrefix = @"GUL_";
   55|       |
   56|       |/**
   57|       | * This class is necessary to store the delegates in an NSArray without retaining them.
   58|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
   59|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
   60|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
   61|       | * automatically is set to nil by the runtime when the object is dealloced.
   62|       | */
   63|       |@interface GULSceneZeroingWeakContainer : NSObject
   64|       |
   65|       |/** Stores a weak object. */
   66|       |@property(nonatomic, weak) id object;
   67|       |
   68|       |@end
   69|       |
   70|       |@implementation GULSceneZeroingWeakContainer
   71|       |@end
   72|       |
   73|       |@implementation GULSceneDelegateSwizzler
   74|       |
   75|       |#pragma mark - Public methods
   76|       |
   77|      1|+ (BOOL)isSceneDelegateProxyEnabled {
   78|      1|  return [GULAppDelegateSwizzler isAppDelegateProxyEnabled];
   79|      1|}
   80|       |
   81|      1|+ (void)proxyOriginalSceneDelegate {
   82|      1|#if UISCENE_SUPPORTED
   83|      1|  if ([GULAppEnvironmentUtil isAppExtension]) {
   84|      0|    return;
   85|      0|  }
   86|      1|
   87|      1|  static dispatch_once_t onceToken;
   88|      1|  dispatch_once(&onceToken, ^{
   89|      1|    if (@available(iOS 13.0, tvOS 13.0, *)) {
   90|      1|      if (![GULSceneDelegateSwizzler isSceneDelegateProxyEnabled]) {
   91|      0|        return;
   92|      0|      }
   93|      1|      [[NSNotificationCenter defaultCenter]
   94|      1|          addObserver:self
   95|      1|             selector:@selector(handleSceneWillConnectToNotification:)
   96|      1|                 name:UISceneWillConnectNotification
   97|      1|               object:nil];
   98|      1|    }
   99|      1|  });
  100|      1|#endif  // UISCENE_SUPPORTED
  101|      1|}
  102|       |
  103|       |#if UISCENE_SUPPORTED
  104|      1|+ (GULSceneDelegateInterceptorID)registerSceneDelegateInterceptor:(id<UISceneDelegate>)interceptor {
  105|      1|  NSAssert(interceptor, @"SceneDelegateProxy cannot add nil interceptor");
  106|      1|  NSAssert([interceptor conformsToProtocol:@protocol(UISceneDelegate)],
  107|      1|           @"SceneDelegateProxy interceptor does not conform to UIApplicationDelegate");
  108|      1|
  109|      1|  if (!interceptor) {
  110|      0|    GULLogError(kGULLoggerSwizzler, NO,
  111|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  112|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling000],
  113|      0|                @"SceneDelegateProxy cannot add nil interceptor.");
  114|      0|    return nil;
  115|      0|  }
  116|      1|  if (![interceptor conformsToProtocol:@protocol(UISceneDelegate)]) {
  117|      0|    GULLogError(kGULLoggerSwizzler, NO,
  118|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  119|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling001],
  120|      0|                @"SceneDelegateProxy interceptor does not conform to UIApplicationDelegate");
  121|      0|    return nil;
  122|      0|  }
  123|      1|
  124|      1|  // The ID should be the same given the same interceptor object.
  125|      1|  NSString *interceptorID =
  126|      1|      [NSString stringWithFormat:@"%@%p", kGULSceneDelegatePrefix, interceptor];
  127|      1|  if (!interceptorID.length) {
  128|      0|    GULLogError(kGULLoggerSwizzler, NO,
  129|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  130|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling002],
  131|      0|                @"SceneDelegateProxy cannot create Interceptor ID.");
  132|      0|    return nil;
  133|      0|  }
  134|      1|  GULSceneZeroingWeakContainer *weakObject = [[GULSceneZeroingWeakContainer alloc] init];
  135|      1|  weakObject.object = interceptor;
  136|      1|  [GULSceneDelegateSwizzler interceptors][interceptorID] = weakObject;
  137|      1|  return interceptorID;
  138|      1|}
  139|       |
  140|      0|+ (void)unregisterSceneDelegateInterceptorWithID:(GULSceneDelegateInterceptorID)interceptorID {
  141|      0|  NSAssert(interceptorID, @"SceneDelegateProxy cannot unregister nil interceptor ID.");
  142|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  143|      0|           @"SceneDelegateProxy cannot unregister empty interceptor ID.");
  144|      0|
  145|      0|  if (!interceptorID) {
  146|      0|    GULLogError(kGULLoggerSwizzler, NO,
  147|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  148|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling003],
  149|      0|                @"SceneDelegateProxy cannot unregister empty interceptor ID.");
  150|      0|    return;
  151|      0|  }
  152|      0|
  153|      0|  GULSceneZeroingWeakContainer *weakContainer =
  154|      0|      [GULSceneDelegateSwizzler interceptors][interceptorID];
  155|      0|  if (!weakContainer.object) {
  156|      0|    GULLogError(kGULLoggerSwizzler, NO,
  157|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  158|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling004],
  159|      0|                @"SceneDelegateProxy cannot unregister interceptor that was not registered. "
  160|      0|                 "Interceptor ID %@",
  161|      0|                interceptorID);
  162|      0|    return;
  163|      0|  }
  164|      0|
  165|      0|  [[GULSceneDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  166|      0|}
  167|       |
  168|       |#pragma mark - Helper methods
  169|       |
  170|      1|+ (GULMutableDictionary *)interceptors {
  171|      1|  static dispatch_once_t onceToken;
  172|      1|  static GULMutableDictionary *sInterceptors;
  173|      1|  dispatch_once(&onceToken, ^{
  174|      1|    sInterceptors = [[GULMutableDictionary alloc] init];
  175|      1|  });
  176|      1|  return sInterceptors;
  177|      1|}
  178|       |
  179|      0|+ (void)clearInterceptors {
  180|      0|  [[self interceptors] removeAllObjects];
  181|      0|}
  182|       |
  183|      0|+ (nullable NSValue *)originalImplementationForSelector:(SEL)selector object:(id)object {
  184|      0|  NSDictionary *realImplementationBySelector =
  185|      0|      objc_getAssociatedObject(object, &kGULRealIMPBySelectorKey);
  186|      0|  return realImplementationBySelector[NSStringFromSelector(selector)];
  187|      0|}
  188|       |
  189|       |+ (void)proxyDestinationSelector:(SEL)destinationSelector
  190|       |    implementationsFromSourceSelector:(SEL)sourceSelector
  191|       |                            fromClass:(Class)sourceClass
  192|       |                              toClass:(Class)destinationClass
  193|       |                            realClass:(Class)realClass
  194|       |     storeDestinationImplementationTo:
  195|      1|         (NSMutableDictionary<NSString *, NSValue *> *)destinationImplementationsBySelector {
  196|      1|  [self addInstanceMethodWithDestinationSelector:destinationSelector
  197|      1|            withImplementationFromSourceSelector:sourceSelector
  198|      1|                                       fromClass:sourceClass
  199|      1|                                         toClass:destinationClass];
  200|      1|  IMP sourceImplementation =
  201|      1|      [GULSceneDelegateSwizzler implementationOfMethodSelector:destinationSelector
  202|      1|                                                     fromClass:realClass];
  203|      1|  NSValue *sourceImplementationPointer = [NSValue valueWithPointer:sourceImplementation];
  204|      1|
  205|      1|  NSString *destinationSelectorString = NSStringFromSelector(destinationSelector);
  206|      1|  destinationImplementationsBySelector[destinationSelectorString] = sourceImplementationPointer;
  207|      1|}
  208|       |
  209|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  210|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  211|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  212|       | *  identified by methodSelector.
  213|       | *
  214|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  215|       | *      one on the toClass.
  216|       | *  @param fromClass The class from which a method is sourced.
  217|       | *  @param toClass The class to which the method is added. If the class already has a method with
  218|       | *      the same selector, this has no effect.
  219|       | */
  220|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  221|       |                            fromClass:(Class)fromClass
  222|      0|                              toClass:(Class)toClass {
  223|      0|  [self addInstanceMethodWithDestinationSelector:methodSelector
  224|      0|            withImplementationFromSourceSelector:methodSelector
  225|      0|                                       fromClass:fromClass
  226|      0|                                         toClass:toClass];
  227|      0|}
  228|       |
  229|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  230|       | *  destinationSelector on the toClass. After this method is called, performing
  231|       | *  [toClassInstance destinationSelector] will be similar to calling
  232|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  233|       | *  identified by destinationSelector.
  234|       | *
  235|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  236|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  237|       | *  @param fromClass The class from which a method is sourced.
  238|       | *  @param toClass The class to which the method is added. If the class already has a method with
  239|       | *      the same selector, this has no effect.
  240|       | */
  241|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  242|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  243|       |                                       fromClass:(Class)fromClass
  244|      1|                                         toClass:(Class)toClass {
  245|      1|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  246|      1|  IMP methodIMP = method_getImplementation(method);
  247|      1|  const char *types = method_getTypeEncoding(method);
  248|      1|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  249|      0|    GULLogWarning(
  250|      0|        kGULLoggerSwizzler, NO,
  251|      0|        [NSString
  252|      0|            stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling009],
  253|      0|        @"Cannot copy method to destination selector %@ as it already exists",
  254|      0|        NSStringFromSelector(destinationSelector));
  255|      0|  }
  256|      1|}
  257|       |
  258|       |/** Gets the IMP of the instance method on the class identified by the selector.
  259|       | *
  260|       | *  @param selector The selector of which the IMP is to be fetched.
  261|       | *  @param aClass The class from which the IMP is to be fetched.
  262|       | *  @return The IMP of the instance method identified by selector and aClass.
  263|       | */
  264|      1|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  265|      1|  Method aMethod = class_getInstanceMethod(aClass, selector);
  266|      1|  return method_getImplementation(aMethod);
  267|      1|}
  268|       |
  269|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  270|       | *  GULSceneDelegateInterceptorCallback with the interceptor.
  271|       | *
  272|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  273|       | *  @param callback the GULSceneDelegateInterceptorCallback.
  274|       | */
  275|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  276|       |                                    callback:(GULSceneDelegateInterceptorCallback)callback
  277|      0|    API_AVAILABLE(ios(13.0)) {
  278|      0|  if (!callback) {
  279|      0|    return;
  280|      0|  }
  281|      0|
  282|      0|  NSDictionary *interceptors = [GULSceneDelegateSwizzler interceptors].dictionary;
  283|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  284|      0|    GULSceneZeroingWeakContainer *interceptorContainer = obj;
  285|      0|    id interceptor = interceptorContainer.object;
  286|      0|    if (!interceptor) {
  287|      0|      GULLogWarning(
  288|      0|          kGULLoggerSwizzler, NO,
  289|      0|          [NSString stringWithFormat:@"I-SWZ%06ld",
  290|      0|                                     (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling010],
  291|      0|          @"SceneDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  292|      0|      [[GULSceneDelegateSwizzler interceptors] removeObjectForKey:key];
  293|      0|      return;
  294|      0|    }
  295|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  296|      0|      callback(interceptor);
  297|      0|    }
  298|      0|  }];
  299|      0|}
  300|       |
  301|      1|+ (void)handleSceneWillConnectToNotification:(NSNotification *)notification {
  302|      1|  if (@available(iOS 13.0, tvOS 13.0, *)) {
  303|      1|    if ([notification.object isKindOfClass:[UIScene class]]) {
  304|      1|      UIScene *scene = (UIScene *)notification.object;
  305|      1|      [GULSceneDelegateSwizzler proxySceneDelegateIfNeeded:scene];
  306|      1|    }
  307|      1|  }
  308|      1|}
  309|       |
  310|       |#pragma mark - [Donor Methods] UISceneDelegate URL handler
  311|       |
  312|       |- (void)scene:(UIScene *)scene
  313|      0|    openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts API_AVAILABLE(ios(13.0), tvos(13.0)) {
  314|      0|  if (@available(iOS 13.0, tvOS 13.0, *)) {
  315|      0|    SEL methodSelector = @selector(scene:openURLContexts:);
  316|      0|    // Call the real implementation if the real Scene Delegate has any.
  317|      0|    NSValue *openURLContextsIMPPointer =
  318|      0|        [GULSceneDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  319|      0|    GULOpenURLContextsIMP openURLContextsIMP = [openURLContextsIMPPointer pointerValue];
  320|      0|
  321|      0|    [GULSceneDelegateSwizzler
  322|      0|        notifyInterceptorsWithMethodSelector:methodSelector
  323|      0|                                    callback:^(id<UISceneDelegate> interceptor) {
  324|      0|                                      if ([interceptor
  325|      0|                                              conformsToProtocol:@protocol(UISceneDelegate)]) {
  326|      0|                                        id<UISceneDelegate> sceneInterceptor =
  327|      0|                                            (id<UISceneDelegate>)interceptor;
  328|      0|                                        [sceneInterceptor scene:scene openURLContexts:URLContexts];
  329|      0|                                      }
  330|      0|                                    }];
  331|      0|
  332|      0|    if (openURLContextsIMP) {
  333|      0|      openURLContextsIMP(self, methodSelector, scene, URLContexts);
  334|      0|    }
  335|      0|  }
  336|      0|}
  337|       |
  338|      1|+ (void)proxySceneDelegateIfNeeded:(UIScene *)scene {
  339|      1|  Class realClass = [scene.delegate class];
  340|      1|  NSString *className = NSStringFromClass(realClass);
  341|      1|
  342|      1|  // Skip proxying if failed to get the delegate class name for some reason (e.g. `delegate == nil`)
  343|      1|  // or the class has a prefix of kGULAppDelegatePrefix, which means it has been proxied before.
  344|      1|  if (className == nil || [className hasPrefix:kGULSceneDelegatePrefix]) {
  345|      0|    return;
  346|      0|  }
  347|      1|
  348|      1|  NSString *classNameWithPrefix = [kGULSceneDelegatePrefix stringByAppendingString:className];
  349|      1|  NSString *newClassName =
  350|      1|      [NSString stringWithFormat:@"%@-%@", classNameWithPrefix, [NSUUID UUID].UUIDString];
  351|      1|
  352|      1|  if (NSClassFromString(newClassName)) {
  353|      0|    GULLogError(
  354|      0|        kGULLoggerSwizzler, NO,
  355|      0|        [NSString
  356|      0|            stringWithFormat:@"I-SWZ%06ld",
  357|      0|                             (long)
  358|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  359|      0|        @"Cannot create a proxy for Scene Delegate. Subclass already exists. Original Class"
  360|      0|        @": %@, subclass: %@",
  361|      0|        className, newClassName);
  362|      0|    return;
  363|      0|  }
  364|      1|
  365|      1|  // Register the new class as subclass of the real one. Do not allocate more than the real class
  366|      1|  // size.
  367|      1|  Class sceneDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  368|      1|  if (sceneDelegateSubClass == Nil) {
  369|      0|    GULLogError(
  370|      0|        kGULLoggerSwizzler, NO,
  371|      0|        [NSString
  372|      0|            stringWithFormat:@"I-SWZ%06ld",
  373|      0|                             (long)
  374|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  375|      0|        @"Cannot create a proxy for Scene Delegate. Subclass already exists. Original Class"
  376|      0|        @": %@, subclass: Nil",
  377|      0|        className);
  378|      0|    return;
  379|      0|  }
  380|      1|
  381|      1|  NSMutableDictionary<NSString *, NSValue *> *realImplementationsBySelector =
  382|      1|      [[NSMutableDictionary alloc] init];
  383|      1|
  384|      1|  // For scene:openURLContexts:
  385|      1|  SEL openURLContextsSEL = @selector(scene:openURLContexts:);
  386|      1|  [self proxyDestinationSelector:openURLContextsSEL
  387|      1|      implementationsFromSourceSelector:openURLContextsSEL
  388|      1|                              fromClass:[GULSceneDelegateSwizzler class]
  389|      1|                                toClass:sceneDelegateSubClass
  390|      1|                              realClass:realClass
  391|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  392|      1|
  393|      1|  // Store original implementations to a fake property of the original delegate.
  394|      1|  objc_setAssociatedObject(scene.delegate, &kGULRealIMPBySelectorKey,
  395|      1|                           [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  396|      1|  objc_setAssociatedObject(scene.delegate, &kGULRealClassKey, realClass,
  397|      1|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  398|      1|
  399|      1|  // The subclass size has to be exactly the same size with the original class size. The subclass
  400|      1|  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  401|      1|  // that can lead to overwriting the isa of an object in the next frame.
  402|      1|  if (class_getInstanceSize(realClass) != class_getInstanceSize(sceneDelegateSubClass)) {
  403|      0|    GULLogError(
  404|      0|        kGULLoggerSwizzler, NO,
  405|      0|        [NSString
  406|      0|            stringWithFormat:@"I-SWZ%06ld",
  407|      0|                             (long)
  408|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  409|      0|        @"Cannot create subclass of Scene Delegate, because the created subclass is not the "
  410|      0|        @"same size. %@",
  411|      0|        className);
  412|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  413|      0|    return;
  414|      0|  }
  415|      1|
  416|      1|  // Make the newly created class to be the subclass of the real Scene Delegate class.
  417|      1|  objc_registerClassPair(sceneDelegateSubClass);
  418|      1|  if (object_setClass(scene.delegate, sceneDelegateSubClass)) {
  419|      1|    GULLogDebug(
  420|      1|        kGULLoggerSwizzler, NO,
  421|      1|        [NSString
  422|      1|            stringWithFormat:@"I-SWZ%06ld",
  423|      1|                             (long)
  424|      1|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  425|      1|        @"Successfully created Scene Delegate Proxy automatically. To disable the "
  426|      1|        @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  427|      1|        [GULSceneDelegateSwizzler correctSceneDelegateProxyKey]);
  428|      1|  }
  429|      1|}
  430|       |
  431|      1|+ (NSString *)correctSceneDelegateProxyKey {
  432|      1|  return NSClassFromString(@"FIRCore") ? kGULFirebaseSceneDelegateProxyEnabledPlistKey
  433|      1|                                       : kGULGoogleUtilitiesSceneDelegateProxyEnabledPlistKey;
  434|      1|}
  435|       |
  436|       |#endif  // UISCENE_SUPPORTED
  437|       |
  438|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/GoogleUtilities/GoogleUtilities/UserDefaults/GULUserDefaults.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULUserDefaults.h"
   16|       |
   17|       |#import <GoogleUtilities/GULLogger.h>
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |static NSTimeInterval const kGULSynchronizeInterval = 1.0;
   22|       |
   23|       |static NSString *const kGULLogFormat = @"I-GUL%06ld";
   24|       |
   25|       |static GULLoggerService kGULLogUserDefaultsService = @"[GoogleUtilities/UserDefaults]";
   26|       |
   27|       |typedef NS_ENUM(NSInteger, GULUDMessageCode) {
   28|       |  GULUDMessageCodeInvalidKeyGet = 1,
   29|       |  GULUDMessageCodeInvalidKeySet = 2,
   30|       |  GULUDMessageCodeInvalidObjectSet = 3,
   31|       |  GULUDMessageCodeSynchronizeFailed = 4,
   32|       |};
   33|       |
   34|       |@interface GULUserDefaults ()
   35|       |
   36|       |/// Equivalent to the suite name for NSUserDefaults.
   37|       |@property(readonly) CFStringRef appNameRef;
   38|       |
   39|       |@property(atomic) BOOL isPreferenceFileExcluded;
   40|       |
   41|       |@end
   42|       |
   43|       |@implementation GULUserDefaults {
   44|       |  // The application name is the same with the suite name of the NSUserDefaults, and it is used for
   45|       |  // preferences.
   46|       |  CFStringRef _appNameRef;
   47|       |}
   48|       |
   49|      0|+ (GULUserDefaults *)standardUserDefaults {
   50|      0|  static GULUserDefaults *standardUserDefaults;
   51|      0|  static dispatch_once_t onceToken;
   52|      0|  dispatch_once(&onceToken, ^{
   53|      0|    standardUserDefaults = [[GULUserDefaults alloc] init];
   54|      0|  });
   55|      0|  return standardUserDefaults;
   56|      0|}
   57|       |
   58|      0|- (instancetype)init {
   59|      0|  return [self initWithSuiteName:nil];
   60|      0|}
   61|       |
   62|      1|- (instancetype)initWithSuiteName:(nullable NSString *)suiteName {
   63|      1|  self = [super init];
   64|      1|
   65|      1|  NSString *name = [suiteName copy];
   66|      1|
   67|      1|  if (self) {
   68|      1|    // `kCFPreferencesCurrentApplication` maps to the same defaults database as
   69|      1|    // `[NSUserDefaults standardUserDefaults]`.
   70|      1|    _appNameRef =
   71|      1|        name.length ? (__bridge_retained CFStringRef)name : kCFPreferencesCurrentApplication;
   72|      1|  }
   73|      1|
   74|      1|  return self;
   75|      1|}
   76|       |
   77|      0|- (void)dealloc {
   78|      0|  // If we're using a custom `_appNameRef` it needs to be released. If it's a constant, it shouldn't
   79|      0|  // need to be released since we don't own it.
   80|      0|  if (CFStringCompare(_appNameRef, kCFPreferencesCurrentApplication, 0) != kCFCompareEqualTo) {
   81|      0|    CFRelease(_appNameRef);
   82|      0|  }
   83|      0|
   84|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
   85|      0|                                           selector:@selector(synchronize)
   86|      0|                                             object:nil];
   87|      0|}
   88|       |
   89|      1|- (nullable id)objectForKey:(NSString *)defaultName {
   90|      1|  NSString *key = [defaultName copy];
   91|      1|  if (![key isKindOfClass:[NSString class]] || !key.length) {
   92|      0|    GULLogWarning(@"<GoogleUtilities>", NO,
   93|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeyGet],
   94|      0|                  @"Cannot get object for invalid user default key.");
   95|      0|    return nil;
   96|      0|  }
   97|      1|  return (__bridge_transfer id)CFPreferencesCopyAppValue((__bridge CFStringRef)key, _appNameRef);
   98|      1|}
   99|       |
  100|      0|- (void)setObject:(nullable id)value forKey:(NSString *)defaultName {
  101|      0|  NSString *key = [defaultName copy];
  102|      0|  if (![key isKindOfClass:[NSString class]] || !key.length) {
  103|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  104|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeySet],
  105|      0|                  @"Cannot set object for invalid user default key.");
  106|      0|    return;
  107|      0|  }
  108|      0|  if (!value) {
  109|      0|    CFPreferencesSetAppValue((__bridge CFStringRef)key, NULL, _appNameRef);
  110|      0|    [self scheduleSynchronize];
  111|      0|    return;
  112|      0|  }
  113|      0|  BOOL isAcceptableValue =
  114|      0|      [value isKindOfClass:[NSString class]] || [value isKindOfClass:[NSNumber class]] ||
  115|      0|      [value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]] ||
  116|      0|      [value isKindOfClass:[NSDate class]] || [value isKindOfClass:[NSData class]];
  117|      0|  if (!isAcceptableValue) {
  118|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  119|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidObjectSet],
  120|      0|                  @"Cannot set invalid object to user defaults. Must be a string, number, array, "
  121|      0|                  @"dictionary, date, or data. Value: %@",
  122|      0|                  value);
  123|      0|    return;
  124|      0|  }
  125|      0|
  126|      0|  CFPreferencesSetAppValue((__bridge CFStringRef)key, (__bridge CFStringRef)value, _appNameRef);
  127|      0|  [self scheduleSynchronize];
  128|      0|}
  129|       |
  130|      0|- (void)removeObjectForKey:(NSString *)key {
  131|      0|  [self setObject:nil forKey:key];
  132|      0|}
  133|       |
  134|       |#pragma mark - Getters
  135|       |
  136|      0|- (NSInteger)integerForKey:(NSString *)defaultName {
  137|      0|  NSNumber *object = [self objectForKey:defaultName];
  138|      0|  return object.integerValue;
  139|      0|}
  140|       |
  141|      0|- (float)floatForKey:(NSString *)defaultName {
  142|      0|  NSNumber *object = [self objectForKey:defaultName];
  143|      0|  return object.floatValue;
  144|      0|}
  145|       |
  146|      0|- (double)doubleForKey:(NSString *)defaultName {
  147|      0|  NSNumber *object = [self objectForKey:defaultName];
  148|      0|  return object.doubleValue;
  149|      0|}
  150|       |
  151|      0|- (BOOL)boolForKey:(NSString *)defaultName {
  152|      0|  NSNumber *object = [self objectForKey:defaultName];
  153|      0|  return object.boolValue;
  154|      0|}
  155|       |
  156|      0|- (nullable NSString *)stringForKey:(NSString *)defaultName {
  157|      0|  return [self objectForKey:defaultName];
  158|      0|}
  159|       |
  160|      0|- (nullable NSArray *)arrayForKey:(NSString *)defaultName {
  161|      0|  return [self objectForKey:defaultName];
  162|      0|}
  163|       |
  164|      0|- (nullable NSDictionary<NSString *, id> *)dictionaryForKey:(NSString *)defaultName {
  165|      0|  return [self objectForKey:defaultName];
  166|      0|}
  167|       |
  168|       |#pragma mark - Setters
  169|       |
  170|      0|- (void)setInteger:(NSInteger)integer forKey:(NSString *)defaultName {
  171|      0|  [self setObject:@(integer) forKey:defaultName];
  172|      0|}
  173|       |
  174|      0|- (void)setFloat:(float)value forKey:(NSString *)defaultName {
  175|      0|  [self setObject:@(value) forKey:defaultName];
  176|      0|}
  177|       |
  178|      0|- (void)setDouble:(double)doubleNumber forKey:(NSString *)defaultName {
  179|      0|  [self setObject:@(doubleNumber) forKey:defaultName];
  180|      0|}
  181|       |
  182|      0|- (void)setBool:(BOOL)boolValue forKey:(NSString *)defaultName {
  183|      0|  [self setObject:@(boolValue) forKey:defaultName];
  184|      0|}
  185|       |
  186|       |#pragma mark - Save data
  187|       |
  188|      0|- (void)synchronize {
  189|      0|  if (!CFPreferencesAppSynchronize(_appNameRef)) {
  190|      0|    GULLogError(kGULLogUserDefaultsService, NO,
  191|      0|                [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeSynchronizeFailed],
  192|      0|                @"Cannot synchronize user defaults to disk");
  193|      0|  }
  194|      0|}
  195|       |
  196|       |#pragma mark - Private methods
  197|       |
  198|      0|- (void)scheduleSynchronize {
  199|      0|  // Synchronize data using a timer so that multiple set... calls can be coalesced under one
  200|      0|  // synchronize.
  201|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
  202|      0|                                           selector:@selector(synchronize)
  203|      0|                                             object:nil];
  204|      0|  // This method may be called on multiple queues (due to set... methods can be called on any queue)
  205|      0|  // synchronize can be scheduled on different queues, so make sure that it does not crash. If this
  206|      0|  // instance goes away, self will be released also, no one will retain it and the schedule won't be
  207|      0|  // called.
  208|      0|  [self performSelector:@selector(synchronize) withObject:nil afterDelay:kGULSynchronizeInterval];
  209|      0|}
  210|       |
  211|       |@end
  212|       |
  213|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/FirebaseCore/FIRComponentContainer.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import <Foundation/Foundation.h>
   17|       |
   18|       |#import <FirebaseCore/FIRComponentType.h>
   19|       |#import <FirebaseCore/FIRLibrary.h>
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/// A type-safe macro to retrieve a component from a container. This should be used to retrieve
   24|       |/// components instead of using the container directly.
   25|       |#define FIR_COMPONENT(type, container) \
   26|      2|  [FIRComponentType<id<type>> instanceForProtocol:@protocol(type) inContainer:container]
   27|       |
   28|       |@class FIRApp;
   29|       |
   30|       |/// A container that holds different components that are registered via the
   31|       |/// `registerAsComponentRegistrant:` call. These classes should conform to `FIRComponentRegistrant`
   32|       |/// in order to properly register components for Core.
   33|       |NS_SWIFT_NAME(FirebaseComponentContainer)
   34|       |@interface FIRComponentContainer : NSObject
   35|       |
   36|       |/// A weak reference to the app that an instance of the container belongs to.
   37|       |@property(nonatomic, weak, readonly) FIRApp *app;
   38|       |
   39|       |/// Unavailable. Use the `container` property on `FIRApp`.
   40|       |- (instancetype)init NS_UNAVAILABLE;
   41|       |
   42|       |@end
   43|       |
   44|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsData.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** If present, is a BOOL wrapped in an NSNumber. */
   22|     14|#define kFIRCDIsDataCollectionDefaultEnabledKey @"FIRCDIsDataCollectionDefaultEnabledKey"
   23|       |
   24|       |/** If present, is an int32_t wrapped in an NSNumber. */
   25|      8|#define kFIRCDConfigurationTypeKey @"FIRCDConfigurationTypeKey"
   26|       |
   27|       |/** If present, is an NSString. */
   28|      6|#define kFIRCDSdkNameKey @"FIRCDSdkNameKey"
   29|       |
   30|       |/** If present, is an NSString. */
   31|      6|#define kFIRCDSdkVersionKey @"FIRCDSdkVersionKey"
   32|       |
   33|       |/** If present, is an int32_t wrapped in an NSNumber. */
   34|     24|#define kFIRCDllAppsCountKey @"FIRCDllAppsCountKey"
   35|       |
   36|       |/** If present, is an NSString. */
   37|      8|#define kFIRCDGoogleAppIDKey @"FIRCDGoogleAppIDKey"
   38|       |
   39|       |/** If present, is an NSString. */
   40|      8|#define kFIRCDBundleIDKey @"FIRCDBundleID"
   41|       |
   42|       |/** If present, is a BOOL wrapped in an NSNumber. */
   43|      8|#define kFIRCDUsingOptionsFromDefaultPlistKey @"FIRCDUsingOptionsFromDefaultPlistKey"
   44|       |
   45|       |/** If present, is an NSString. */
   46|      8|#define kFIRCDLibraryVersionIDKey @"FIRCDLibraryVersionIDKey"
   47|       |
   48|       |/** If present, is an NSString. */
   49|     14|#define kFIRCDFirebaseUserAgentKey @"FIRCDFirebaseUserAgentKey"
   50|       |
   51|       |/** Defines the interface of a data object needed to log diagnostics data. */
   52|       |@protocol FIRCoreDiagnosticsData <NSObject>
   53|       |
   54|       |@required
   55|       |
   56|       |/** A dictionary containing data (non-exhaustive) to be logged in diagnostics. */
   57|       |@property(nonatomic) NSDictionary<NSString *, id> *diagnosticObjects;
   58|       |
   59|       |@end
   60|       |
   61|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/GoogleDataTransport/GDTCORConsoleLogger.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |// Set this to 1 to have the library print out as much as possible about what GDT is doing.
   20|       |#define GDT_VERBOSE_LOGGING 0
   21|       |
   22|       |/** A list of message codes to print in the logger that help to correspond printed messages with
   23|       | * code locations.
   24|       | *
   25|       | * Prefixes:
   26|       | * - MCW => MessageCodeWarning
   27|       | * - MCE => MessageCodeError
   28|       | */
   29|       |typedef NS_ENUM(NSInteger, GDTCORMessageCode) {
   30|       |
   31|       |  /** For warning messages concerning transportBytes: not being implemented by a data object. */
   32|       |  GDTCORMCWDataObjectMissingBytesImpl = 1,
   33|       |
   34|       |  /** For warning messages concerning a failed event upload. */
   35|       |  GDTCORMCWUploadFailed = 2,
   36|       |
   37|       |  /** For warning messages concerning a forced event upload. */
   38|       |  GDTCORMCWForcedUpload = 3,
   39|       |
   40|       |  /** For warning messages concerning a failed reachability call. */
   41|       |  GDTCORMCWReachabilityFailed = 4,
   42|       |
   43|       |  /** For error messages concerning transform: not being implemented by an event transformer. */
   44|       |  GDTCORMCETransformerDoesntImplementTransform = 1000,
   45|       |
   46|       |  /** For error messages concerning the creation of a directory failing. */
   47|       |  GDTCORMCEDirectoryCreationError = 1001,
   48|       |
   49|       |  /** For error messages concerning the writing of a event file. */
   50|       |  GDTCORMCEFileWriteError = 1002,
   51|       |
   52|       |  /** For error messages concerning the lack of a prioritizer for a given backend. */
   53|       |  GDTCORMCEPrioritizerError = 1003,
   54|       |
   55|       |  /** For error messages concerning a package delivery API violation. */
   56|       |  GDTCORMCEDeliverTwice = 1004,
   57|       |
   58|       |  /** For error messages concerning an error in an implementation of -transportBytes. */
   59|       |  GDTCORMCETransportBytesError = 1005,
   60|       |
   61|       |  /** For general purpose error messages in a dependency. */
   62|       |  GDTCORMCEGeneralError = 1006,
   63|       |
   64|       |  /** For fatal errors. Please go to https://github.com/firebase/firebase-ios-sdk/issues and open
   65|       |   * an issue if you encounter an error with this code.
   66|       |   */
   67|       |  GDTCORMCEFatalAssertion = 1007
   68|       |};
   69|       |
   70|       |/** */
   71|       |FOUNDATION_EXPORT
   72|       |void GDTCORLog(GDTCORMessageCode code, NSString *_Nonnull format, ...);
   73|       |
   74|       |/** Returns the string that represents some message code.
   75|       | *
   76|       | * @param code The code to convert to a string.
   77|       | * @return The string representing the message code.
   78|       | */
   79|       |FOUNDATION_EXPORT NSString *_Nonnull GDTCORMessageCodeEnumToString(GDTCORMessageCode code);
   80|       |
   81|       |// A define to wrap GULLogWarning with slightly more convenient usage.
   82|       |#define GDTCORLogWarning(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
   83|      0|  GDTCORLog(MESSAGE_CODE, MESSAGE_FORMAT, __VA_ARGS__);
   84|       |
   85|       |// A define to wrap GULLogError with slightly more convenient usage and a failing assert.
   86|       |#define GDTCORLogError(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
   87|      0|  GDTCORLog(MESSAGE_CODE, MESSAGE_FORMAT, __VA_ARGS__);
   88|       |
   89|       |// A define to wrap NSLog for verbose console logs only useful for local debugging.
   90|       |#if GDT_VERBOSE_LOGGING == 1
   91|       |#define GDTCORLogDebug(FORMAT, ...) NSLog(@"GDT: " FORMAT, __VA_ARGS__);
   92|       |#else
   93|       |#define GDTCORLogDebug(...)
   94|       |#endif  // GDT_VERBOSE_LOGGING == 1

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/cache.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// A Cache is an interface that maps keys to values.  It has internal
    6|       |// synchronization and may be safely accessed concurrently from
    7|       |// multiple threads.  It may automatically evict entries to make room
    8|       |// for new entries.  Values have a specified charge against the cache
    9|       |// capacity.  For example, a cache where the values are variable
   10|       |// length strings, may use the length of the string as the charge for
   11|       |// the string.
   12|       |//
   13|       |// A builtin cache implementation with a least-recently-used eviction
   14|       |// policy is provided.  Clients may use their own implementations if
   15|       |// they want something more sophisticated (like scan-resistance, a
   16|       |// custom eviction policy, variable cache sizing, etc.)
   17|       |
   18|       |#ifndef STORAGE_LEVELDB_INCLUDE_CACHE_H_
   19|       |#define STORAGE_LEVELDB_INCLUDE_CACHE_H_
   20|       |
   21|       |#include <stdint.h>
   22|       |
   23|       |#include "leveldb/export.h"
   24|       |#include "leveldb/slice.h"
   25|       |
   26|       |namespace leveldb {
   27|       |
   28|       |class LEVELDB_EXPORT Cache;
   29|       |
   30|       |// Create a new cache with a fixed size capacity.  This implementation
   31|       |// of Cache uses a least-recently-used eviction policy.
   32|       |LEVELDB_EXPORT Cache* NewLRUCache(size_t capacity);
   33|       |
   34|       |class LEVELDB_EXPORT Cache {
   35|       | public:
   36|      0|  Cache() = default;
   37|       |
   38|       |  Cache(const Cache&) = delete;
   39|       |  Cache& operator=(const Cache&) = delete;
   40|       |
   41|       |  // Destroys all existing entries by calling the "deleter"
   42|       |  // function that was passed to the constructor.
   43|       |  virtual ~Cache();
   44|       |
   45|       |  // Opaque handle to an entry stored in the cache.
   46|       |  struct Handle {};
   47|       |
   48|       |  // Insert a mapping from key->value into the cache and assign it
   49|       |  // the specified charge against the total cache capacity.
   50|       |  //
   51|       |  // Returns a handle that corresponds to the mapping.  The caller
   52|       |  // must call this->Release(handle) when the returned mapping is no
   53|       |  // longer needed.
   54|       |  //
   55|       |  // When the inserted entry is no longer needed, the key and
   56|       |  // value will be passed to "deleter".
   57|       |  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
   58|       |                         void (*deleter)(const Slice& key, void* value)) = 0;
   59|       |
   60|       |  // If the cache has no mapping for "key", returns nullptr.
   61|       |  //
   62|       |  // Else return a handle that corresponds to the mapping.  The caller
   63|       |  // must call this->Release(handle) when the returned mapping is no
   64|       |  // longer needed.
   65|       |  virtual Handle* Lookup(const Slice& key) = 0;
   66|       |
   67|       |  // Release a mapping returned by a previous Lookup().
   68|       |  // REQUIRES: handle must not have been released yet.
   69|       |  // REQUIRES: handle must have been returned by a method on *this.
   70|       |  virtual void Release(Handle* handle) = 0;
   71|       |
   72|       |  // Return the value encapsulated in a handle returned by a
   73|       |  // successful Lookup().
   74|       |  // REQUIRES: handle must not have been released yet.
   75|       |  // REQUIRES: handle must have been returned by a method on *this.
   76|       |  virtual void* Value(Handle* handle) = 0;
   77|       |
   78|       |  // If the cache contains entry for key, erase it.  Note that the
   79|       |  // underlying entry will be kept around until all existing handles
   80|       |  // to it have been released.
   81|       |  virtual void Erase(const Slice& key) = 0;
   82|       |
   83|       |  // Return a new numeric id.  May be used by multiple clients who are
   84|       |  // sharing the same cache to partition the key space.  Typically the
   85|       |  // client will allocate a new id at startup and prepend the id to
   86|       |  // its cache keys.
   87|       |  virtual uint64_t NewId() = 0;
   88|       |
   89|       |  // Remove all cache entries that are not actively in use.  Memory-constrained
   90|       |  // applications may wish to call this method to reduce memory usage.
   91|       |  // Default implementation of Prune() does nothing.  Subclasses are strongly
   92|       |  // encouraged to override the default implementation.  A future release of
   93|       |  // leveldb may change Prune() to a pure abstract method.
   94|      0|  virtual void Prune() {}
   95|       |
   96|       |  // Return an estimate of the combined charges of all elements stored in the
   97|       |  // cache.
   98|       |  virtual size_t TotalCharge() const = 0;
   99|       |
  100|       | private:
  101|       |  void LRU_Remove(Handle* e);
  102|       |  void LRU_Append(Handle* e);
  103|       |  void Unref(Handle* e);
  104|       |
  105|       |  struct Rep;
  106|       |  Rep* rep_;
  107|       |};
  108|       |
  109|       |}  // namespace leveldb
  110|       |
  111|       |#endif  // STORAGE_LEVELDB_INCLUDE_CACHE_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/db.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_INCLUDE_DB_H_
    6|       |#define STORAGE_LEVELDB_INCLUDE_DB_H_
    7|       |
    8|       |#include <stdint.h>
    9|       |#include <stdio.h>
   10|       |
   11|       |#include "leveldb/export.h"
   12|       |#include "leveldb/iterator.h"
   13|       |#include "leveldb/options.h"
   14|       |
   15|       |namespace leveldb {
   16|       |
   17|       |// Update CMakeLists.txt if you change these
   18|       |static const int kMajorVersion = 1;
   19|       |static const int kMinorVersion = 22;
   20|       |
   21|       |struct Options;
   22|       |struct ReadOptions;
   23|       |struct WriteOptions;
   24|       |class WriteBatch;
   25|       |
   26|       |// Abstract handle to particular state of a DB.
   27|       |// A Snapshot is an immutable object and can therefore be safely
   28|       |// accessed from multiple threads without any external synchronization.
   29|       |class LEVELDB_EXPORT Snapshot {
   30|       | protected:
   31|       |  virtual ~Snapshot();
   32|       |};
   33|       |
   34|       |// A range of keys
   35|       |struct LEVELDB_EXPORT Range {
   36|       |  Range() {}
   37|       |  Range(const Slice& s, const Slice& l) : start(s), limit(l) {}
   38|       |
   39|       |  Slice start;  // Included in the range
   40|       |  Slice limit;  // Not included in the range
   41|       |};
   42|       |
   43|       |// A DB is a persistent ordered map from keys to values.
   44|       |// A DB is safe for concurrent access from multiple threads without
   45|       |// any external synchronization.
   46|       |class LEVELDB_EXPORT DB {
   47|       | public:
   48|       |  // Open the database with the specified "name".
   49|       |  // Stores a pointer to a heap-allocated database in *dbptr and returns
   50|       |  // OK on success.
   51|       |  // Stores nullptr in *dbptr and returns a non-OK status on error.
   52|       |  // Caller should delete *dbptr when it is no longer needed.
   53|       |  static Status Open(const Options& options, const std::string& name,
   54|       |                     DB** dbptr);
   55|       |
   56|      0|  DB() = default;
   57|       |
   58|       |  DB(const DB&) = delete;
   59|       |  DB& operator=(const DB&) = delete;
   60|       |
   61|       |  virtual ~DB();
   62|       |
   63|       |  // Set the database entry for "key" to "value".  Returns OK on success,
   64|       |  // and a non-OK status on error.
   65|       |  // Note: consider setting options.sync = true.
   66|       |  virtual Status Put(const WriteOptions& options, const Slice& key,
   67|       |                     const Slice& value) = 0;
   68|       |
   69|       |  // Remove the database entry (if any) for "key".  Returns OK on
   70|       |  // success, and a non-OK status on error.  It is not an error if "key"
   71|       |  // did not exist in the database.
   72|       |  // Note: consider setting options.sync = true.
   73|       |  virtual Status Delete(const WriteOptions& options, const Slice& key) = 0;
   74|       |
   75|       |  // Apply the specified updates to the database.
   76|       |  // Returns OK on success, non-OK on failure.
   77|       |  // Note: consider setting options.sync = true.
   78|       |  virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;
   79|       |
   80|       |  // If the database contains an entry for "key" store the
   81|       |  // corresponding value in *value and return OK.
   82|       |  //
   83|       |  // If there is no entry for "key" leave *value unchanged and return
   84|       |  // a status for which Status::IsNotFound() returns true.
   85|       |  //
   86|       |  // May return some other Status on an error.
   87|       |  virtual Status Get(const ReadOptions& options, const Slice& key,
   88|       |                     std::string* value) = 0;
   89|       |
   90|       |  // Return a heap-allocated iterator over the contents of the database.
   91|       |  // The result of NewIterator() is initially invalid (caller must
   92|       |  // call one of the Seek methods on the iterator before using it).
   93|       |  //
   94|       |  // Caller should delete the iterator when it is no longer needed.
   95|       |  // The returned iterator should be deleted before this db is deleted.
   96|       |  virtual Iterator* NewIterator(const ReadOptions& options) = 0;
   97|       |
   98|       |  // Return a handle to the current DB state.  Iterators created with
   99|       |  // this handle will all observe a stable snapshot of the current DB
  100|       |  // state.  The caller must call ReleaseSnapshot(result) when the
  101|       |  // snapshot is no longer needed.
  102|       |  virtual const Snapshot* GetSnapshot() = 0;
  103|       |
  104|       |  // Release a previously acquired snapshot.  The caller must not
  105|       |  // use "snapshot" after this call.
  106|       |  virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;
  107|       |
  108|       |  // DB implementations can export properties about their state
  109|       |  // via this method.  If "property" is a valid property understood by this
  110|       |  // DB implementation, fills "*value" with its current value and returns
  111|       |  // true.  Otherwise returns false.
  112|       |  //
  113|       |  //
  114|       |  // Valid property names include:
  115|       |  //
  116|       |  //  "leveldb.num-files-at-level<N>" - return the number of files at level <N>,
  117|       |  //     where <N> is an ASCII representation of a level number (e.g. "0").
  118|       |  //  "leveldb.stats" - returns a multi-line string that describes statistics
  119|       |  //     about the internal operation of the DB.
  120|       |  //  "leveldb.sstables" - returns a multi-line string that describes all
  121|       |  //     of the sstables that make up the db contents.
  122|       |  //  "leveldb.approximate-memory-usage" - returns the approximate number of
  123|       |  //     bytes of memory in use by the DB.
  124|       |  virtual bool GetProperty(const Slice& property, std::string* value) = 0;
  125|       |
  126|       |  // For each i in [0,n-1], store in "sizes[i]", the approximate
  127|       |  // file system space used by keys in "[range[i].start .. range[i].limit)".
  128|       |  //
  129|       |  // Note that the returned sizes measure file system space usage, so
  130|       |  // if the user data compresses by a factor of ten, the returned
  131|       |  // sizes will be one-tenth the size of the corresponding user data size.
  132|       |  //
  133|       |  // The results may not include the sizes of recently written data.
  134|       |  virtual void GetApproximateSizes(const Range* range, int n,
  135|       |                                   uint64_t* sizes) = 0;
  136|       |
  137|       |  // Compact the underlying storage for the key range [*begin,*end].
  138|       |  // In particular, deleted and overwritten versions are discarded,
  139|       |  // and the data is rearranged to reduce the cost of operations
  140|       |  // needed to access the data.  This operation should typically only
  141|       |  // be invoked by users who understand the underlying implementation.
  142|       |  //
  143|       |  // begin==nullptr is treated as a key before all keys in the database.
  144|       |  // end==nullptr is treated as a key after all keys in the database.
  145|       |  // Therefore the following call will compact the entire database:
  146|       |  //    db->CompactRange(nullptr, nullptr);
  147|       |  virtual void CompactRange(const Slice* begin, const Slice* end) = 0;
  148|       |};
  149|       |
  150|       |// Destroy the contents of the specified database.
  151|       |// Be very careful using this method.
  152|       |//
  153|       |// Note: For backwards compatibility, if DestroyDB is unable to list the
  154|       |// database files, Status::OK() will still be returned masking this failure.
  155|       |LEVELDB_EXPORT Status DestroyDB(const std::string& name,
  156|       |                                const Options& options);
  157|       |
  158|       |// If a DB cannot be opened, you may attempt to call this method to
  159|       |// resurrect as much of the contents of the database as possible.
  160|       |// Some data may be lost, so be careful when calling this function
  161|       |// on a database that contains important information.
  162|       |LEVELDB_EXPORT Status RepairDB(const std::string& dbname,
  163|       |                               const Options& options);
  164|       |
  165|       |}  // namespace leveldb
  166|       |
  167|       |#endif  // STORAGE_LEVELDB_INCLUDE_DB_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/env.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// An Env is an interface used by the leveldb implementation to access
    6|       |// operating system functionality like the filesystem etc.  Callers
    7|       |// may wish to provide a custom Env object when opening a database to
    8|       |// get fine gain control; e.g., to rate limit file system operations.
    9|       |//
   10|       |// All Env implementations are safe for concurrent access from
   11|       |// multiple threads without any external synchronization.
   12|       |
   13|       |#ifndef STORAGE_LEVELDB_INCLUDE_ENV_H_
   14|       |#define STORAGE_LEVELDB_INCLUDE_ENV_H_
   15|       |
   16|       |#include <stdarg.h>
   17|       |#include <stdint.h>
   18|       |
   19|       |#include <string>
   20|       |#include <vector>
   21|       |
   22|       |#include "leveldb/export.h"
   23|       |#include "leveldb/status.h"
   24|       |
   25|       |#if defined(_WIN32)
   26|       |// The leveldb::Env class below contains a DeleteFile method.
   27|       |// At the same time, <windows.h>, a fairly popular header
   28|       |// file for Windows applications, defines a DeleteFile macro.
   29|       |//
   30|       |// Without any intervention on our part, the result of this
   31|       |// unfortunate coincidence is that the name of the
   32|       |// leveldb::Env::DeleteFile method seen by the compiler depends on
   33|       |// whether <windows.h> was included before or after the LevelDB
   34|       |// headers.
   35|       |//
   36|       |// To avoid headaches, we undefined DeleteFile (if defined) and
   37|       |// redefine it at the bottom of this file. This way <windows.h>
   38|       |// can be included before this file (or not at all) and the
   39|       |// exported method will always be leveldb::Env::DeleteFile.
   40|       |#if defined(DeleteFile)
   41|       |#undef DeleteFile
   42|       |#define LEVELDB_DELETEFILE_UNDEFINED
   43|       |#endif  // defined(DeleteFile)
   44|       |#endif  // defined(_WIN32)
   45|       |
   46|       |namespace leveldb {
   47|       |
   48|       |class FileLock;
   49|       |class Logger;
   50|       |class RandomAccessFile;
   51|       |class SequentialFile;
   52|       |class Slice;
   53|       |class WritableFile;
   54|       |
   55|       |class LEVELDB_EXPORT Env {
   56|       | public:
   57|      0|  Env() = default;
   58|       |
   59|       |  Env(const Env&) = delete;
   60|       |  Env& operator=(const Env&) = delete;
   61|       |
   62|       |  virtual ~Env();
   63|       |
   64|       |  // Return a default environment suitable for the current operating
   65|       |  // system.  Sophisticated users may wish to provide their own Env
   66|       |  // implementation instead of relying on this default environment.
   67|       |  //
   68|       |  // The result of Default() belongs to leveldb and must never be deleted.
   69|       |  static Env* Default();
   70|       |
   71|       |  // Create an object that sequentially reads the file with the specified name.
   72|       |  // On success, stores a pointer to the new file in *result and returns OK.
   73|       |  // On failure stores nullptr in *result and returns non-OK.  If the file does
   74|       |  // not exist, returns a non-OK status.  Implementations should return a
   75|       |  // NotFound status when the file does not exist.
   76|       |  //
   77|       |  // The returned file will only be accessed by one thread at a time.
   78|       |  virtual Status NewSequentialFile(const std::string& fname,
   79|       |                                   SequentialFile** result) = 0;
   80|       |
   81|       |  // Create an object supporting random-access reads from the file with the
   82|       |  // specified name.  On success, stores a pointer to the new file in
   83|       |  // *result and returns OK.  On failure stores nullptr in *result and
   84|       |  // returns non-OK.  If the file does not exist, returns a non-OK
   85|       |  // status.  Implementations should return a NotFound status when the file does
   86|       |  // not exist.
   87|       |  //
   88|       |  // The returned file may be concurrently accessed by multiple threads.
   89|       |  virtual Status NewRandomAccessFile(const std::string& fname,
   90|       |                                     RandomAccessFile** result) = 0;
   91|       |
   92|       |  // Create an object that writes to a new file with the specified
   93|       |  // name.  Deletes any existing file with the same name and creates a
   94|       |  // new file.  On success, stores a pointer to the new file in
   95|       |  // *result and returns OK.  On failure stores nullptr in *result and
   96|       |  // returns non-OK.
   97|       |  //
   98|       |  // The returned file will only be accessed by one thread at a time.
   99|       |  virtual Status NewWritableFile(const std::string& fname,
  100|       |                                 WritableFile** result) = 0;
  101|       |
  102|       |  // Create an object that either appends to an existing file, or
  103|       |  // writes to a new file (if the file does not exist to begin with).
  104|       |  // On success, stores a pointer to the new file in *result and
  105|       |  // returns OK.  On failure stores nullptr in *result and returns
  106|       |  // non-OK.
  107|       |  //
  108|       |  // The returned file will only be accessed by one thread at a time.
  109|       |  //
  110|       |  // May return an IsNotSupportedError error if this Env does
  111|       |  // not allow appending to an existing file.  Users of Env (including
  112|       |  // the leveldb implementation) must be prepared to deal with
  113|       |  // an Env that does not support appending.
  114|       |  virtual Status NewAppendableFile(const std::string& fname,
  115|       |                                   WritableFile** result);
  116|       |
  117|       |  // Returns true iff the named file exists.
  118|       |  virtual bool FileExists(const std::string& fname) = 0;
  119|       |
  120|       |  // Store in *result the names of the children of the specified directory.
  121|       |  // The names are relative to "dir".
  122|       |  // Original contents of *results are dropped.
  123|       |  virtual Status GetChildren(const std::string& dir,
  124|       |                             std::vector<std::string>* result) = 0;
  125|       |
  126|       |  // Delete the named file.
  127|       |  virtual Status DeleteFile(const std::string& fname) = 0;
  128|       |
  129|       |  // Create the specified directory.
  130|       |  virtual Status CreateDir(const std::string& dirname) = 0;
  131|       |
  132|       |  // Delete the specified directory.
  133|       |  virtual Status DeleteDir(const std::string& dirname) = 0;
  134|       |
  135|       |  // Store the size of fname in *file_size.
  136|       |  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) = 0;
  137|       |
  138|       |  // Rename file src to target.
  139|       |  virtual Status RenameFile(const std::string& src,
  140|       |                            const std::string& target) = 0;
  141|       |
  142|       |  // Lock the specified file.  Used to prevent concurrent access to
  143|       |  // the same db by multiple processes.  On failure, stores nullptr in
  144|       |  // *lock and returns non-OK.
  145|       |  //
  146|       |  // On success, stores a pointer to the object that represents the
  147|       |  // acquired lock in *lock and returns OK.  The caller should call
  148|       |  // UnlockFile(*lock) to release the lock.  If the process exits,
  149|       |  // the lock will be automatically released.
  150|       |  //
  151|       |  // If somebody else already holds the lock, finishes immediately
  152|       |  // with a failure.  I.e., this call does not wait for existing locks
  153|       |  // to go away.
  154|       |  //
  155|       |  // May create the named file if it does not already exist.
  156|       |  virtual Status LockFile(const std::string& fname, FileLock** lock) = 0;
  157|       |
  158|       |  // Release the lock acquired by a previous successful call to LockFile.
  159|       |  // REQUIRES: lock was returned by a successful LockFile() call
  160|       |  // REQUIRES: lock has not already been unlocked.
  161|       |  virtual Status UnlockFile(FileLock* lock) = 0;
  162|       |
  163|       |  // Arrange to run "(*function)(arg)" once in a background thread.
  164|       |  //
  165|       |  // "function" may run in an unspecified thread.  Multiple functions
  166|       |  // added to the same Env may run concurrently in different threads.
  167|       |  // I.e., the caller may not assume that background work items are
  168|       |  // serialized.
  169|       |  virtual void Schedule(void (*function)(void* arg), void* arg) = 0;
  170|       |
  171|       |  // Start a new thread, invoking "function(arg)" within the new thread.
  172|       |  // When "function(arg)" returns, the thread will be destroyed.
  173|       |  virtual void StartThread(void (*function)(void* arg), void* arg) = 0;
  174|       |
  175|       |  // *path is set to a temporary directory that can be used for testing. It may
  176|       |  // or may not have just been created. The directory may or may not differ
  177|       |  // between runs of the same process, but subsequent calls will return the
  178|       |  // same directory.
  179|       |  virtual Status GetTestDirectory(std::string* path) = 0;
  180|       |
  181|       |  // Create and return a log file for storing informational messages.
  182|       |  virtual Status NewLogger(const std::string& fname, Logger** result) = 0;
  183|       |
  184|       |  // Returns the number of micro-seconds since some fixed point in time. Only
  185|       |  // useful for computing deltas of time.
  186|       |  virtual uint64_t NowMicros() = 0;
  187|       |
  188|       |  // Sleep/delay the thread for the prescribed number of micro-seconds.
  189|       |  virtual void SleepForMicroseconds(int micros) = 0;
  190|       |};
  191|       |
  192|       |// A file abstraction for reading sequentially through a file
  193|       |class LEVELDB_EXPORT SequentialFile {
  194|       | public:
  195|      0|  SequentialFile() = default;
  196|       |
  197|       |  SequentialFile(const SequentialFile&) = delete;
  198|       |  SequentialFile& operator=(const SequentialFile&) = delete;
  199|       |
  200|       |  virtual ~SequentialFile();
  201|       |
  202|       |  // Read up to "n" bytes from the file.  "scratch[0..n-1]" may be
  203|       |  // written by this routine.  Sets "*result" to the data that was
  204|       |  // read (including if fewer than "n" bytes were successfully read).
  205|       |  // May set "*result" to point at data in "scratch[0..n-1]", so
  206|       |  // "scratch[0..n-1]" must be live when "*result" is used.
  207|       |  // If an error was encountered, returns a non-OK status.
  208|       |  //
  209|       |  // REQUIRES: External synchronization
  210|       |  virtual Status Read(size_t n, Slice* result, char* scratch) = 0;
  211|       |
  212|       |  // Skip "n" bytes from the file. This is guaranteed to be no
  213|       |  // slower that reading the same data, but may be faster.
  214|       |  //
  215|       |  // If end of file is reached, skipping will stop at the end of the
  216|       |  // file, and Skip will return OK.
  217|       |  //
  218|       |  // REQUIRES: External synchronization
  219|       |  virtual Status Skip(uint64_t n) = 0;
  220|       |};
  221|       |
  222|       |// A file abstraction for randomly reading the contents of a file.
  223|       |class LEVELDB_EXPORT RandomAccessFile {
  224|       | public:
  225|      0|  RandomAccessFile() = default;
  226|       |
  227|       |  RandomAccessFile(const RandomAccessFile&) = delete;
  228|       |  RandomAccessFile& operator=(const RandomAccessFile&) = delete;
  229|       |
  230|       |  virtual ~RandomAccessFile();
  231|       |
  232|       |  // Read up to "n" bytes from the file starting at "offset".
  233|       |  // "scratch[0..n-1]" may be written by this routine.  Sets "*result"
  234|       |  // to the data that was read (including if fewer than "n" bytes were
  235|       |  // successfully read).  May set "*result" to point at data in
  236|       |  // "scratch[0..n-1]", so "scratch[0..n-1]" must be live when
  237|       |  // "*result" is used.  If an error was encountered, returns a non-OK
  238|       |  // status.
  239|       |  //
  240|       |  // Safe for concurrent use by multiple threads.
  241|       |  virtual Status Read(uint64_t offset, size_t n, Slice* result,
  242|       |                      char* scratch) const = 0;
  243|       |};
  244|       |
  245|       |// A file abstraction for sequential writing.  The implementation
  246|       |// must provide buffering since callers may append small fragments
  247|       |// at a time to the file.
  248|       |class LEVELDB_EXPORT WritableFile {
  249|       | public:
  250|      0|  WritableFile() = default;
  251|       |
  252|       |  WritableFile(const WritableFile&) = delete;
  253|       |  WritableFile& operator=(const WritableFile&) = delete;
  254|       |
  255|       |  virtual ~WritableFile();
  256|       |
  257|       |  virtual Status Append(const Slice& data) = 0;
  258|       |  virtual Status Close() = 0;
  259|       |  virtual Status Flush() = 0;
  260|       |  virtual Status Sync() = 0;
  261|       |};
  262|       |
  263|       |// An interface for writing log messages.
  264|       |class LEVELDB_EXPORT Logger {
  265|       | public:
  266|      0|  Logger() = default;
  267|       |
  268|       |  Logger(const Logger&) = delete;
  269|       |  Logger& operator=(const Logger&) = delete;
  270|       |
  271|       |  virtual ~Logger();
  272|       |
  273|       |  // Write an entry to the log file with the specified format.
  274|       |  virtual void Logv(const char* format, va_list ap) = 0;
  275|       |};
  276|       |
  277|       |// Identifies a locked file.
  278|       |class LEVELDB_EXPORT FileLock {
  279|       | public:
  280|      0|  FileLock() = default;
  281|       |
  282|       |  FileLock(const FileLock&) = delete;
  283|       |  FileLock& operator=(const FileLock&) = delete;
  284|       |
  285|       |  virtual ~FileLock();
  286|       |};
  287|       |
  288|       |// Log the specified data to *info_log if info_log is non-null.
  289|       |void Log(Logger* info_log, const char* format, ...)
  290|       |#if defined(__GNUC__) || defined(__clang__)
  291|       |    __attribute__((__format__(__printf__, 2, 3)))
  292|       |#endif
  293|       |    ;
  294|       |
  295|       |// A utility routine: write "data" to the named file.
  296|       |LEVELDB_EXPORT Status WriteStringToFile(Env* env, const Slice& data,
  297|       |                                        const std::string& fname);
  298|       |
  299|       |// A utility routine: read contents of named file into *data
  300|       |LEVELDB_EXPORT Status ReadFileToString(Env* env, const std::string& fname,
  301|       |                                       std::string* data);
  302|       |
  303|       |// An implementation of Env that forwards all calls to another Env.
  304|       |// May be useful to clients who wish to override just part of the
  305|       |// functionality of another Env.
  306|       |class LEVELDB_EXPORT EnvWrapper : public Env {
  307|       | public:
  308|       |  // Initialize an EnvWrapper that delegates all calls to *t.
  309|      0|  explicit EnvWrapper(Env* t) : target_(t) {}
  310|       |  virtual ~EnvWrapper();
  311|       |
  312|       |  // Return the target to which this Env forwards all calls.
  313|      0|  Env* target() const { return target_; }
  314|       |
  315|       |  // The following text is boilerplate that forwards all methods to target().
  316|      0|  Status NewSequentialFile(const std::string& f, SequentialFile** r) override {
  317|      0|    return target_->NewSequentialFile(f, r);
  318|      0|  }
  319|       |  Status NewRandomAccessFile(const std::string& f,
  320|      0|                             RandomAccessFile** r) override {
  321|      0|    return target_->NewRandomAccessFile(f, r);
  322|      0|  }
  323|      0|  Status NewWritableFile(const std::string& f, WritableFile** r) override {
  324|      0|    return target_->NewWritableFile(f, r);
  325|      0|  }
  326|      0|  Status NewAppendableFile(const std::string& f, WritableFile** r) override {
  327|      0|    return target_->NewAppendableFile(f, r);
  328|      0|  }
  329|      0|  bool FileExists(const std::string& f) override {
  330|      0|    return target_->FileExists(f);
  331|      0|  }
  332|       |  Status GetChildren(const std::string& dir,
  333|      0|                     std::vector<std::string>* r) override {
  334|      0|    return target_->GetChildren(dir, r);
  335|      0|  }
  336|      0|  Status DeleteFile(const std::string& f) override {
  337|      0|    return target_->DeleteFile(f);
  338|      0|  }
  339|      0|  Status CreateDir(const std::string& d) override {
  340|      0|    return target_->CreateDir(d);
  341|      0|  }
  342|      0|  Status DeleteDir(const std::string& d) override {
  343|      0|    return target_->DeleteDir(d);
  344|      0|  }
  345|      0|  Status GetFileSize(const std::string& f, uint64_t* s) override {
  346|      0|    return target_->GetFileSize(f, s);
  347|      0|  }
  348|      0|  Status RenameFile(const std::string& s, const std::string& t) override {
  349|      0|    return target_->RenameFile(s, t);
  350|      0|  }
  351|      0|  Status LockFile(const std::string& f, FileLock** l) override {
  352|      0|    return target_->LockFile(f, l);
  353|      0|  }
  354|      0|  Status UnlockFile(FileLock* l) override { return target_->UnlockFile(l); }
  355|      0|  void Schedule(void (*f)(void*), void* a) override {
  356|      0|    return target_->Schedule(f, a);
  357|      0|  }
  358|      0|  void StartThread(void (*f)(void*), void* a) override {
  359|      0|    return target_->StartThread(f, a);
  360|      0|  }
  361|      0|  Status GetTestDirectory(std::string* path) override {
  362|      0|    return target_->GetTestDirectory(path);
  363|      0|  }
  364|      0|  Status NewLogger(const std::string& fname, Logger** result) override {
  365|      0|    return target_->NewLogger(fname, result);
  366|      0|  }
  367|      0|  uint64_t NowMicros() override { return target_->NowMicros(); }
  368|      0|  void SleepForMicroseconds(int micros) override {
  369|      0|    target_->SleepForMicroseconds(micros);
  370|      0|  }
  371|       |
  372|       | private:
  373|       |  Env* target_;
  374|       |};
  375|       |
  376|       |}  // namespace leveldb
  377|       |
  378|       |// Redefine DeleteFile if necessary.
  379|       |#if defined(_WIN32) && defined(LEVELDB_DELETEFILE_UNDEFINED)
  380|       |#if defined(UNICODE)
  381|       |#define DeleteFile DeleteFileW
  382|       |#else
  383|       |#define DeleteFile DeleteFileA
  384|       |#endif  // defined(UNICODE)
  385|       |#endif  // defined(_WIN32) && defined(LEVELDB_DELETEFILE_UNDEFINED)
  386|       |
  387|       |#endif  // STORAGE_LEVELDB_INCLUDE_ENV_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/iterator.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// An iterator yields a sequence of key/value pairs from a source.
    6|       |// The following class defines the interface.  Multiple implementations
    7|       |// are provided by this library.  In particular, iterators are provided
    8|       |// to access the contents of a Table or a DB.
    9|       |//
   10|       |// Multiple threads can invoke const methods on an Iterator without
   11|       |// external synchronization, but if any of the threads may call a
   12|       |// non-const method, all threads accessing the same Iterator must use
   13|       |// external synchronization.
   14|       |
   15|       |#ifndef STORAGE_LEVELDB_INCLUDE_ITERATOR_H_
   16|       |#define STORAGE_LEVELDB_INCLUDE_ITERATOR_H_
   17|       |
   18|       |#include "leveldb/export.h"
   19|       |#include "leveldb/slice.h"
   20|       |#include "leveldb/status.h"
   21|       |
   22|       |namespace leveldb {
   23|       |
   24|       |class LEVELDB_EXPORT Iterator {
   25|       | public:
   26|       |  Iterator();
   27|       |
   28|       |  Iterator(const Iterator&) = delete;
   29|       |  Iterator& operator=(const Iterator&) = delete;
   30|       |
   31|       |  virtual ~Iterator();
   32|       |
   33|       |  // An iterator is either positioned at a key/value pair, or
   34|       |  // not valid.  This method returns true iff the iterator is valid.
   35|       |  virtual bool Valid() const = 0;
   36|       |
   37|       |  // Position at the first key in the source.  The iterator is Valid()
   38|       |  // after this call iff the source is not empty.
   39|       |  virtual void SeekToFirst() = 0;
   40|       |
   41|       |  // Position at the last key in the source.  The iterator is
   42|       |  // Valid() after this call iff the source is not empty.
   43|       |  virtual void SeekToLast() = 0;
   44|       |
   45|       |  // Position at the first key in the source that is at or past target.
   46|       |  // The iterator is Valid() after this call iff the source contains
   47|       |  // an entry that comes at or past target.
   48|       |  virtual void Seek(const Slice& target) = 0;
   49|       |
   50|       |  // Moves to the next entry in the source.  After this call, Valid() is
   51|       |  // true iff the iterator was not positioned at the last entry in the source.
   52|       |  // REQUIRES: Valid()
   53|       |  virtual void Next() = 0;
   54|       |
   55|       |  // Moves to the previous entry in the source.  After this call, Valid() is
   56|       |  // true iff the iterator was not positioned at the first entry in source.
   57|       |  // REQUIRES: Valid()
   58|       |  virtual void Prev() = 0;
   59|       |
   60|       |  // Return the key for the current entry.  The underlying storage for
   61|       |  // the returned slice is valid only until the next modification of
   62|       |  // the iterator.
   63|       |  // REQUIRES: Valid()
   64|       |  virtual Slice key() const = 0;
   65|       |
   66|       |  // Return the value for the current entry.  The underlying storage for
   67|       |  // the returned slice is valid only until the next modification of
   68|       |  // the iterator.
   69|       |  // REQUIRES: Valid()
   70|       |  virtual Slice value() const = 0;
   71|       |
   72|       |  // If an error has occurred, return it.  Else return an ok status.
   73|       |  virtual Status status() const = 0;
   74|       |
   75|       |  // Clients are allowed to register function/arg1/arg2 triples that
   76|       |  // will be invoked when this iterator is destroyed.
   77|       |  //
   78|       |  // Note that unlike all of the preceding methods, this method is
   79|       |  // not abstract and therefore clients should not override it.
   80|       |  using CleanupFunction = void (*)(void* arg1, void* arg2);
   81|       |  void RegisterCleanup(CleanupFunction function, void* arg1, void* arg2);
   82|       |
   83|       | private:
   84|       |  // Cleanup functions are stored in a single-linked list.
   85|       |  // The list's head node is inlined in the iterator.
   86|       |  struct CleanupNode {
   87|       |    // True if the node is not used. Only head nodes might be unused.
   88|      0|    bool IsEmpty() const { return function == nullptr; }
   89|       |    // Invokes the cleanup function.
   90|      0|    void Run() {
   91|      0|      assert(function != nullptr);
   92|      0|      (*function)(arg1, arg2);
   93|      0|    }
   94|       |
   95|       |    // The head node is used if the function pointer is not null.
   96|       |    CleanupFunction function;
   97|       |    void* arg1;
   98|       |    void* arg2;
   99|       |    CleanupNode* next;
  100|       |  };
  101|       |  CleanupNode cleanup_head_;
  102|       |};
  103|       |
  104|       |// Return an empty iterator (yields nothing).
  105|       |LEVELDB_EXPORT Iterator* NewEmptyIterator();
  106|       |
  107|       |// Return an empty iterator with the specified status.
  108|       |LEVELDB_EXPORT Iterator* NewErrorIterator(const Status& status);
  109|       |
  110|       |}  // namespace leveldb
  111|       |
  112|       |#endif  // STORAGE_LEVELDB_INCLUDE_ITERATOR_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/slice.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// Slice is a simple structure containing a pointer into some external
    6|       |// storage and a size.  The user of a Slice must ensure that the slice
    7|       |// is not used after the corresponding external storage has been
    8|       |// deallocated.
    9|       |//
   10|       |// Multiple threads can invoke const methods on a Slice without
   11|       |// external synchronization, but if any of the threads may call a
   12|       |// non-const method, all threads accessing the same Slice must use
   13|       |// external synchronization.
   14|       |
   15|       |#ifndef STORAGE_LEVELDB_INCLUDE_SLICE_H_
   16|       |#define STORAGE_LEVELDB_INCLUDE_SLICE_H_
   17|       |
   18|       |#include <assert.h>
   19|       |#include <stddef.h>
   20|       |#include <string.h>
   21|       |
   22|       |#include <string>
   23|       |
   24|       |#include "leveldb/export.h"
   25|       |
   26|       |namespace leveldb {
   27|       |
   28|       |class LEVELDB_EXPORT Slice {
   29|       | public:
   30|       |  // Create an empty slice.
   31|       |  Slice() : data_(""), size_(0) {}
   32|       |
   33|       |  // Create a slice that refers to d[0,n-1].
   34|       |  Slice(const char* d, size_t n) : data_(d), size_(n) {}
   35|       |
   36|       |  // Create a slice that refers to the contents of "s"
   37|      0|  Slice(const std::string& s) : data_(s.data()), size_(s.size()) {}
   38|       |
   39|       |  // Create a slice that refers to s[0,strlen(s)-1]
   40|      0|  Slice(const char* s) : data_(s), size_(strlen(s)) {}
   41|       |
   42|       |  // Intentionally copyable.
   43|       |  Slice(const Slice&) = default;
   44|       |  Slice& operator=(const Slice&) = default;
   45|       |
   46|       |  // Return a pointer to the beginning of the referenced data
   47|       |  const char* data() const { return data_; }
   48|       |
   49|       |  // Return the length (in bytes) of the referenced data
   50|       |  size_t size() const { return size_; }
   51|       |
   52|       |  // Return true iff the length of the referenced data is zero
   53|      0|  bool empty() const { return size_ == 0; }
   54|       |
   55|       |  // Return the ith byte in the referenced data.
   56|       |  // REQUIRES: n < size()
   57|      0|  char operator[](size_t n) const {
   58|      0|    assert(n < size());
   59|      0|    return data_[n];
   60|      0|  }
   61|       |
   62|       |  // Change this slice to refer to an empty array
   63|      0|  void clear() {
   64|      0|    data_ = "";
   65|      0|    size_ = 0;
   66|      0|  }
   67|       |
   68|       |  // Drop the first "n" bytes from this slice.
   69|      0|  void remove_prefix(size_t n) {
   70|      0|    assert(n <= size());
   71|      0|    data_ += n;
   72|      0|    size_ -= n;
   73|      0|  }
   74|       |
   75|       |  // Return a string that contains the copy of the referenced data.
   76|      0|  std::string ToString() const { return std::string(data_, size_); }
   77|       |
   78|       |  // Three-way comparison.  Returns value:
   79|       |  //   <  0 iff "*this" <  "b",
   80|       |  //   == 0 iff "*this" == "b",
   81|       |  //   >  0 iff "*this" >  "b"
   82|       |  int compare(const Slice& b) const;
   83|       |
   84|       |  // Return true iff "x" is a prefix of "*this"
   85|       |  bool starts_with(const Slice& x) const {
   86|       |    return ((size_ >= x.size_) && (memcmp(data_, x.data_, x.size_) == 0));
   87|       |  }
   88|       |
   89|       | private:
   90|       |  const char* data_;
   91|       |  size_t size_;
   92|       |};
   93|       |
   94|      0|inline bool operator==(const Slice& x, const Slice& y) {
   95|      0|  return ((x.size() == y.size()) &&
   96|      0|          (memcmp(x.data(), y.data(), x.size()) == 0));
   97|      0|}
   98|       |
   99|      0|inline bool operator!=(const Slice& x, const Slice& y) { return !(x == y); }
  100|       |
  101|       |inline int Slice::compare(const Slice& b) const {
  102|       |  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  103|       |  int r = memcmp(data_, b.data_, min_len);
  104|       |  if (r == 0) {
  105|       |    if (size_ < b.size_)
  106|       |      r = -1;
  107|       |    else if (size_ > b.size_)
  108|       |      r = +1;
  109|       |  }
  110|       |  return r;
  111|       |}
  112|       |
  113|       |}  // namespace leveldb
  114|       |
  115|       |#endif  // STORAGE_LEVELDB_INCLUDE_SLICE_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/status.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// A Status encapsulates the result of an operation.  It may indicate success,
    6|       |// or it may indicate an error with an associated error message.
    7|       |//
    8|       |// Multiple threads can invoke const methods on a Status without
    9|       |// external synchronization, but if any of the threads may call a
   10|       |// non-const method, all threads accessing the same Status must use
   11|       |// external synchronization.
   12|       |
   13|       |#ifndef STORAGE_LEVELDB_INCLUDE_STATUS_H_
   14|       |#define STORAGE_LEVELDB_INCLUDE_STATUS_H_
   15|       |
   16|       |#include <algorithm>
   17|       |#include <string>
   18|       |
   19|       |#include "leveldb/export.h"
   20|       |#include "leveldb/slice.h"
   21|       |
   22|       |namespace leveldb {
   23|       |
   24|       |class LEVELDB_EXPORT Status {
   25|       | public:
   26|       |  // Create a success status.
   27|       |  Status() noexcept : state_(nullptr) {}
   28|       |  ~Status() { delete[] state_; }
   29|       |
   30|       |  Status(const Status& rhs);
   31|       |  Status& operator=(const Status& rhs);
   32|       |
   33|      0|  Status(Status&& rhs) noexcept : state_(rhs.state_) { rhs.state_ = nullptr; }
   34|       |  Status& operator=(Status&& rhs) noexcept;
   35|       |
   36|       |  // Return a success status.
   37|      0|  static Status OK() { return Status(); }
   38|       |
   39|       |  // Return error status of an appropriate type.
   40|      0|  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
   41|      0|    return Status(kNotFound, msg, msg2);
   42|      0|  }
   43|      0|  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
   44|      0|    return Status(kCorruption, msg, msg2);
   45|      0|  }
   46|      0|  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
   47|      0|    return Status(kNotSupported, msg, msg2);
   48|      0|  }
   49|      0|  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
   50|      0|    return Status(kInvalidArgument, msg, msg2);
   51|      0|  }
   52|      0|  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
   53|      0|    return Status(kIOError, msg, msg2);
   54|      0|  }
   55|       |
   56|       |  // Returns true iff the status indicates success.
   57|       |  bool ok() const { return (state_ == nullptr); }
   58|       |
   59|       |  // Returns true iff the status indicates a NotFound error.
   60|      0|  bool IsNotFound() const { return code() == kNotFound; }
   61|       |
   62|       |  // Returns true iff the status indicates a Corruption error.
   63|       |  bool IsCorruption() const { return code() == kCorruption; }
   64|       |
   65|       |  // Returns true iff the status indicates an IOError.
   66|       |  bool IsIOError() const { return code() == kIOError; }
   67|       |
   68|       |  // Returns true iff the status indicates a NotSupportedError.
   69|       |  bool IsNotSupportedError() const { return code() == kNotSupported; }
   70|       |
   71|       |  // Returns true iff the status indicates an InvalidArgument.
   72|       |  bool IsInvalidArgument() const { return code() == kInvalidArgument; }
   73|       |
   74|       |  // Return a string representation of this status suitable for printing.
   75|       |  // Returns the string "OK" for success.
   76|       |  std::string ToString() const;
   77|       |
   78|       | private:
   79|       |  enum Code {
   80|       |    kOk = 0,
   81|       |    kNotFound = 1,
   82|       |    kCorruption = 2,
   83|       |    kNotSupported = 3,
   84|       |    kInvalidArgument = 4,
   85|       |    kIOError = 5
   86|       |  };
   87|       |
   88|      0|  Code code() const {
   89|      0|    return (state_ == nullptr) ? kOk : static_cast<Code>(state_[4]);
   90|      0|  }
   91|       |
   92|       |  Status(Code code, const Slice& msg, const Slice& msg2);
   93|       |  static const char* CopyState(const char* s);
   94|       |
   95|       |  // OK status has a null state_.  Otherwise, state_ is a new[] array
   96|       |  // of the following form:
   97|       |  //    state_[0..3] == length of message
   98|       |  //    state_[4]    == code
   99|       |  //    state_[5..]  == message
  100|       |  const char* state_;
  101|       |};
  102|       |
  103|      0|inline Status::Status(const Status& rhs) {
  104|      0|  state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_);
  105|      0|}
  106|      0|inline Status& Status::operator=(const Status& rhs) {
  107|      0|  // The following condition catches both aliasing (when this == &rhs),
  108|      0|  // and the common case where both rhs and *this are ok.
  109|      0|  if (state_ != rhs.state_) {
  110|      0|    delete[] state_;
  111|      0|    state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_);
  112|      0|  }
  113|      0|  return *this;
  114|      0|}
  115|       |inline Status& Status::operator=(Status&& rhs) noexcept {
  116|       |  std::swap(state_, rhs.state_);
  117|       |  return *this;
  118|       |}
  119|       |
  120|       |}  // namespace leveldb
  121|       |
  122|       |#endif  // STORAGE_LEVELDB_INCLUDE_STATUS_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/table.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_INCLUDE_TABLE_H_
    6|       |#define STORAGE_LEVELDB_INCLUDE_TABLE_H_
    7|       |
    8|       |#include <stdint.h>
    9|       |
   10|       |#include "leveldb/export.h"
   11|       |#include "leveldb/iterator.h"
   12|       |
   13|       |namespace leveldb {
   14|       |
   15|       |class Block;
   16|       |class BlockHandle;
   17|       |class Footer;
   18|       |struct Options;
   19|       |class RandomAccessFile;
   20|       |struct ReadOptions;
   21|       |class TableCache;
   22|       |
   23|       |// A Table is a sorted map from strings to strings.  Tables are
   24|       |// immutable and persistent.  A Table may be safely accessed from
   25|       |// multiple threads without external synchronization.
   26|       |class LEVELDB_EXPORT Table {
   27|       | public:
   28|       |  // Attempt to open the table that is stored in bytes [0..file_size)
   29|       |  // of "file", and read the metadata entries necessary to allow
   30|       |  // retrieving data from the table.
   31|       |  //
   32|       |  // If successful, returns ok and sets "*table" to the newly opened
   33|       |  // table.  The client should delete "*table" when no longer needed.
   34|       |  // If there was an error while initializing the table, sets "*table"
   35|       |  // to nullptr and returns a non-ok status.  Does not take ownership of
   36|       |  // "*source", but the client must ensure that "source" remains live
   37|       |  // for the duration of the returned table's lifetime.
   38|       |  //
   39|       |  // *file must remain live while this Table is in use.
   40|       |  static Status Open(const Options& options, RandomAccessFile* file,
   41|       |                     uint64_t file_size, Table** table);
   42|       |
   43|       |  Table(const Table&) = delete;
   44|       |  Table& operator=(const Table&) = delete;
   45|       |
   46|       |  ~Table();
   47|       |
   48|       |  // Returns a new iterator over the table contents.
   49|       |  // The result of NewIterator() is initially invalid (caller must
   50|       |  // call one of the Seek methods on the iterator before using it).
   51|       |  Iterator* NewIterator(const ReadOptions&) const;
   52|       |
   53|       |  // Given a key, return an approximate byte offset in the file where
   54|       |  // the data for that key begins (or would begin if the key were
   55|       |  // present in the file).  The returned value is in terms of file
   56|       |  // bytes, and so includes effects like compression of the underlying data.
   57|       |  // E.g., the approximate offset of the last key in the table will
   58|       |  // be close to the file length.
   59|       |  uint64_t ApproximateOffsetOf(const Slice& key) const;
   60|       |
   61|       | private:
   62|       |  friend class TableCache;
   63|       |  struct Rep;
   64|       |
   65|       |  static Iterator* BlockReader(void*, const ReadOptions&, const Slice&);
   66|       |
   67|      0|  explicit Table(Rep* rep) : rep_(rep) {}
   68|       |
   69|       |  // Calls (*handle_result)(arg, ...) with the entry found after a call
   70|       |  // to Seek(key).  May not make such a call if filter policy says
   71|       |  // that key is not present.
   72|       |  Status InternalGet(const ReadOptions&, const Slice& key, void* arg,
   73|       |                     void (*handle_result)(void* arg, const Slice& k,
   74|       |                                           const Slice& v));
   75|       |
   76|       |  void ReadMeta(const Footer& footer);
   77|       |  void ReadFilter(const Slice& filter_handle_value);
   78|       |
   79|       |  Rep* const rep_;
   80|       |};
   81|       |
   82|       |}  // namespace leveldb
   83|       |
   84|       |#endif  // STORAGE_LEVELDB_INCLUDE_TABLE_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/leveldb-library/leveldb/table_builder.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// TableBuilder provides the interface used to build a Table
    6|       |// (an immutable and sorted map from keys to values).
    7|       |//
    8|       |// Multiple threads can invoke const methods on a TableBuilder without
    9|       |// external synchronization, but if any of the threads may call a
   10|       |// non-const method, all threads accessing the same TableBuilder must use
   11|       |// external synchronization.
   12|       |
   13|       |#ifndef STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_
   14|       |#define STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_
   15|       |
   16|       |#include <stdint.h>
   17|       |
   18|       |#include "leveldb/export.h"
   19|       |#include "leveldb/options.h"
   20|       |#include "leveldb/status.h"
   21|       |
   22|       |namespace leveldb {
   23|       |
   24|       |class BlockBuilder;
   25|       |class BlockHandle;
   26|       |class WritableFile;
   27|       |
   28|       |class LEVELDB_EXPORT TableBuilder {
   29|       | public:
   30|       |  // Create a builder that will store the contents of the table it is
   31|       |  // building in *file.  Does not close the file.  It is up to the
   32|       |  // caller to close the file after calling Finish().
   33|       |  TableBuilder(const Options& options, WritableFile* file);
   34|       |
   35|       |  TableBuilder(const TableBuilder&) = delete;
   36|       |  TableBuilder& operator=(const TableBuilder&) = delete;
   37|       |
   38|       |  // REQUIRES: Either Finish() or Abandon() has been called.
   39|       |  ~TableBuilder();
   40|       |
   41|       |  // Change the options used by this builder.  Note: only some of the
   42|       |  // option fields can be changed after construction.  If a field is
   43|       |  // not allowed to change dynamically and its value in the structure
   44|       |  // passed to the constructor is different from its value in the
   45|       |  // structure passed to this method, this method will return an error
   46|       |  // without changing any fields.
   47|       |  Status ChangeOptions(const Options& options);
   48|       |
   49|       |  // Add key,value to the table being constructed.
   50|       |  // REQUIRES: key is after any previously added key according to comparator.
   51|       |  // REQUIRES: Finish(), Abandon() have not been called
   52|       |  void Add(const Slice& key, const Slice& value);
   53|       |
   54|       |  // Advanced operation: flush any buffered key/value pairs to file.
   55|       |  // Can be used to ensure that two adjacent entries never live in
   56|       |  // the same data block.  Most clients should not need to use this method.
   57|       |  // REQUIRES: Finish(), Abandon() have not been called
   58|       |  void Flush();
   59|       |
   60|       |  // Return non-ok iff some error has been detected.
   61|       |  Status status() const;
   62|       |
   63|       |  // Finish building the table.  Stops using the file passed to the
   64|       |  // constructor after this function returns.
   65|       |  // REQUIRES: Finish(), Abandon() have not been called
   66|       |  Status Finish();
   67|       |
   68|       |  // Indicate that the contents of this builder should be abandoned.  Stops
   69|       |  // using the file passed to the constructor after this function returns.
   70|       |  // If the caller is not going to call Finish(), it must call Abandon()
   71|       |  // before destroying this builder.
   72|       |  // REQUIRES: Finish(), Abandon() have not been called
   73|       |  void Abandon();
   74|       |
   75|       |  // Number of calls to Add() so far.
   76|       |  uint64_t NumEntries() const;
   77|       |
   78|       |  // Size of the file generated so far.  If invoked after a successful
   79|       |  // Finish() call, returns the size of the final generated file.
   80|       |  uint64_t FileSize() const;
   81|       |
   82|       | private:
   83|      0|  bool ok() const { return status().ok(); }
   84|       |  void WriteBlock(BlockBuilder* block, BlockHandle* handle);
   85|       |  void WriteRawBlock(const Slice& data, CompressionType, BlockHandle* handle);
   86|       |
   87|       |  struct Rep;
   88|       |  Rep* rep_;
   89|       |};
   90|       |
   91|       |}  // namespace leveldb
   92|       |
   93|       |#endif  // STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/nanopb/pb.h:
    1|       |/* Common parts of the nanopb library. Most of these are quite low-level
    2|       | * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.
    3|       | */
    4|       |
    5|       |#ifndef PB_H_INCLUDED
    6|       |#define PB_H_INCLUDED
    7|       |
    8|       |/*****************************************************************
    9|       | * Nanopb compilation time options. You can change these here by *
   10|       | * uncommenting the lines, or on the compiler command line.      *
   11|       | *****************************************************************/
   12|       |
   13|       |/* Enable support for dynamically allocated fields */
   14|       |/* #define PB_ENABLE_MALLOC 1 */
   15|       |
   16|       |/* Define this if your CPU / compiler combination does not support
   17|       | * unaligned memory access to packed structures. */
   18|       |/* #define PB_NO_PACKED_STRUCTS 1 */
   19|       |
   20|       |/* Increase the number of required fields that are tracked.
   21|       | * A compiler warning will tell if you need this. */
   22|       |/* #define PB_MAX_REQUIRED_FIELDS 256 */
   23|       |
   24|       |/* Add support for tag numbers > 255 and fields larger than 255 bytes. */
   25|       |/* #define PB_FIELD_16BIT 1 */
   26|       |
   27|       |/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */
   28|       |/* #define PB_FIELD_32BIT 1 */
   29|       |
   30|       |/* Disable support for error messages in order to save some code space. */
   31|       |/* #define PB_NO_ERRMSG 1 */
   32|       |
   33|       |/* Disable support for custom streams (support only memory buffers). */
   34|       |/* #define PB_BUFFER_ONLY 1 */
   35|       |
   36|       |/* Switch back to the old-style callback function signature.
   37|       | * This was the default until nanopb-0.2.1. */
   38|       |/* #define PB_OLD_CALLBACK_STYLE */
   39|       |
   40|       |
   41|       |/******************************************************************
   42|       | * You usually don't need to change anything below this line.     *
   43|       | * Feel free to look around and use the defined macros, though.   *
   44|       | ******************************************************************/
   45|       |
   46|       |
   47|       |/* Version of the nanopb library. Just in case you want to check it in
   48|       | * your own program. */
   49|       |#define NANOPB_VERSION nanopb-0.3.9.1
   50|       |
   51|       |/* Include all the system headers needed by nanopb. You will need the
   52|       | * definitions of the following:
   53|       | * - strlen, memcpy, memset functions
   54|       | * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t
   55|       | * - size_t
   56|       | * - bool
   57|       | *
   58|       | * If you don't have the standard header files, you can instead provide
   59|       | * a custom header that defines or includes all this. In that case,
   60|       | * define PB_SYSTEM_HEADER to the path of this file.
   61|       | */
   62|       |#ifdef PB_SYSTEM_HEADER
   63|       |#include PB_SYSTEM_HEADER
   64|       |#else
   65|       |#include <stdint.h>
   66|       |#include <stddef.h>
   67|       |#include <stdbool.h>
   68|       |#include <string.h>
   69|       |
   70|       |#ifdef PB_ENABLE_MALLOC
   71|       |#include <stdlib.h>
   72|       |#endif
   73|       |#endif
   74|       |
   75|       |/* Macro for defining packed structures (compiler dependent).
   76|       | * This just reduces memory requirements, but is not required.
   77|       | */
   78|       |#if defined(PB_NO_PACKED_STRUCTS)
   79|       |    /* Disable struct packing */
   80|       |#   define PB_PACKED_STRUCT_START
   81|       |#   define PB_PACKED_STRUCT_END
   82|       |#   define pb_packed
   83|       |#elif defined(__GNUC__) || defined(__clang__)
   84|       |    /* For GCC and clang */
   85|       |#   define PB_PACKED_STRUCT_START
   86|       |#   define PB_PACKED_STRUCT_END
   87|       |#   define pb_packed __attribute__((packed))
   88|       |#elif defined(__ICCARM__) || defined(__CC_ARM)
   89|       |    /* For IAR ARM and Keil MDK-ARM compilers */
   90|       |#   define PB_PACKED_STRUCT_START _Pragma("pack(push, 1)")
   91|       |#   define PB_PACKED_STRUCT_END _Pragma("pack(pop)")
   92|       |#   define pb_packed
   93|       |#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
   94|       |    /* For Microsoft Visual C++ */
   95|       |#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))
   96|       |#   define PB_PACKED_STRUCT_END __pragma(pack(pop))
   97|       |#   define pb_packed
   98|       |#else
   99|       |    /* Unknown compiler */
  100|       |#   define PB_PACKED_STRUCT_START
  101|       |#   define PB_PACKED_STRUCT_END
  102|       |#   define pb_packed
  103|       |#endif
  104|       |
  105|       |/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
  106|       |#ifndef PB_UNUSED
  107|       |#define PB_UNUSED(x) (void)(x)
  108|       |#endif
  109|       |
  110|       |/* Compile-time assertion, used for checking compatible compilation options.
  111|       | * If this does not work properly on your compiler, use
  112|       | * #define PB_NO_STATIC_ASSERT to disable it.
  113|       | *
  114|       | * But before doing that, check carefully the error message / place where it
  115|       | * comes from to see if the error has a real cause. Unfortunately the error
  116|       | * message is not always very clear to read, but you can see the reason better
  117|       | * in the place where the PB_STATIC_ASSERT macro was called.
  118|       | */
  119|       |#ifndef PB_NO_STATIC_ASSERT
  120|       |#ifndef PB_STATIC_ASSERT
  121|       |#define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
  122|       |#define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
  123|       |#define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##LINE##COUNTER
  124|       |#endif
  125|       |#else
  126|       |#define PB_STATIC_ASSERT(COND,MSG)
  127|       |#endif
  128|       |
  129|       |/* Number of required fields to keep track of. */
  130|       |#ifndef PB_MAX_REQUIRED_FIELDS
  131|       |#define PB_MAX_REQUIRED_FIELDS 64
  132|       |#endif
  133|       |
  134|       |#if PB_MAX_REQUIRED_FIELDS < 64
  135|       |#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).
  136|       |#endif
  137|       |
  138|       |/* List of possible field types. These are used in the autogenerated code.
  139|       | * Least-significant 4 bits tell the scalar type
  140|       | * Most-significant 4 bits specify repeated/required/packed etc.
  141|       | */
  142|       |
  143|       |typedef uint_least8_t pb_type_t;
  144|       |
  145|       |/**** Field data types ****/
  146|       |
  147|       |/* Numeric types */
  148|       |#define PB_LTYPE_VARINT  0x00 /* int32, int64, enum, bool */
  149|       |#define PB_LTYPE_UVARINT 0x01 /* uint32, uint64 */
  150|       |#define PB_LTYPE_SVARINT 0x02 /* sint32, sint64 */
  151|       |#define PB_LTYPE_FIXED32 0x03 /* fixed32, sfixed32, float */
  152|       |#define PB_LTYPE_FIXED64 0x04 /* fixed64, sfixed64, double */
  153|       |
  154|       |/* Marker for last packable field type. */
  155|       |#define PB_LTYPE_LAST_PACKABLE 0x04
  156|       |
  157|       |/* Byte array with pre-allocated buffer.
  158|       | * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
  159|       |#define PB_LTYPE_BYTES 0x05
  160|       |
  161|       |/* String with pre-allocated buffer.
  162|       | * data_size is the maximum length. */
  163|       |#define PB_LTYPE_STRING 0x06
  164|       |
  165|       |/* Submessage
  166|       | * submsg_fields is pointer to field descriptions */
  167|       |#define PB_LTYPE_SUBMESSAGE 0x07
  168|       |
  169|       |/* Extension pseudo-field
  170|       | * The field contains a pointer to pb_extension_t */
  171|       |#define PB_LTYPE_EXTENSION 0x08
  172|       |
  173|       |/* Byte array with inline, pre-allocated byffer.
  174|       | * data_size is the length of the inline, allocated buffer.
  175|       | * This differs from PB_LTYPE_BYTES by defining the element as
  176|       | * pb_byte_t[data_size] rather than pb_bytes_array_t. */
  177|       |#define PB_LTYPE_FIXED_LENGTH_BYTES 0x09
  178|       |
  179|       |/* Number of declared LTYPES */
  180|       |#define PB_LTYPES_COUNT 0x0A
  181|       |#define PB_LTYPE_MASK 0x0F
  182|       |
  183|       |/**** Field repetition rules ****/
  184|       |
  185|       |#define PB_HTYPE_REQUIRED 0x00
  186|       |#define PB_HTYPE_OPTIONAL 0x10
  187|       |#define PB_HTYPE_REPEATED 0x20
  188|       |#define PB_HTYPE_ONEOF    0x30
  189|       |#define PB_HTYPE_MASK     0x30
  190|       |
  191|       |/**** Field allocation types ****/
  192|       | 
  193|       |#define PB_ATYPE_STATIC   0x00
  194|       |#define PB_ATYPE_POINTER  0x80
  195|       |#define PB_ATYPE_CALLBACK 0x40
  196|       |#define PB_ATYPE_MASK     0xC0
  197|       |
  198|       |#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)
  199|       |#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)
  200|       |#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)
  201|       |
  202|       |/* Data type used for storing sizes of struct fields
  203|       | * and array counts.
  204|       | */
  205|       |#if defined(PB_FIELD_32BIT)
  206|       |    typedef uint32_t pb_size_t;
  207|       |    typedef int32_t pb_ssize_t;
  208|       |#elif defined(PB_FIELD_16BIT)
  209|       |    typedef uint_least16_t pb_size_t;
  210|       |    typedef int_least16_t pb_ssize_t;
  211|       |#else
  212|       |    typedef uint_least8_t pb_size_t;
  213|       |    typedef int_least8_t pb_ssize_t;
  214|       |#endif
  215|       |#define PB_SIZE_MAX ((pb_size_t)-1)
  216|       |
  217|       |/* Data type for storing encoded data and other byte streams.
  218|       | * This typedef exists to support platforms where uint8_t does not exist.
  219|       | * You can regard it as equivalent on uint8_t on other platforms.
  220|       | */
  221|       |typedef uint_least8_t pb_byte_t;
  222|       |
  223|       |/* This structure is used in auto-generated constants
  224|       | * to specify struct fields.
  225|       | * You can change field sizes if you need structures
  226|       | * larger than 256 bytes or field tags larger than 256.
  227|       | * The compiler should complain if your .proto has such
  228|       | * structures. Fix that by defining PB_FIELD_16BIT or
  229|       | * PB_FIELD_32BIT.
  230|       | */
  231|       |PB_PACKED_STRUCT_START
  232|       |typedef struct pb_field_s pb_field_t;
  233|       |struct pb_field_s {
  234|       |    pb_size_t tag;
  235|       |    pb_type_t type;
  236|       |    pb_size_t data_offset; /* Offset of field data, relative to previous field. */
  237|       |    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
  238|       |    pb_size_t data_size; /* Data size in bytes for a single item */
  239|       |    pb_size_t array_size; /* Maximum number of entries in array */
  240|       |    
  241|       |    /* Field definitions for submessage
  242|       |     * OR default value for all other non-array, non-callback types
  243|       |     * If null, then field will zeroed. */
  244|       |    const void *ptr;
  245|       |} pb_packed;
  246|       |PB_PACKED_STRUCT_END
  247|       |
  248|       |/* Make sure that the standard integer types are of the expected sizes.
  249|       | * Otherwise fixed32/fixed64 fields can break.
  250|       | *
  251|       | * If you get errors here, it probably means that your stdint.h is not
  252|       | * correct for your platform.
  253|       | */
  254|       |#ifndef PB_WITHOUT_64BIT
  255|       |PB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)
  256|       |PB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)
  257|       |#endif
  258|       |
  259|       |/* This structure is used for 'bytes' arrays.
  260|       | * It has the number of bytes in the beginning, and after that an array.
  261|       | * Note that actual structs used will have a different length of bytes array.
  262|       | */
  263|       |#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }
  264|     24|#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))
  265|       |
  266|       |struct pb_bytes_array_s {
  267|       |    pb_size_t size;
  268|       |    pb_byte_t bytes[1];
  269|       |};
  270|       |typedef struct pb_bytes_array_s pb_bytes_array_t;
  271|       |
  272|       |/* This structure is used for giving the callback function.
  273|       | * It is stored in the message structure and filled in by the method that
  274|       | * calls pb_decode.
  275|       | *
  276|       | * The decoding callback will be given a limited-length stream
  277|       | * If the wire type was string, the length is the length of the string.
  278|       | * If the wire type was a varint/fixed32/fixed64, the length is the length
  279|       | * of the actual value.
  280|       | * The function may be called multiple times (especially for repeated types,
  281|       | * but also otherwise if the message happens to contain the field multiple
  282|       | * times.)
  283|       | *
  284|       | * The encoding callback will receive the actual output stream.
  285|       | * It should write all the data in one call, including the field tag and
  286|       | * wire type. It can write multiple fields.
  287|       | *
  288|       | * The callback can be null if you want to skip a field.
  289|       | */
  290|       |typedef struct pb_istream_s pb_istream_t;
  291|       |typedef struct pb_ostream_s pb_ostream_t;
  292|       |typedef struct pb_callback_s pb_callback_t;
  293|       |struct pb_callback_s {
  294|       |#ifdef PB_OLD_CALLBACK_STYLE
  295|       |    /* Deprecated since nanopb-0.2.1 */
  296|       |    union {
  297|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
  298|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
  299|       |    } funcs;
  300|       |#else
  301|       |    /* New function signature, which allows modifying arg contents in callback. */
  302|       |    union {
  303|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
  304|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
  305|       |    } funcs;
  306|       |#endif    
  307|       |    
  308|       |    /* Free arg for use by callback */
  309|       |    void *arg;
  310|       |};
  311|       |
  312|       |/* Wire types. Library user needs these only in encoder callbacks. */
  313|       |typedef enum {
  314|       |    PB_WT_VARINT = 0,
  315|       |    PB_WT_64BIT  = 1,
  316|       |    PB_WT_STRING = 2,
  317|       |    PB_WT_32BIT  = 5
  318|       |} pb_wire_type_t;
  319|       |
  320|       |/* Structure for defining the handling of unknown/extension fields.
  321|       | * Usually the pb_extension_type_t structure is automatically generated,
  322|       | * while the pb_extension_t structure is created by the user. However,
  323|       | * if you want to catch all unknown fields, you can also create a custom
  324|       | * pb_extension_type_t with your own callback.
  325|       | */
  326|       |typedef struct pb_extension_type_s pb_extension_type_t;
  327|       |typedef struct pb_extension_s pb_extension_t;
  328|       |struct pb_extension_type_s {
  329|       |    /* Called for each unknown field in the message.
  330|       |     * If you handle the field, read off all of its data and return true.
  331|       |     * If you do not handle the field, do not read anything and return true.
  332|       |     * If you run into an error, return false.
  333|       |     * Set to NULL for default handler.
  334|       |     */
  335|       |    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
  336|       |                   uint32_t tag, pb_wire_type_t wire_type);
  337|       |    
  338|       |    /* Called once after all regular fields have been encoded.
  339|       |     * If you have something to write, do so and return true.
  340|       |     * If you do not have anything to write, just return true.
  341|       |     * If you run into an error, return false.
  342|       |     * Set to NULL for default handler.
  343|       |     */
  344|       |    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
  345|       |    
  346|       |    /* Free field for use by the callback. */
  347|       |    const void *arg;
  348|       |};
  349|       |
  350|       |struct pb_extension_s {
  351|       |    /* Type describing the extension field. Usually you'll initialize
  352|       |     * this to a pointer to the automatically generated structure. */
  353|       |    const pb_extension_type_t *type;
  354|       |    
  355|       |    /* Destination for the decoded data. This must match the datatype
  356|       |     * of the extension field. */
  357|       |    void *dest;
  358|       |    
  359|       |    /* Pointer to the next extension handler, or NULL.
  360|       |     * If this extension does not match a field, the next handler is
  361|       |     * automatically called. */
  362|       |    pb_extension_t *next;
  363|       |
  364|       |    /* The decoder sets this to true if the extension was found.
  365|       |     * Ignored for encoding. */
  366|       |    bool found;
  367|       |};
  368|       |
  369|       |/* Memory allocation functions to use. You can define pb_realloc and
  370|       | * pb_free to custom functions if you want. */
  371|       |#ifdef PB_ENABLE_MALLOC
  372|       |#   ifndef pb_realloc
  373|       |#       define pb_realloc(ptr, size) realloc(ptr, size)
  374|       |#   endif
  375|       |#   ifndef pb_free
  376|       |#       define pb_free(ptr) free(ptr)
  377|       |#   endif
  378|       |#endif
  379|       |
  380|       |/* This is used to inform about need to regenerate .pb.h/.pb.c files. */
  381|       |#define PB_PROTO_HEADER_VERSION 30
  382|       |
  383|       |/* These macros are used to declare pb_field_t's in the constant array. */
  384|       |/* Size of a structure member, in bytes. */
  385|       |#define pb_membersize(st, m) (sizeof ((st*)0)->m)
  386|       |/* Number of entries in an array. */
  387|       |#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
  388|       |/* Delta from start of one member to the start of another member. */
  389|       |#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
  390|       |/* Marks the end of the field list */
  391|       |#define PB_LAST_FIELD {0,(pb_type_t) 0,0,0,0,0,0}
  392|       |
  393|       |/* Macros for filling in the data_offset field */
  394|       |/* data_offset for first field in a message */
  395|       |#define PB_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
  396|       |/* data_offset for subsequent fields */
  397|       |#define PB_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))
  398|       |/* data offset for subsequent fields inside an union (oneof) */
  399|       |#define PB_DATAOFFSET_UNION(st, m1, m2) (PB_SIZE_MAX)
  400|       |/* Choose first/other based on m1 == m2 (deprecated, remains for backwards compatibility) */
  401|       |#define PB_DATAOFFSET_CHOOSE(st, m1, m2) (int)(offsetof(st, m1) == offsetof(st, m2) \
  402|       |                                  ? PB_DATAOFFSET_FIRST(st, m1, m2) \
  403|       |                                  : PB_DATAOFFSET_OTHER(st, m1, m2))
  404|       |
  405|       |/* Required fields are the simplest. They just have delta (padding) from
  406|       | * previous field end, and the size of the field. Pointer is used for
  407|       | * submessages and default values.
  408|       | */
  409|       |#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
  410|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  411|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  412|       |
  413|       |/* Optional fields add the delta to the has_ variable. */
  414|       |#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
  415|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  416|       |    fd, \
  417|       |    pb_delta(st, has_ ## m, m), \
  418|       |    pb_membersize(st, m), 0, ptr}
  419|       |
  420|       |#define PB_SINGULAR_STATIC(tag, st, m, fd, ltype, ptr) \
  421|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  422|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  423|       |
  424|       |/* Repeated fields have a _count field and also the maximum number of entries. */
  425|       |#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
  426|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, \
  427|       |    fd, \
  428|       |    pb_delta(st, m ## _count, m), \
  429|       |    pb_membersize(st, m[0]), \
  430|       |    pb_arraysize(st, m), ptr}
  431|       |
  432|       |/* Allocated fields carry the size of the actual data, not the pointer */
  433|       |#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
  434|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, \
  435|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  436|       |
  437|       |/* Optional fields don't need a has_ variable, as information would be redundant */
  438|       |#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
  439|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  440|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  441|       |
  442|       |/* Same as optional fields*/
  443|       |#define PB_SINGULAR_POINTER(tag, st, m, fd, ltype, ptr) \
  444|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  445|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  446|       |
  447|       |/* Repeated fields have a _count field and a pointer to array of pointers */
  448|       |#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
  449|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, \
  450|       |    fd, pb_delta(st, m ## _count, m), \
  451|       |    pb_membersize(st, m[0]), 0, ptr}
  452|       |
  453|       |/* Callbacks are much like required fields except with special datatype. */
  454|       |#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  455|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, \
  456|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  457|       |
  458|       |#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
  459|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  460|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  461|       |
  462|       |#define PB_SINGULAR_CALLBACK(tag, st, m, fd, ltype, ptr) \
  463|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  464|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  465|       |    
  466|       |#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  467|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, \
  468|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  469|       |
  470|       |/* Optional extensions don't have the has_ field, as that would be redundant.
  471|       | * Furthermore, the combination of OPTIONAL without has_ field is used
  472|       | * for indicating proto3 style fields. Extensions exist in proto2 mode only,
  473|       | * so they should be encoded according to proto2 rules. To avoid the conflict,
  474|       | * extensions are marked as REQUIRED instead.
  475|       | */
  476|       |#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
  477|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  478|       |    0, \
  479|       |    0, \
  480|       |    pb_membersize(st, m), 0, ptr}
  481|       |
  482|       |#define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
  483|       |    PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
  484|       |
  485|       |#define PB_OPTEXT_CALLBACK(tag, st, m, fd, ltype, ptr) \
  486|       |    PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)
  487|       |
  488|       |/* The mapping from protobuf types to LTYPEs is done using these macros. */
  489|       |#define PB_LTYPE_MAP_BOOL               PB_LTYPE_VARINT
  490|       |#define PB_LTYPE_MAP_BYTES              PB_LTYPE_BYTES
  491|       |#define PB_LTYPE_MAP_DOUBLE             PB_LTYPE_FIXED64
  492|       |#define PB_LTYPE_MAP_ENUM               PB_LTYPE_VARINT
  493|       |#define PB_LTYPE_MAP_UENUM              PB_LTYPE_UVARINT
  494|       |#define PB_LTYPE_MAP_FIXED32            PB_LTYPE_FIXED32
  495|       |#define PB_LTYPE_MAP_FIXED64            PB_LTYPE_FIXED64
  496|       |#define PB_LTYPE_MAP_FLOAT              PB_LTYPE_FIXED32
  497|       |#define PB_LTYPE_MAP_INT32              PB_LTYPE_VARINT
  498|       |#define PB_LTYPE_MAP_INT64              PB_LTYPE_VARINT
  499|       |#define PB_LTYPE_MAP_MESSAGE            PB_LTYPE_SUBMESSAGE
  500|       |#define PB_LTYPE_MAP_SFIXED32           PB_LTYPE_FIXED32
  501|       |#define PB_LTYPE_MAP_SFIXED64           PB_LTYPE_FIXED64
  502|       |#define PB_LTYPE_MAP_SINT32             PB_LTYPE_SVARINT
  503|       |#define PB_LTYPE_MAP_SINT64             PB_LTYPE_SVARINT
  504|       |#define PB_LTYPE_MAP_STRING             PB_LTYPE_STRING
  505|       |#define PB_LTYPE_MAP_UINT32             PB_LTYPE_UVARINT
  506|       |#define PB_LTYPE_MAP_UINT64             PB_LTYPE_UVARINT
  507|       |#define PB_LTYPE_MAP_EXTENSION          PB_LTYPE_EXTENSION
  508|       |#define PB_LTYPE_MAP_FIXED_LENGTH_BYTES PB_LTYPE_FIXED_LENGTH_BYTES
  509|       |
  510|       |/* This is the actual macro used in field descriptions.
  511|       | * It takes these arguments:
  512|       | * - Field tag number
  513|       | * - Field type:   BOOL, BYTES, DOUBLE, ENUM, UENUM, FIXED32, FIXED64,
  514|       | *                 FLOAT, INT32, INT64, MESSAGE, SFIXED32, SFIXED64
  515|       | *                 SINT32, SINT64, STRING, UINT32, UINT64 or EXTENSION
  516|       | * - Field rules:  REQUIRED, OPTIONAL or REPEATED
  517|       | * - Allocation:   STATIC, CALLBACK or POINTER
  518|       | * - Placement: FIRST or OTHER, depending on if this is the first field in structure.
  519|       | * - Message name
  520|       | * - Field name
  521|       | * - Previous field name (or field name again for first field)
  522|       | * - Pointer to default value or submsg fields.
  523|       | */
  524|       |
  525|       |#define PB_FIELD(tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  526|       |        PB_ ## rules ## _ ## allocation(tag, message, field, \
  527|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  528|       |        PB_LTYPE_MAP_ ## type, ptr)
  529|       |
  530|       |/* Field description for repeated static fixed count fields.*/
  531|       |#define PB_REPEATED_FIXED_COUNT(tag, type, placement, message, field, prevfield, ptr) \
  532|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | PB_LTYPE_MAP_ ## type, \
  533|       |    PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  534|       |    0, \
  535|       |    pb_membersize(message, field[0]), \
  536|       |    pb_arraysize(message, field), ptr}
  537|       |
  538|       |/* Field description for oneof fields. This requires taking into account the
  539|       | * union name also, that's why a separate set of macros is needed.
  540|       | */
  541|       |#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  542|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  543|       |    fd, pb_delta(st, which_ ## u, u.m), \
  544|       |    pb_membersize(st, u.m), 0, ptr}
  545|       |
  546|       |#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  547|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  548|       |    fd, pb_delta(st, which_ ## u, u.m), \
  549|       |    pb_membersize(st, u.m[0]), 0, ptr}
  550|       |
  551|       |#define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  552|       |        PB_ONEOF_ ## allocation(union_name, tag, message, field, \
  553|       |        PB_DATAOFFSET_ ## placement(message, union_name.field, prevfield), \
  554|       |        PB_LTYPE_MAP_ ## type, ptr)
  555|       |
  556|       |#define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  557|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  558|       |    fd, pb_delta(st, which_ ## u, m), \
  559|       |    pb_membersize(st, m), 0, ptr}
  560|       |
  561|       |#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  562|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  563|       |    fd, pb_delta(st, which_ ## u, m), \
  564|       |    pb_membersize(st, m[0]), 0, ptr}
  565|       |
  566|       |#define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  567|       |        PB_ANONYMOUS_ONEOF_ ## allocation(union_name, tag, message, field, \
  568|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  569|       |        PB_LTYPE_MAP_ ## type, ptr)
  570|       |
  571|       |/* These macros are used for giving out error messages.
  572|       | * They are mostly a debugging aid; the main error information
  573|       | * is the true/false return value from functions.
  574|       | * Some code space can be saved by disabling the error
  575|       | * messages if not used.
  576|       | *
  577|       | * PB_SET_ERROR() sets the error message if none has been set yet.
  578|       | *                msg must be a constant string literal.
  579|       | * PB_GET_ERROR() always returns a pointer to a string.
  580|       | * PB_RETURN_ERROR() sets the error and returns false from current
  581|       | *                   function.
  582|       | */
  583|       |#ifdef PB_NO_ERRMSG
  584|       |#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)
  585|       |#define PB_GET_ERROR(stream) "(errmsg disabled)"
  586|       |#else
  587|       |#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))
  588|      0|#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : "(none)")
  589|       |#endif
  590|       |
  591|       |#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false
  592|       |
  593|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Private/nanopb/pb_encode.h:
    1|       |/* pb_encode.h: Functions to encode protocol buffers. Depends on pb_encode.c.
    2|       | * The main function is pb_encode. You also need an output stream, and the
    3|       | * field descriptions created by nanopb_generator.py.
    4|       | */
    5|       |
    6|       |#ifndef PB_ENCODE_H_INCLUDED
    7|       |#define PB_ENCODE_H_INCLUDED
    8|       |
    9|       |#include "pb.h"
   10|       |
   11|       |#ifdef __cplusplus
   12|       |extern "C" {
   13|       |#endif
   14|       |
   15|       |/* Structure for defining custom output streams. You will need to provide
   16|       | * a callback function to write the bytes to your storage, which can be
   17|       | * for example a file or a network socket.
   18|       | *
   19|       | * The callback must conform to these rules:
   20|       | *
   21|       | * 1) Return false on IO errors. This will cause encoding to abort.
   22|       | * 2) You can use state to store your own data (e.g. buffer pointer).
   23|       | * 3) pb_write will update bytes_written after your callback runs.
   24|       | * 4) Substreams will modify max_size and bytes_written. Don't use them
   25|       | *    to calculate any pointers.
   26|       | */
   27|       |struct pb_ostream_s
   28|       |{
   29|       |#ifdef PB_BUFFER_ONLY
   30|       |    /* Callback pointer is not used in buffer-only configuration.
   31|       |     * Having an int pointer here allows binary compatibility but
   32|       |     * gives an error if someone tries to assign callback function.
   33|       |     * Also, NULL pointer marks a 'sizing stream' that does not
   34|       |     * write anything.
   35|       |     */
   36|       |    int *callback;
   37|       |#else
   38|       |    bool (*callback)(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
   39|       |#endif
   40|       |    void *state;          /* Free field for use by callback implementation. */
   41|       |    size_t max_size;      /* Limit number of output bytes written (or use SIZE_MAX). */
   42|       |    size_t bytes_written; /* Number of bytes written so far. */
   43|       |    
   44|       |#ifndef PB_NO_ERRMSG
   45|       |    const char *errmsg;
   46|       |#endif
   47|       |};
   48|       |
   49|       |/***************************
   50|       | * Main encoding functions *
   51|       | ***************************/
   52|       |
   53|       |/* Encode a single protocol buffers message from C structure into a stream.
   54|       | * Returns true on success, false on any failure.
   55|       | * The actual struct pointed to by src_struct must match the description in fields.
   56|       | * All required fields in the struct are assumed to have been filled in.
   57|       | *
   58|       | * Example usage:
   59|       | *    MyMessage msg = {};
   60|       | *    uint8_t buffer[64];
   61|       | *    pb_ostream_t stream;
   62|       | *
   63|       | *    msg.field1 = 42;
   64|       | *    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
   65|       | *    pb_encode(&stream, MyMessage_fields, &msg);
   66|       | */
   67|       |bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   68|       |
   69|       |/* Same as pb_encode, but prepends the length of the message as a varint.
   70|       | * Corresponds to writeDelimitedTo() in Google's protobuf API.
   71|       | */
   72|       |bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   73|       |
   74|       |/* Same as pb_encode, but appends a null byte to the message for termination.
   75|       | * NOTE: This behaviour is not supported in most other protobuf implementations, so pb_encode_delimited()
   76|       | * is a better option for compatibility.
   77|       | */
   78|       |bool pb_encode_nullterminated(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   79|       |
   80|       |/* Encode the message to get the size of the encoded data, but do not store
   81|       | * the data. */
   82|       |bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct);
   83|       |
   84|       |/**************************************
   85|       | * Functions for manipulating streams *
   86|       | **************************************/
   87|       |
   88|       |/* Create an output stream for writing into a memory buffer.
   89|       | * The number of bytes written can be found in stream.bytes_written after
   90|       | * encoding the message.
   91|       | *
   92|       | * Alternatively, you can use a custom stream that writes directly to e.g.
   93|       | * a file or a network socket.
   94|       | */
   95|       |pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
   96|       |
   97|       |/* Pseudo-stream for measuring the size of a message without actually storing
   98|       | * the encoded data.
   99|       | * 
  100|       | * Example usage:
  101|       | *    MyMessage msg = {};
  102|       | *    pb_ostream_t stream = PB_OSTREAM_SIZING;
  103|       | *    pb_encode(&stream, MyMessage_fields, &msg);
  104|       | *    printf("Message size is %d\n", stream.bytes_written);
  105|       | */
  106|       |#ifndef PB_NO_ERRMSG
  107|      5|#define PB_OSTREAM_SIZING {0,0,0,0,0}
  108|       |#else
  109|       |#define PB_OSTREAM_SIZING {0,0,0,0}
  110|       |#endif
  111|       |
  112|       |/* Function to write into a pb_ostream_t stream. You can use this if you need
  113|       | * to append or prepend some custom headers to the message.
  114|       | */
  115|       |bool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
  116|       |
  117|       |
  118|       |/************************************************
  119|       | * Helper functions for writing field callbacks *
  120|       | ************************************************/
  121|       |
  122|       |/* Encode field header based on type and field number defined in the field
  123|       | * structure. Call this from the callback before writing out field contents. */
  124|       |bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);
  125|       |
  126|       |/* Encode field header by manually specifing wire type. You need to use this
  127|       | * if you want to write out packed arrays from a callback field. */
  128|       |bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);
  129|       |
  130|       |/* Encode an integer in the varint format.
  131|       | * This works for bool, enum, int32, int64, uint32 and uint64 field types. */
  132|       |#ifndef PB_WITHOUT_64BIT
  133|       |bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);
  134|       |#else
  135|       |bool pb_encode_varint(pb_ostream_t *stream, uint32_t value);
  136|       |#endif
  137|       |
  138|       |/* Encode an integer in the zig-zagged svarint format.
  139|       | * This works for sint32 and sint64. */
  140|       |#ifndef PB_WITHOUT_64BIT
  141|       |bool pb_encode_svarint(pb_ostream_t *stream, int64_t value);
  142|       |#else
  143|       |bool pb_encode_svarint(pb_ostream_t *stream, int32_t value);
  144|       |#endif
  145|       |
  146|       |/* Encode a string or bytes type field. For strings, pass strlen(s) as size. */
  147|       |bool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);
  148|       |
  149|       |/* Encode a fixed32, sfixed32 or float value.
  150|       | * You need to pass a pointer to a 4-byte wide C variable. */
  151|       |bool pb_encode_fixed32(pb_ostream_t *stream, const void *value);
  152|       |
  153|       |#ifndef PB_WITHOUT_64BIT
  154|       |/* Encode a fixed64, sfixed64 or double value.
  155|       | * You need to pass a pointer to a 8-byte wide C variable. */
  156|       |bool pb_encode_fixed64(pb_ostream_t *stream, const void *value);
  157|       |#endif
  158|       |
  159|       |/* Encode a submessage field.
  160|       | * You need to pass the pb_field_t array and pointer to struct, just like
  161|       | * with pb_encode(). This internally encodes the submessage twice, first to
  162|       | * calculate message size and then to actually write it out.
  163|       | */
  164|       |bool pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
  165|       |
  166|       |#ifdef __cplusplus
  167|       |} /* extern "C" */
  168|       |#endif
  169|       |
  170|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Public/leveldb-library/leveldb/db.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_INCLUDE_DB_H_
    6|       |#define STORAGE_LEVELDB_INCLUDE_DB_H_
    7|       |
    8|       |#include <stdint.h>
    9|       |#include <stdio.h>
   10|       |
   11|       |#include "leveldb/export.h"
   12|       |#include "leveldb/iterator.h"
   13|       |#include "leveldb/options.h"
   14|       |
   15|       |namespace leveldb {
   16|       |
   17|       |// Update CMakeLists.txt if you change these
   18|       |static const int kMajorVersion = 1;
   19|       |static const int kMinorVersion = 22;
   20|       |
   21|       |struct Options;
   22|       |struct ReadOptions;
   23|       |struct WriteOptions;
   24|       |class WriteBatch;
   25|       |
   26|       |// Abstract handle to particular state of a DB.
   27|       |// A Snapshot is an immutable object and can therefore be safely
   28|       |// accessed from multiple threads without any external synchronization.
   29|       |class LEVELDB_EXPORT Snapshot {
   30|       | protected:
   31|       |  virtual ~Snapshot();
   32|       |};
   33|       |
   34|       |// A range of keys
   35|       |struct LEVELDB_EXPORT Range {
   36|      0|  Range() {}
   37|      0|  Range(const Slice& s, const Slice& l) : start(s), limit(l) {}
   38|       |
   39|       |  Slice start;  // Included in the range
   40|       |  Slice limit;  // Not included in the range
   41|       |};
   42|       |
   43|       |// A DB is a persistent ordered map from keys to values.
   44|       |// A DB is safe for concurrent access from multiple threads without
   45|       |// any external synchronization.
   46|       |class LEVELDB_EXPORT DB {
   47|       | public:
   48|       |  // Open the database with the specified "name".
   49|       |  // Stores a pointer to a heap-allocated database in *dbptr and returns
   50|       |  // OK on success.
   51|       |  // Stores nullptr in *dbptr and returns a non-OK status on error.
   52|       |  // Caller should delete *dbptr when it is no longer needed.
   53|       |  static Status Open(const Options& options, const std::string& name,
   54|       |                     DB** dbptr);
   55|       |
   56|       |  DB() = default;
   57|       |
   58|       |  DB(const DB&) = delete;
   59|       |  DB& operator=(const DB&) = delete;
   60|       |
   61|       |  virtual ~DB();
   62|       |
   63|       |  // Set the database entry for "key" to "value".  Returns OK on success,
   64|       |  // and a non-OK status on error.
   65|       |  // Note: consider setting options.sync = true.
   66|       |  virtual Status Put(const WriteOptions& options, const Slice& key,
   67|       |                     const Slice& value) = 0;
   68|       |
   69|       |  // Remove the database entry (if any) for "key".  Returns OK on
   70|       |  // success, and a non-OK status on error.  It is not an error if "key"
   71|       |  // did not exist in the database.
   72|       |  // Note: consider setting options.sync = true.
   73|       |  virtual Status Delete(const WriteOptions& options, const Slice& key) = 0;
   74|       |
   75|       |  // Apply the specified updates to the database.
   76|       |  // Returns OK on success, non-OK on failure.
   77|       |  // Note: consider setting options.sync = true.
   78|       |  virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;
   79|       |
   80|       |  // If the database contains an entry for "key" store the
   81|       |  // corresponding value in *value and return OK.
   82|       |  //
   83|       |  // If there is no entry for "key" leave *value unchanged and return
   84|       |  // a status for which Status::IsNotFound() returns true.
   85|       |  //
   86|       |  // May return some other Status on an error.
   87|       |  virtual Status Get(const ReadOptions& options, const Slice& key,
   88|       |                     std::string* value) = 0;
   89|       |
   90|       |  // Return a heap-allocated iterator over the contents of the database.
   91|       |  // The result of NewIterator() is initially invalid (caller must
   92|       |  // call one of the Seek methods on the iterator before using it).
   93|       |  //
   94|       |  // Caller should delete the iterator when it is no longer needed.
   95|       |  // The returned iterator should be deleted before this db is deleted.
   96|       |  virtual Iterator* NewIterator(const ReadOptions& options) = 0;
   97|       |
   98|       |  // Return a handle to the current DB state.  Iterators created with
   99|       |  // this handle will all observe a stable snapshot of the current DB
  100|       |  // state.  The caller must call ReleaseSnapshot(result) when the
  101|       |  // snapshot is no longer needed.
  102|       |  virtual const Snapshot* GetSnapshot() = 0;
  103|       |
  104|       |  // Release a previously acquired snapshot.  The caller must not
  105|       |  // use "snapshot" after this call.
  106|       |  virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;
  107|       |
  108|       |  // DB implementations can export properties about their state
  109|       |  // via this method.  If "property" is a valid property understood by this
  110|       |  // DB implementation, fills "*value" with its current value and returns
  111|       |  // true.  Otherwise returns false.
  112|       |  //
  113|       |  //
  114|       |  // Valid property names include:
  115|       |  //
  116|       |  //  "leveldb.num-files-at-level<N>" - return the number of files at level <N>,
  117|       |  //     where <N> is an ASCII representation of a level number (e.g. "0").
  118|       |  //  "leveldb.stats" - returns a multi-line string that describes statistics
  119|       |  //     about the internal operation of the DB.
  120|       |  //  "leveldb.sstables" - returns a multi-line string that describes all
  121|       |  //     of the sstables that make up the db contents.
  122|       |  //  "leveldb.approximate-memory-usage" - returns the approximate number of
  123|       |  //     bytes of memory in use by the DB.
  124|       |  virtual bool GetProperty(const Slice& property, std::string* value) = 0;
  125|       |
  126|       |  // For each i in [0,n-1], store in "sizes[i]", the approximate
  127|       |  // file system space used by keys in "[range[i].start .. range[i].limit)".
  128|       |  //
  129|       |  // Note that the returned sizes measure file system space usage, so
  130|       |  // if the user data compresses by a factor of ten, the returned
  131|       |  // sizes will be one-tenth the size of the corresponding user data size.
  132|       |  //
  133|       |  // The results may not include the sizes of recently written data.
  134|       |  virtual void GetApproximateSizes(const Range* range, int n,
  135|       |                                   uint64_t* sizes) = 0;
  136|       |
  137|       |  // Compact the underlying storage for the key range [*begin,*end].
  138|       |  // In particular, deleted and overwritten versions are discarded,
  139|       |  // and the data is rearranged to reduce the cost of operations
  140|       |  // needed to access the data.  This operation should typically only
  141|       |  // be invoked by users who understand the underlying implementation.
  142|       |  //
  143|       |  // begin==nullptr is treated as a key before all keys in the database.
  144|       |  // end==nullptr is treated as a key after all keys in the database.
  145|       |  // Therefore the following call will compact the entire database:
  146|       |  //    db->CompactRange(nullptr, nullptr);
  147|       |  virtual void CompactRange(const Slice* begin, const Slice* end) = 0;
  148|       |};
  149|       |
  150|       |// Destroy the contents of the specified database.
  151|       |// Be very careful using this method.
  152|       |//
  153|       |// Note: For backwards compatibility, if DestroyDB is unable to list the
  154|       |// database files, Status::OK() will still be returned masking this failure.
  155|       |LEVELDB_EXPORT Status DestroyDB(const std::string& name,
  156|       |                                const Options& options);
  157|       |
  158|       |// If a DB cannot be opened, you may attempt to call this method to
  159|       |// resurrect as much of the contents of the database as possible.
  160|       |// Some data may be lost, so be careful when calling this function
  161|       |// on a database that contains important information.
  162|       |LEVELDB_EXPORT Status RepairDB(const std::string& dbname,
  163|       |                               const Options& options);
  164|       |
  165|       |}  // namespace leveldb
  166|       |
  167|       |#endif  // STORAGE_LEVELDB_INCLUDE_DB_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Public/leveldb-library/leveldb/options.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_INCLUDE_OPTIONS_H_
    6|       |#define STORAGE_LEVELDB_INCLUDE_OPTIONS_H_
    7|       |
    8|       |#include <stddef.h>
    9|       |
   10|       |#include "leveldb/export.h"
   11|       |
   12|       |namespace leveldb {
   13|       |
   14|       |class Cache;
   15|       |class Comparator;
   16|       |class Env;
   17|       |class FilterPolicy;
   18|       |class Logger;
   19|       |class Snapshot;
   20|       |
   21|       |// DB contents are stored in a set of blocks, each of which holds a
   22|       |// sequence of key,value pairs.  Each block may be compressed before
   23|       |// being stored in a file.  The following enum describes which
   24|       |// compression method (if any) is used to compress a block.
   25|       |enum CompressionType {
   26|       |  // NOTE: do not change the values of existing entries, as these are
   27|       |  // part of the persistent format on disk.
   28|       |  kNoCompression = 0x0,
   29|       |  kSnappyCompression = 0x1
   30|       |};
   31|       |
   32|       |// Options to control the behavior of a database (passed to DB::Open)
   33|       |struct LEVELDB_EXPORT Options {
   34|       |  // Create an Options object with default values for all fields.
   35|       |  Options();
   36|       |
   37|       |  // -------------------
   38|       |  // Parameters that affect behavior
   39|       |
   40|       |  // Comparator used to define the order of keys in the table.
   41|       |  // Default: a comparator that uses lexicographic byte-wise ordering
   42|       |  //
   43|       |  // REQUIRES: The client must ensure that the comparator supplied
   44|       |  // here has the same name and orders keys *exactly* the same as the
   45|       |  // comparator provided to previous open calls on the same DB.
   46|       |  const Comparator* comparator;
   47|       |
   48|       |  // If true, the database will be created if it is missing.
   49|       |  bool create_if_missing = false;
   50|       |
   51|       |  // If true, an error is raised if the database already exists.
   52|       |  bool error_if_exists = false;
   53|       |
   54|       |  // If true, the implementation will do aggressive checking of the
   55|       |  // data it is processing and will stop early if it detects any
   56|       |  // errors.  This may have unforeseen ramifications: for example, a
   57|       |  // corruption of one DB entry may cause a large number of entries to
   58|       |  // become unreadable or for the entire DB to become unopenable.
   59|       |  bool paranoid_checks = false;
   60|       |
   61|       |  // Use the specified object to interact with the environment,
   62|       |  // e.g. to read/write files, schedule background work, etc.
   63|       |  // Default: Env::Default()
   64|       |  Env* env;
   65|       |
   66|       |  // Any internal progress/error information generated by the db will
   67|       |  // be written to info_log if it is non-null, or to a file stored
   68|       |  // in the same directory as the DB contents if info_log is null.
   69|       |  Logger* info_log = nullptr;
   70|       |
   71|       |  // -------------------
   72|       |  // Parameters that affect performance
   73|       |
   74|       |  // Amount of data to build up in memory (backed by an unsorted log
   75|       |  // on disk) before converting to a sorted on-disk file.
   76|       |  //
   77|       |  // Larger values increase performance, especially during bulk loads.
   78|       |  // Up to two write buffers may be held in memory at the same time,
   79|       |  // so you may wish to adjust this parameter to control memory usage.
   80|       |  // Also, a larger write buffer will result in a longer recovery time
   81|       |  // the next time the database is opened.
   82|       |  size_t write_buffer_size = 4 * 1024 * 1024;
   83|       |
   84|       |  // Number of open files that can be used by the DB.  You may need to
   85|       |  // increase this if your database has a large working set (budget
   86|       |  // one open file per 2MB of working set).
   87|       |  int max_open_files = 1000;
   88|       |
   89|       |  // Control over blocks (user data is stored in a set of blocks, and
   90|       |  // a block is the unit of reading from disk).
   91|       |
   92|       |  // If non-null, use the specified cache for blocks.
   93|       |  // If null, leveldb will automatically create and use an 8MB internal cache.
   94|       |  Cache* block_cache = nullptr;
   95|       |
   96|       |  // Approximate size of user data packed per block.  Note that the
   97|       |  // block size specified here corresponds to uncompressed data.  The
   98|       |  // actual size of the unit read from disk may be smaller if
   99|       |  // compression is enabled.  This parameter can be changed dynamically.
  100|       |  size_t block_size = 4 * 1024;
  101|       |
  102|       |  // Number of keys between restart points for delta encoding of keys.
  103|       |  // This parameter can be changed dynamically.  Most clients should
  104|       |  // leave this parameter alone.
  105|       |  int block_restart_interval = 16;
  106|       |
  107|       |  // Leveldb will write up to this amount of bytes to a file before
  108|       |  // switching to a new one.
  109|       |  // Most clients should leave this parameter alone.  However if your
  110|       |  // filesystem is more efficient with larger files, you could
  111|       |  // consider increasing the value.  The downside will be longer
  112|       |  // compactions and hence longer latency/performance hiccups.
  113|       |  // Another reason to increase this parameter might be when you are
  114|       |  // initially populating a large database.
  115|       |  size_t max_file_size = 2 * 1024 * 1024;
  116|       |
  117|       |  // Compress blocks using the specified compression algorithm.  This
  118|       |  // parameter can be changed dynamically.
  119|       |  //
  120|       |  // Default: kSnappyCompression, which gives lightweight but fast
  121|       |  // compression.
  122|       |  //
  123|       |  // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
  124|       |  //    ~200-500MB/s compression
  125|       |  //    ~400-800MB/s decompression
  126|       |  // Note that these speeds are significantly faster than most
  127|       |  // persistent storage speeds, and therefore it is typically never
  128|       |  // worth switching to kNoCompression.  Even if the input data is
  129|       |  // incompressible, the kSnappyCompression implementation will
  130|       |  // efficiently detect that and will switch to uncompressed mode.
  131|       |  CompressionType compression = kSnappyCompression;
  132|       |
  133|       |  // EXPERIMENTAL: If true, append to existing MANIFEST and log files
  134|       |  // when a database is opened.  This can significantly speed up open.
  135|       |  //
  136|       |  // Default: currently false, but may become true later.
  137|       |  bool reuse_logs = false;
  138|       |
  139|       |  // If non-null, use the specified filter policy to reduce disk reads.
  140|       |  // Many applications will benefit from passing the result of
  141|       |  // NewBloomFilterPolicy() here.
  142|       |  const FilterPolicy* filter_policy = nullptr;
  143|       |};
  144|       |
  145|       |// Options that control read operations
  146|       |struct LEVELDB_EXPORT ReadOptions {
  147|      0|  ReadOptions() = default;
  148|       |
  149|       |  // If true, all data read from underlying storage will be
  150|       |  // verified against corresponding checksums.
  151|       |  bool verify_checksums = false;
  152|       |
  153|       |  // Should the data read for this iteration be cached in memory?
  154|       |  // Callers may wish to set this field to false for bulk scans.
  155|       |  bool fill_cache = true;
  156|       |
  157|       |  // If "snapshot" is non-null, read as of the supplied snapshot
  158|       |  // (which must belong to the DB that is being read and which must
  159|       |  // not have been released).  If "snapshot" is null, use an implicit
  160|       |  // snapshot of the state at the beginning of this read operation.
  161|       |  const Snapshot* snapshot = nullptr;
  162|       |};
  163|       |
  164|       |// Options that control write operations
  165|       |struct LEVELDB_EXPORT WriteOptions {
  166|      0|  WriteOptions() = default;
  167|       |
  168|       |  // If true, the write will be flushed from the operating system
  169|       |  // buffer cache (by calling WritableFile::Sync()) before the write
  170|       |  // is considered complete.  If this flag is true, writes will be
  171|       |  // slower.
  172|       |  //
  173|       |  // If this flag is false, and the machine crashes, some recent
  174|       |  // writes may be lost.  Note that if it is just the process that
  175|       |  // crashes (i.e., the machine does not reboot), no writes will be
  176|       |  // lost even if sync==false.
  177|       |  //
  178|       |  // In other words, a DB write with sync==false has similar
  179|       |  // crash semantics as the "write()" system call.  A DB write
  180|       |  // with sync==true has similar crash semantics to a "write()"
  181|       |  // system call followed by "fsync()".
  182|       |  bool sync = false;
  183|       |};
  184|       |
  185|       |}  // namespace leveldb
  186|       |
  187|       |#endif  // STORAGE_LEVELDB_INCLUDE_OPTIONS_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Public/leveldb-library/leveldb/slice.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// Slice is a simple structure containing a pointer into some external
    6|       |// storage and a size.  The user of a Slice must ensure that the slice
    7|       |// is not used after the corresponding external storage has been
    8|       |// deallocated.
    9|       |//
   10|       |// Multiple threads can invoke const methods on a Slice without
   11|       |// external synchronization, but if any of the threads may call a
   12|       |// non-const method, all threads accessing the same Slice must use
   13|       |// external synchronization.
   14|       |
   15|       |#ifndef STORAGE_LEVELDB_INCLUDE_SLICE_H_
   16|       |#define STORAGE_LEVELDB_INCLUDE_SLICE_H_
   17|       |
   18|       |#include <assert.h>
   19|       |#include <stddef.h>
   20|       |#include <string.h>
   21|       |
   22|       |#include <string>
   23|       |
   24|       |#include "leveldb/export.h"
   25|       |
   26|       |namespace leveldb {
   27|       |
   28|       |class LEVELDB_EXPORT Slice {
   29|       | public:
   30|       |  // Create an empty slice.
   31|      0|  Slice() : data_(""), size_(0) {}
   32|       |
   33|       |  // Create a slice that refers to d[0,n-1].
   34|      0|  Slice(const char* d, size_t n) : data_(d), size_(n) {}
   35|       |
   36|       |  // Create a slice that refers to the contents of "s"
   37|       |  Slice(const std::string& s) : data_(s.data()), size_(s.size()) {}
   38|       |
   39|       |  // Create a slice that refers to s[0,strlen(s)-1]
   40|       |  Slice(const char* s) : data_(s), size_(strlen(s)) {}
   41|       |
   42|       |  // Intentionally copyable.
   43|       |  Slice(const Slice&) = default;
   44|       |  Slice& operator=(const Slice&) = default;
   45|       |
   46|       |  // Return a pointer to the beginning of the referenced data
   47|      0|  const char* data() const { return data_; }
   48|       |
   49|       |  // Return the length (in bytes) of the referenced data
   50|      0|  size_t size() const { return size_; }
   51|       |
   52|       |  // Return true iff the length of the referenced data is zero
   53|       |  bool empty() const { return size_ == 0; }
   54|       |
   55|       |  // Return the ith byte in the referenced data.
   56|       |  // REQUIRES: n < size()
   57|       |  char operator[](size_t n) const {
   58|       |    assert(n < size());
   59|       |    return data_[n];
   60|       |  }
   61|       |
   62|       |  // Change this slice to refer to an empty array
   63|       |  void clear() {
   64|       |    data_ = "";
   65|       |    size_ = 0;
   66|       |  }
   67|       |
   68|       |  // Drop the first "n" bytes from this slice.
   69|       |  void remove_prefix(size_t n) {
   70|       |    assert(n <= size());
   71|       |    data_ += n;
   72|       |    size_ -= n;
   73|       |  }
   74|       |
   75|       |  // Return a string that contains the copy of the referenced data.
   76|       |  std::string ToString() const { return std::string(data_, size_); }
   77|       |
   78|       |  // Three-way comparison.  Returns value:
   79|       |  //   <  0 iff "*this" <  "b",
   80|       |  //   == 0 iff "*this" == "b",
   81|       |  //   >  0 iff "*this" >  "b"
   82|       |  int compare(const Slice& b) const;
   83|       |
   84|       |  // Return true iff "x" is a prefix of "*this"
   85|      0|  bool starts_with(const Slice& x) const {
   86|      0|    return ((size_ >= x.size_) && (memcmp(data_, x.data_, x.size_) == 0));
   87|      0|  }
   88|       |
   89|       | private:
   90|       |  const char* data_;
   91|       |  size_t size_;
   92|       |};
   93|       |
   94|       |inline bool operator==(const Slice& x, const Slice& y) {
   95|       |  return ((x.size() == y.size()) &&
   96|       |          (memcmp(x.data(), y.data(), x.size()) == 0));
   97|       |}
   98|       |
   99|       |inline bool operator!=(const Slice& x, const Slice& y) { return !(x == y); }
  100|       |
  101|      0|inline int Slice::compare(const Slice& b) const {
  102|      0|  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  103|      0|  int r = memcmp(data_, b.data_, min_len);
  104|      0|  if (r == 0) {
  105|      0|    if (size_ < b.size_)
  106|      0|      r = -1;
  107|      0|    else if (size_ > b.size_)
  108|      0|      r = +1;
  109|      0|  }
  110|      0|  return r;
  111|      0|}
  112|       |
  113|       |}  // namespace leveldb
  114|       |
  115|       |#endif  // STORAGE_LEVELDB_INCLUDE_SLICE_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/Headers/Public/leveldb-library/leveldb/status.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// A Status encapsulates the result of an operation.  It may indicate success,
    6|       |// or it may indicate an error with an associated error message.
    7|       |//
    8|       |// Multiple threads can invoke const methods on a Status without
    9|       |// external synchronization, but if any of the threads may call a
   10|       |// non-const method, all threads accessing the same Status must use
   11|       |// external synchronization.
   12|       |
   13|       |#ifndef STORAGE_LEVELDB_INCLUDE_STATUS_H_
   14|       |#define STORAGE_LEVELDB_INCLUDE_STATUS_H_
   15|       |
   16|       |#include <algorithm>
   17|       |#include <string>
   18|       |
   19|       |#include "leveldb/export.h"
   20|       |#include "leveldb/slice.h"
   21|       |
   22|       |namespace leveldb {
   23|       |
   24|       |class LEVELDB_EXPORT Status {
   25|       | public:
   26|       |  // Create a success status.
   27|      0|  Status() noexcept : state_(nullptr) {}
   28|      0|  ~Status() { delete[] state_; }
   29|       |
   30|       |  Status(const Status& rhs);
   31|       |  Status& operator=(const Status& rhs);
   32|       |
   33|       |  Status(Status&& rhs) noexcept : state_(rhs.state_) { rhs.state_ = nullptr; }
   34|       |  Status& operator=(Status&& rhs) noexcept;
   35|       |
   36|       |  // Return a success status.
   37|       |  static Status OK() { return Status(); }
   38|       |
   39|       |  // Return error status of an appropriate type.
   40|       |  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
   41|       |    return Status(kNotFound, msg, msg2);
   42|       |  }
   43|       |  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
   44|       |    return Status(kCorruption, msg, msg2);
   45|       |  }
   46|       |  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
   47|       |    return Status(kNotSupported, msg, msg2);
   48|       |  }
   49|       |  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
   50|       |    return Status(kInvalidArgument, msg, msg2);
   51|       |  }
   52|       |  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
   53|       |    return Status(kIOError, msg, msg2);
   54|       |  }
   55|       |
   56|       |  // Returns true iff the status indicates success.
   57|      0|  bool ok() const { return (state_ == nullptr); }
   58|       |
   59|       |  // Returns true iff the status indicates a NotFound error.
   60|       |  bool IsNotFound() const { return code() == kNotFound; }
   61|       |
   62|       |  // Returns true iff the status indicates a Corruption error.
   63|      0|  bool IsCorruption() const { return code() == kCorruption; }
   64|       |
   65|       |  // Returns true iff the status indicates an IOError.
   66|      0|  bool IsIOError() const { return code() == kIOError; }
   67|       |
   68|       |  // Returns true iff the status indicates a NotSupportedError.
   69|      0|  bool IsNotSupportedError() const { return code() == kNotSupported; }
   70|       |
   71|       |  // Returns true iff the status indicates an InvalidArgument.
   72|      0|  bool IsInvalidArgument() const { return code() == kInvalidArgument; }
   73|       |
   74|       |  // Return a string representation of this status suitable for printing.
   75|       |  // Returns the string "OK" for success.
   76|       |  std::string ToString() const;
   77|       |
   78|       | private:
   79|       |  enum Code {
   80|       |    kOk = 0,
   81|       |    kNotFound = 1,
   82|       |    kCorruption = 2,
   83|       |    kNotSupported = 3,
   84|       |    kInvalidArgument = 4,
   85|       |    kIOError = 5
   86|       |  };
   87|       |
   88|       |  Code code() const {
   89|       |    return (state_ == nullptr) ? kOk : static_cast<Code>(state_[4]);
   90|       |  }
   91|       |
   92|       |  Status(Code code, const Slice& msg, const Slice& msg2);
   93|       |  static const char* CopyState(const char* s);
   94|       |
   95|       |  // OK status has a null state_.  Otherwise, state_ is a new[] array
   96|       |  // of the following form:
   97|       |  //    state_[0..3] == length of message
   98|       |  //    state_[4]    == code
   99|       |  //    state_[5..]  == message
  100|       |  const char* state_;
  101|       |};
  102|       |
  103|       |inline Status::Status(const Status& rhs) {
  104|       |  state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_);
  105|       |}
  106|       |inline Status& Status::operator=(const Status& rhs) {
  107|       |  // The following condition catches both aliasing (when this == &rhs),
  108|       |  // and the common case where both rhs and *this are ok.
  109|       |  if (state_ != rhs.state_) {
  110|       |    delete[] state_;
  111|       |    state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_);
  112|       |  }
  113|       |  return *this;
  114|       |}
  115|      0|inline Status& Status::operator=(Status&& rhs) noexcept {
  116|      0|  std::swap(state_, rhs.state_);
  117|      0|  return *this;
  118|      0|}
  119|       |
  120|       |}  // namespace leveldb
  121|       |
  122|       |#endif  // STORAGE_LEVELDB_INCLUDE_STATUS_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+All.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+All.h"
   18|       |
   19|       |#import "FBLPromise+Async.h"
   20|       |#import "FBLPromisePrivate.h"
   21|       |
   22|       |@implementation FBLPromise (AllAdditions)
   23|       |
   24|      0|+ (FBLPromise<NSArray *> *)all:(NSArray *)promises {
   25|      0|  return [self onQueue:self.defaultDispatchQueue all:promises];
   26|      0|}
   27|       |
   28|      0|+ (FBLPromise<NSArray *> *)onQueue:(dispatch_queue_t)queue all:(NSArray *)allPromises {
   29|      0|  NSParameterAssert(queue);
   30|      0|  NSParameterAssert(allPromises);
   31|      0|
   32|      0|  if (allPromises.count == 0) {
   33|      0|    return [[FBLPromise alloc] initWithResolution:@[]];
   34|      0|  }
   35|      0|  NSMutableArray *promises = [allPromises mutableCopy];
   36|      0|  return [FBLPromise
   37|      0|      onQueue:queue
   38|      0|        async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
   39|      0|          for (NSUInteger i = 0; i < promises.count; ++i) {
   40|      0|            id promise = promises[i];
   41|      0|            if ([promise isKindOfClass:self]) {
   42|      0|              continue;
   43|      0|            } else if ([promise isKindOfClass:[NSError class]]) {
   44|      0|              reject(promise);
   45|      0|              return;
   46|      0|            } else {
   47|      0|              [promises replaceObjectAtIndex:i
   48|      0|                                  withObject:[[FBLPromise alloc] initWithResolution:promise]];
   49|      0|            }
   50|      0|          }
   51|      0|          for (FBLPromise *promise in promises) {
   52|      0|            [promise observeOnQueue:queue
   53|      0|                fulfill:^(id __unused _) {
   54|      0|                  // Wait until all are fulfilled.
   55|      0|                  for (FBLPromise *promise in promises) {
   56|      0|                    if (!promise.isFulfilled) {
   57|      0|                      return;
   58|      0|                    }
   59|      0|                  }
   60|      0|                  // If called multiple times, only the first one affects the result.
   61|      0|                  fulfill([promises valueForKey:NSStringFromSelector(@selector(value))]);
   62|      0|                }
   63|      0|                reject:^(NSError *error) {
   64|      0|                  reject(error);
   65|      0|                }];
   66|      0|          }
   67|      0|        }];
   68|      0|}
   69|       |
   70|       |@end
   71|       |
   72|       |@implementation FBLPromise (DotSyntax_AllAdditions)
   73|       |
   74|      0|+ (FBLPromise<NSArray *> * (^)(NSArray *))all {
   75|      0|  return ^(NSArray<FBLPromise *> *promises) {
   76|      0|    return [self all:promises];
   77|      0|  };
   78|      0|}
   79|       |
   80|      0|+ (FBLPromise<NSArray *> * (^)(dispatch_queue_t, NSArray *))allOn {
   81|      0|  return ^(dispatch_queue_t queue, NSArray<FBLPromise *> *promises) {
   82|      0|    return [self onQueue:queue all:promises];
   83|      0|  };
   84|      0|}
   85|       |
   86|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Always.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Always.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (AlwaysAdditions)
   22|       |
   23|      0|- (FBLPromise *)always:(FBLPromiseAlwaysWorkBlock)work {
   24|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue always:work];
   25|      0|}
   26|       |
   27|      0|- (FBLPromise *)onQueue:(dispatch_queue_t)queue always:(FBLPromiseAlwaysWorkBlock)work {
   28|      0|  NSParameterAssert(queue);
   29|      0|  NSParameterAssert(work);
   30|      0|
   31|      0|  return [self chainOnQueue:queue
   32|      0|      chainedFulfill:^id(id value) {
   33|      0|        work();
   34|      0|        return value;
   35|      0|      }
   36|      0|      chainedReject:^id(NSError *error) {
   37|      0|        work();
   38|      0|        return error;
   39|      0|      }];
   40|      0|}
   41|       |
   42|       |@end
   43|       |
   44|       |@implementation FBLPromise (DotSyntax_AlwaysAdditions)
   45|       |
   46|      0|- (FBLPromise * (^)(FBLPromiseAlwaysWorkBlock))always {
   47|      0|  return ^(FBLPromiseAlwaysWorkBlock work) {
   48|      0|    return [self always:work];
   49|      0|  };
   50|      0|}
   51|       |
   52|      0|- (FBLPromise * (^)(dispatch_queue_t, FBLPromiseAlwaysWorkBlock))alwaysOn {
   53|      0|  return ^(dispatch_queue_t queue, FBLPromiseAlwaysWorkBlock work) {
   54|      0|    return [self onQueue:queue always:work];
   55|      0|  };
   56|      0|}
   57|       |
   58|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Any.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Any.h"
   18|       |
   19|       |#import "FBLPromise+Async.h"
   20|       |#import "FBLPromisePrivate.h"
   21|       |
   22|      0|static NSArray *FBLPromiseCombineValuesAndErrors(NSArray<FBLPromise *> *promises) {
   23|      0|  NSMutableArray *combinedValuesAndErrors = [[NSMutableArray alloc] init];
   24|      0|  for (FBLPromise *promise in promises) {
   25|      0|    if (promise.isFulfilled) {
   26|      0|      [combinedValuesAndErrors addObject:promise.value ?: [NSNull null]];
   27|      0|      continue;
   28|      0|    }
   29|      0|    if (promise.isRejected) {
   30|      0|      [combinedValuesAndErrors addObject:promise.error];
   31|      0|      continue;
   32|      0|    }
   33|      0|    assert(!promise.isPending);
   34|      0|  };
   35|      0|  return combinedValuesAndErrors;
   36|      0|}
   37|       |
   38|       |@implementation FBLPromise (AnyAdditions)
   39|       |
   40|      0|+ (FBLPromise<NSArray *> *)any:(NSArray *)promises {
   41|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue any:promises];
   42|      0|}
   43|       |
   44|      0|+ (FBLPromise<NSArray *> *)onQueue:(dispatch_queue_t)queue any:(NSArray *)anyPromises {
   45|      0|  NSParameterAssert(queue);
   46|      0|  NSParameterAssert(anyPromises);
   47|      0|
   48|      0|  if (anyPromises.count == 0) {
   49|      0|    return [[FBLPromise alloc] initWithResolution:@[]];
   50|      0|  }
   51|      0|  NSMutableArray *promises = [anyPromises mutableCopy];
   52|      0|  return [FBLPromise
   53|      0|      onQueue:queue
   54|      0|        async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
   55|      0|          for (NSUInteger i = 0; i < promises.count; ++i) {
   56|      0|            id promise = promises[i];
   57|      0|            if ([promise isKindOfClass:self]) {
   58|      0|              continue;
   59|      0|            } else {
   60|      0|              [promises replaceObjectAtIndex:i
   61|      0|                                  withObject:[[FBLPromise alloc] initWithResolution:promise]];
   62|      0|            }
   63|      0|          }
   64|      0|          for (FBLPromise *promise in promises) {
   65|      0|            [promise observeOnQueue:queue
   66|      0|                fulfill:^(id __unused _) {
   67|      0|                  // Wait until all are resolved.
   68|      0|                  for (FBLPromise *promise in promises) {
   69|      0|                    if (promise.isPending) {
   70|      0|                      return;
   71|      0|                    }
   72|      0|                  }
   73|      0|                  // If called multiple times, only the first one affects the result.
   74|      0|                  fulfill(FBLPromiseCombineValuesAndErrors(promises));
   75|      0|                }
   76|      0|                reject:^(NSError *error) {
   77|      0|                  BOOL atLeastOneIsFulfilled = NO;
   78|      0|                  for (FBLPromise *promise in promises) {
   79|      0|                    if (promise.isPending) {
   80|      0|                      return;
   81|      0|                    }
   82|      0|                    if (promise.isFulfilled) {
   83|      0|                      atLeastOneIsFulfilled = YES;
   84|      0|                    }
   85|      0|                  }
   86|      0|                  if (atLeastOneIsFulfilled) {
   87|      0|                    fulfill(FBLPromiseCombineValuesAndErrors(promises));
   88|      0|                  } else {
   89|      0|                    reject(error);
   90|      0|                  }
   91|      0|                }];
   92|      0|          }
   93|      0|        }];
   94|      0|}
   95|       |
   96|       |@end
   97|       |
   98|       |@implementation FBLPromise (DotSyntax_AnyAdditions)
   99|       |
  100|      0|+ (FBLPromise<NSArray *> * (^)(NSArray *))any {
  101|      0|  return ^(NSArray *promises) {
  102|      0|    return [self any:promises];
  103|      0|  };
  104|      0|}
  105|       |
  106|      0|+ (FBLPromise<NSArray *> * (^)(dispatch_queue_t, NSArray *))anyOn {
  107|      0|  return ^(dispatch_queue_t queue, NSArray *promises) {
  108|      0|    return [self onQueue:queue any:promises];
  109|      0|  };
  110|      0|}
  111|       |
  112|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Async.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Async.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (AsyncAdditions)
   22|       |
   23|      1|+ (instancetype)async:(FBLPromiseAsyncWorkBlock)work {
   24|      1|  return [self onQueue:self.defaultDispatchQueue async:work];
   25|      1|}
   26|       |
   27|      1|+ (instancetype)onQueue:(dispatch_queue_t)queue async:(FBLPromiseAsyncWorkBlock)work {
   28|      1|  NSParameterAssert(queue);
   29|      1|  NSParameterAssert(work);
   30|      1|
   31|      1|  FBLPromise *promise = [[FBLPromise alloc] initPending];
   32|      1|  dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{
   33|      1|    work(
   34|      1|        ^(id __nullable value) {
   35|      0|          if ([value isKindOfClass:[FBLPromise class]]) {
   36|      0|            [(FBLPromise *)value observeOnQueue:queue
   37|      0|                fulfill:^(id __nullable value) {
   38|      0|                  [promise fulfill:value];
   39|      0|                }
   40|      0|                reject:^(NSError *error) {
   41|      0|                  [promise reject:error];
   42|      0|                }];
   43|      0|          } else {
   44|      0|            [promise fulfill:value];
   45|      0|          }
   46|      0|        },
   47|      1|        ^(NSError *error) {
   48|      0|          [promise reject:error];
   49|      0|        });
   50|      1|  });
   51|      1|  return promise;
   52|      1|}
   53|       |
   54|       |@end
   55|       |
   56|       |@implementation FBLPromise (DotSyntax_AsyncAdditions)
   57|       |
   58|      0|+ (FBLPromise* (^)(FBLPromiseAsyncWorkBlock))async {
   59|      0|  return ^(FBLPromiseAsyncWorkBlock work) {
   60|      0|    return [self async:work];
   61|      0|  };
   62|      0|}
   63|       |
   64|      0|+ (FBLPromise* (^)(dispatch_queue_t, FBLPromiseAsyncWorkBlock))asyncOn {
   65|      0|  return ^(dispatch_queue_t queue, FBLPromiseAsyncWorkBlock work) {
   66|      0|    return [self onQueue:queue async:work];
   67|      0|  };
   68|      0|}
   69|       |
   70|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Catch.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Catch.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (CatchAdditions)
   22|       |
   23|      5|- (FBLPromise *)catch:(FBLPromiseCatchWorkBlock)reject {
   24|      5|  return [self onQueue:FBLPromise.defaultDispatchQueue catch:reject];
   25|      5|}
   26|       |
   27|      5|- (FBLPromise *)onQueue:(dispatch_queue_t)queue catch:(FBLPromiseCatchWorkBlock)reject {
   28|      5|  NSParameterAssert(queue);
   29|      5|  NSParameterAssert(reject);
   30|      5|
   31|      5|  return [self chainOnQueue:queue
   32|      5|             chainedFulfill:nil
   33|      5|              chainedReject:^id(NSError *error) {
   34|      0|                reject(error);
   35|      0|                return error;
   36|      0|              }];
   37|      5|}
   38|       |
   39|       |@end
   40|       |
   41|       |@implementation FBLPromise (DotSyntax_CatchAdditions)
   42|       |
   43|      5|- (FBLPromise* (^)(FBLPromiseCatchWorkBlock))catch {
   44|      5|  return ^(FBLPromiseCatchWorkBlock catch) {
   45|      5|    return [self catch:catch];
   46|      5|  };
   47|      5|}
   48|       |
   49|      0|- (FBLPromise* (^)(dispatch_queue_t, FBLPromiseCatchWorkBlock))catchOn {
   50|      0|  return ^(dispatch_queue_t queue, FBLPromiseCatchWorkBlock catch) {
   51|      0|    return [self onQueue:queue catch:catch];
   52|      0|  };
   53|      0|}
   54|       |
   55|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Delay.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Delay.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (DelayAdditions)
   22|       |
   23|      0|- (FBLPromise *)delay:(NSTimeInterval)interval {
   24|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue delay:interval];
   25|      0|}
   26|       |
   27|      0|- (FBLPromise *)onQueue:(dispatch_queue_t)queue delay:(NSTimeInterval)interval {
   28|      0|  NSParameterAssert(queue);
   29|      0|
   30|      0|  FBLPromise *promise = [[FBLPromise alloc] initPending];
   31|      0|  [self observeOnQueue:queue
   32|      0|      fulfill:^(id __nullable value) {
   33|      0|        dispatch_after(dispatch_time(0, (int64_t)(interval * NSEC_PER_SEC)), queue, ^{
   34|      0|          [promise fulfill:value];
   35|      0|        });
   36|      0|      }
   37|      0|      reject:^(NSError *error) {
   38|      0|        [promise reject:error];
   39|      0|      }];
   40|      0|  return promise;
   41|      0|}
   42|       |
   43|       |@end
   44|       |
   45|       |@implementation FBLPromise (DotSyntax_DelayAdditions)
   46|       |
   47|      0|- (FBLPromise * (^)(NSTimeInterval))delay {
   48|      0|  return ^(NSTimeInterval interval) {
   49|      0|    return [self delay:interval];
   50|      0|  };
   51|      0|}
   52|       |
   53|      0|- (FBLPromise * (^)(dispatch_queue_t, NSTimeInterval))delayOn {
   54|      0|  return ^(dispatch_queue_t queue, NSTimeInterval interval) {
   55|      0|    return [self onQueue:queue delay:interval];
   56|      0|  };
   57|      0|}
   58|       |
   59|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Do.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Do.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (DoAdditions)
   22|       |
   23|      0|+ (instancetype)do:(FBLPromiseDoWorkBlock)work {
   24|      0|  return [self onQueue:self.defaultDispatchQueue do:work];
   25|      0|}
   26|       |
   27|      3|+ (instancetype)onQueue:(dispatch_queue_t)queue do:(FBLPromiseDoWorkBlock)work {
   28|      3|  NSParameterAssert(queue);
   29|      3|  NSParameterAssert(work);
   30|      3|
   31|      3|  FBLPromise *promise = [[FBLPromise alloc] initPending];
   32|      3|  dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{
   33|      3|    id value = work();
   34|      3|    if ([value isKindOfClass:[FBLPromise class]]) {
   35|      0|      [(FBLPromise *)value observeOnQueue:queue
   36|      0|          fulfill:^(id __nullable value) {
   37|      0|            [promise fulfill:value];
   38|      0|          }
   39|      0|          reject:^(NSError *error) {
   40|      0|            [promise reject:error];
   41|      0|          }];
   42|      3|    } else {
   43|      3|      [promise fulfill:value];
   44|      3|    }
   45|      3|  });
   46|      3|  return promise;
   47|      3|}
   48|       |
   49|       |@end
   50|       |
   51|       |@implementation FBLPromise (DotSyntax_DoAdditions)
   52|       |
   53|      0|+ (FBLPromise* (^)(dispatch_queue_t, FBLPromiseDoWorkBlock))doOn {
   54|      0|  return ^(dispatch_queue_t queue, FBLPromiseDoWorkBlock work) {
   55|      0|    return [self onQueue:queue do:work];
   56|      0|  };
   57|      0|}
   58|       |
   59|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Race.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Race.h"
   18|       |
   19|       |#import "FBLPromise+Async.h"
   20|       |#import "FBLPromisePrivate.h"
   21|       |
   22|       |@implementation FBLPromise (RaceAdditions)
   23|       |
   24|      0|+ (instancetype)race:(NSArray *)promises {
   25|      0|  return [self onQueue:self.defaultDispatchQueue race:promises];
   26|      0|}
   27|       |
   28|      0|+ (instancetype)onQueue:(dispatch_queue_t)queue race:(NSArray *)racePromises {
   29|      0|  NSParameterAssert(queue);
   30|      0|  NSAssert(racePromises.count > 0, @"No promises to observe");
   31|      0|
   32|      0|  NSArray *promises = [racePromises copy];
   33|      0|  return [FBLPromise onQueue:queue
   34|      0|                       async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
   35|      0|                         for (id promise in promises) {
   36|      0|                           if (![promise isKindOfClass:self]) {
   37|      0|                             fulfill(promise);
   38|      0|                             return;
   39|      0|                           }
   40|      0|                         }
   41|      0|                         // Subscribe all, but only the first one to resolve will change
   42|      0|                         // the resulting promise's state.
   43|      0|                         for (FBLPromise *promise in promises) {
   44|      0|                           [promise observeOnQueue:queue fulfill:fulfill reject:reject];
   45|      0|                         }
   46|      0|                       }];
   47|      0|}
   48|       |
   49|       |@end
   50|       |
   51|       |@implementation FBLPromise (DotSyntax_RaceAdditions)
   52|       |
   53|      0|+ (FBLPromise * (^)(NSArray *))race {
   54|      0|  return ^(NSArray *promises) {
   55|      0|    return [self race:promises];
   56|      0|  };
   57|      0|}
   58|       |
   59|      0|+ (FBLPromise * (^)(dispatch_queue_t, NSArray *))raceOn {
   60|      0|  return ^(dispatch_queue_t queue, NSArray *promises) {
   61|      0|    return [self onQueue:queue race:promises];
   62|      0|  };
   63|      0|}
   64|       |
   65|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Recover.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Recover.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (RecoverAdditions)
   22|       |
   23|      3|- (FBLPromise *)recover:(FBLPromiseRecoverWorkBlock)recovery {
   24|      3|  return [self onQueue:FBLPromise.defaultDispatchQueue recover:recovery];
   25|      3|}
   26|       |
   27|      3|- (FBLPromise *)onQueue:(dispatch_queue_t)queue recover:(FBLPromiseRecoverWorkBlock)recovery {
   28|      3|  NSParameterAssert(queue);
   29|      3|  NSParameterAssert(recovery);
   30|      3|
   31|      3|  return [self chainOnQueue:queue
   32|      3|             chainedFulfill:nil
   33|      3|              chainedReject:^id(NSError *error) {
   34|      1|                return recovery(error);
   35|      1|              }];
   36|      3|}
   37|       |
   38|       |@end
   39|       |
   40|       |@implementation FBLPromise (DotSyntax_RecoverAdditions)
   41|       |
   42|      3|- (FBLPromise * (^)(FBLPromiseRecoverWorkBlock))recover {
   43|      3|  return ^(FBLPromiseRecoverWorkBlock recovery) {
   44|      3|    return [self recover:recovery];
   45|      3|  };
   46|      3|}
   47|       |
   48|      0|- (FBLPromise * (^)(dispatch_queue_t, FBLPromiseRecoverWorkBlock))recoverOn {
   49|      0|  return ^(dispatch_queue_t queue, FBLPromiseRecoverWorkBlock recovery) {
   50|      0|    return [self onQueue:queue recover:recovery];
   51|      0|  };
   52|      0|}
   53|       |
   54|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Reduce.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Reduce.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (ReduceAdditions)
   22|       |
   23|      0|- (FBLPromise *)reduce:(NSArray *)items combine:(FBLPromiseReducerBlock)reducer {
   24|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue reduce:items combine:reducer];
   25|      0|}
   26|       |
   27|       |- (FBLPromise *)onQueue:(dispatch_queue_t)queue
   28|       |                 reduce:(NSArray *)items
   29|      0|                combine:(FBLPromiseReducerBlock)reducer {
   30|      0|  NSParameterAssert(queue);
   31|      0|  NSParameterAssert(items);
   32|      0|  NSParameterAssert(reducer);
   33|      0|
   34|      0|  FBLPromise *promise = self;
   35|      0|  for (id item in items) {
   36|      0|    promise = [promise chainOnQueue:queue
   37|      0|                     chainedFulfill:^id(id value) {
   38|      0|                       return reducer(value, item);
   39|      0|                     }
   40|      0|                      chainedReject:nil];
   41|      0|  }
   42|      0|  return promise;
   43|      0|}
   44|       |
   45|       |@end
   46|       |
   47|       |@implementation FBLPromise (DotSyntax_ReduceAdditions)
   48|       |
   49|      0|- (FBLPromise * (^)(NSArray *, FBLPromiseReducerBlock))reduce {
   50|      0|  return ^(NSArray *items, FBLPromiseReducerBlock reducer) {
   51|      0|    return [self reduce:items combine:reducer];
   52|      0|  };
   53|      0|}
   54|       |
   55|      0|- (FBLPromise * (^)(dispatch_queue_t, NSArray *, FBLPromiseReducerBlock))reduceOn {
   56|      0|  return ^(dispatch_queue_t queue, NSArray *items, FBLPromiseReducerBlock reducer) {
   57|      0|    return [self onQueue:queue reduce:items combine:reducer];
   58|      0|  };
   59|      0|}
   60|       |
   61|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Retry.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Retry.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |NSInteger const FBLPromiseRetryDefaultAttemptsCount = 1;
   22|       |NSTimeInterval const FBLPromiseRetryDefaultDelayInterval = 1.0;
   23|       |
   24|       |static void FBLPromiseRetryAttempt(FBLPromise *promise, dispatch_queue_t queue, NSInteger count,
   25|       |                                   NSTimeInterval interval, FBLPromiseRetryPredicateBlock predicate,
   26|      1|                                   FBLPromiseRetryWorkBlock work) {
   27|      1|  __auto_type retrier = ^(id __nullable value) {
   28|      0|    if ([value isKindOfClass:[NSError class]]) {
   29|      0|      if (count <= 0 || (predicate && !predicate(count, value))) {
   30|      0|        [promise reject:value];
   31|      0|      } else {
   32|      0|        dispatch_after(dispatch_time(0, (int64_t)(interval * NSEC_PER_SEC)), queue, ^{
   33|      0|          FBLPromiseRetryAttempt(promise, queue, count - 1, interval, predicate, work);
   34|      0|        });
   35|      0|      }
   36|      0|    } else {
   37|      0|      [promise fulfill:value];
   38|      0|    }
   39|      0|  };
   40|      1|  id value = work();
   41|      1|  if ([value isKindOfClass:[FBLPromise class]]) {
   42|      1|    [(FBLPromise *)value observeOnQueue:queue fulfill:retrier reject:retrier];
   43|      1|  } else  {
   44|      0|    retrier(value);
   45|      0|  }
   46|      1|}
   47|       |
   48|       |@implementation FBLPromise (RetryAdditions)
   49|       |
   50|      0|+ (FBLPromise *)retry:(FBLPromiseRetryWorkBlock)work {
   51|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue retry:work];
   52|      0|}
   53|       |
   54|      0|+ (FBLPromise *)onQueue:(dispatch_queue_t)queue retry:(FBLPromiseRetryWorkBlock)work {
   55|      0|  return [self onQueue:queue attempts:FBLPromiseRetryDefaultAttemptsCount retry:work];
   56|      0|}
   57|       |
   58|      0|+ (FBLPromise *)attempts:(NSInteger)count retry:(FBLPromiseRetryWorkBlock)work {
   59|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue attempts:count retry:work];
   60|      0|}
   61|       |
   62|       |+ (FBLPromise *)onQueue:(dispatch_queue_t)queue
   63|       |               attempts:(NSInteger)count
   64|      0|                  retry:(FBLPromiseRetryWorkBlock)work {
   65|      0|  return [self onQueue:queue
   66|      0|              attempts:count
   67|      0|                 delay:FBLPromiseRetryDefaultDelayInterval
   68|      0|             condition:nil
   69|      0|                 retry:work];
   70|      0|}
   71|       |
   72|       |+ (FBLPromise *)attempts:(NSInteger)count
   73|       |                   delay:(NSTimeInterval)interval
   74|       |               condition:(nullable FBLPromiseRetryPredicateBlock)predicate
   75|      1|                   retry:(FBLPromiseRetryWorkBlock)work {
   76|      1|  return [self onQueue:FBLPromise.defaultDispatchQueue
   77|      1|              attempts:count
   78|      1|                 delay:interval
   79|      1|             condition:predicate
   80|      1|                 retry:work];
   81|      1|}
   82|       |
   83|       |+ (FBLPromise *)onQueue:(dispatch_queue_t)queue
   84|       |               attempts:(NSInteger)count
   85|       |                  delay:(NSTimeInterval)interval
   86|       |              condition:(nullable FBLPromiseRetryPredicateBlock)predicate
   87|      1|                  retry:(FBLPromiseRetryWorkBlock)work {
   88|      1|  NSParameterAssert(queue);
   89|      1|  NSParameterAssert(work);
   90|      1|
   91|      1|  FBLPromise *promise = [[FBLPromise alloc] initPending];
   92|      1|  FBLPromiseRetryAttempt(promise, queue, count, interval, predicate, work);
   93|      1|  return promise;
   94|      1|}
   95|       |
   96|       |@end
   97|       |
   98|       |@implementation FBLPromise (DotSyntax_RetryAdditions)
   99|       |
  100|      0|+ (FBLPromise * (^)(FBLPromiseRetryWorkBlock))retry {
  101|      0|  return ^id(FBLPromiseRetryWorkBlock work) {
  102|      0|    return [self retry:work];
  103|      0|  };
  104|      0|}
  105|       |
  106|      0|+ (FBLPromise * (^)(dispatch_queue_t, FBLPromiseRetryWorkBlock))retryOn {
  107|      0|  return ^id(dispatch_queue_t queue, FBLPromiseRetryWorkBlock work) {
  108|      0|    return [self onQueue:queue retry:work];
  109|      0|  };
  110|      0|}
  111|       |
  112|       |+ (FBLPromise * (^)(NSInteger, NSTimeInterval, FBLPromiseRetryPredicateBlock,
  113|      0|                    FBLPromiseRetryWorkBlock))retryAgain {
  114|      0|  return ^id(NSInteger count, NSTimeInterval interval, FBLPromiseRetryPredicateBlock predicate,
  115|      0|             FBLPromiseRetryWorkBlock work) {
  116|      0|    return [self attempts:count delay:interval condition:predicate retry:work];
  117|      0|  };
  118|      0|}
  119|       |
  120|       |+ (FBLPromise * (^)(dispatch_queue_t, NSInteger, NSTimeInterval, FBLPromiseRetryPredicateBlock,
  121|      0|                    FBLPromiseRetryWorkBlock))retryAgainOn {
  122|      0|  return ^id(dispatch_queue_t queue, NSInteger count, NSTimeInterval interval,
  123|      0|             FBLPromiseRetryPredicateBlock predicate, FBLPromiseRetryWorkBlock work) {
  124|      0|    return [self onQueue:queue attempts:count delay:interval condition:predicate retry:work];
  125|      0|  };
  126|      0|}
  127|       |
  128|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Testing.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Testing.h"
   18|       |
   19|      0|BOOL FBLWaitForPromisesWithTimeout(NSTimeInterval timeout) {
   20|      0|  BOOL isTimedOut = NO;
   21|      0|  NSDate *timeoutDate = [NSDate dateWithTimeIntervalSinceNow:timeout];
   22|      0|  static NSTimeInterval const minimalTimeout = 0.01;
   23|      0|  static int64_t const minimalTimeToWait = (int64_t)(minimalTimeout * NSEC_PER_SEC);
   24|      0|  dispatch_time_t waitTime = dispatch_time(DISPATCH_TIME_NOW, minimalTimeToWait);
   25|      0|  dispatch_group_t dispatchGroup = FBLPromise.dispatchGroup;
   26|      0|  NSRunLoop *runLoop = NSRunLoop.currentRunLoop;
   27|      0|  while (dispatch_group_wait(dispatchGroup, waitTime)) {
   28|      0|    isTimedOut = timeoutDate.timeIntervalSinceNow < 0.0;
   29|      0|    if (isTimedOut) {
   30|      0|      break;
   31|      0|    }
   32|      0|    [runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:minimalTimeout]];
   33|      0|  }
   34|      0|  return !isTimedOut;
   35|      0|}
   36|       |
   37|       |@implementation FBLPromise (TestingAdditions)
   38|       |
   39|       |// These properties are implemented in the FBLPromise class itself.
   40|       |@dynamic isPending;
   41|       |@dynamic isFulfilled;
   42|       |@dynamic isRejected;
   43|       |@dynamic pendingObjects;
   44|       |@dynamic value;
   45|       |@dynamic error;
   46|       |
   47|     61|+ (dispatch_group_t)dispatchGroup {
   48|     61|  static dispatch_group_t gDispatchGroup;
   49|     61|  static dispatch_once_t onceToken;
   50|     61|  dispatch_once(&onceToken, ^{
   51|      1|    gDispatchGroup = dispatch_group_create();
   52|      1|  });
   53|     61|  return gDispatchGroup;
   54|     61|}
   55|       |
   56|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Then.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Then.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (ThenAdditions)
   22|       |
   23|     14|- (FBLPromise *)then:(FBLPromiseThenWorkBlock)work {
   24|     14|  return [self onQueue:FBLPromise.defaultDispatchQueue then:work];
   25|     14|}
   26|       |
   27|     15|- (FBLPromise *)onQueue:(dispatch_queue_t)queue then:(FBLPromiseThenWorkBlock)work {
   28|     15|  NSParameterAssert(queue);
   29|     15|  NSParameterAssert(work);
   30|     15|
   31|     15|  return [self chainOnQueue:queue chainedFulfill:work chainedReject:nil];
   32|     15|}
   33|       |
   34|       |@end
   35|       |
   36|       |@implementation FBLPromise (DotSyntax_ThenAdditions)
   37|       |
   38|     13|- (FBLPromise* (^)(FBLPromiseThenWorkBlock))then {
   39|     13|  return ^(FBLPromiseThenWorkBlock work) {
   40|     13|    return [self then:work];
   41|     13|  };
   42|     13|}
   43|       |
   44|      1|- (FBLPromise* (^)(dispatch_queue_t, FBLPromiseThenWorkBlock))thenOn {
   45|      1|  return ^(dispatch_queue_t queue, FBLPromiseThenWorkBlock work) {
   46|      1|    return [self onQueue:queue then:work];
   47|      1|  };
   48|      1|}
   49|       |
   50|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Timeout.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Timeout.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (TimeoutAdditions)
   22|       |
   23|      0|- (FBLPromise *)timeout:(NSTimeInterval)interval {
   24|      0|  return [self onQueue:FBLPromise.defaultDispatchQueue timeout:interval];
   25|      0|}
   26|       |
   27|      0|- (FBLPromise *)onQueue:(dispatch_queue_t)queue timeout:(NSTimeInterval)interval {
   28|      0|  NSParameterAssert(queue);
   29|      0|
   30|      0|  FBLPromise *promise = [[FBLPromise alloc] initPending];
   31|      0|  [self observeOnQueue:queue
   32|      0|      fulfill:^(id __nullable value) {
   33|      0|        [promise fulfill:value];
   34|      0|      }
   35|      0|      reject:^(NSError *error) {
   36|      0|        [promise reject:error];
   37|      0|      }];
   38|      0|  typeof(self) __weak weakPromise = promise;
   39|      0|  dispatch_after(dispatch_time(0, (int64_t)(interval * NSEC_PER_SEC)), queue, ^{
   40|      0|    NSError *timedOutError = [[NSError alloc] initWithDomain:FBLPromiseErrorDomain
   41|      0|                                                        code:FBLPromiseErrorCodeTimedOut
   42|      0|                                                    userInfo:nil];
   43|      0|    [weakPromise reject:timedOutError];
   44|      0|  });
   45|      0|  return promise;
   46|      0|}
   47|       |
   48|       |@end
   49|       |
   50|       |@implementation FBLPromise (DotSyntax_TimeoutAdditions)
   51|       |
   52|      0|- (FBLPromise* (^)(NSTimeInterval))timeout {
   53|      0|  return ^(NSTimeInterval interval) {
   54|      0|    return [self timeout:interval];
   55|      0|  };
   56|      0|}
   57|       |
   58|      0|- (FBLPromise* (^)(dispatch_queue_t, NSTimeInterval))timeoutOn {
   59|      0|  return ^(dispatch_queue_t queue, NSTimeInterval interval) {
   60|      0|    return [self onQueue:queue timeout:interval];
   61|      0|  };
   62|      0|}
   63|       |
   64|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Validate.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Validate.h"
   18|       |
   19|       |#import "FBLPromisePrivate.h"
   20|       |
   21|       |@implementation FBLPromise (ValidateAdditions)
   22|       |
   23|      1|- (FBLPromise*)validate:(FBLPromiseValidateWorkBlock)predicate {
   24|      1|  return [self onQueue:FBLPromise.defaultDispatchQueue validate:predicate];
   25|      1|}
   26|       |
   27|      1|- (FBLPromise*)onQueue:(dispatch_queue_t)queue validate:(FBLPromiseValidateWorkBlock)predicate {
   28|      1|  NSParameterAssert(queue);
   29|      1|  NSParameterAssert(predicate);
   30|      1|
   31|      1|  FBLPromiseChainedFulfillBlock chainedFulfill = ^id(id value) {
   32|      1|    return predicate(value) ? value :
   33|      1|                              [[NSError alloc] initWithDomain:FBLPromiseErrorDomain
   34|      0|                                                         code:FBLPromiseErrorCodeValidationFailure
   35|      0|                                                     userInfo:nil];
   36|      1|  };
   37|      1|  return [self chainOnQueue:queue chainedFulfill:chainedFulfill chainedReject:nil];
   38|      1|}
   39|       |
   40|       |@end
   41|       |
   42|       |@implementation FBLPromise (DotSyntax_ValidateAdditions)
   43|       |
   44|      1|- (FBLPromise* (^)(FBLPromiseValidateWorkBlock))validate {
   45|      1|  return ^(FBLPromiseValidateWorkBlock predicate) {
   46|      1|    return [self validate:predicate];
   47|      1|  };
   48|      1|}
   49|       |
   50|      0|- (FBLPromise* (^)(dispatch_queue_t, FBLPromiseValidateWorkBlock))validateOn {
   51|      0|  return ^(dispatch_queue_t queue, FBLPromiseValidateWorkBlock predicate) {
   52|      0|    return [self onQueue:queue validate:predicate];
   53|      0|  };
   54|      0|}
   55|       |
   56|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise+Wrap.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromise+Wrap.h"
   18|       |
   19|       |#import "FBLPromise+Async.h"
   20|       |
   21|       |@implementation FBLPromise (WrapAdditions)
   22|       |
   23|      0|+ (instancetype)wrapCompletion:(void (^)(FBLPromiseCompletion))work {
   24|      0|  return [self onQueue:self.defaultDispatchQueue wrapCompletion:work];
   25|      0|}
   26|       |
   27|       |+ (instancetype)onQueue:(dispatch_queue_t)queue
   28|      0|         wrapCompletion:(void (^)(FBLPromiseCompletion))work {
   29|      0|  NSParameterAssert(queue);
   30|      0|  NSParameterAssert(work);
   31|      0|
   32|      0|  return [self onQueue:queue
   33|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock __unused _) {
   34|      0|                   work(^{
   35|      0|                     fulfill(nil);
   36|      0|                   });
   37|      0|                 }];
   38|      0|}
   39|       |
   40|      0|+ (instancetype)wrapObjectCompletion:(void (^)(FBLPromiseObjectCompletion))work {
   41|      0|  return [self onQueue:self.defaultDispatchQueue wrapObjectCompletion:work];
   42|      0|}
   43|       |
   44|       |+ (instancetype)onQueue:(dispatch_queue_t)queue
   45|      0|    wrapObjectCompletion:(void (^)(FBLPromiseObjectCompletion))work {
   46|      0|  NSParameterAssert(queue);
   47|      0|  NSParameterAssert(work);
   48|      0|
   49|      0|  return [self onQueue:queue
   50|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock __unused _) {
   51|      0|                   work(^(id __nullable value) {
   52|      0|                     fulfill(value);
   53|      0|                   });
   54|      0|                 }];
   55|      0|}
   56|       |
   57|      0|+ (instancetype)wrapErrorCompletion:(void (^)(FBLPromiseErrorCompletion))work {
   58|      0|  return [self onQueue:self.defaultDispatchQueue wrapErrorCompletion:work];
   59|      0|}
   60|       |
   61|       |+ (instancetype)onQueue:(dispatch_queue_t)queue
   62|      0|    wrapErrorCompletion:(void (^)(FBLPromiseErrorCompletion))work {
   63|      0|  NSParameterAssert(queue);
   64|      0|  NSParameterAssert(work);
   65|      0|
   66|      0|  return [self onQueue:queue
   67|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
   68|      0|                   work(^(NSError *__nullable error) {
   69|      0|                     if (error) {
   70|      0|                       reject(error);
   71|      0|                     } else {
   72|      0|                       fulfill(nil);
   73|      0|                     }
   74|      0|                   });
   75|      0|                 }];
   76|      0|}
   77|       |
   78|      0|+ (instancetype)wrapObjectOrErrorCompletion:(void (^)(FBLPromiseObjectOrErrorCompletion))work {
   79|      0|  return [self onQueue:self.defaultDispatchQueue wrapObjectOrErrorCompletion:work];
   80|      0|}
   81|       |
   82|       |+ (instancetype)onQueue:(dispatch_queue_t)queue
   83|      0|    wrapObjectOrErrorCompletion:(void (^)(FBLPromiseObjectOrErrorCompletion))work {
   84|      0|  NSParameterAssert(queue);
   85|      0|  NSParameterAssert(work);
   86|      0|
   87|      0|  return [self onQueue:queue
   88|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
   89|      0|                   work(^(id __nullable value, NSError *__nullable error) {
   90|      0|                     if (error) {
   91|      0|                       reject(error);
   92|      0|                     } else {
   93|      0|                       fulfill(value);
   94|      0|                     }
   95|      0|                   });
   96|      0|                 }];
   97|      0|}
   98|       |
   99|      0|+ (instancetype)wrapErrorOrObjectCompletion:(void (^)(FBLPromiseErrorOrObjectCompletion))work {
  100|      0|  return [self onQueue:self.defaultDispatchQueue wrapErrorOrObjectCompletion:work];
  101|      0|}
  102|       |
  103|       |+ (instancetype)onQueue:(dispatch_queue_t)queue
  104|      0|    wrapErrorOrObjectCompletion:(void (^)(FBLPromiseErrorOrObjectCompletion))work {
  105|      0|  NSParameterAssert(queue);
  106|      0|  NSParameterAssert(work);
  107|      0|
  108|      0|  return [self onQueue:queue
  109|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  110|      0|                   work(^(NSError *__nullable error, id __nullable value) {
  111|      0|                     if (error) {
  112|      0|                       reject(error);
  113|      0|                     } else {
  114|      0|                       fulfill(value);
  115|      0|                     }
  116|      0|                   });
  117|      0|                 }];
  118|      0|}
  119|       |
  120|       |+ (FBLPromise<NSArray *> *)wrap2ObjectsOrErrorCompletion:
  121|      0|    (void (^)(FBLPromise2ObjectsOrErrorCompletion))work {
  122|      0|  return [self onQueue:self.defaultDispatchQueue wrap2ObjectsOrErrorCompletion:work];
  123|      0|}
  124|       |
  125|       |+ (FBLPromise<NSArray *> *)onQueue:(dispatch_queue_t)queue
  126|      0|     wrap2ObjectsOrErrorCompletion:(void (^)(FBLPromise2ObjectsOrErrorCompletion))work {
  127|      0|  NSParameterAssert(queue);
  128|      0|  NSParameterAssert(work);
  129|      0|
  130|      0|  return [self onQueue:queue
  131|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  132|      0|                   work(^(id __nullable value1, id __nullable value2, NSError *__nullable error) {
  133|      0|                     if (error) {
  134|      0|                       reject(error);
  135|      0|                     } else {
  136|      0|                       fulfill(@[ value1, value2 ]);
  137|      0|                     }
  138|      0|                   });
  139|      0|                 }];
  140|      0|}
  141|       |
  142|      0|+ (FBLPromise<NSNumber *> *)wrapBoolCompletion:(void (^)(FBLPromiseBoolCompletion))work {
  143|      0|  return [self onQueue:self.defaultDispatchQueue wrapBoolCompletion:work];
  144|      0|}
  145|       |
  146|       |+ (FBLPromise<NSNumber *> *)onQueue:(dispatch_queue_t)queue
  147|      0|                 wrapBoolCompletion:(void (^)(FBLPromiseBoolCompletion))work {
  148|      0|  NSParameterAssert(queue);
  149|      0|  NSParameterAssert(work);
  150|      0|
  151|      0|  return [self onQueue:queue
  152|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock __unused _) {
  153|      0|                   work(^(BOOL value) {
  154|      0|                     fulfill(@(value));
  155|      0|                   });
  156|      0|                 }];
  157|      0|}
  158|       |
  159|       |+ (FBLPromise<NSNumber *> *)wrapBoolOrErrorCompletion:
  160|      0|    (void (^)(FBLPromiseBoolOrErrorCompletion))work {
  161|      0|  return [self onQueue:self.defaultDispatchQueue wrapBoolOrErrorCompletion:work];
  162|      0|}
  163|       |
  164|       |+ (FBLPromise<NSNumber *> *)onQueue:(dispatch_queue_t)queue
  165|      0|          wrapBoolOrErrorCompletion:(void (^)(FBLPromiseBoolOrErrorCompletion))work {
  166|      0|  NSParameterAssert(queue);
  167|      0|  NSParameterAssert(work);
  168|      0|
  169|      0|  return [self onQueue:queue
  170|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  171|      0|                   work(^(BOOL value, NSError *__nullable error) {
  172|      0|                     if (error) {
  173|      0|                       reject(error);
  174|      0|                     } else {
  175|      0|                       fulfill(@(value));
  176|      0|                     }
  177|      0|                   });
  178|      0|                 }];
  179|      0|}
  180|       |
  181|      0|+ (FBLPromise<NSNumber *> *)wrapIntegerCompletion:(void (^)(FBLPromiseIntegerCompletion))work {
  182|      0|  return [self onQueue:self.defaultDispatchQueue wrapIntegerCompletion:work];
  183|      0|}
  184|       |
  185|       |+ (FBLPromise<NSNumber *> *)onQueue:(dispatch_queue_t)queue
  186|      0|              wrapIntegerCompletion:(void (^)(FBLPromiseIntegerCompletion))work {
  187|      0|  NSParameterAssert(queue);
  188|      0|  NSParameterAssert(work);
  189|      0|
  190|      0|  return [self onQueue:queue
  191|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock __unused _) {
  192|      0|                   work(^(NSInteger value) {
  193|      0|                     fulfill(@(value));
  194|      0|                   });
  195|      0|                 }];
  196|      0|}
  197|       |
  198|       |+ (FBLPromise<NSNumber *> *)wrapIntegerOrErrorCompletion:
  199|      0|    (void (^)(FBLPromiseIntegerOrErrorCompletion))work {
  200|      0|  return [self onQueue:self.defaultDispatchQueue wrapIntegerOrErrorCompletion:work];
  201|      0|}
  202|       |
  203|       |+ (FBLPromise<NSNumber *> *)onQueue:(dispatch_queue_t)queue
  204|      0|       wrapIntegerOrErrorCompletion:(void (^)(FBLPromiseIntegerOrErrorCompletion))work {
  205|      0|  NSParameterAssert(queue);
  206|      0|  NSParameterAssert(work);
  207|      0|
  208|      0|  return [self onQueue:queue
  209|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  210|      0|                   work(^(NSInteger value, NSError *__nullable error) {
  211|      0|                     if (error) {
  212|      0|                       reject(error);
  213|      0|                     } else {
  214|      0|                       fulfill(@(value));
  215|      0|                     }
  216|      0|                   });
  217|      0|                 }];
  218|      0|}
  219|       |
  220|      0|+ (FBLPromise<NSNumber *> *)wrapDoubleCompletion:(void (^)(FBLPromiseDoubleCompletion))work {
  221|      0|  return [self onQueue:self.defaultDispatchQueue wrapDoubleCompletion:work];
  222|      0|}
  223|       |
  224|       |+ (FBLPromise<NSNumber *> *)onQueue:(dispatch_queue_t)queue
  225|      0|               wrapDoubleCompletion:(void (^)(FBLPromiseDoubleCompletion))work {
  226|      0|  NSParameterAssert(queue);
  227|      0|  NSParameterAssert(work);
  228|      0|
  229|      0|  return [self onQueue:(dispatch_queue_t)queue
  230|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock __unused _) {
  231|      0|                   work(^(double value) {
  232|      0|                     fulfill(@(value));
  233|      0|                   });
  234|      0|                 }];
  235|      0|}
  236|       |
  237|       |+ (FBLPromise<NSNumber *> *)wrapDoubleOrErrorCompletion:
  238|      0|    (void (^)(FBLPromiseDoubleOrErrorCompletion))work {
  239|      0|  return [self onQueue:self.defaultDispatchQueue wrapDoubleOrErrorCompletion:work];
  240|      0|}
  241|       |
  242|       |+ (FBLPromise<NSNumber *> *)onQueue:(dispatch_queue_t)queue
  243|      0|        wrapDoubleOrErrorCompletion:(void (^)(FBLPromiseDoubleOrErrorCompletion))work {
  244|      0|  NSParameterAssert(queue);
  245|      0|  NSParameterAssert(work);
  246|      0|
  247|      0|  return [self onQueue:queue
  248|      0|                 async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  249|      0|                   work(^(double value, NSError *__nullable error) {
  250|      0|                     if (error) {
  251|      0|                       reject(error);
  252|      0|                     } else {
  253|      0|                       fulfill(@(value));
  254|      0|                     }
  255|      0|                   });
  256|      0|                 }];
  257|      0|}
  258|       |
  259|       |@end
  260|       |
  261|       |@implementation FBLPromise (DotSyntax_WrapAdditions)
  262|       |
  263|      0|+ (FBLPromise * (^)(void (^)(FBLPromiseCompletion)))wrapCompletion {
  264|      0|  return ^(void (^work)(FBLPromiseCompletion)) {
  265|      0|    return [self wrapCompletion:work];
  266|      0|  };
  267|      0|}
  268|       |
  269|      0|+ (FBLPromise * (^)(dispatch_queue_t, void (^)(FBLPromiseCompletion)))wrapCompletionOn {
  270|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseCompletion)) {
  271|      0|    return [self onQueue:queue wrapCompletion:work];
  272|      0|  };
  273|      0|}
  274|       |
  275|      0|+ (FBLPromise * (^)(void (^)(FBLPromiseObjectCompletion)))wrapObjectCompletion {
  276|      0|  return ^(void (^work)(FBLPromiseObjectCompletion)) {
  277|      0|    return [self wrapObjectCompletion:work];
  278|      0|  };
  279|      0|}
  280|       |
  281|      0|+ (FBLPromise * (^)(dispatch_queue_t, void (^)(FBLPromiseObjectCompletion)))wrapObjectCompletionOn {
  282|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseObjectCompletion)) {
  283|      0|    return [self onQueue:queue wrapObjectCompletion:work];
  284|      0|  };
  285|      0|}
  286|       |
  287|      0|+ (FBLPromise * (^)(void (^)(FBLPromiseErrorCompletion)))wrapErrorCompletion {
  288|      0|  return ^(void (^work)(FBLPromiseErrorCompletion)) {
  289|      0|    return [self wrapErrorCompletion:work];
  290|      0|  };
  291|      0|}
  292|       |
  293|      0|+ (FBLPromise * (^)(dispatch_queue_t, void (^)(FBLPromiseErrorCompletion)))wrapErrorCompletionOn {
  294|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseErrorCompletion)) {
  295|      0|    return [self onQueue:queue wrapErrorCompletion:work];
  296|      0|  };
  297|      0|}
  298|       |
  299|      0|+ (FBLPromise * (^)(void (^)(FBLPromiseObjectOrErrorCompletion)))wrapObjectOrErrorCompletion {
  300|      0|  return ^(void (^work)(FBLPromiseObjectOrErrorCompletion)) {
  301|      0|    return [self wrapObjectOrErrorCompletion:work];
  302|      0|  };
  303|      0|}
  304|       |
  305|       |+ (FBLPromise * (^)(dispatch_queue_t,
  306|      0|                    void (^)(FBLPromiseObjectOrErrorCompletion)))wrapObjectOrErrorCompletionOn {
  307|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseObjectOrErrorCompletion)) {
  308|      0|    return [self onQueue:queue wrapObjectOrErrorCompletion:work];
  309|      0|  };
  310|      0|}
  311|       |
  312|      0|+ (FBLPromise * (^)(void (^)(FBLPromiseErrorOrObjectCompletion)))wrapErrorOrObjectCompletion {
  313|      0|  return ^(void (^work)(FBLPromiseErrorOrObjectCompletion)) {
  314|      0|    return [self wrapErrorOrObjectCompletion:work];
  315|      0|  };
  316|      0|}
  317|       |
  318|       |+ (FBLPromise * (^)(dispatch_queue_t,
  319|      0|                    void (^)(FBLPromiseErrorOrObjectCompletion)))wrapErrorOrObjectCompletionOn {
  320|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseErrorOrObjectCompletion)) {
  321|      0|    return [self onQueue:queue wrapErrorOrObjectCompletion:work];
  322|      0|  };
  323|      0|}
  324|       |
  325|       |+ (FBLPromise<NSArray *> * (^)(void (^)(FBLPromise2ObjectsOrErrorCompletion)))
  326|      0|    wrap2ObjectsOrErrorCompletion {
  327|      0|  return ^(void (^work)(FBLPromise2ObjectsOrErrorCompletion)) {
  328|      0|    return [self wrap2ObjectsOrErrorCompletion:work];
  329|      0|  };
  330|      0|}
  331|       |
  332|       |+ (FBLPromise<NSArray *> * (^)(dispatch_queue_t, void (^)(FBLPromise2ObjectsOrErrorCompletion)))
  333|      0|    wrap2ObjectsOrErrorCompletionOn {
  334|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromise2ObjectsOrErrorCompletion)) {
  335|      0|    return [self onQueue:queue wrap2ObjectsOrErrorCompletion:work];
  336|      0|  };
  337|      0|}
  338|       |
  339|      0|+ (FBLPromise<NSNumber *> * (^)(void (^)(FBLPromiseBoolCompletion)))wrapBoolCompletion {
  340|      0|  return ^(void (^work)(FBLPromiseBoolCompletion)) {
  341|      0|    return [self wrapBoolCompletion:work];
  342|      0|  };
  343|      0|}
  344|       |
  345|       |+ (FBLPromise<NSNumber *> * (^)(dispatch_queue_t,
  346|      0|                                void (^)(FBLPromiseBoolCompletion)))wrapBoolCompletionOn {
  347|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseBoolCompletion)) {
  348|      0|    return [self onQueue:queue wrapBoolCompletion:work];
  349|      0|  };
  350|      0|}
  351|       |
  352|       |+ (FBLPromise<NSNumber *> * (^)(void (^)(FBLPromiseBoolOrErrorCompletion)))
  353|      0|    wrapBoolOrErrorCompletion {
  354|      0|  return ^(void (^work)(FBLPromiseBoolOrErrorCompletion)) {
  355|      0|    return [self wrapBoolOrErrorCompletion:work];
  356|      0|  };
  357|      0|}
  358|       |
  359|       |+ (FBLPromise<NSNumber *> * (^)(dispatch_queue_t, void (^)(FBLPromiseBoolOrErrorCompletion)))
  360|      0|    wrapBoolOrErrorCompletionOn {
  361|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseBoolOrErrorCompletion)) {
  362|      0|    return [self onQueue:queue wrapBoolOrErrorCompletion:work];
  363|      0|  };
  364|      0|}
  365|       |
  366|      0|+ (FBLPromise<NSNumber *> * (^)(void (^)(FBLPromiseIntegerCompletion)))wrapIntegerCompletion {
  367|      0|  return ^(void (^work)(FBLPromiseIntegerCompletion)) {
  368|      0|    return [self wrapIntegerCompletion:work];
  369|      0|  };
  370|      0|}
  371|       |
  372|       |+ (FBLPromise<NSNumber *> * (^)(dispatch_queue_t,
  373|      0|                                void (^)(FBLPromiseIntegerCompletion)))wrapIntegerCompletionOn {
  374|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseIntegerCompletion)) {
  375|      0|    return [self onQueue:queue wrapIntegerCompletion:work];
  376|      0|  };
  377|      0|}
  378|       |
  379|       |+ (FBLPromise<NSNumber *> * (^)(void (^)(FBLPromiseIntegerOrErrorCompletion)))
  380|      0|    wrapIntegerOrErrorCompletion {
  381|      0|  return ^(void (^work)(FBLPromiseIntegerOrErrorCompletion)) {
  382|      0|    return [self wrapIntegerOrErrorCompletion:work];
  383|      0|  };
  384|      0|}
  385|       |
  386|       |+ (FBLPromise<NSNumber *> * (^)(dispatch_queue_t, void (^)(FBLPromiseIntegerOrErrorCompletion)))
  387|      0|    wrapIntegerOrErrorCompletionOn {
  388|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseIntegerOrErrorCompletion)) {
  389|      0|    return [self onQueue:queue wrapIntegerOrErrorCompletion:work];
  390|      0|  };
  391|      0|}
  392|       |
  393|      0|+ (FBLPromise<NSNumber *> * (^)(void (^)(FBLPromiseDoubleCompletion)))wrapDoubleCompletion {
  394|      0|  return ^(void (^work)(FBLPromiseDoubleCompletion)) {
  395|      0|    return [self wrapDoubleCompletion:work];
  396|      0|  };
  397|      0|}
  398|       |
  399|       |+ (FBLPromise<NSNumber *> * (^)(dispatch_queue_t,
  400|      0|                                void (^)(FBLPromiseDoubleCompletion)))wrapDoubleCompletionOn {
  401|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseDoubleCompletion)) {
  402|      0|    return [self onQueue:queue wrapDoubleCompletion:work];
  403|      0|  };
  404|      0|}
  405|       |
  406|       |+ (FBLPromise<NSNumber *> * (^)(void (^)(FBLPromiseDoubleOrErrorCompletion)))
  407|      0|    wrapDoubleOrErrorCompletion {
  408|      0|  return ^(void (^work)(FBLPromiseDoubleOrErrorCompletion)) {
  409|      0|    return [self wrapDoubleOrErrorCompletion:work];
  410|      0|  };
  411|      0|}
  412|       |
  413|       |+ (FBLPromise<NSNumber *> * (^)(dispatch_queue_t, void (^)(FBLPromiseDoubleOrErrorCompletion)))
  414|      0|    wrapDoubleOrErrorCompletionOn {
  415|      0|  return ^(dispatch_queue_t queue, void (^work)(FBLPromiseDoubleOrErrorCompletion)) {
  416|      0|    return [self onQueue:queue wrapDoubleOrErrorCompletion:work];
  417|      0|  };
  418|      0|}
  419|       |
  420|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/FBLPromise.m:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FBLPromisePrivate.h"
   18|       |
   19|       |/** All states a promise can be in. */
   20|       |typedef NS_ENUM(NSInteger, FBLPromiseState) {
   21|       |  FBLPromiseStatePending = 0,
   22|       |  FBLPromiseStateFulfilled,
   23|       |  FBLPromiseStateRejected,
   24|       |};
   25|       |
   26|       |typedef void (^FBLPromiseObserver)(FBLPromiseState state, id __nullable resolution);
   27|       |
   28|       |static dispatch_queue_t gFBLPromiseDefaultDispatchQueue;
   29|       |
   30|       |@implementation FBLPromise {
   31|       |  /** Current state of the promise. */
   32|       |  FBLPromiseState _state;
   33|       |  /**
   34|       |   Set of arbitrary objects to keep strongly while the promise is pending.
   35|       |   Becomes nil after the promise has been resolved.
   36|       |   */
   37|       |  NSMutableSet *__nullable _pendingObjects;
   38|       |  /**
   39|       |   Value to fulfill the promise with.
   40|       |   Can be nil if the promise is still pending, was resolved with nil or after it has been rejected.
   41|       |   */
   42|       |  id __nullable _value;
   43|       |  /**
   44|       |   Error to reject the promise with.
   45|       |   Can be nil if the promise is still pending or after it has been fulfilled.
   46|       |   */
   47|       |  NSError *__nullable _error;
   48|       |  /** List of observers to notify when the promise gets resolved. */
   49|       |  NSMutableArray<FBLPromiseObserver> *_observers;
   50|       |}
   51|       |
   52|      1|+ (void)initialize {
   53|      1|  if (self == [FBLPromise class]) {
   54|      1|    gFBLPromiseDefaultDispatchQueue = dispatch_get_main_queue();
   55|      1|  }
   56|      1|}
   57|       |
   58|     25|+ (dispatch_queue_t)defaultDispatchQueue {
   59|     25|  @synchronized(self) {
   60|     25|    return gFBLPromiseDefaultDispatchQueue;
   61|     25|  }
   62|     25|}
   63|       |
   64|      0|+ (void)setDefaultDispatchQueue:(dispatch_queue_t)queue {
   65|      0|  NSParameterAssert(queue);
   66|      0|
   67|      0|  @synchronized(self) {
   68|      0|    gFBLPromiseDefaultDispatchQueue = queue;
   69|      0|  }
   70|      0|}
   71|       |
   72|      0|+ (instancetype)pendingPromise {
   73|      0|  return [[self alloc] initPending];
   74|      0|}
   75|       |
   76|      0|+ (instancetype)resolvedWith:(nullable id)resolution {
   77|      0|  return [[self alloc] initWithResolution:resolution];
   78|      0|}
   79|       |
   80|     14|- (void)fulfill:(nullable id)value {
   81|     14|  if ([value isKindOfClass:[NSError class]]) {
   82|      1|    [self reject:(NSError *)value];
   83|     13|  } else {
   84|     13|    @synchronized(self) {
   85|     13|      if (_state == FBLPromiseStatePending) {
   86|     13|        _state = FBLPromiseStateFulfilled;
   87|     13|        _value = value;
   88|     13|        _pendingObjects = nil;
   89|     13|        for (FBLPromiseObserver observer in _observers) {
   90|     13|          observer(_state, _value);
   91|     13|        }
   92|     13|        _observers = nil;
   93|     13|        dispatch_group_leave(FBLPromise.dispatchGroup);
   94|     13|      }
   95|     13|    }
   96|     13|  }
   97|     14|}
   98|       |
   99|      1|- (void)reject:(NSError *)error {
  100|      1|  NSAssert([error isKindOfClass:[NSError class]], @"Invalid error type.");
  101|      1|
  102|      1|  if (![error isKindOfClass:[NSError class]]) {
  103|      0|    // Give up on invalid error type in Release mode.
  104|      0|    @throw error;  // NOLINT
  105|      0|  }
  106|      1|  @synchronized(self) {
  107|      1|    if (_state == FBLPromiseStatePending) {
  108|      1|      _state = FBLPromiseStateRejected;
  109|      1|      _error = error;
  110|      1|      _pendingObjects = nil;
  111|      1|      for (FBLPromiseObserver observer in _observers) {
  112|      1|        observer(_state, _error);
  113|      1|      }
  114|      1|      _observers = nil;
  115|      1|      dispatch_group_leave(FBLPromise.dispatchGroup);
  116|      1|    }
  117|      1|  }
  118|      1|}
  119|       |
  120|       |#pragma mark - NSObject
  121|       |
  122|      0|- (NSString *)description {
  123|      0|  if (self.isFulfilled) {
  124|      0|    return [NSString stringWithFormat:@"<%@ %p> Fulfilled: %@", NSStringFromClass([self class]),
  125|      0|                                      self, self.value];
  126|      0|  }
  127|      0|  if (self.isRejected) {
  128|      0|    return [NSString stringWithFormat:@"<%@ %p> Rejected: %@", NSStringFromClass([self class]),
  129|      0|                                      self, self.error];
  130|      0|  }
  131|      0|  return [NSString stringWithFormat:@"<%@ %p> Pending", NSStringFromClass([self class]), self];
  132|      0|}
  133|       |
  134|       |#pragma mark - Private
  135|       |
  136|     29|- (instancetype)initPending {
  137|     29|  self = [super init];
  138|     29|  if (self) {
  139|     29|    dispatch_group_enter(FBLPromise.dispatchGroup);
  140|     29|  }
  141|     29|  return self;
  142|     29|}
  143|       |
  144|      0|- (instancetype)initWithResolution:(nullable id)resolution {
  145|      0|  self = [super init];
  146|      0|  if (self) {
  147|      0|    if ([resolution isKindOfClass:[NSError class]]) {
  148|      0|      _state = FBLPromiseStateRejected;
  149|      0|      _error = (NSError *)resolution;
  150|      0|    } else {
  151|      0|      _state = FBLPromiseStateFulfilled;
  152|      0|      _value = resolution;
  153|      0|    }
  154|      0|  }
  155|      0|  return self;
  156|      0|}
  157|       |
  158|     14|- (void)dealloc {
  159|     14|  if (_state == FBLPromiseStatePending) {
  160|      0|    dispatch_group_leave(FBLPromise.dispatchGroup);
  161|      0|  }
  162|     14|}
  163|       |
  164|      0|- (BOOL)isPending {
  165|      0|  @synchronized(self) {
  166|      0|    return _state == FBLPromiseStatePending;
  167|      0|  }
  168|      0|}
  169|       |
  170|      0|- (BOOL)isFulfilled {
  171|      0|  @synchronized(self) {
  172|      0|    return _state == FBLPromiseStateFulfilled;
  173|      0|  }
  174|      0|}
  175|       |
  176|      0|- (BOOL)isRejected {
  177|      0|  @synchronized(self) {
  178|      0|    return _state == FBLPromiseStateRejected;
  179|      0|  }
  180|      0|}
  181|       |
  182|      0|- (nullable id)value {
  183|      0|  @synchronized(self) {
  184|      0|    return _value;
  185|      0|  }
  186|      0|}
  187|       |
  188|      0|- (NSError *__nullable)error {
  189|      0|  @synchronized(self) {
  190|      0|    return _error;
  191|      0|  }
  192|      0|}
  193|       |
  194|      0|- (NSMutableSet *__nullable)pendingObjects {
  195|      0|  @synchronized(self) {
  196|      0|    if (_state == FBLPromiseStatePending) {
  197|      0|      if (!_pendingObjects) {
  198|      0|        _pendingObjects = [[NSMutableSet alloc] init];
  199|      0|      }
  200|      0|    }
  201|      0|    return _pendingObjects;
  202|      0|  }
  203|      0|}
  204|       |
  205|       |- (void)observeOnQueue:(dispatch_queue_t)queue
  206|       |               fulfill:(FBLPromiseOnFulfillBlock)onFulfill
  207|     28|                reject:(FBLPromiseOnRejectBlock)onReject {
  208|     28|  NSParameterAssert(queue);
  209|     28|  NSParameterAssert(onFulfill);
  210|     28|  NSParameterAssert(onReject);
  211|     28|
  212|     28|  @synchronized(self) {
  213|     28|    switch (_state) {
  214|     28|      case FBLPromiseStatePending: {
  215|     28|        if (!_observers) {
  216|     24|          _observers = [[NSMutableArray alloc] init];
  217|     24|        }
  218|     28|        [_observers addObject:^(FBLPromiseState state, id __nullable resolution) {
  219|     14|          dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{
  220|     14|            switch (state) {
  221|     14|              case FBLPromiseStatePending:
  222|      0|                break;
  223|     14|              case FBLPromiseStateFulfilled:
  224|     13|                onFulfill(resolution);
  225|     13|                break;
  226|     14|              case FBLPromiseStateRejected:
  227|      1|                onReject(resolution);
  228|      1|                break;
  229|     14|            }
  230|     14|          });
  231|     14|        }];
  232|     28|        break;
  233|     28|      }
  234|     28|      case FBLPromiseStateFulfilled: {
  235|      0|        dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{
  236|      0|          onFulfill(self->_value);
  237|      0|        });
  238|      0|        break;
  239|     28|      }
  240|     28|      case FBLPromiseStateRejected: {
  241|      0|        dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{
  242|      0|          onReject(self->_error);
  243|      0|        });
  244|      0|        break;
  245|     28|      }
  246|     28|    }
  247|     28|  }
  248|     28|}
  249|       |
  250|       |- (FBLPromise *)chainOnQueue:(dispatch_queue_t)queue
  251|       |              chainedFulfill:(FBLPromiseChainedFulfillBlock)chainedFulfill
  252|     24|               chainedReject:(FBLPromiseChainedRejectBlock)chainedReject {
  253|     24|  NSParameterAssert(queue);
  254|     24|
  255|     24|  FBLPromise *promise = [[FBLPromise alloc] initPending];
  256|     24|  __auto_type resolver = ^(id __nullable value) {
  257|     12|    if ([value isKindOfClass:[FBLPromise class]]) {
  258|      3|      [(FBLPromise *)value observeOnQueue:queue
  259|      3|          fulfill:^(id __nullable value) {
  260|      2|            [promise fulfill:value];
  261|      2|          }
  262|      3|          reject:^(NSError *error) {
  263|      0|            [promise reject:error];
  264|      0|          }];
  265|      9|    } else {
  266|      9|      [promise fulfill:value];
  267|      9|    }
  268|     12|  };
  269|     24|  [self observeOnQueue:queue
  270|     24|      fulfill:^(id __nullable value) {
  271|     11|        value = chainedFulfill ? chainedFulfill(value) : value;
  272|     11|        resolver(value);
  273|     11|      }
  274|     24|      reject:^(NSError *error) {
  275|      1|        id value = chainedReject ? chainedReject(error) : error;
  276|      1|        resolver(value);
  277|      1|      }];
  278|     24|  return promise;
  279|     24|}
  280|       |
  281|       |@end
  282|       |
  283|       |@implementation FBLPromise (DotSyntaxAdditions)
  284|       |
  285|      0|+ (instancetype (^)(void))pending {
  286|      0|  return ^(void) {
  287|      0|    return [self pendingPromise];
  288|      0|  };
  289|      0|}
  290|       |
  291|      0|+ (instancetype (^)(id __nullable))resolved {
  292|      0|  return ^(id resolution) {
  293|      0|    return [self resolvedWith:resolution];
  294|      0|  };
  295|      0|}
  296|       |
  297|       |@end

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/PromisesObjC/Sources/FBLPromises/include/FBLPromiseError.h:
    1|       |/**
    2|       | Copyright 2018 Google Inc. All rights reserved.
    3|       |
    4|       | Licensed under the Apache License, Version 2.0 (the "License");
    5|       | you may not use this file except in compliance with the License.
    6|       | You may obtain a copy of the License at:
    7|       |
    8|       | http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       | Unless required by applicable law or agreed to in writing, software
   11|       | distributed under the License is distributed on an "AS IS" BASIS,
   12|       | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | See the License for the specific language governing permissions and
   14|       | limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |FOUNDATION_EXTERN NSErrorDomain const FBLPromiseErrorDomain NS_REFINED_FOR_SWIFT;
   22|       |
   23|       |/**
   24|       | Possible error codes in `FBLPromiseErrorDomain`.
   25|       | */
   26|       |typedef NS_ENUM(NSInteger, FBLPromiseErrorCode) {
   27|       |  /** Promise failed to resolve in time. */
   28|       |  FBLPromiseErrorCodeTimedOut = 1,
   29|       |  /** Validation predicate returned false. */
   30|       |  FBLPromiseErrorCodeValidationFailure = 2,
   31|       |} NS_REFINED_FOR_SWIFT;
   32|       |
   33|      0|NS_INLINE BOOL FBLPromiseErrorIsTimedOut(NSError *error) NS_SWIFT_UNAVAILABLE("") {
   34|      0|  return error.domain == FBLPromiseErrorDomain &&
   35|      0|         error.code == FBLPromiseErrorCodeTimedOut;
   36|      0|}
  ------------------
  | Unexecuted instantiation: FIRInstallations.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRInstallationsAPIService.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRInstallationsIDController.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRInstallationsIIDStore.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRInstallationsIIDTokenStore.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRInstallationsSingleOperationPromiseCache.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRInstallationsStore.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FIRSecureStorage.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+All.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Always.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Any.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Async.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Catch.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Delay.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Do.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Race.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Recover.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Reduce.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Retry.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Testing.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Then.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Timeout.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Validate.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise+Wrap.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromise.m:FBLPromiseErrorIsTimedOut
  ------------------
  | Unexecuted instantiation: FBLPromiseError.m:FBLPromiseErrorIsTimedOut
  ------------------
   37|       |
   38|      0|NS_INLINE BOOL FBLPromiseErrorIsValidationFailure(NSError *error) NS_SWIFT_UNAVAILABLE("") {
   39|      0|  return error.domain == FBLPromiseErrorDomain &&
   40|      0|         error.code == FBLPromiseErrorCodeValidationFailure;
   41|      0|}
  ------------------
  | Unexecuted instantiation: FIRInstallations.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRInstallationsAPIService.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRInstallationsIDController.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRInstallationsIIDStore.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRInstallationsIIDTokenStore.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRInstallationsSingleOperationPromiseCache.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRInstallationsStore.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FIRSecureStorage.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+All.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Always.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Any.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Async.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Catch.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Delay.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Do.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Race.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Recover.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Reduce.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Retry.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Testing.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Then.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Timeout.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Validate.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise+Wrap.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromise.m:FBLPromiseErrorIsValidationFailure
  ------------------
  | Unexecuted instantiation: FBLPromiseError.m:FBLPromiseErrorIsValidationFailure
  ------------------
   42|       |
   43|       |NS_ASSUME_NONNULL_END

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/builder.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/builder.h"
    6|       |
    7|       |#include "db/dbformat.h"
    8|       |#include "db/filename.h"
    9|       |#include "db/table_cache.h"
   10|       |#include "db/version_edit.h"
   11|       |#include "leveldb/db.h"
   12|       |#include "leveldb/env.h"
   13|       |#include "leveldb/iterator.h"
   14|       |
   15|       |namespace leveldb {
   16|       |
   17|       |Status BuildTable(const std::string& dbname, Env* env, const Options& options,
   18|      0|                  TableCache* table_cache, Iterator* iter, FileMetaData* meta) {
   19|      0|  Status s;
   20|      0|  meta->file_size = 0;
   21|      0|  iter->SeekToFirst();
   22|      0|
   23|      0|  std::string fname = TableFileName(dbname, meta->number);
   24|      0|  if (iter->Valid()) {
   25|      0|    WritableFile* file;
   26|      0|    s = env->NewWritableFile(fname, &file);
   27|      0|    if (!s.ok()) {
   28|      0|      return s;
   29|      0|    }
   30|      0|
   31|      0|    TableBuilder* builder = new TableBuilder(options, file);
   32|      0|    meta->smallest.DecodeFrom(iter->key());
   33|      0|    for (; iter->Valid(); iter->Next()) {
   34|      0|      Slice key = iter->key();
   35|      0|      meta->largest.DecodeFrom(key);
   36|      0|      builder->Add(key, iter->value());
   37|      0|    }
   38|      0|
   39|      0|    // Finish and check for builder errors
   40|      0|    s = builder->Finish();
   41|      0|    if (s.ok()) {
   42|      0|      meta->file_size = builder->FileSize();
   43|      0|      assert(meta->file_size > 0);
   44|      0|    }
   45|      0|    delete builder;
   46|      0|
   47|      0|    // Finish and check for file errors
   48|      0|    if (s.ok()) {
   49|      0|      s = file->Sync();
   50|      0|    }
   51|      0|    if (s.ok()) {
   52|      0|      s = file->Close();
   53|      0|    }
   54|      0|    delete file;
   55|      0|    file = nullptr;
   56|      0|
   57|      0|    if (s.ok()) {
   58|      0|      // Verify that the table is usable
   59|      0|      Iterator* it = table_cache->NewIterator(ReadOptions(), meta->number,
   60|      0|                                              meta->file_size);
   61|      0|      s = it->status();
   62|      0|      delete it;
   63|      0|    }
   64|      0|  }
   65|      0|
   66|      0|  // Check for input iterator errors
   67|      0|  if (!iter->status().ok()) {
   68|      0|    s = iter->status();
   69|      0|  }
   70|      0|
   71|      0|  if (s.ok() && meta->file_size > 0) {
   72|      0|    // Keep it
   73|      0|  } else {
   74|      0|    env->DeleteFile(fname);
   75|      0|  }
   76|      0|  return s;
   77|      0|}
   78|       |
   79|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/db_impl.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/db_impl.h"
    6|       |
    7|       |#include <stdint.h>
    8|       |#include <stdio.h>
    9|       |
   10|       |#include <algorithm>
   11|       |#include <atomic>
   12|       |#include <set>
   13|       |#include <string>
   14|       |#include <vector>
   15|       |
   16|       |#include "db/builder.h"
   17|       |#include "db/db_iter.h"
   18|       |#include "db/dbformat.h"
   19|       |#include "db/filename.h"
   20|       |#include "db/log_reader.h"
   21|       |#include "db/log_writer.h"
   22|       |#include "db/memtable.h"
   23|       |#include "db/table_cache.h"
   24|       |#include "db/version_set.h"
   25|       |#include "db/write_batch_internal.h"
   26|       |#include "leveldb/db.h"
   27|       |#include "leveldb/env.h"
   28|       |#include "leveldb/status.h"
   29|       |#include "leveldb/table.h"
   30|       |#include "leveldb/table_builder.h"
   31|       |#include "port/port.h"
   32|       |#include "table/block.h"
   33|       |#include "table/merger.h"
   34|       |#include "table/two_level_iterator.h"
   35|       |#include "util/coding.h"
   36|       |#include "util/logging.h"
   37|       |#include "util/mutexlock.h"
   38|       |
   39|       |namespace leveldb {
   40|       |
   41|       |const int kNumNonTableCacheFiles = 10;
   42|       |
   43|       |// Information kept for every waiting writer
   44|       |struct DBImpl::Writer {
   45|       |  explicit Writer(port::Mutex* mu)
   46|      0|      : batch(nullptr), sync(false), done(false), cv(mu) {}
   47|       |
   48|       |  Status status;
   49|       |  WriteBatch* batch;
   50|       |  bool sync;
   51|       |  bool done;
   52|       |  port::CondVar cv;
   53|       |};
   54|       |
   55|       |struct DBImpl::CompactionState {
   56|       |  // Files produced by compaction
   57|       |  struct Output {
   58|       |    uint64_t number;
   59|       |    uint64_t file_size;
   60|       |    InternalKey smallest, largest;
   61|       |  };
   62|       |
   63|      0|  Output* current_output() { return &outputs[outputs.size() - 1]; }
   64|       |
   65|       |  explicit CompactionState(Compaction* c)
   66|       |      : compaction(c),
   67|       |        smallest_snapshot(0),
   68|       |        outfile(nullptr),
   69|       |        builder(nullptr),
   70|      0|        total_bytes(0) {}
   71|       |
   72|       |  Compaction* const compaction;
   73|       |
   74|       |  // Sequence numbers < smallest_snapshot are not significant since we
   75|       |  // will never have to service a snapshot below smallest_snapshot.
   76|       |  // Therefore if we have seen a sequence number S <= smallest_snapshot,
   77|       |  // we can drop all entries for the same key with sequence numbers < S.
   78|       |  SequenceNumber smallest_snapshot;
   79|       |
   80|       |  std::vector<Output> outputs;
   81|       |
   82|       |  // State kept for output being generated
   83|       |  WritableFile* outfile;
   84|       |  TableBuilder* builder;
   85|       |
   86|       |  uint64_t total_bytes;
   87|       |};
   88|       |
   89|       |// Fix user-supplied options to be reasonable
   90|       |template <class T, class V>
   91|      0|static void ClipToRange(T* ptr, V minvalue, V maxvalue) {
   92|      0|  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;
   93|      0|  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;
   94|      0|}
  ------------------
  | Unexecuted instantiation: db_impl.cc:_ZN7leveldbL11ClipToRangeIiiEEvPT_T0_S3_
  ------------------
  | Unexecuted instantiation: db_impl.cc:_ZN7leveldbL11ClipToRangeImiEEvPT_T0_S3_
  ------------------
   95|       |Options SanitizeOptions(const std::string& dbname,
   96|       |                        const InternalKeyComparator* icmp,
   97|       |                        const InternalFilterPolicy* ipolicy,
   98|      0|                        const Options& src) {
   99|      0|  Options result = src;
  100|      0|  result.comparator = icmp;
  101|      0|  result.filter_policy = (src.filter_policy != nullptr) ? ipolicy : nullptr;
  102|      0|  ClipToRange(&result.max_open_files, 64 + kNumNonTableCacheFiles, 50000);
  103|      0|  ClipToRange(&result.write_buffer_size, 64 << 10, 1 << 30);
  104|      0|  ClipToRange(&result.max_file_size, 1 << 20, 1 << 30);
  105|      0|  ClipToRange(&result.block_size, 1 << 10, 4 << 20);
  106|      0|  if (result.info_log == nullptr) {
  107|      0|    // Open a log file in the same directory as the db
  108|      0|    src.env->CreateDir(dbname);  // In case it does not exist
  109|      0|    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
  110|      0|    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
  111|      0|    if (!s.ok()) {
  112|      0|      // No place suitable for logging
  113|      0|      result.info_log = nullptr;
  114|      0|    }
  115|      0|  }
  116|      0|  if (result.block_cache == nullptr) {
  117|      0|    result.block_cache = NewLRUCache(8 << 20);
  118|      0|  }
  119|      0|  return result;
  120|      0|}
  121|       |
  122|      0|static int TableCacheSize(const Options& sanitized_options) {
  123|      0|  // Reserve ten files or so for other uses and give the rest to TableCache.
  124|      0|  return sanitized_options.max_open_files - kNumNonTableCacheFiles;
  125|      0|}
  126|       |
  127|       |DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)
  128|       |    : env_(raw_options.env),
  129|       |      internal_comparator_(raw_options.comparator),
  130|       |      internal_filter_policy_(raw_options.filter_policy),
  131|       |      options_(SanitizeOptions(dbname, &internal_comparator_,
  132|       |                               &internal_filter_policy_, raw_options)),
  133|       |      owns_info_log_(options_.info_log != raw_options.info_log),
  134|       |      owns_cache_(options_.block_cache != raw_options.block_cache),
  135|       |      dbname_(dbname),
  136|       |      table_cache_(new TableCache(dbname_, options_, TableCacheSize(options_))),
  137|       |      db_lock_(nullptr),
  138|       |      shutting_down_(false),
  139|       |      background_work_finished_signal_(&mutex_),
  140|       |      mem_(nullptr),
  141|       |      imm_(nullptr),
  142|       |      has_imm_(false),
  143|       |      logfile_(nullptr),
  144|       |      logfile_number_(0),
  145|       |      log_(nullptr),
  146|       |      seed_(0),
  147|       |      tmp_batch_(new WriteBatch),
  148|       |      background_compaction_scheduled_(false),
  149|       |      manual_compaction_(nullptr),
  150|       |      versions_(new VersionSet(dbname_, &options_, table_cache_,
  151|      0|                               &internal_comparator_)) {}
  152|       |
  153|      0|DBImpl::~DBImpl() {
  154|      0|  // Wait for background work to finish.
  155|      0|  mutex_.Lock();
  156|      0|  shutting_down_.store(true, std::memory_order_release);
  157|      0|  while (background_compaction_scheduled_) {
  158|      0|    background_work_finished_signal_.Wait();
  159|      0|  }
  160|      0|  mutex_.Unlock();
  161|      0|
  162|      0|  if (db_lock_ != nullptr) {
  163|      0|    env_->UnlockFile(db_lock_);
  164|      0|  }
  165|      0|
  166|      0|  delete versions_;
  167|      0|  if (mem_ != nullptr) mem_->Unref();
  168|      0|  if (imm_ != nullptr) imm_->Unref();
  169|      0|  delete tmp_batch_;
  170|      0|  delete log_;
  171|      0|  delete logfile_;
  172|      0|  delete table_cache_;
  173|      0|
  174|      0|  if (owns_info_log_) {
  175|      0|    delete options_.info_log;
  176|      0|  }
  177|      0|  if (owns_cache_) {
  178|      0|    delete options_.block_cache;
  179|      0|  }
  180|      0|}
  181|       |
  182|      0|Status DBImpl::NewDB() {
  183|      0|  VersionEdit new_db;
  184|      0|  new_db.SetComparatorName(user_comparator()->Name());
  185|      0|  new_db.SetLogNumber(0);
  186|      0|  new_db.SetNextFile(2);
  187|      0|  new_db.SetLastSequence(0);
  188|      0|
  189|      0|  const std::string manifest = DescriptorFileName(dbname_, 1);
  190|      0|  WritableFile* file;
  191|      0|  Status s = env_->NewWritableFile(manifest, &file);
  192|      0|  if (!s.ok()) {
  193|      0|    return s;
  194|      0|  }
  195|      0|  {
  196|      0|    log::Writer log(file);
  197|      0|    std::string record;
  198|      0|    new_db.EncodeTo(&record);
  199|      0|    s = log.AddRecord(record);
  200|      0|    if (s.ok()) {
  201|      0|      s = file->Close();
  202|      0|    }
  203|      0|  }
  204|      0|  delete file;
  205|      0|  if (s.ok()) {
  206|      0|    // Make "CURRENT" file that points to the new manifest file.
  207|      0|    s = SetCurrentFile(env_, dbname_, 1);
  208|      0|  } else {
  209|      0|    env_->DeleteFile(manifest);
  210|      0|  }
  211|      0|  return s;
  212|      0|}
  213|       |
  214|      0|void DBImpl::MaybeIgnoreError(Status* s) const {
  215|      0|  if (s->ok() || options_.paranoid_checks) {
  216|      0|    // No change needed
  217|      0|  } else {
  218|      0|    Log(options_.info_log, "Ignoring error %s", s->ToString().c_str());
  219|      0|    *s = Status::OK();
  220|      0|  }
  221|      0|}
  222|       |
  223|      0|void DBImpl::DeleteObsoleteFiles() {
  224|      0|  mutex_.AssertHeld();
  225|      0|
  226|      0|  if (!bg_error_.ok()) {
  227|      0|    // After a background error, we don't know whether a new version may
  228|      0|    // or may not have been committed, so we cannot safely garbage collect.
  229|      0|    return;
  230|      0|  }
  231|      0|
  232|      0|  // Make a set of all of the live files
  233|      0|  std::set<uint64_t> live = pending_outputs_;
  234|      0|  versions_->AddLiveFiles(&live);
  235|      0|
  236|      0|  std::vector<std::string> filenames;
  237|      0|  env_->GetChildren(dbname_, &filenames);  // Ignoring errors on purpose
  238|      0|  uint64_t number;
  239|      0|  FileType type;
  240|      0|  for (size_t i = 0; i < filenames.size(); i++) {
  241|      0|    if (ParseFileName(filenames[i], &number, &type)) {
  242|      0|      bool keep = true;
  243|      0|      switch (type) {
  244|      0|        case kLogFile:
  245|      0|          keep = ((number >= versions_->LogNumber()) ||
  246|      0|                  (number == versions_->PrevLogNumber()));
  247|      0|          break;
  248|      0|        case kDescriptorFile:
  249|      0|          // Keep my manifest file, and any newer incarnations'
  250|      0|          // (in case there is a race that allows other incarnations)
  251|      0|          keep = (number >= versions_->ManifestFileNumber());
  252|      0|          break;
  253|      0|        case kTableFile:
  254|      0|          keep = (live.find(number) != live.end());
  255|      0|          break;
  256|      0|        case kTempFile:
  257|      0|          // Any temp files that are currently being written to must
  258|      0|          // be recorded in pending_outputs_, which is inserted into "live"
  259|      0|          keep = (live.find(number) != live.end());
  260|      0|          break;
  261|      0|        case kCurrentFile:
  262|      0|        case kDBLockFile:
  263|      0|        case kInfoLogFile:
  264|      0|          keep = true;
  265|      0|          break;
  266|      0|      }
  267|      0|
  268|      0|      if (!keep) {
  269|      0|        if (type == kTableFile) {
  270|      0|          table_cache_->Evict(number);
  271|      0|        }
  272|      0|        Log(options_.info_log, "Delete type=%d #%lld\n", static_cast<int>(type),
  273|      0|            static_cast<unsigned long long>(number));
  274|      0|        env_->DeleteFile(dbname_ + "/" + filenames[i]);
  275|      0|      }
  276|      0|    }
  277|      0|  }
  278|      0|}
  279|       |
  280|      0|Status DBImpl::Recover(VersionEdit* edit, bool* save_manifest) {
  281|      0|  mutex_.AssertHeld();
  282|      0|
  283|      0|  // Ignore error from CreateDir since the creation of the DB is
  284|      0|  // committed only when the descriptor is created, and this directory
  285|      0|  // may already exist from a previous failed creation attempt.
  286|      0|  env_->CreateDir(dbname_);
  287|      0|  assert(db_lock_ == nullptr);
  288|      0|  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);
  289|      0|  if (!s.ok()) {
  290|      0|    return s;
  291|      0|  }
  292|      0|
  293|      0|  if (!env_->FileExists(CurrentFileName(dbname_))) {
  294|      0|    if (options_.create_if_missing) {
  295|      0|      s = NewDB();
  296|      0|      if (!s.ok()) {
  297|      0|        return s;
  298|      0|      }
  299|      0|    } else {
  300|      0|      return Status::InvalidArgument(
  301|      0|          dbname_, "does not exist (create_if_missing is false)");
  302|      0|    }
  303|      0|  } else {
  304|      0|    if (options_.error_if_exists) {
  305|      0|      return Status::InvalidArgument(dbname_,
  306|      0|                                     "exists (error_if_exists is true)");
  307|      0|    }
  308|      0|  }
  309|      0|
  310|      0|  s = versions_->Recover(save_manifest);
  311|      0|  if (!s.ok()) {
  312|      0|    return s;
  313|      0|  }
  314|      0|  SequenceNumber max_sequence(0);
  315|      0|
  316|      0|  // Recover from all newer log files than the ones named in the
  317|      0|  // descriptor (new log files may have been added by the previous
  318|      0|  // incarnation without registering them in the descriptor).
  319|      0|  //
  320|      0|  // Note that PrevLogNumber() is no longer used, but we pay
  321|      0|  // attention to it in case we are recovering a database
  322|      0|  // produced by an older version of leveldb.
  323|      0|  const uint64_t min_log = versions_->LogNumber();
  324|      0|  const uint64_t prev_log = versions_->PrevLogNumber();
  325|      0|  std::vector<std::string> filenames;
  326|      0|  s = env_->GetChildren(dbname_, &filenames);
  327|      0|  if (!s.ok()) {
  328|      0|    return s;
  329|      0|  }
  330|      0|  std::set<uint64_t> expected;
  331|      0|  versions_->AddLiveFiles(&expected);
  332|      0|  uint64_t number;
  333|      0|  FileType type;
  334|      0|  std::vector<uint64_t> logs;
  335|      0|  for (size_t i = 0; i < filenames.size(); i++) {
  336|      0|    if (ParseFileName(filenames[i], &number, &type)) {
  337|      0|      expected.erase(number);
  338|      0|      if (type == kLogFile && ((number >= min_log) || (number == prev_log)))
  339|      0|        logs.push_back(number);
  340|      0|    }
  341|      0|  }
  342|      0|  if (!expected.empty()) {
  343|      0|    char buf[50];
  344|      0|    snprintf(buf, sizeof(buf), "%d missing files; e.g.",
  345|      0|             static_cast<int>(expected.size()));
  346|      0|    return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));
  347|      0|  }
  348|      0|
  349|      0|  // Recover in the order in which the logs were generated
  350|      0|  std::sort(logs.begin(), logs.end());
  351|      0|  for (size_t i = 0; i < logs.size(); i++) {
  352|      0|    s = RecoverLogFile(logs[i], (i == logs.size() - 1), save_manifest, edit,
  353|      0|                       &max_sequence);
  354|      0|    if (!s.ok()) {
  355|      0|      return s;
  356|      0|    }
  357|      0|
  358|      0|    // The previous incarnation may not have written any MANIFEST
  359|      0|    // records after allocating this log number.  So we manually
  360|      0|    // update the file number allocation counter in VersionSet.
  361|      0|    versions_->MarkFileNumberUsed(logs[i]);
  362|      0|  }
  363|      0|
  364|      0|  if (versions_->LastSequence() < max_sequence) {
  365|      0|    versions_->SetLastSequence(max_sequence);
  366|      0|  }
  367|      0|
  368|      0|  return Status::OK();
  369|      0|}
  370|       |
  371|       |Status DBImpl::RecoverLogFile(uint64_t log_number, bool last_log,
  372|       |                              bool* save_manifest, VersionEdit* edit,
  373|      0|                              SequenceNumber* max_sequence) {
  374|      0|  struct LogReporter : public log::Reader::Reporter {
  375|      0|    Env* env;
  376|      0|    Logger* info_log;
  377|      0|    const char* fname;
  378|      0|    Status* status;  // null if options_.paranoid_checks==false
  379|      0|    virtual void Corruption(size_t bytes, const Status& s) {
  380|      0|      Log(info_log, "%s%s: dropping %d bytes; %s",
  381|      0|          (this->status == nullptr ? "(ignoring error) " : ""), fname,
  382|      0|          static_cast<int>(bytes), s.ToString().c_str());
  383|      0|      if (this->status != nullptr && this->status->ok()) *this->status = s;
  384|      0|    }
  385|      0|  };
  386|      0|
  387|      0|  mutex_.AssertHeld();
  388|      0|
  389|      0|  // Open the log file
  390|      0|  std::string fname = LogFileName(dbname_, log_number);
  391|      0|  SequentialFile* file;
  392|      0|  Status status = env_->NewSequentialFile(fname, &file);
  393|      0|  if (!status.ok()) {
  394|      0|    MaybeIgnoreError(&status);
  395|      0|    return status;
  396|      0|  }
  397|      0|
  398|      0|  // Create the log reader.
  399|      0|  LogReporter reporter;
  400|      0|  reporter.env = env_;
  401|      0|  reporter.info_log = options_.info_log;
  402|      0|  reporter.fname = fname.c_str();
  403|      0|  reporter.status = (options_.paranoid_checks ? &status : nullptr);
  404|      0|  // We intentionally make log::Reader do checksumming even if
  405|      0|  // paranoid_checks==false so that corruptions cause entire commits
  406|      0|  // to be skipped instead of propagating bad information (like overly
  407|      0|  // large sequence numbers).
  408|      0|  log::Reader reader(file, &reporter, true /*checksum*/, 0 /*initial_offset*/);
  409|      0|  Log(options_.info_log, "Recovering log #%llu",
  410|      0|      (unsigned long long)log_number);
  411|      0|
  412|      0|  // Read all the records and add to a memtable
  413|      0|  std::string scratch;
  414|      0|  Slice record;
  415|      0|  WriteBatch batch;
  416|      0|  int compactions = 0;
  417|      0|  MemTable* mem = nullptr;
  418|      0|  while (reader.ReadRecord(&record, &scratch) && status.ok()) {
  419|      0|    if (record.size() < 12) {
  420|      0|      reporter.Corruption(record.size(),
  421|      0|                          Status::Corruption("log record too small"));
  422|      0|      continue;
  423|      0|    }
  424|      0|    WriteBatchInternal::SetContents(&batch, record);
  425|      0|
  426|      0|    if (mem == nullptr) {
  427|      0|      mem = new MemTable(internal_comparator_);
  428|      0|      mem->Ref();
  429|      0|    }
  430|      0|    status = WriteBatchInternal::InsertInto(&batch, mem);
  431|      0|    MaybeIgnoreError(&status);
  432|      0|    if (!status.ok()) {
  433|      0|      break;
  434|      0|    }
  435|      0|    const SequenceNumber last_seq = WriteBatchInternal::Sequence(&batch) +
  436|      0|                                    WriteBatchInternal::Count(&batch) - 1;
  437|      0|    if (last_seq > *max_sequence) {
  438|      0|      *max_sequence = last_seq;
  439|      0|    }
  440|      0|
  441|      0|    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {
  442|      0|      compactions++;
  443|      0|      *save_manifest = true;
  444|      0|      status = WriteLevel0Table(mem, edit, nullptr);
  445|      0|      mem->Unref();
  446|      0|      mem = nullptr;
  447|      0|      if (!status.ok()) {
  448|      0|        // Reflect errors immediately so that conditions like full
  449|      0|        // file-systems cause the DB::Open() to fail.
  450|      0|        break;
  451|      0|      }
  452|      0|    }
  453|      0|  }
  454|      0|
  455|      0|  delete file;
  456|      0|
  457|      0|  // See if we should keep reusing the last log file.
  458|      0|  if (status.ok() && options_.reuse_logs && last_log && compactions == 0) {
  459|      0|    assert(logfile_ == nullptr);
  460|      0|    assert(log_ == nullptr);
  461|      0|    assert(mem_ == nullptr);
  462|      0|    uint64_t lfile_size;
  463|      0|    if (env_->GetFileSize(fname, &lfile_size).ok() &&
  464|      0|        env_->NewAppendableFile(fname, &logfile_).ok()) {
  465|      0|      Log(options_.info_log, "Reusing old log %s \n", fname.c_str());
  466|      0|      log_ = new log::Writer(logfile_, lfile_size);
  467|      0|      logfile_number_ = log_number;
  468|      0|      if (mem != nullptr) {
  469|      0|        mem_ = mem;
  470|      0|        mem = nullptr;
  471|      0|      } else {
  472|      0|        // mem can be nullptr if lognum exists but was empty.
  473|      0|        mem_ = new MemTable(internal_comparator_);
  474|      0|        mem_->Ref();
  475|      0|      }
  476|      0|    }
  477|      0|  }
  478|      0|
  479|      0|  if (mem != nullptr) {
  480|      0|    // mem did not get reused; compact it.
  481|      0|    if (status.ok()) {
  482|      0|      *save_manifest = true;
  483|      0|      status = WriteLevel0Table(mem, edit, nullptr);
  484|      0|    }
  485|      0|    mem->Unref();
  486|      0|  }
  487|      0|
  488|      0|  return status;
  489|      0|}
  490|       |
  491|       |Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
  492|      0|                                Version* base) {
  493|      0|  mutex_.AssertHeld();
  494|      0|  const uint64_t start_micros = env_->NowMicros();
  495|      0|  FileMetaData meta;
  496|      0|  meta.number = versions_->NewFileNumber();
  497|      0|  pending_outputs_.insert(meta.number);
  498|      0|  Iterator* iter = mem->NewIterator();
  499|      0|  Log(options_.info_log, "Level-0 table #%llu: started",
  500|      0|      (unsigned long long)meta.number);
  501|      0|
  502|      0|  Status s;
  503|      0|  {
  504|      0|    mutex_.Unlock();
  505|      0|    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
  506|      0|    mutex_.Lock();
  507|      0|  }
  508|      0|
  509|      0|  Log(options_.info_log, "Level-0 table #%llu: %lld bytes %s",
  510|      0|      (unsigned long long)meta.number, (unsigned long long)meta.file_size,
  511|      0|      s.ToString().c_str());
  512|      0|  delete iter;
  513|      0|  pending_outputs_.erase(meta.number);
  514|      0|
  515|      0|  // Note that if file_size is zero, the file has been deleted and
  516|      0|  // should not be added to the manifest.
  517|      0|  int level = 0;
  518|      0|  if (s.ok() && meta.file_size > 0) {
  519|      0|    const Slice min_user_key = meta.smallest.user_key();
  520|      0|    const Slice max_user_key = meta.largest.user_key();
  521|      0|    if (base != nullptr) {
  522|      0|      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);
  523|      0|    }
  524|      0|    edit->AddFile(level, meta.number, meta.file_size, meta.smallest,
  525|      0|                  meta.largest);
  526|      0|  }
  527|      0|
  528|      0|  CompactionStats stats;
  529|      0|  stats.micros = env_->NowMicros() - start_micros;
  530|      0|  stats.bytes_written = meta.file_size;
  531|      0|  stats_[level].Add(stats);
  532|      0|  return s;
  533|      0|}
  534|       |
  535|      0|void DBImpl::CompactMemTable() {
  536|      0|  mutex_.AssertHeld();
  537|      0|  assert(imm_ != nullptr);
  538|      0|
  539|      0|  // Save the contents of the memtable as a new Table
  540|      0|  VersionEdit edit;
  541|      0|  Version* base = versions_->current();
  542|      0|  base->Ref();
  543|      0|  Status s = WriteLevel0Table(imm_, &edit, base);
  544|      0|  base->Unref();
  545|      0|
  546|      0|  if (s.ok() && shutting_down_.load(std::memory_order_acquire)) {
  547|      0|    s = Status::IOError("Deleting DB during memtable compaction");
  548|      0|  }
  549|      0|
  550|      0|  // Replace immutable memtable with the generated Table
  551|      0|  if (s.ok()) {
  552|      0|    edit.SetPrevLogNumber(0);
  553|      0|    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
  554|      0|    s = versions_->LogAndApply(&edit, &mutex_);
  555|      0|  }
  556|      0|
  557|      0|  if (s.ok()) {
  558|      0|    // Commit to the new state
  559|      0|    imm_->Unref();
  560|      0|    imm_ = nullptr;
  561|      0|    has_imm_.store(false, std::memory_order_release);
  562|      0|    DeleteObsoleteFiles();
  563|      0|  } else {
  564|      0|    RecordBackgroundError(s);
  565|      0|  }
  566|      0|}
  567|       |
  568|      0|void DBImpl::CompactRange(const Slice* begin, const Slice* end) {
  569|      0|  int max_level_with_files = 1;
  570|      0|  {
  571|      0|    MutexLock l(&mutex_);
  572|      0|    Version* base = versions_->current();
  573|      0|    for (int level = 1; level < config::kNumLevels; level++) {
  574|      0|      if (base->OverlapInLevel(level, begin, end)) {
  575|      0|        max_level_with_files = level;
  576|      0|      }
  577|      0|    }
  578|      0|  }
  579|      0|  TEST_CompactMemTable();  // TODO(sanjay): Skip if memtable does not overlap
  580|      0|  for (int level = 0; level < max_level_with_files; level++) {
  581|      0|    TEST_CompactRange(level, begin, end);
  582|      0|  }
  583|      0|}
  584|       |
  585|       |void DBImpl::TEST_CompactRange(int level, const Slice* begin,
  586|      0|                               const Slice* end) {
  587|      0|  assert(level >= 0);
  588|      0|  assert(level + 1 < config::kNumLevels);
  589|      0|
  590|      0|  InternalKey begin_storage, end_storage;
  591|      0|
  592|      0|  ManualCompaction manual;
  593|      0|  manual.level = level;
  594|      0|  manual.done = false;
  595|      0|  if (begin == nullptr) {
  596|      0|    manual.begin = nullptr;
  597|      0|  } else {
  598|      0|    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
  599|      0|    manual.begin = &begin_storage;
  600|      0|  }
  601|      0|  if (end == nullptr) {
  602|      0|    manual.end = nullptr;
  603|      0|  } else {
  604|      0|    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
  605|      0|    manual.end = &end_storage;
  606|      0|  }
  607|      0|
  608|      0|  MutexLock l(&mutex_);
  609|      0|  while (!manual.done && !shutting_down_.load(std::memory_order_acquire) &&
  610|      0|         bg_error_.ok()) {
  611|      0|    if (manual_compaction_ == nullptr) {  // Idle
  612|      0|      manual_compaction_ = &manual;
  613|      0|      MaybeScheduleCompaction();
  614|      0|    } else {  // Running either my compaction or another compaction.
  615|      0|      background_work_finished_signal_.Wait();
  616|      0|    }
  617|      0|  }
  618|      0|  if (manual_compaction_ == &manual) {
  619|      0|    // Cancel my manual compaction since we aborted early for some reason.
  620|      0|    manual_compaction_ = nullptr;
  621|      0|  }
  622|      0|}
  623|       |
  624|      0|Status DBImpl::TEST_CompactMemTable() {
  625|      0|  // nullptr batch means just wait for earlier writes to be done
  626|      0|  Status s = Write(WriteOptions(), nullptr);
  627|      0|  if (s.ok()) {
  628|      0|    // Wait until the compaction completes
  629|      0|    MutexLock l(&mutex_);
  630|      0|    while (imm_ != nullptr && bg_error_.ok()) {
  631|      0|      background_work_finished_signal_.Wait();
  632|      0|    }
  633|      0|    if (imm_ != nullptr) {
  634|      0|      s = bg_error_;
  635|      0|    }
  636|      0|  }
  637|      0|  return s;
  638|      0|}
  639|       |
  640|      0|void DBImpl::RecordBackgroundError(const Status& s) {
  641|      0|  mutex_.AssertHeld();
  642|      0|  if (bg_error_.ok()) {
  643|      0|    bg_error_ = s;
  644|      0|    background_work_finished_signal_.SignalAll();
  645|      0|  }
  646|      0|}
  647|       |
  648|      0|void DBImpl::MaybeScheduleCompaction() {
  649|      0|  mutex_.AssertHeld();
  650|      0|  if (background_compaction_scheduled_) {
  651|      0|    // Already scheduled
  652|      0|  } else if (shutting_down_.load(std::memory_order_acquire)) {
  653|      0|    // DB is being deleted; no more background compactions
  654|      0|  } else if (!bg_error_.ok()) {
  655|      0|    // Already got an error; no more changes
  656|      0|  } else if (imm_ == nullptr && manual_compaction_ == nullptr &&
  657|      0|             !versions_->NeedsCompaction()) {
  658|      0|    // No work to be done
  659|      0|  } else {
  660|      0|    background_compaction_scheduled_ = true;
  661|      0|    env_->Schedule(&DBImpl::BGWork, this);
  662|      0|  }
  663|      0|}
  664|       |
  665|      0|void DBImpl::BGWork(void* db) {
  666|      0|  reinterpret_cast<DBImpl*>(db)->BackgroundCall();
  667|      0|}
  668|       |
  669|      0|void DBImpl::BackgroundCall() {
  670|      0|  MutexLock l(&mutex_);
  671|      0|  assert(background_compaction_scheduled_);
  672|      0|  if (shutting_down_.load(std::memory_order_acquire)) {
  673|      0|    // No more background work when shutting down.
  674|      0|  } else if (!bg_error_.ok()) {
  675|      0|    // No more background work after a background error.
  676|      0|  } else {
  677|      0|    BackgroundCompaction();
  678|      0|  }
  679|      0|
  680|      0|  background_compaction_scheduled_ = false;
  681|      0|
  682|      0|  // Previous compaction may have produced too many files in a level,
  683|      0|  // so reschedule another compaction if needed.
  684|      0|  MaybeScheduleCompaction();
  685|      0|  background_work_finished_signal_.SignalAll();
  686|      0|}
  687|       |
  688|      0|void DBImpl::BackgroundCompaction() {
  689|      0|  mutex_.AssertHeld();
  690|      0|
  691|      0|  if (imm_ != nullptr) {
  692|      0|    CompactMemTable();
  693|      0|    return;
  694|      0|  }
  695|      0|
  696|      0|  Compaction* c;
  697|      0|  bool is_manual = (manual_compaction_ != nullptr);
  698|      0|  InternalKey manual_end;
  699|      0|  if (is_manual) {
  700|      0|    ManualCompaction* m = manual_compaction_;
  701|      0|    c = versions_->CompactRange(m->level, m->begin, m->end);
  702|      0|    m->done = (c == nullptr);
  703|      0|    if (c != nullptr) {
  704|      0|      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
  705|      0|    }
  706|      0|    Log(options_.info_log,
  707|      0|        "Manual compaction at level-%d from %s .. %s; will stop at %s\n",
  708|      0|        m->level, (m->begin ? m->begin->DebugString().c_str() : "(begin)"),
  709|      0|        (m->end ? m->end->DebugString().c_str() : "(end)"),
  710|      0|        (m->done ? "(end)" : manual_end.DebugString().c_str()));
  711|      0|  } else {
  712|      0|    c = versions_->PickCompaction();
  713|      0|  }
  714|      0|
  715|      0|  Status status;
  716|      0|  if (c == nullptr) {
  717|      0|    // Nothing to do
  718|      0|  } else if (!is_manual && c->IsTrivialMove()) {
  719|      0|    // Move file to next level
  720|      0|    assert(c->num_input_files(0) == 1);
  721|      0|    FileMetaData* f = c->input(0, 0);
  722|      0|    c->edit()->DeleteFile(c->level(), f->number);
  723|      0|    c->edit()->AddFile(c->level() + 1, f->number, f->file_size, f->smallest,
  724|      0|                       f->largest);
  725|      0|    status = versions_->LogAndApply(c->edit(), &mutex_);
  726|      0|    if (!status.ok()) {
  727|      0|      RecordBackgroundError(status);
  728|      0|    }
  729|      0|    VersionSet::LevelSummaryStorage tmp;
  730|      0|    Log(options_.info_log, "Moved #%lld to level-%d %lld bytes %s: %s\n",
  731|      0|        static_cast<unsigned long long>(f->number), c->level() + 1,
  732|      0|        static_cast<unsigned long long>(f->file_size),
  733|      0|        status.ToString().c_str(), versions_->LevelSummary(&tmp));
  734|      0|  } else {
  735|      0|    CompactionState* compact = new CompactionState(c);
  736|      0|    status = DoCompactionWork(compact);
  737|      0|    if (!status.ok()) {
  738|      0|      RecordBackgroundError(status);
  739|      0|    }
  740|      0|    CleanupCompaction(compact);
  741|      0|    c->ReleaseInputs();
  742|      0|    DeleteObsoleteFiles();
  743|      0|  }
  744|      0|  delete c;
  745|      0|
  746|      0|  if (status.ok()) {
  747|      0|    // Done
  748|      0|  } else if (shutting_down_.load(std::memory_order_acquire)) {
  749|      0|    // Ignore compaction errors found during shutting down
  750|      0|  } else {
  751|      0|    Log(options_.info_log, "Compaction error: %s", status.ToString().c_str());
  752|      0|  }
  753|      0|
  754|      0|  if (is_manual) {
  755|      0|    ManualCompaction* m = manual_compaction_;
  756|      0|    if (!status.ok()) {
  757|      0|      m->done = true;
  758|      0|    }
  759|      0|    if (!m->done) {
  760|      0|      // We only compacted part of the requested range.  Update *m
  761|      0|      // to the range that is left to be compacted.
  762|      0|      m->tmp_storage = manual_end;
  763|      0|      m->begin = &m->tmp_storage;
  764|      0|    }
  765|      0|    manual_compaction_ = nullptr;
  766|      0|  }
  767|      0|}
  768|       |
  769|      0|void DBImpl::CleanupCompaction(CompactionState* compact) {
  770|      0|  mutex_.AssertHeld();
  771|      0|  if (compact->builder != nullptr) {
  772|      0|    // May happen if we get a shutdown call in the middle of compaction
  773|      0|    compact->builder->Abandon();
  774|      0|    delete compact->builder;
  775|      0|  } else {
  776|      0|    assert(compact->outfile == nullptr);
  777|      0|  }
  778|      0|  delete compact->outfile;
  779|      0|  for (size_t i = 0; i < compact->outputs.size(); i++) {
  780|      0|    const CompactionState::Output& out = compact->outputs[i];
  781|      0|    pending_outputs_.erase(out.number);
  782|      0|  }
  783|      0|  delete compact;
  784|      0|}
  785|       |
  786|      0|Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {
  787|      0|  assert(compact != nullptr);
  788|      0|  assert(compact->builder == nullptr);
  789|      0|  uint64_t file_number;
  790|      0|  {
  791|      0|    mutex_.Lock();
  792|      0|    file_number = versions_->NewFileNumber();
  793|      0|    pending_outputs_.insert(file_number);
  794|      0|    CompactionState::Output out;
  795|      0|    out.number = file_number;
  796|      0|    out.smallest.Clear();
  797|      0|    out.largest.Clear();
  798|      0|    compact->outputs.push_back(out);
  799|      0|    mutex_.Unlock();
  800|      0|  }
  801|      0|
  802|      0|  // Make the output file
  803|      0|  std::string fname = TableFileName(dbname_, file_number);
  804|      0|  Status s = env_->NewWritableFile(fname, &compact->outfile);
  805|      0|  if (s.ok()) {
  806|      0|    compact->builder = new TableBuilder(options_, compact->outfile);
  807|      0|  }
  808|      0|  return s;
  809|      0|}
  810|       |
  811|       |Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
  812|      0|                                          Iterator* input) {
  813|      0|  assert(compact != nullptr);
  814|      0|  assert(compact->outfile != nullptr);
  815|      0|  assert(compact->builder != nullptr);
  816|      0|
  817|      0|  const uint64_t output_number = compact->current_output()->number;
  818|      0|  assert(output_number != 0);
  819|      0|
  820|      0|  // Check for iterator errors
  821|      0|  Status s = input->status();
  822|      0|  const uint64_t current_entries = compact->builder->NumEntries();
  823|      0|  if (s.ok()) {
  824|      0|    s = compact->builder->Finish();
  825|      0|  } else {
  826|      0|    compact->builder->Abandon();
  827|      0|  }
  828|      0|  const uint64_t current_bytes = compact->builder->FileSize();
  829|      0|  compact->current_output()->file_size = current_bytes;
  830|      0|  compact->total_bytes += current_bytes;
  831|      0|  delete compact->builder;
  832|      0|  compact->builder = nullptr;
  833|      0|
  834|      0|  // Finish and check for file errors
  835|      0|  if (s.ok()) {
  836|      0|    s = compact->outfile->Sync();
  837|      0|  }
  838|      0|  if (s.ok()) {
  839|      0|    s = compact->outfile->Close();
  840|      0|  }
  841|      0|  delete compact->outfile;
  842|      0|  compact->outfile = nullptr;
  843|      0|
  844|      0|  if (s.ok() && current_entries > 0) {
  845|      0|    // Verify that the table is usable
  846|      0|    Iterator* iter =
  847|      0|        table_cache_->NewIterator(ReadOptions(), output_number, current_bytes);
  848|      0|    s = iter->status();
  849|      0|    delete iter;
  850|      0|    if (s.ok()) {
  851|      0|      Log(options_.info_log, "Generated table #%llu@%d: %lld keys, %lld bytes",
  852|      0|          (unsigned long long)output_number, compact->compaction->level(),
  853|      0|          (unsigned long long)current_entries,
  854|      0|          (unsigned long long)current_bytes);
  855|      0|    }
  856|      0|  }
  857|      0|  return s;
  858|      0|}
  859|       |
  860|      0|Status DBImpl::InstallCompactionResults(CompactionState* compact) {
  861|      0|  mutex_.AssertHeld();
  862|      0|  Log(options_.info_log, "Compacted %d@%d + %d@%d files => %lld bytes",
  863|      0|      compact->compaction->num_input_files(0), compact->compaction->level(),
  864|      0|      compact->compaction->num_input_files(1), compact->compaction->level() + 1,
  865|      0|      static_cast<long long>(compact->total_bytes));
  866|      0|
  867|      0|  // Add compaction outputs
  868|      0|  compact->compaction->AddInputDeletions(compact->compaction->edit());
  869|      0|  const int level = compact->compaction->level();
  870|      0|  for (size_t i = 0; i < compact->outputs.size(); i++) {
  871|      0|    const CompactionState::Output& out = compact->outputs[i];
  872|      0|    compact->compaction->edit()->AddFile(level + 1, out.number, out.file_size,
  873|      0|                                         out.smallest, out.largest);
  874|      0|  }
  875|      0|  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);
  876|      0|}
  877|       |
  878|      0|Status DBImpl::DoCompactionWork(CompactionState* compact) {
  879|      0|  const uint64_t start_micros = env_->NowMicros();
  880|      0|  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions
  881|      0|
  882|      0|  Log(options_.info_log, "Compacting %d@%d + %d@%d files",
  883|      0|      compact->compaction->num_input_files(0), compact->compaction->level(),
  884|      0|      compact->compaction->num_input_files(1),
  885|      0|      compact->compaction->level() + 1);
  886|      0|
  887|      0|  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);
  888|      0|  assert(compact->builder == nullptr);
  889|      0|  assert(compact->outfile == nullptr);
  890|      0|  if (snapshots_.empty()) {
  891|      0|    compact->smallest_snapshot = versions_->LastSequence();
  892|      0|  } else {
  893|      0|    compact->smallest_snapshot = snapshots_.oldest()->sequence_number();
  894|      0|  }
  895|      0|
  896|      0|  // Release mutex while we're actually doing the compaction work
  897|      0|  mutex_.Unlock();
  898|      0|
  899|      0|  Iterator* input = versions_->MakeInputIterator(compact->compaction);
  900|      0|  input->SeekToFirst();
  901|      0|  Status status;
  902|      0|  ParsedInternalKey ikey;
  903|      0|  std::string current_user_key;
  904|      0|  bool has_current_user_key = false;
  905|      0|  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;
  906|      0|  for (; input->Valid() && !shutting_down_.load(std::memory_order_acquire);) {
  907|      0|    // Prioritize immutable compaction work
  908|      0|    if (has_imm_.load(std::memory_order_relaxed)) {
  909|      0|      const uint64_t imm_start = env_->NowMicros();
  910|      0|      mutex_.Lock();
  911|      0|      if (imm_ != nullptr) {
  912|      0|        CompactMemTable();
  913|      0|        // Wake up MakeRoomForWrite() if necessary.
  914|      0|        background_work_finished_signal_.SignalAll();
  915|      0|      }
  916|      0|      mutex_.Unlock();
  917|      0|      imm_micros += (env_->NowMicros() - imm_start);
  918|      0|    }
  919|      0|
  920|      0|    Slice key = input->key();
  921|      0|    if (compact->compaction->ShouldStopBefore(key) &&
  922|      0|        compact->builder != nullptr) {
  923|      0|      status = FinishCompactionOutputFile(compact, input);
  924|      0|      if (!status.ok()) {
  925|      0|        break;
  926|      0|      }
  927|      0|    }
  928|      0|
  929|      0|    // Handle key/value, add to state, etc.
  930|      0|    bool drop = false;
  931|      0|    if (!ParseInternalKey(key, &ikey)) {
  932|      0|      // Do not hide error keys
  933|      0|      current_user_key.clear();
  934|      0|      has_current_user_key = false;
  935|      0|      last_sequence_for_key = kMaxSequenceNumber;
  936|      0|    } else {
  937|      0|      if (!has_current_user_key ||
  938|      0|          user_comparator()->Compare(ikey.user_key, Slice(current_user_key)) !=
  939|      0|              0) {
  940|      0|        // First occurrence of this user key
  941|      0|        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
  942|      0|        has_current_user_key = true;
  943|      0|        last_sequence_for_key = kMaxSequenceNumber;
  944|      0|      }
  945|      0|
  946|      0|      if (last_sequence_for_key <= compact->smallest_snapshot) {
  947|      0|        // Hidden by an newer entry for same user key
  948|      0|        drop = true;  // (A)
  949|      0|      } else if (ikey.type == kTypeDeletion &&
  950|      0|                 ikey.sequence <= compact->smallest_snapshot &&
  951|      0|                 compact->compaction->IsBaseLevelForKey(ikey.user_key)) {
  952|      0|        // For this user key:
  953|      0|        // (1) there is no data in higher levels
  954|      0|        // (2) data in lower levels will have larger sequence numbers
  955|      0|        // (3) data in layers that are being compacted here and have
  956|      0|        //     smaller sequence numbers will be dropped in the next
  957|      0|        //     few iterations of this loop (by rule (A) above).
  958|      0|        // Therefore this deletion marker is obsolete and can be dropped.
  959|      0|        drop = true;
  960|      0|      }
  961|      0|
  962|      0|      last_sequence_for_key = ikey.sequence;
  963|      0|    }
  964|       |#if 0
  965|       |    Log(options_.info_log,
  966|       |        "  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, "
  967|       |        "%d smallest_snapshot: %d",
  968|       |        ikey.user_key.ToString().c_str(),
  969|       |        (int)ikey.sequence, ikey.type, kTypeValue, drop,
  970|       |        compact->compaction->IsBaseLevelForKey(ikey.user_key),
  971|       |        (int)last_sequence_for_key, (int)compact->smallest_snapshot);
  972|       |#endif
  973|       |
  974|      0|    if (!drop) {
  975|      0|      // Open output file if necessary
  976|      0|      if (compact->builder == nullptr) {
  977|      0|        status = OpenCompactionOutputFile(compact);
  978|      0|        if (!status.ok()) {
  979|      0|          break;
  980|      0|        }
  981|      0|      }
  982|      0|      if (compact->builder->NumEntries() == 0) {
  983|      0|        compact->current_output()->smallest.DecodeFrom(key);
  984|      0|      }
  985|      0|      compact->current_output()->largest.DecodeFrom(key);
  986|      0|      compact->builder->Add(key, input->value());
  987|      0|
  988|      0|      // Close output file if it is big enough
  989|      0|      if (compact->builder->FileSize() >=
  990|      0|          compact->compaction->MaxOutputFileSize()) {
  991|      0|        status = FinishCompactionOutputFile(compact, input);
  992|      0|        if (!status.ok()) {
  993|      0|          break;
  994|      0|        }
  995|      0|      }
  996|      0|    }
  997|      0|
  998|      0|    input->Next();
  999|      0|  }
 1000|      0|
 1001|      0|  if (status.ok() && shutting_down_.load(std::memory_order_acquire)) {
 1002|      0|    status = Status::IOError("Deleting DB during compaction");
 1003|      0|  }
 1004|      0|  if (status.ok() && compact->builder != nullptr) {
 1005|      0|    status = FinishCompactionOutputFile(compact, input);
 1006|      0|  }
 1007|      0|  if (status.ok()) {
 1008|      0|    status = input->status();
 1009|      0|  }
 1010|      0|  delete input;
 1011|      0|  input = nullptr;
 1012|      0|
 1013|      0|  CompactionStats stats;
 1014|      0|  stats.micros = env_->NowMicros() - start_micros - imm_micros;
 1015|      0|  for (int which = 0; which < 2; which++) {
 1016|      0|    for (int i = 0; i < compact->compaction->num_input_files(which); i++) {
 1017|      0|      stats.bytes_read += compact->compaction->input(which, i)->file_size;
 1018|      0|    }
 1019|      0|  }
 1020|      0|  for (size_t i = 0; i < compact->outputs.size(); i++) {
 1021|      0|    stats.bytes_written += compact->outputs[i].file_size;
 1022|      0|  }
 1023|      0|
 1024|      0|  mutex_.Lock();
 1025|      0|  stats_[compact->compaction->level() + 1].Add(stats);
 1026|      0|
 1027|      0|  if (status.ok()) {
 1028|      0|    status = InstallCompactionResults(compact);
 1029|      0|  }
 1030|      0|  if (!status.ok()) {
 1031|      0|    RecordBackgroundError(status);
 1032|      0|  }
 1033|      0|  VersionSet::LevelSummaryStorage tmp;
 1034|      0|  Log(options_.info_log, "compacted to: %s", versions_->LevelSummary(&tmp));
 1035|      0|  return status;
 1036|      0|}
 1037|       |
 1038|       |namespace {
 1039|       |
 1040|       |struct IterState {
 1041|       |  port::Mutex* const mu;
 1042|       |  Version* const version GUARDED_BY(mu);
 1043|       |  MemTable* const mem GUARDED_BY(mu);
 1044|       |  MemTable* const imm GUARDED_BY(mu);
 1045|       |
 1046|       |  IterState(port::Mutex* mutex, MemTable* mem, MemTable* imm, Version* version)
 1047|      0|      : mu(mutex), version(version), mem(mem), imm(imm) {}
 1048|       |};
 1049|       |
 1050|      0|static void CleanupIteratorState(void* arg1, void* arg2) {
 1051|      0|  IterState* state = reinterpret_cast<IterState*>(arg1);
 1052|      0|  state->mu->Lock();
 1053|      0|  state->mem->Unref();
 1054|      0|  if (state->imm != nullptr) state->imm->Unref();
 1055|      0|  state->version->Unref();
 1056|      0|  state->mu->Unlock();
 1057|      0|  delete state;
 1058|      0|}
 1059|       |
 1060|       |}  // anonymous namespace
 1061|       |
 1062|       |Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,
 1063|       |                                      SequenceNumber* latest_snapshot,
 1064|      0|                                      uint32_t* seed) {
 1065|      0|  mutex_.Lock();
 1066|      0|  *latest_snapshot = versions_->LastSequence();
 1067|      0|
 1068|      0|  // Collect together all needed child iterators
 1069|      0|  std::vector<Iterator*> list;
 1070|      0|  list.push_back(mem_->NewIterator());
 1071|      0|  mem_->Ref();
 1072|      0|  if (imm_ != nullptr) {
 1073|      0|    list.push_back(imm_->NewIterator());
 1074|      0|    imm_->Ref();
 1075|      0|  }
 1076|      0|  versions_->current()->AddIterators(options, &list);
 1077|      0|  Iterator* internal_iter =
 1078|      0|      NewMergingIterator(&internal_comparator_, &list[0], list.size());
 1079|      0|  versions_->current()->Ref();
 1080|      0|
 1081|      0|  IterState* cleanup = new IterState(&mutex_, mem_, imm_, versions_->current());
 1082|      0|  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, nullptr);
 1083|      0|
 1084|      0|  *seed = ++seed_;
 1085|      0|  mutex_.Unlock();
 1086|      0|  return internal_iter;
 1087|      0|}
 1088|       |
 1089|      0|Iterator* DBImpl::TEST_NewInternalIterator() {
 1090|      0|  SequenceNumber ignored;
 1091|      0|  uint32_t ignored_seed;
 1092|      0|  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);
 1093|      0|}
 1094|       |
 1095|      0|int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {
 1096|      0|  MutexLock l(&mutex_);
 1097|      0|  return versions_->MaxNextLevelOverlappingBytes();
 1098|      0|}
 1099|       |
 1100|       |Status DBImpl::Get(const ReadOptions& options, const Slice& key,
 1101|      0|                   std::string* value) {
 1102|      0|  Status s;
 1103|      0|  MutexLock l(&mutex_);
 1104|      0|  SequenceNumber snapshot;
 1105|      0|  if (options.snapshot != nullptr) {
 1106|      0|    snapshot =
 1107|      0|        static_cast<const SnapshotImpl*>(options.snapshot)->sequence_number();
 1108|      0|  } else {
 1109|      0|    snapshot = versions_->LastSequence();
 1110|      0|  }
 1111|      0|
 1112|      0|  MemTable* mem = mem_;
 1113|      0|  MemTable* imm = imm_;
 1114|      0|  Version* current = versions_->current();
 1115|      0|  mem->Ref();
 1116|      0|  if (imm != nullptr) imm->Ref();
 1117|      0|  current->Ref();
 1118|      0|
 1119|      0|  bool have_stat_update = false;
 1120|      0|  Version::GetStats stats;
 1121|      0|
 1122|      0|  // Unlock while reading from files and memtables
 1123|      0|  {
 1124|      0|    mutex_.Unlock();
 1125|      0|    // First look in the memtable, then in the immutable memtable (if any).
 1126|      0|    LookupKey lkey(key, snapshot);
 1127|      0|    if (mem->Get(lkey, value, &s)) {
 1128|      0|      // Done
 1129|      0|    } else if (imm != nullptr && imm->Get(lkey, value, &s)) {
 1130|      0|      // Done
 1131|      0|    } else {
 1132|      0|      s = current->Get(options, lkey, value, &stats);
 1133|      0|      have_stat_update = true;
 1134|      0|    }
 1135|      0|    mutex_.Lock();
 1136|      0|  }
 1137|      0|
 1138|      0|  if (have_stat_update && current->UpdateStats(stats)) {
 1139|      0|    MaybeScheduleCompaction();
 1140|      0|  }
 1141|      0|  mem->Unref();
 1142|      0|  if (imm != nullptr) imm->Unref();
 1143|      0|  current->Unref();
 1144|      0|  return s;
 1145|      0|}
 1146|       |
 1147|      0|Iterator* DBImpl::NewIterator(const ReadOptions& options) {
 1148|      0|  SequenceNumber latest_snapshot;
 1149|      0|  uint32_t seed;
 1150|      0|  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);
 1151|      0|  return NewDBIterator(this, user_comparator(), iter,
 1152|      0|                       (options.snapshot != nullptr
 1153|      0|                            ? static_cast<const SnapshotImpl*>(options.snapshot)
 1154|      0|                                  ->sequence_number()
 1155|      0|                            : latest_snapshot),
 1156|      0|                       seed);
 1157|      0|}
 1158|       |
 1159|      0|void DBImpl::RecordReadSample(Slice key) {
 1160|      0|  MutexLock l(&mutex_);
 1161|      0|  if (versions_->current()->RecordReadSample(key)) {
 1162|      0|    MaybeScheduleCompaction();
 1163|      0|  }
 1164|      0|}
 1165|       |
 1166|      0|const Snapshot* DBImpl::GetSnapshot() {
 1167|      0|  MutexLock l(&mutex_);
 1168|      0|  return snapshots_.New(versions_->LastSequence());
 1169|      0|}
 1170|       |
 1171|      0|void DBImpl::ReleaseSnapshot(const Snapshot* snapshot) {
 1172|      0|  MutexLock l(&mutex_);
 1173|      0|  snapshots_.Delete(static_cast<const SnapshotImpl*>(snapshot));
 1174|      0|}
 1175|       |
 1176|       |// Convenience methods
 1177|      0|Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {
 1178|      0|  return DB::Put(o, key, val);
 1179|      0|}
 1180|       |
 1181|      0|Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {
 1182|      0|  return DB::Delete(options, key);
 1183|      0|}
 1184|       |
 1185|      0|Status DBImpl::Write(const WriteOptions& options, WriteBatch* updates) {
 1186|      0|  Writer w(&mutex_);
 1187|      0|  w.batch = updates;
 1188|      0|  w.sync = options.sync;
 1189|      0|  w.done = false;
 1190|      0|
 1191|      0|  MutexLock l(&mutex_);
 1192|      0|  writers_.push_back(&w);
 1193|      0|  while (!w.done && &w != writers_.front()) {
 1194|      0|    w.cv.Wait();
 1195|      0|  }
 1196|      0|  if (w.done) {
 1197|      0|    return w.status;
 1198|      0|  }
 1199|      0|
 1200|      0|  // May temporarily unlock and wait.
 1201|      0|  Status status = MakeRoomForWrite(updates == nullptr);
 1202|      0|  uint64_t last_sequence = versions_->LastSequence();
 1203|      0|  Writer* last_writer = &w;
 1204|      0|  if (status.ok() && updates != nullptr) {  // nullptr batch is for compactions
 1205|      0|    WriteBatch* updates = BuildBatchGroup(&last_writer);
 1206|      0|    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
 1207|      0|    last_sequence += WriteBatchInternal::Count(updates);
 1208|      0|
 1209|      0|    // Add to log and apply to memtable.  We can release the lock
 1210|      0|    // during this phase since &w is currently responsible for logging
 1211|      0|    // and protects against concurrent loggers and concurrent writes
 1212|      0|    // into mem_.
 1213|      0|    {
 1214|      0|      mutex_.Unlock();
 1215|      0|      status = log_->AddRecord(WriteBatchInternal::Contents(updates));
 1216|      0|      bool sync_error = false;
 1217|      0|      if (status.ok() && options.sync) {
 1218|      0|        status = logfile_->Sync();
 1219|      0|        if (!status.ok()) {
 1220|      0|          sync_error = true;
 1221|      0|        }
 1222|      0|      }
 1223|      0|      if (status.ok()) {
 1224|      0|        status = WriteBatchInternal::InsertInto(updates, mem_);
 1225|      0|      }
 1226|      0|      mutex_.Lock();
 1227|      0|      if (sync_error) {
 1228|      0|        // The state of the log file is indeterminate: the log record we
 1229|      0|        // just added may or may not show up when the DB is re-opened.
 1230|      0|        // So we force the DB into a mode where all future writes fail.
 1231|      0|        RecordBackgroundError(status);
 1232|      0|      }
 1233|      0|    }
 1234|      0|    if (updates == tmp_batch_) tmp_batch_->Clear();
 1235|      0|
 1236|      0|    versions_->SetLastSequence(last_sequence);
 1237|      0|  }
 1238|      0|
 1239|      0|  while (true) {
 1240|      0|    Writer* ready = writers_.front();
 1241|      0|    writers_.pop_front();
 1242|      0|    if (ready != &w) {
 1243|      0|      ready->status = status;
 1244|      0|      ready->done = true;
 1245|      0|      ready->cv.Signal();
 1246|      0|    }
 1247|      0|    if (ready == last_writer) break;
 1248|      0|  }
 1249|      0|
 1250|      0|  // Notify new head of write queue
 1251|      0|  if (!writers_.empty()) {
 1252|      0|    writers_.front()->cv.Signal();
 1253|      0|  }
 1254|      0|
 1255|      0|  return status;
 1256|      0|}
 1257|       |
 1258|       |// REQUIRES: Writer list must be non-empty
 1259|       |// REQUIRES: First writer must have a non-null batch
 1260|      0|WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {
 1261|      0|  mutex_.AssertHeld();
 1262|      0|  assert(!writers_.empty());
 1263|      0|  Writer* first = writers_.front();
 1264|      0|  WriteBatch* result = first->batch;
 1265|      0|  assert(result != nullptr);
 1266|      0|
 1267|      0|  size_t size = WriteBatchInternal::ByteSize(first->batch);
 1268|      0|
 1269|      0|  // Allow the group to grow up to a maximum size, but if the
 1270|      0|  // original write is small, limit the growth so we do not slow
 1271|      0|  // down the small write too much.
 1272|      0|  size_t max_size = 1 << 20;
 1273|      0|  if (size <= (128 << 10)) {
 1274|      0|    max_size = size + (128 << 10);
 1275|      0|  }
 1276|      0|
 1277|      0|  *last_writer = first;
 1278|      0|  std::deque<Writer*>::iterator iter = writers_.begin();
 1279|      0|  ++iter;  // Advance past "first"
 1280|      0|  for (; iter != writers_.end(); ++iter) {
 1281|      0|    Writer* w = *iter;
 1282|      0|    if (w->sync && !first->sync) {
 1283|      0|      // Do not include a sync write into a batch handled by a non-sync write.
 1284|      0|      break;
 1285|      0|    }
 1286|      0|
 1287|      0|    if (w->batch != nullptr) {
 1288|      0|      size += WriteBatchInternal::ByteSize(w->batch);
 1289|      0|      if (size > max_size) {
 1290|      0|        // Do not make batch too big
 1291|      0|        break;
 1292|      0|      }
 1293|      0|
 1294|      0|      // Append to *result
 1295|      0|      if (result == first->batch) {
 1296|      0|        // Switch to temporary batch instead of disturbing caller's batch
 1297|      0|        result = tmp_batch_;
 1298|      0|        assert(WriteBatchInternal::Count(result) == 0);
 1299|      0|        WriteBatchInternal::Append(result, first->batch);
 1300|      0|      }
 1301|      0|      WriteBatchInternal::Append(result, w->batch);
 1302|      0|    }
 1303|      0|    *last_writer = w;
 1304|      0|  }
 1305|      0|  return result;
 1306|      0|}
 1307|       |
 1308|       |// REQUIRES: mutex_ is held
 1309|       |// REQUIRES: this thread is currently at the front of the writer queue
 1310|      0|Status DBImpl::MakeRoomForWrite(bool force) {
 1311|      0|  mutex_.AssertHeld();
 1312|      0|  assert(!writers_.empty());
 1313|      0|  bool allow_delay = !force;
 1314|      0|  Status s;
 1315|      0|  while (true) {
 1316|      0|    if (!bg_error_.ok()) {
 1317|      0|      // Yield previous error
 1318|      0|      s = bg_error_;
 1319|      0|      break;
 1320|      0|    } else if (allow_delay && versions_->NumLevelFiles(0) >=
 1321|      0|                                  config::kL0_SlowdownWritesTrigger) {
 1322|      0|      // We are getting close to hitting a hard limit on the number of
 1323|      0|      // L0 files.  Rather than delaying a single write by several
 1324|      0|      // seconds when we hit the hard limit, start delaying each
 1325|      0|      // individual write by 1ms to reduce latency variance.  Also,
 1326|      0|      // this delay hands over some CPU to the compaction thread in
 1327|      0|      // case it is sharing the same core as the writer.
 1328|      0|      mutex_.Unlock();
 1329|      0|      env_->SleepForMicroseconds(1000);
 1330|      0|      allow_delay = false;  // Do not delay a single write more than once
 1331|      0|      mutex_.Lock();
 1332|      0|    } else if (!force &&
 1333|      0|               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {
 1334|      0|      // There is room in current memtable
 1335|      0|      break;
 1336|      0|    } else if (imm_ != nullptr) {
 1337|      0|      // We have filled up the current memtable, but the previous
 1338|      0|      // one is still being compacted, so we wait.
 1339|      0|      Log(options_.info_log, "Current memtable full; waiting...\n");
 1340|      0|      background_work_finished_signal_.Wait();
 1341|      0|    } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {
 1342|      0|      // There are too many level-0 files.
 1343|      0|      Log(options_.info_log, "Too many L0 files; waiting...\n");
 1344|      0|      background_work_finished_signal_.Wait();
 1345|      0|    } else {
 1346|      0|      // Attempt to switch to a new memtable and trigger compaction of old
 1347|      0|      assert(versions_->PrevLogNumber() == 0);
 1348|      0|      uint64_t new_log_number = versions_->NewFileNumber();
 1349|      0|      WritableFile* lfile = nullptr;
 1350|      0|      s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);
 1351|      0|      if (!s.ok()) {
 1352|      0|        // Avoid chewing through file number space in a tight loop.
 1353|      0|        versions_->ReuseFileNumber(new_log_number);
 1354|      0|        break;
 1355|      0|      }
 1356|      0|      delete log_;
 1357|      0|      delete logfile_;
 1358|      0|      logfile_ = lfile;
 1359|      0|      logfile_number_ = new_log_number;
 1360|      0|      log_ = new log::Writer(lfile);
 1361|      0|      imm_ = mem_;
 1362|      0|      has_imm_.store(true, std::memory_order_release);
 1363|      0|      mem_ = new MemTable(internal_comparator_);
 1364|      0|      mem_->Ref();
 1365|      0|      force = false;  // Do not force another compaction if have room
 1366|      0|      MaybeScheduleCompaction();
 1367|      0|    }
 1368|      0|  }
 1369|      0|  return s;
 1370|      0|}
 1371|       |
 1372|      0|bool DBImpl::GetProperty(const Slice& property, std::string* value) {
 1373|      0|  value->clear();
 1374|      0|
 1375|      0|  MutexLock l(&mutex_);
 1376|      0|  Slice in = property;
 1377|      0|  Slice prefix("leveldb.");
 1378|      0|  if (!in.starts_with(prefix)) return false;
 1379|      0|  in.remove_prefix(prefix.size());
 1380|      0|
 1381|      0|  if (in.starts_with("num-files-at-level")) {
 1382|      0|    in.remove_prefix(strlen("num-files-at-level"));
 1383|      0|    uint64_t level;
 1384|      0|    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
 1385|      0|    if (!ok || level >= config::kNumLevels) {
 1386|      0|      return false;
 1387|      0|    } else {
 1388|      0|      char buf[100];
 1389|      0|      snprintf(buf, sizeof(buf), "%d",
 1390|      0|               versions_->NumLevelFiles(static_cast<int>(level)));
 1391|      0|      *value = buf;
 1392|      0|      return true;
 1393|      0|    }
 1394|      0|  } else if (in == "stats") {
 1395|      0|    char buf[200];
 1396|      0|    snprintf(buf, sizeof(buf),
 1397|      0|             "                               Compactions\n"
 1398|      0|             "Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n"
 1399|      0|             "--------------------------------------------------\n");
 1400|      0|    value->append(buf);
 1401|      0|    for (int level = 0; level < config::kNumLevels; level++) {
 1402|      0|      int files = versions_->NumLevelFiles(level);
 1403|      0|      if (stats_[level].micros > 0 || files > 0) {
 1404|      0|        snprintf(buf, sizeof(buf), "%3d %8d %8.0f %9.0f %8.0f %9.0f\n", level,
 1405|      0|                 files, versions_->NumLevelBytes(level) / 1048576.0,
 1406|      0|                 stats_[level].micros / 1e6,
 1407|      0|                 stats_[level].bytes_read / 1048576.0,
 1408|      0|                 stats_[level].bytes_written / 1048576.0);
 1409|      0|        value->append(buf);
 1410|      0|      }
 1411|      0|    }
 1412|      0|    return true;
 1413|      0|  } else if (in == "sstables") {
 1414|      0|    *value = versions_->current()->DebugString();
 1415|      0|    return true;
 1416|      0|  } else if (in == "approximate-memory-usage") {
 1417|      0|    size_t total_usage = options_.block_cache->TotalCharge();
 1418|      0|    if (mem_) {
 1419|      0|      total_usage += mem_->ApproximateMemoryUsage();
 1420|      0|    }
 1421|      0|    if (imm_) {
 1422|      0|      total_usage += imm_->ApproximateMemoryUsage();
 1423|      0|    }
 1424|      0|    char buf[50];
 1425|      0|    snprintf(buf, sizeof(buf), "%llu",
 1426|      0|             static_cast<unsigned long long>(total_usage));
 1427|      0|    value->append(buf);
 1428|      0|    return true;
 1429|      0|  }
 1430|      0|
 1431|      0|  return false;
 1432|      0|}
 1433|       |
 1434|      0|void DBImpl::GetApproximateSizes(const Range* range, int n, uint64_t* sizes) {
 1435|      0|  // TODO(opt): better implementation
 1436|      0|  Version* v;
 1437|      0|  {
 1438|      0|    MutexLock l(&mutex_);
 1439|      0|    versions_->current()->Ref();
 1440|      0|    v = versions_->current();
 1441|      0|  }
 1442|      0|
 1443|      0|  for (int i = 0; i < n; i++) {
 1444|      0|    // Convert user_key into a corresponding internal key.
 1445|      0|    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
 1446|      0|    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
 1447|      0|    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
 1448|      0|    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
 1449|      0|    sizes[i] = (limit >= start ? limit - start : 0);
 1450|      0|  }
 1451|      0|
 1452|      0|  {
 1453|      0|    MutexLock l(&mutex_);
 1454|      0|    v->Unref();
 1455|      0|  }
 1456|      0|}
 1457|       |
 1458|       |// Default implementations of convenience methods that subclasses of DB
 1459|       |// can call if they wish
 1460|      0|Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {
 1461|      0|  WriteBatch batch;
 1462|      0|  batch.Put(key, value);
 1463|      0|  return Write(opt, &batch);
 1464|      0|}
 1465|       |
 1466|      0|Status DB::Delete(const WriteOptions& opt, const Slice& key) {
 1467|      0|  WriteBatch batch;
 1468|      0|  batch.Delete(key);
 1469|      0|  return Write(opt, &batch);
 1470|      0|}
 1471|       |
 1472|      0|DB::~DB() {}
 1473|       |
 1474|      0|Status DB::Open(const Options& options, const std::string& dbname, DB** dbptr) {
 1475|      0|  *dbptr = nullptr;
 1476|      0|
 1477|      0|  DBImpl* impl = new DBImpl(options, dbname);
 1478|      0|  impl->mutex_.Lock();
 1479|      0|  VersionEdit edit;
 1480|      0|  // Recover handles create_if_missing, error_if_exists
 1481|      0|  bool save_manifest = false;
 1482|      0|  Status s = impl->Recover(&edit, &save_manifest);
 1483|      0|  if (s.ok() && impl->mem_ == nullptr) {
 1484|      0|    // Create new log and a corresponding memtable.
 1485|      0|    uint64_t new_log_number = impl->versions_->NewFileNumber();
 1486|      0|    WritableFile* lfile;
 1487|      0|    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
 1488|      0|                                     &lfile);
 1489|      0|    if (s.ok()) {
 1490|      0|      edit.SetLogNumber(new_log_number);
 1491|      0|      impl->logfile_ = lfile;
 1492|      0|      impl->logfile_number_ = new_log_number;
 1493|      0|      impl->log_ = new log::Writer(lfile);
 1494|      0|      impl->mem_ = new MemTable(impl->internal_comparator_);
 1495|      0|      impl->mem_->Ref();
 1496|      0|    }
 1497|      0|  }
 1498|      0|  if (s.ok() && save_manifest) {
 1499|      0|    edit.SetPrevLogNumber(0);  // No older logs needed after recovery.
 1500|      0|    edit.SetLogNumber(impl->logfile_number_);
 1501|      0|    s = impl->versions_->LogAndApply(&edit, &impl->mutex_);
 1502|      0|  }
 1503|      0|  if (s.ok()) {
 1504|      0|    impl->DeleteObsoleteFiles();
 1505|      0|    impl->MaybeScheduleCompaction();
 1506|      0|  }
 1507|      0|  impl->mutex_.Unlock();
 1508|      0|  if (s.ok()) {
 1509|      0|    assert(impl->mem_ != nullptr);
 1510|      0|    *dbptr = impl;
 1511|      0|  } else {
 1512|      0|    delete impl;
 1513|      0|  }
 1514|      0|  return s;
 1515|      0|}
 1516|       |
 1517|      0|Snapshot::~Snapshot() {}
 1518|       |
 1519|      0|Status DestroyDB(const std::string& dbname, const Options& options) {
 1520|      0|  Env* env = options.env;
 1521|      0|  std::vector<std::string> filenames;
 1522|      0|  Status result = env->GetChildren(dbname, &filenames);
 1523|      0|  if (!result.ok()) {
 1524|      0|    // Ignore error in case directory does not exist
 1525|      0|    return Status::OK();
 1526|      0|  }
 1527|      0|
 1528|      0|  FileLock* lock;
 1529|      0|  const std::string lockname = LockFileName(dbname);
 1530|      0|  result = env->LockFile(lockname, &lock);
 1531|      0|  if (result.ok()) {
 1532|      0|    uint64_t number;
 1533|      0|    FileType type;
 1534|      0|    for (size_t i = 0; i < filenames.size(); i++) {
 1535|      0|      if (ParseFileName(filenames[i], &number, &type) &&
 1536|      0|          type != kDBLockFile) {  // Lock file will be deleted at end
 1537|      0|        Status del = env->DeleteFile(dbname + "/" + filenames[i]);
 1538|      0|        if (result.ok() && !del.ok()) {
 1539|      0|          result = del;
 1540|      0|        }
 1541|      0|      }
 1542|      0|    }
 1543|      0|    env->UnlockFile(lock);  // Ignore error since state is already gone
 1544|      0|    env->DeleteFile(lockname);
 1545|      0|    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
 1546|      0|  }
 1547|      0|  return result;
 1548|      0|}
 1549|       |
 1550|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/db_impl.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_DB_IMPL_H_
    6|       |#define STORAGE_LEVELDB_DB_DB_IMPL_H_
    7|       |
    8|       |#include <atomic>
    9|       |#include <deque>
   10|       |#include <set>
   11|       |#include <string>
   12|       |
   13|       |#include "db/dbformat.h"
   14|       |#include "db/log_writer.h"
   15|       |#include "db/snapshot.h"
   16|       |#include "leveldb/db.h"
   17|       |#include "leveldb/env.h"
   18|       |#include "port/port.h"
   19|       |#include "port/thread_annotations.h"
   20|       |
   21|       |namespace leveldb {
   22|       |
   23|       |class MemTable;
   24|       |class TableCache;
   25|       |class Version;
   26|       |class VersionEdit;
   27|       |class VersionSet;
   28|       |
   29|       |class DBImpl : public DB {
   30|       | public:
   31|       |  DBImpl(const Options& options, const std::string& dbname);
   32|       |
   33|       |  DBImpl(const DBImpl&) = delete;
   34|       |  DBImpl& operator=(const DBImpl&) = delete;
   35|       |
   36|       |  virtual ~DBImpl();
   37|       |
   38|       |  // Implementations of the DB interface
   39|       |  virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);
   40|       |  virtual Status Delete(const WriteOptions&, const Slice& key);
   41|       |  virtual Status Write(const WriteOptions& options, WriteBatch* updates);
   42|       |  virtual Status Get(const ReadOptions& options, const Slice& key,
   43|       |                     std::string* value);
   44|       |  virtual Iterator* NewIterator(const ReadOptions&);
   45|       |  virtual const Snapshot* GetSnapshot();
   46|       |  virtual void ReleaseSnapshot(const Snapshot* snapshot);
   47|       |  virtual bool GetProperty(const Slice& property, std::string* value);
   48|       |  virtual void GetApproximateSizes(const Range* range, int n, uint64_t* sizes);
   49|       |  virtual void CompactRange(const Slice* begin, const Slice* end);
   50|       |
   51|       |  // Extra methods (for testing) that are not in the public DB interface
   52|       |
   53|       |  // Compact any files in the named level that overlap [*begin,*end]
   54|       |  void TEST_CompactRange(int level, const Slice* begin, const Slice* end);
   55|       |
   56|       |  // Force current memtable contents to be compacted.
   57|       |  Status TEST_CompactMemTable();
   58|       |
   59|       |  // Return an internal iterator over the current state of the database.
   60|       |  // The keys of this iterator are internal keys (see format.h).
   61|       |  // The returned iterator should be deleted when no longer needed.
   62|       |  Iterator* TEST_NewInternalIterator();
   63|       |
   64|       |  // Return the maximum overlapping data (in bytes) at next level for any
   65|       |  // file at a level >= 1.
   66|       |  int64_t TEST_MaxNextLevelOverlappingBytes();
   67|       |
   68|       |  // Record a sample of bytes read at the specified internal key.
   69|       |  // Samples are taken approximately once every config::kReadBytesPeriod
   70|       |  // bytes.
   71|       |  void RecordReadSample(Slice key);
   72|       |
   73|       | private:
   74|       |  friend class DB;
   75|       |  struct CompactionState;
   76|       |  struct Writer;
   77|       |
   78|       |  // Information for a manual compaction
   79|       |  struct ManualCompaction {
   80|       |    int level;
   81|       |    bool done;
   82|       |    const InternalKey* begin;  // null means beginning of key range
   83|       |    const InternalKey* end;    // null means end of key range
   84|       |    InternalKey tmp_storage;   // Used to keep track of compaction progress
   85|       |  };
   86|       |
   87|       |  // Per level compaction stats.  stats_[level] stores the stats for
   88|       |  // compactions that produced data for the specified "level".
   89|       |  struct CompactionStats {
   90|      0|    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) {}
   91|       |
   92|      0|    void Add(const CompactionStats& c) {
   93|      0|      this->micros += c.micros;
   94|      0|      this->bytes_read += c.bytes_read;
   95|      0|      this->bytes_written += c.bytes_written;
   96|      0|    }
   97|       |
   98|       |    int64_t micros;
   99|       |    int64_t bytes_read;
  100|       |    int64_t bytes_written;
  101|       |  };
  102|       |
  103|       |  Iterator* NewInternalIterator(const ReadOptions&,
  104|       |                                SequenceNumber* latest_snapshot,
  105|       |                                uint32_t* seed);
  106|       |
  107|       |  Status NewDB();
  108|       |
  109|       |  // Recover the descriptor from persistent storage.  May do a significant
  110|       |  // amount of work to recover recently logged updates.  Any changes to
  111|       |  // be made to the descriptor are added to *edit.
  112|       |  Status Recover(VersionEdit* edit, bool* save_manifest)
  113|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  114|       |
  115|       |  void MaybeIgnoreError(Status* s) const;
  116|       |
  117|       |  // Delete any unneeded files and stale in-memory entries.
  118|       |  void DeleteObsoleteFiles() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  119|       |
  120|       |  // Compact the in-memory write buffer to disk.  Switches to a new
  121|       |  // log-file/memtable and writes a new descriptor iff successful.
  122|       |  // Errors are recorded in bg_error_.
  123|       |  void CompactMemTable() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  124|       |
  125|       |  Status RecoverLogFile(uint64_t log_number, bool last_log, bool* save_manifest,
  126|       |                        VersionEdit* edit, SequenceNumber* max_sequence)
  127|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  128|       |
  129|       |  Status WriteLevel0Table(MemTable* mem, VersionEdit* edit, Version* base)
  130|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  131|       |
  132|       |  Status MakeRoomForWrite(bool force /* compact even if there is room? */)
  133|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  134|       |  WriteBatch* BuildBatchGroup(Writer** last_writer)
  135|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  136|       |
  137|       |  void RecordBackgroundError(const Status& s);
  138|       |
  139|       |  void MaybeScheduleCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  140|       |  static void BGWork(void* db);
  141|       |  void BackgroundCall();
  142|       |  void BackgroundCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  143|       |  void CleanupCompaction(CompactionState* compact)
  144|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  145|       |  Status DoCompactionWork(CompactionState* compact)
  146|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  147|       |
  148|       |  Status OpenCompactionOutputFile(CompactionState* compact);
  149|       |  Status FinishCompactionOutputFile(CompactionState* compact, Iterator* input);
  150|       |  Status InstallCompactionResults(CompactionState* compact)
  151|       |      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  152|       |
  153|      0|  const Comparator* user_comparator() const {
  154|      0|    return internal_comparator_.user_comparator();
  155|      0|  }
  156|       |
  157|       |  // Constant after construction
  158|       |  Env* const env_;
  159|       |  const InternalKeyComparator internal_comparator_;
  160|       |  const InternalFilterPolicy internal_filter_policy_;
  161|       |  const Options options_;  // options_.comparator == &internal_comparator_
  162|       |  const bool owns_info_log_;
  163|       |  const bool owns_cache_;
  164|       |  const std::string dbname_;
  165|       |
  166|       |  // table_cache_ provides its own synchronization
  167|       |  TableCache* const table_cache_;
  168|       |
  169|       |  // Lock over the persistent DB state.  Non-null iff successfully acquired.
  170|       |  FileLock* db_lock_;
  171|       |
  172|       |  // State below is protected by mutex_
  173|       |  port::Mutex mutex_;
  174|       |  std::atomic<bool> shutting_down_;
  175|       |  port::CondVar background_work_finished_signal_ GUARDED_BY(mutex_);
  176|       |  MemTable* mem_;
  177|       |  MemTable* imm_ GUARDED_BY(mutex_);  // Memtable being compacted
  178|       |  std::atomic<bool> has_imm_;         // So bg thread can detect non-null imm_
  179|       |  WritableFile* logfile_;
  180|       |  uint64_t logfile_number_ GUARDED_BY(mutex_);
  181|       |  log::Writer* log_;
  182|       |  uint32_t seed_ GUARDED_BY(mutex_);  // For sampling.
  183|       |
  184|       |  // Queue of writers.
  185|       |  std::deque<Writer*> writers_ GUARDED_BY(mutex_);
  186|       |  WriteBatch* tmp_batch_ GUARDED_BY(mutex_);
  187|       |
  188|       |  SnapshotList snapshots_ GUARDED_BY(mutex_);
  189|       |
  190|       |  // Set of table files to protect from deletion because they are
  191|       |  // part of ongoing compactions.
  192|       |  std::set<uint64_t> pending_outputs_ GUARDED_BY(mutex_);
  193|       |
  194|       |  // Has a background compaction been scheduled or is running?
  195|       |  bool background_compaction_scheduled_ GUARDED_BY(mutex_);
  196|       |
  197|       |  ManualCompaction* manual_compaction_ GUARDED_BY(mutex_);
  198|       |
  199|       |  VersionSet* const versions_;
  200|       |
  201|       |  // Have we encountered a background error in paranoid mode?
  202|       |  Status bg_error_ GUARDED_BY(mutex_);
  203|       |
  204|       |  CompactionStats stats_[config::kNumLevels] GUARDED_BY(mutex_);
  205|       |};
  206|       |
  207|       |// Sanitize db options.  The caller should delete result.info_log if
  208|       |// it is not equal to src.info_log.
  209|       |Options SanitizeOptions(const std::string& db,
  210|       |                        const InternalKeyComparator* icmp,
  211|       |                        const InternalFilterPolicy* ipolicy,
  212|       |                        const Options& src);
  213|       |
  214|       |}  // namespace leveldb
  215|       |
  216|       |#endif  // STORAGE_LEVELDB_DB_DB_IMPL_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/db_iter.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/db_iter.h"
    6|       |
    7|       |#include "db/db_impl.h"
    8|       |#include "db/dbformat.h"
    9|       |#include "db/filename.h"
   10|       |#include "leveldb/env.h"
   11|       |#include "leveldb/iterator.h"
   12|       |#include "port/port.h"
   13|       |#include "util/logging.h"
   14|       |#include "util/mutexlock.h"
   15|       |#include "util/random.h"
   16|       |
   17|       |namespace leveldb {
   18|       |
   19|       |#if 0
   20|       |static void DumpInternalIter(Iterator* iter) {
   21|       |  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
   22|       |    ParsedInternalKey k;
   23|       |    if (!ParseInternalKey(iter->key(), &k)) {
   24|       |      fprintf(stderr, "Corrupt '%s'\n", EscapeString(iter->key()).c_str());
   25|       |    } else {
   26|       |      fprintf(stderr, "@ '%s'\n", k.DebugString().c_str());
   27|       |    }
   28|       |  }
   29|       |}
   30|       |#endif
   31|       |
   32|       |namespace {
   33|       |
   34|       |// Memtables and sstables that make the DB representation contain
   35|       |// (userkey,seq,type) => uservalue entries.  DBIter
   36|       |// combines multiple entries for the same userkey found in the DB
   37|       |// representation into a single entry while accounting for sequence
   38|       |// numbers, deletion markers, overwrites, etc.
   39|       |class DBIter : public Iterator {
   40|       | public:
   41|       |  // Which direction is the iterator currently moving?
   42|       |  // (1) When moving forward, the internal iterator is positioned at
   43|       |  //     the exact entry that yields this->key(), this->value()
   44|       |  // (2) When moving backwards, the internal iterator is positioned
   45|       |  //     just before all entries whose user key == this->key().
   46|       |  enum Direction { kForward, kReverse };
   47|       |
   48|       |  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,
   49|       |         uint32_t seed)
   50|       |      : db_(db),
   51|       |        user_comparator_(cmp),
   52|       |        iter_(iter),
   53|       |        sequence_(s),
   54|       |        direction_(kForward),
   55|       |        valid_(false),
   56|       |        rnd_(seed),
   57|      0|        bytes_until_read_sampling_(RandomCompactionPeriod()) {}
   58|       |
   59|       |  DBIter(const DBIter&) = delete;
   60|       |  DBIter& operator=(const DBIter&) = delete;
   61|       |
   62|      0|  virtual ~DBIter() { delete iter_; }
   63|      0|  virtual bool Valid() const { return valid_; }
   64|      0|  virtual Slice key() const {
   65|      0|    assert(valid_);
   66|      0|    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
   67|      0|  }
   68|      0|  virtual Slice value() const {
   69|      0|    assert(valid_);
   70|      0|    return (direction_ == kForward) ? iter_->value() : saved_value_;
   71|      0|  }
   72|      0|  virtual Status status() const {
   73|      0|    if (status_.ok()) {
   74|      0|      return iter_->status();
   75|      0|    } else {
   76|      0|      return status_;
   77|      0|    }
   78|      0|  }
   79|       |
   80|       |  virtual void Next();
   81|       |  virtual void Prev();
   82|       |  virtual void Seek(const Slice& target);
   83|       |  virtual void SeekToFirst();
   84|       |  virtual void SeekToLast();
   85|       |
   86|       | private:
   87|       |  void FindNextUserEntry(bool skipping, std::string* skip);
   88|       |  void FindPrevUserEntry();
   89|       |  bool ParseKey(ParsedInternalKey* key);
   90|       |
   91|      0|  inline void SaveKey(const Slice& k, std::string* dst) {
   92|      0|    dst->assign(k.data(), k.size());
   93|      0|  }
   94|       |
   95|      0|  inline void ClearSavedValue() {
   96|      0|    if (saved_value_.capacity() > 1048576) {
   97|      0|      std::string empty;
   98|      0|      swap(empty, saved_value_);
   99|      0|    } else {
  100|      0|      saved_value_.clear();
  101|      0|    }
  102|      0|  }
  103|       |
  104|       |  // Picks the number of bytes that can be read until a compaction is scheduled.
  105|      0|  size_t RandomCompactionPeriod() {
  106|      0|    return rnd_.Uniform(2 * config::kReadBytesPeriod);
  107|      0|  }
  108|       |
  109|       |  DBImpl* db_;
  110|       |  const Comparator* const user_comparator_;
  111|       |  Iterator* const iter_;
  112|       |  SequenceNumber const sequence_;
  113|       |  Status status_;
  114|       |  std::string saved_key_;    // == current key when direction_==kReverse
  115|       |  std::string saved_value_;  // == current raw value when direction_==kReverse
  116|       |  Direction direction_;
  117|       |  bool valid_;
  118|       |  Random rnd_;
  119|       |  size_t bytes_until_read_sampling_;
  120|       |};
  121|       |
  122|      0|inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
  123|      0|  Slice k = iter_->key();
  124|      0|
  125|      0|  size_t bytes_read = k.size() + iter_->value().size();
  126|      0|  while (bytes_until_read_sampling_ < bytes_read) {
  127|      0|    bytes_until_read_sampling_ += RandomCompactionPeriod();
  128|      0|    db_->RecordReadSample(k);
  129|      0|  }
  130|      0|  assert(bytes_until_read_sampling_ >= bytes_read);
  131|      0|  bytes_until_read_sampling_ -= bytes_read;
  132|      0|
  133|      0|  if (!ParseInternalKey(k, ikey)) {
  134|      0|    status_ = Status::Corruption("corrupted internal key in DBIter");
  135|      0|    return false;
  136|      0|  } else {
  137|      0|    return true;
  138|      0|  }
  139|      0|}
  140|       |
  141|      0|void DBIter::Next() {
  142|      0|  assert(valid_);
  143|      0|
  144|      0|  if (direction_ == kReverse) {  // Switch directions?
  145|      0|    direction_ = kForward;
  146|      0|    // iter_ is pointing just before the entries for this->key(),
  147|      0|    // so advance into the range of entries for this->key() and then
  148|      0|    // use the normal skipping code below.
  149|      0|    if (!iter_->Valid()) {
  150|      0|      iter_->SeekToFirst();
  151|      0|    } else {
  152|      0|      iter_->Next();
  153|      0|    }
  154|      0|    if (!iter_->Valid()) {
  155|      0|      valid_ = false;
  156|      0|      saved_key_.clear();
  157|      0|      return;
  158|      0|    }
  159|      0|    // saved_key_ already contains the key to skip past.
  160|      0|  } else {
  161|      0|    // Store in saved_key_ the current key so we skip it below.
  162|      0|    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  163|      0|  }
  164|      0|
  165|      0|  FindNextUserEntry(true, &saved_key_);
  166|      0|}
  167|       |
  168|      0|void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
  169|      0|  // Loop until we hit an acceptable entry to yield
  170|      0|  assert(iter_->Valid());
  171|      0|  assert(direction_ == kForward);
  172|      0|  do {
  173|      0|    ParsedInternalKey ikey;
  174|      0|    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
  175|      0|      switch (ikey.type) {
  176|      0|        case kTypeDeletion:
  177|      0|          // Arrange to skip all upcoming entries for this key since
  178|      0|          // they are hidden by this deletion.
  179|      0|          SaveKey(ikey.user_key, skip);
  180|      0|          skipping = true;
  181|      0|          break;
  182|      0|        case kTypeValue:
  183|      0|          if (skipping &&
  184|      0|              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
  185|      0|            // Entry hidden
  186|      0|          } else {
  187|      0|            valid_ = true;
  188|      0|            saved_key_.clear();
  189|      0|            return;
  190|      0|          }
  191|      0|          break;
  192|      0|      }
  193|      0|    }
  194|      0|    iter_->Next();
  195|      0|  } while (iter_->Valid());
  196|      0|  saved_key_.clear();
  197|      0|  valid_ = false;
  198|      0|}
  199|       |
  200|      0|void DBIter::Prev() {
  201|      0|  assert(valid_);
  202|      0|
  203|      0|  if (direction_ == kForward) {  // Switch directions?
  204|      0|    // iter_ is pointing at the current entry.  Scan backwards until
  205|      0|    // the key changes so we can use the normal reverse scanning code.
  206|      0|    assert(iter_->Valid());  // Otherwise valid_ would have been false
  207|      0|    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  208|      0|    while (true) {
  209|      0|      iter_->Prev();
  210|      0|      if (!iter_->Valid()) {
  211|      0|        valid_ = false;
  212|      0|        saved_key_.clear();
  213|      0|        ClearSavedValue();
  214|      0|        return;
  215|      0|      }
  216|      0|      if (user_comparator_->Compare(ExtractUserKey(iter_->key()), saved_key_) <
  217|      0|          0) {
  218|      0|        break;
  219|      0|      }
  220|      0|    }
  221|      0|    direction_ = kReverse;
  222|      0|  }
  223|      0|
  224|      0|  FindPrevUserEntry();
  225|      0|}
  226|       |
  227|      0|void DBIter::FindPrevUserEntry() {
  228|      0|  assert(direction_ == kReverse);
  229|      0|
  230|      0|  ValueType value_type = kTypeDeletion;
  231|      0|  if (iter_->Valid()) {
  232|      0|    do {
  233|      0|      ParsedInternalKey ikey;
  234|      0|      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
  235|      0|        if ((value_type != kTypeDeletion) &&
  236|      0|            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
  237|      0|          // We encountered a non-deleted value in entries for previous keys,
  238|      0|          break;
  239|      0|        }
  240|      0|        value_type = ikey.type;
  241|      0|        if (value_type == kTypeDeletion) {
  242|      0|          saved_key_.clear();
  243|      0|          ClearSavedValue();
  244|      0|        } else {
  245|      0|          Slice raw_value = iter_->value();
  246|      0|          if (saved_value_.capacity() > raw_value.size() + 1048576) {
  247|      0|            std::string empty;
  248|      0|            swap(empty, saved_value_);
  249|      0|          }
  250|      0|          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  251|      0|          saved_value_.assign(raw_value.data(), raw_value.size());
  252|      0|        }
  253|      0|      }
  254|      0|      iter_->Prev();
  255|      0|    } while (iter_->Valid());
  256|      0|  }
  257|      0|
  258|      0|  if (value_type == kTypeDeletion) {
  259|      0|    // End
  260|      0|    valid_ = false;
  261|      0|    saved_key_.clear();
  262|      0|    ClearSavedValue();
  263|      0|    direction_ = kForward;
  264|      0|  } else {
  265|      0|    valid_ = true;
  266|      0|  }
  267|      0|}
  268|       |
  269|      0|void DBIter::Seek(const Slice& target) {
  270|      0|  direction_ = kForward;
  271|      0|  ClearSavedValue();
  272|      0|  saved_key_.clear();
  273|      0|  AppendInternalKey(&saved_key_,
  274|      0|                    ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  275|      0|  iter_->Seek(saved_key_);
  276|      0|  if (iter_->Valid()) {
  277|      0|    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  278|      0|  } else {
  279|      0|    valid_ = false;
  280|      0|  }
  281|      0|}
  282|       |
  283|      0|void DBIter::SeekToFirst() {
  284|      0|  direction_ = kForward;
  285|      0|  ClearSavedValue();
  286|      0|  iter_->SeekToFirst();
  287|      0|  if (iter_->Valid()) {
  288|      0|    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  289|      0|  } else {
  290|      0|    valid_ = false;
  291|      0|  }
  292|      0|}
  293|       |
  294|      0|void DBIter::SeekToLast() {
  295|      0|  direction_ = kReverse;
  296|      0|  ClearSavedValue();
  297|      0|  iter_->SeekToLast();
  298|      0|  FindPrevUserEntry();
  299|      0|}
  300|       |
  301|       |}  // anonymous namespace
  302|       |
  303|       |Iterator* NewDBIterator(DBImpl* db, const Comparator* user_key_comparator,
  304|       |                        Iterator* internal_iter, SequenceNumber sequence,
  305|      0|                        uint32_t seed) {
  306|      0|  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);
  307|      0|}
  308|       |
  309|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/dbformat.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/dbformat.h"
    6|       |
    7|       |#include <stdio.h>
    8|       |
    9|       |#include "port/port.h"
   10|       |#include "util/coding.h"
   11|       |
   12|       |namespace leveldb {
   13|       |
   14|      0|static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
   15|      0|  assert(seq <= kMaxSequenceNumber);
   16|      0|  assert(t <= kValueTypeForSeek);
   17|      0|  return (seq << 8) | t;
   18|      0|}
   19|       |
   20|      0|void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {
   21|      0|  result->append(key.user_key.data(), key.user_key.size());
   22|      0|  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
   23|      0|}
   24|       |
   25|      0|std::string ParsedInternalKey::DebugString() const {
   26|      0|  char buf[50];
   27|      0|  snprintf(buf, sizeof(buf), "' @ %llu : %d", (unsigned long long)sequence,
   28|      0|           int(type));
   29|      0|  std::string result = "'";
   30|      0|  result += EscapeString(user_key.ToString());
   31|      0|  result += buf;
   32|      0|  return result;
   33|      0|}
   34|       |
   35|      0|std::string InternalKey::DebugString() const {
   36|      0|  std::string result;
   37|      0|  ParsedInternalKey parsed;
   38|      0|  if (ParseInternalKey(rep_, &parsed)) {
   39|      0|    result = parsed.DebugString();
   40|      0|  } else {
   41|      0|    result = "(bad)";
   42|      0|    result.append(EscapeString(rep_));
   43|      0|  }
   44|      0|  return result;
   45|      0|}
   46|       |
   47|      0|const char* InternalKeyComparator::Name() const {
   48|      0|  return "leveldb.InternalKeyComparator";
   49|      0|}
   50|       |
   51|      0|int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {
   52|      0|  // Order by:
   53|      0|  //    increasing user key (according to user-supplied comparator)
   54|      0|  //    decreasing sequence number
   55|      0|  //    decreasing type (though sequence# should be enough to disambiguate)
   56|      0|  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
   57|      0|  if (r == 0) {
   58|      0|    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
   59|      0|    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
   60|      0|    if (anum > bnum) {
   61|      0|      r = -1;
   62|      0|    } else if (anum < bnum) {
   63|      0|      r = +1;
   64|      0|    }
   65|      0|  }
   66|      0|  return r;
   67|      0|}
   68|       |
   69|       |void InternalKeyComparator::FindShortestSeparator(std::string* start,
   70|      0|                                                  const Slice& limit) const {
   71|      0|  // Attempt to shorten the user portion of the key
   72|      0|  Slice user_start = ExtractUserKey(*start);
   73|      0|  Slice user_limit = ExtractUserKey(limit);
   74|      0|  std::string tmp(user_start.data(), user_start.size());
   75|      0|  user_comparator_->FindShortestSeparator(&tmp, user_limit);
   76|      0|  if (tmp.size() < user_start.size() &&
   77|      0|      user_comparator_->Compare(user_start, tmp) < 0) {
   78|      0|    // User key has become shorter physically, but larger logically.
   79|      0|    // Tack on the earliest possible number to the shortened user key.
   80|      0|    PutFixed64(&tmp,
   81|      0|               PackSequenceAndType(kMaxSequenceNumber, kValueTypeForSeek));
   82|      0|    assert(this->Compare(*start, tmp) < 0);
   83|      0|    assert(this->Compare(tmp, limit) < 0);
   84|      0|    start->swap(tmp);
   85|      0|  }
   86|      0|}
   87|       |
   88|      0|void InternalKeyComparator::FindShortSuccessor(std::string* key) const {
   89|      0|  Slice user_key = ExtractUserKey(*key);
   90|      0|  std::string tmp(user_key.data(), user_key.size());
   91|      0|  user_comparator_->FindShortSuccessor(&tmp);
   92|      0|  if (tmp.size() < user_key.size() &&
   93|      0|      user_comparator_->Compare(user_key, tmp) < 0) {
   94|      0|    // User key has become shorter physically, but larger logically.
   95|      0|    // Tack on the earliest possible number to the shortened user key.
   96|      0|    PutFixed64(&tmp,
   97|      0|               PackSequenceAndType(kMaxSequenceNumber, kValueTypeForSeek));
   98|      0|    assert(this->Compare(*key, tmp) < 0);
   99|      0|    key->swap(tmp);
  100|      0|  }
  101|      0|}
  102|       |
  103|      0|const char* InternalFilterPolicy::Name() const { return user_policy_->Name(); }
  104|       |
  105|       |void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,
  106|      0|                                        std::string* dst) const {
  107|      0|  // We rely on the fact that the code in table.cc does not mind us
  108|      0|  // adjusting keys[].
  109|      0|  Slice* mkey = const_cast<Slice*>(keys);
  110|      0|  for (int i = 0; i < n; i++) {
  111|      0|    mkey[i] = ExtractUserKey(keys[i]);
  112|      0|    // TODO(sanjay): Suppress dups?
  113|      0|  }
  114|      0|  user_policy_->CreateFilter(keys, n, dst);
  115|      0|}
  116|       |
  117|      0|bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {
  118|      0|  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);
  119|      0|}
  120|       |
  121|      0|LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
  122|      0|  size_t usize = user_key.size();
  123|      0|  size_t needed = usize + 13;  // A conservative estimate
  124|      0|  char* dst;
  125|      0|  if (needed <= sizeof(space_)) {
  126|      0|    dst = space_;
  127|      0|  } else {
  128|      0|    dst = new char[needed];
  129|      0|  }
  130|      0|  start_ = dst;
  131|      0|  dst = EncodeVarint32(dst, usize + 8);
  132|      0|  kstart_ = dst;
  133|      0|  memcpy(dst, user_key.data(), usize);
  134|      0|  dst += usize;
  135|      0|  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  136|      0|  dst += 8;
  137|      0|  end_ = dst;
  138|      0|}
  139|       |
  140|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/dbformat.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_DBFORMAT_H_
    6|       |#define STORAGE_LEVELDB_DB_DBFORMAT_H_
    7|       |
    8|       |#include <stdio.h>
    9|       |
   10|       |#include "leveldb/comparator.h"
   11|       |#include "leveldb/db.h"
   12|       |#include "leveldb/filter_policy.h"
   13|       |#include "leveldb/slice.h"
   14|       |#include "leveldb/table_builder.h"
   15|       |#include "util/coding.h"
   16|       |#include "util/logging.h"
   17|       |
   18|       |namespace leveldb {
   19|       |
   20|       |// Grouping of constants.  We may want to make some of these
   21|       |// parameters set via options.
   22|       |namespace config {
   23|       |static const int kNumLevels = 7;
   24|       |
   25|       |// Level-0 compaction is started when we hit this many files.
   26|       |static const int kL0_CompactionTrigger = 4;
   27|       |
   28|       |// Soft limit on number of level-0 files.  We slow down writes at this point.
   29|       |static const int kL0_SlowdownWritesTrigger = 8;
   30|       |
   31|       |// Maximum number of level-0 files.  We stop writes at this point.
   32|       |static const int kL0_StopWritesTrigger = 12;
   33|       |
   34|       |// Maximum level to which a new compacted memtable is pushed if it
   35|       |// does not create overlap.  We try to push to level 2 to avoid the
   36|       |// relatively expensive level 0=>1 compactions and to avoid some
   37|       |// expensive manifest file operations.  We do not push all the way to
   38|       |// the largest level since that can generate a lot of wasted disk
   39|       |// space if the same key space is being repeatedly overwritten.
   40|       |static const int kMaxMemCompactLevel = 2;
   41|       |
   42|       |// Approximate gap in bytes between samples of data read during iteration.
   43|       |static const int kReadBytesPeriod = 1048576;
   44|       |
   45|       |}  // namespace config
   46|       |
   47|       |class InternalKey;
   48|       |
   49|       |// Value types encoded as the last component of internal keys.
   50|       |// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk
   51|       |// data structures.
   52|       |enum ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 };
   53|       |// kValueTypeForSeek defines the ValueType that should be passed when
   54|       |// constructing a ParsedInternalKey object for seeking to a particular
   55|       |// sequence number (since we sort sequence numbers in decreasing order
   56|       |// and the value type is embedded as the low 8 bits in the sequence
   57|       |// number in internal keys, we need to use the highest-numbered
   58|       |// ValueType, not the lowest).
   59|       |static const ValueType kValueTypeForSeek = kTypeValue;
   60|       |
   61|       |typedef uint64_t SequenceNumber;
   62|       |
   63|       |// We leave eight bits empty at the bottom so a type and sequence#
   64|       |// can be packed together into 64-bits.
   65|       |static const SequenceNumber kMaxSequenceNumber = ((0x1ull << 56) - 1);
   66|       |
   67|       |struct ParsedInternalKey {
   68|       |  Slice user_key;
   69|       |  SequenceNumber sequence;
   70|       |  ValueType type;
   71|       |
   72|      0|  ParsedInternalKey() {}  // Intentionally left uninitialized (for speed)
   73|       |  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)
   74|      0|      : user_key(u), sequence(seq), type(t) {}
   75|       |  std::string DebugString() const;
   76|       |};
   77|       |
   78|       |// Return the length of the encoding of "key".
   79|      0|inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {
   80|      0|  return key.user_key.size() + 8;
   81|      0|}
   82|       |
   83|       |// Append the serialization of "key" to *result.
   84|       |void AppendInternalKey(std::string* result, const ParsedInternalKey& key);
   85|       |
   86|       |// Attempt to parse an internal key from "internal_key".  On success,
   87|       |// stores the parsed data in "*result", and returns true.
   88|       |//
   89|       |// On error, returns false, leaves "*result" in an undefined state.
   90|       |bool ParseInternalKey(const Slice& internal_key, ParsedInternalKey* result);
   91|       |
   92|       |// Returns the user key portion of an internal key.
   93|      0|inline Slice ExtractUserKey(const Slice& internal_key) {
   94|      0|  assert(internal_key.size() >= 8);
   95|      0|  return Slice(internal_key.data(), internal_key.size() - 8);
   96|      0|}
   97|       |
   98|       |// A comparator for internal keys that uses a specified comparator for
   99|       |// the user key portion and breaks ties by decreasing sequence number.
  100|       |class InternalKeyComparator : public Comparator {
  101|       | private:
  102|       |  const Comparator* user_comparator_;
  103|       |
  104|       | public:
  105|      0|  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) {}
  106|       |  virtual const char* Name() const;
  107|       |  virtual int Compare(const Slice& a, const Slice& b) const;
  108|       |  virtual void FindShortestSeparator(std::string* start,
  109|       |                                     const Slice& limit) const;
  110|       |  virtual void FindShortSuccessor(std::string* key) const;
  111|       |
  112|      0|  const Comparator* user_comparator() const { return user_comparator_; }
  113|       |
  114|       |  int Compare(const InternalKey& a, const InternalKey& b) const;
  115|       |};
  116|       |
  117|       |// Filter policy wrapper that converts from internal keys to user keys
  118|       |class InternalFilterPolicy : public FilterPolicy {
  119|       | private:
  120|       |  const FilterPolicy* const user_policy_;
  121|       |
  122|       | public:
  123|      0|  explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) {}
  124|       |  virtual const char* Name() const;
  125|       |  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const;
  126|       |  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const;
  127|       |};
  128|       |
  129|       |// Modules in this directory should keep internal keys wrapped inside
  130|       |// the following class instead of plain strings so that we do not
  131|       |// incorrectly use string comparisons instead of an InternalKeyComparator.
  132|       |class InternalKey {
  133|       | private:
  134|       |  std::string rep_;
  135|       |
  136|       | public:
  137|      0|  InternalKey() {}  // Leave rep_ as empty to indicate it is invalid
  138|      0|  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {
  139|      0|    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
  140|      0|  }
  141|       |
  142|      0|  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }
  143|      0|  Slice Encode() const {
  144|      0|    assert(!rep_.empty());
  145|      0|    return rep_;
  146|      0|  }
  147|       |
  148|      0|  Slice user_key() const { return ExtractUserKey(rep_); }
  149|       |
  150|      0|  void SetFrom(const ParsedInternalKey& p) {
  151|      0|    rep_.clear();
  152|      0|    AppendInternalKey(&rep_, p);
  153|      0|  }
  154|       |
  155|      0|  void Clear() { rep_.clear(); }
  156|       |
  157|       |  std::string DebugString() const;
  158|       |};
  159|       |
  160|       |inline int InternalKeyComparator::Compare(const InternalKey& a,
  161|      0|                                          const InternalKey& b) const {
  162|      0|  return Compare(a.Encode(), b.Encode());
  163|      0|}
  164|       |
  165|       |inline bool ParseInternalKey(const Slice& internal_key,
  166|      0|                             ParsedInternalKey* result) {
  167|      0|  const size_t n = internal_key.size();
  168|      0|  if (n < 8) return false;
  169|      0|  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  170|      0|  unsigned char c = num & 0xff;
  171|      0|  result->sequence = num >> 8;
  172|      0|  result->type = static_cast<ValueType>(c);
  173|      0|  result->user_key = Slice(internal_key.data(), n - 8);
  174|      0|  return (c <= static_cast<unsigned char>(kTypeValue));
  175|      0|}
  176|       |
  177|       |// A helper class useful for DBImpl::Get()
  178|       |class LookupKey {
  179|       | public:
  180|       |  // Initialize *this for looking up user_key at a snapshot with
  181|       |  // the specified sequence number.
  182|       |  LookupKey(const Slice& user_key, SequenceNumber sequence);
  183|       |
  184|       |  LookupKey(const LookupKey&) = delete;
  185|       |  LookupKey& operator=(const LookupKey&) = delete;
  186|       |
  187|       |  ~LookupKey();
  188|       |
  189|       |  // Return a key suitable for lookup in a MemTable.
  190|      0|  Slice memtable_key() const { return Slice(start_, end_ - start_); }
  191|       |
  192|       |  // Return an internal key (suitable for passing to an internal iterator)
  193|      0|  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }
  194|       |
  195|       |  // Return the user key
  196|      0|  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }
  197|       |
  198|       | private:
  199|       |  // We construct a char array of the form:
  200|       |  //    klength  varint32               <-- start_
  201|       |  //    userkey  char[klength]          <-- kstart_
  202|       |  //    tag      uint64
  203|       |  //                                    <-- end_
  204|       |  // The array is a suitable MemTable key.
  205|       |  // The suffix starting with "userkey" can be used as an InternalKey.
  206|       |  const char* start_;
  207|       |  const char* kstart_;
  208|       |  const char* end_;
  209|       |  char space_[200];  // Avoid allocation for short keys
  210|       |};
  211|       |
  212|      0|inline LookupKey::~LookupKey() {
  213|      0|  if (start_ != space_) delete[] start_;
  214|      0|}
  215|       |
  216|       |}  // namespace leveldb
  217|       |
  218|       |#endif  // STORAGE_LEVELDB_DB_DBFORMAT_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/filename.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/filename.h"
    6|       |
    7|       |#include <ctype.h>
    8|       |#include <stdio.h>
    9|       |
   10|       |#include "db/dbformat.h"
   11|       |#include "leveldb/env.h"
   12|       |#include "util/logging.h"
   13|       |
   14|       |namespace leveldb {
   15|       |
   16|       |// A utility routine: write "data" to the named file and Sync() it.
   17|       |Status WriteStringToFileSync(Env* env, const Slice& data,
   18|       |                             const std::string& fname);
   19|       |
   20|       |static std::string MakeFileName(const std::string& dbname, uint64_t number,
   21|      0|                                const char* suffix) {
   22|      0|  char buf[100];
   23|      0|  snprintf(buf, sizeof(buf), "/%06llu.%s",
   24|      0|           static_cast<unsigned long long>(number), suffix);
   25|      0|  return dbname + buf;
   26|      0|}
   27|       |
   28|      0|std::string LogFileName(const std::string& dbname, uint64_t number) {
   29|      0|  assert(number > 0);
   30|      0|  return MakeFileName(dbname, number, "log");
   31|      0|}
   32|       |
   33|      0|std::string TableFileName(const std::string& dbname, uint64_t number) {
   34|      0|  assert(number > 0);
   35|      0|  return MakeFileName(dbname, number, "ldb");
   36|      0|}
   37|       |
   38|      0|std::string SSTTableFileName(const std::string& dbname, uint64_t number) {
   39|      0|  assert(number > 0);
   40|      0|  return MakeFileName(dbname, number, "sst");
   41|      0|}
   42|       |
   43|      0|std::string DescriptorFileName(const std::string& dbname, uint64_t number) {
   44|      0|  assert(number > 0);
   45|      0|  char buf[100];
   46|      0|  snprintf(buf, sizeof(buf), "/MANIFEST-%06llu",
   47|      0|           static_cast<unsigned long long>(number));
   48|      0|  return dbname + buf;
   49|      0|}
   50|       |
   51|      0|std::string CurrentFileName(const std::string& dbname) {
   52|      0|  return dbname + "/CURRENT";
   53|      0|}
   54|       |
   55|      0|std::string LockFileName(const std::string& dbname) { return dbname + "/LOCK"; }
   56|       |
   57|      0|std::string TempFileName(const std::string& dbname, uint64_t number) {
   58|      0|  assert(number > 0);
   59|      0|  return MakeFileName(dbname, number, "dbtmp");
   60|      0|}
   61|       |
   62|      0|std::string InfoLogFileName(const std::string& dbname) {
   63|      0|  return dbname + "/LOG";
   64|      0|}
   65|       |
   66|       |// Return the name of the old info log file for "dbname".
   67|      0|std::string OldInfoLogFileName(const std::string& dbname) {
   68|      0|  return dbname + "/LOG.old";
   69|      0|}
   70|       |
   71|       |// Owned filenames have the form:
   72|       |//    dbname/CURRENT
   73|       |//    dbname/LOCK
   74|       |//    dbname/LOG
   75|       |//    dbname/LOG.old
   76|       |//    dbname/MANIFEST-[0-9]+
   77|       |//    dbname/[0-9]+.(log|sst|ldb)
   78|       |bool ParseFileName(const std::string& filename, uint64_t* number,
   79|      0|                   FileType* type) {
   80|      0|  Slice rest(filename);
   81|      0|  if (rest == "CURRENT") {
   82|      0|    *number = 0;
   83|      0|    *type = kCurrentFile;
   84|      0|  } else if (rest == "LOCK") {
   85|      0|    *number = 0;
   86|      0|    *type = kDBLockFile;
   87|      0|  } else if (rest == "LOG" || rest == "LOG.old") {
   88|      0|    *number = 0;
   89|      0|    *type = kInfoLogFile;
   90|      0|  } else if (rest.starts_with("MANIFEST-")) {
   91|      0|    rest.remove_prefix(strlen("MANIFEST-"));
   92|      0|    uint64_t num;
   93|      0|    if (!ConsumeDecimalNumber(&rest, &num)) {
   94|      0|      return false;
   95|      0|    }
   96|      0|    if (!rest.empty()) {
   97|      0|      return false;
   98|      0|    }
   99|      0|    *type = kDescriptorFile;
  100|      0|    *number = num;
  101|      0|  } else {
  102|      0|    // Avoid strtoull() to keep filename format independent of the
  103|      0|    // current locale
  104|      0|    uint64_t num;
  105|      0|    if (!ConsumeDecimalNumber(&rest, &num)) {
  106|      0|      return false;
  107|      0|    }
  108|      0|    Slice suffix = rest;
  109|      0|    if (suffix == Slice(".log")) {
  110|      0|      *type = kLogFile;
  111|      0|    } else if (suffix == Slice(".sst") || suffix == Slice(".ldb")) {
  112|      0|      *type = kTableFile;
  113|      0|    } else if (suffix == Slice(".dbtmp")) {
  114|      0|      *type = kTempFile;
  115|      0|    } else {
  116|      0|      return false;
  117|      0|    }
  118|      0|    *number = num;
  119|      0|  }
  120|      0|  return true;
  121|      0|}
  122|       |
  123|       |Status SetCurrentFile(Env* env, const std::string& dbname,
  124|      0|                      uint64_t descriptor_number) {
  125|      0|  // Remove leading "dbname/" and add newline to manifest file name
  126|      0|  std::string manifest = DescriptorFileName(dbname, descriptor_number);
  127|      0|  Slice contents = manifest;
  128|      0|  assert(contents.starts_with(dbname + "/"));
  129|      0|  contents.remove_prefix(dbname.size() + 1);
  130|      0|  std::string tmp = TempFileName(dbname, descriptor_number);
  131|      0|  Status s = WriteStringToFileSync(env, contents.ToString() + "\n", tmp);
  132|      0|  if (s.ok()) {
  133|      0|    s = env->RenameFile(tmp, CurrentFileName(dbname));
  134|      0|  }
  135|      0|  if (!s.ok()) {
  136|      0|    env->DeleteFile(tmp);
  137|      0|  }
  138|      0|  return s;
  139|      0|}
  140|       |
  141|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/log_reader.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/log_reader.h"
    6|       |
    7|       |#include <stdio.h>
    8|       |
    9|       |#include "leveldb/env.h"
   10|       |#include "util/coding.h"
   11|       |#include "util/crc32c.h"
   12|       |
   13|       |namespace leveldb {
   14|       |namespace log {
   15|       |
   16|      0|Reader::Reporter::~Reporter() {}
   17|       |
   18|       |Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,
   19|       |               uint64_t initial_offset)
   20|       |    : file_(file),
   21|       |      reporter_(reporter),
   22|       |      checksum_(checksum),
   23|       |      backing_store_(new char[kBlockSize]),
   24|       |      buffer_(),
   25|       |      eof_(false),
   26|       |      last_record_offset_(0),
   27|       |      end_of_buffer_offset_(0),
   28|       |      initial_offset_(initial_offset),
   29|      0|      resyncing_(initial_offset > 0) {}
   30|       |
   31|      0|Reader::~Reader() { delete[] backing_store_; }
   32|       |
   33|      0|bool Reader::SkipToInitialBlock() {
   34|      0|  const size_t offset_in_block = initial_offset_ % kBlockSize;
   35|      0|  uint64_t block_start_location = initial_offset_ - offset_in_block;
   36|      0|
   37|      0|  // Don't search a block if we'd be in the trailer
   38|      0|  if (offset_in_block > kBlockSize - 6) {
   39|      0|    block_start_location += kBlockSize;
   40|      0|  }
   41|      0|
   42|      0|  end_of_buffer_offset_ = block_start_location;
   43|      0|
   44|      0|  // Skip to start of first block that can contain the initial record
   45|      0|  if (block_start_location > 0) {
   46|      0|    Status skip_status = file_->Skip(block_start_location);
   47|      0|    if (!skip_status.ok()) {
   48|      0|      ReportDrop(block_start_location, skip_status);
   49|      0|      return false;
   50|      0|    }
   51|      0|  }
   52|      0|
   53|      0|  return true;
   54|      0|}
   55|       |
   56|      0|bool Reader::ReadRecord(Slice* record, std::string* scratch) {
   57|      0|  if (last_record_offset_ < initial_offset_) {
   58|      0|    if (!SkipToInitialBlock()) {
   59|      0|      return false;
   60|      0|    }
   61|      0|  }
   62|      0|
   63|      0|  scratch->clear();
   64|      0|  record->clear();
   65|      0|  bool in_fragmented_record = false;
   66|      0|  // Record offset of the logical record that we're reading
   67|      0|  // 0 is a dummy value to make compilers happy
   68|      0|  uint64_t prospective_record_offset = 0;
   69|      0|
   70|      0|  Slice fragment;
   71|      0|  while (true) {
   72|      0|    const unsigned int record_type = ReadPhysicalRecord(&fragment);
   73|      0|
   74|      0|    // ReadPhysicalRecord may have only had an empty trailer remaining in its
   75|      0|    // internal buffer. Calculate the offset of the next physical record now
   76|      0|    // that it has returned, properly accounting for its header size.
   77|      0|    uint64_t physical_record_offset =
   78|      0|        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size();
   79|      0|
   80|      0|    if (resyncing_) {
   81|      0|      if (record_type == kMiddleType) {
   82|      0|        continue;
   83|      0|      } else if (record_type == kLastType) {
   84|      0|        resyncing_ = false;
   85|      0|        continue;
   86|      0|      } else {
   87|      0|        resyncing_ = false;
   88|      0|      }
   89|      0|    }
   90|      0|
   91|      0|    switch (record_type) {
   92|      0|      case kFullType:
   93|      0|        if (in_fragmented_record) {
   94|      0|          // Handle bug in earlier versions of log::Writer where
   95|      0|          // it could emit an empty kFirstType record at the tail end
   96|      0|          // of a block followed by a kFullType or kFirstType record
   97|      0|          // at the beginning of the next block.
   98|      0|          if (!scratch->empty()) {
   99|      0|            ReportCorruption(scratch->size(), "partial record without end(1)");
  100|      0|          }
  101|      0|        }
  102|      0|        prospective_record_offset = physical_record_offset;
  103|      0|        scratch->clear();
  104|      0|        *record = fragment;
  105|      0|        last_record_offset_ = prospective_record_offset;
  106|      0|        return true;
  107|      0|
  108|      0|      case kFirstType:
  109|      0|        if (in_fragmented_record) {
  110|      0|          // Handle bug in earlier versions of log::Writer where
  111|      0|          // it could emit an empty kFirstType record at the tail end
  112|      0|          // of a block followed by a kFullType or kFirstType record
  113|      0|          // at the beginning of the next block.
  114|      0|          if (!scratch->empty()) {
  115|      0|            ReportCorruption(scratch->size(), "partial record without end(2)");
  116|      0|          }
  117|      0|        }
  118|      0|        prospective_record_offset = physical_record_offset;
  119|      0|        scratch->assign(fragment.data(), fragment.size());
  120|      0|        in_fragmented_record = true;
  121|      0|        break;
  122|      0|
  123|      0|      case kMiddleType:
  124|      0|        if (!in_fragmented_record) {
  125|      0|          ReportCorruption(fragment.size(),
  126|      0|                           "missing start of fragmented record(1)");
  127|      0|        } else {
  128|      0|          scratch->append(fragment.data(), fragment.size());
  129|      0|        }
  130|      0|        break;
  131|      0|
  132|      0|      case kLastType:
  133|      0|        if (!in_fragmented_record) {
  134|      0|          ReportCorruption(fragment.size(),
  135|      0|                           "missing start of fragmented record(2)");
  136|      0|        } else {
  137|      0|          scratch->append(fragment.data(), fragment.size());
  138|      0|          *record = Slice(*scratch);
  139|      0|          last_record_offset_ = prospective_record_offset;
  140|      0|          return true;
  141|      0|        }
  142|      0|        break;
  143|      0|
  144|      0|      case kEof:
  145|      0|        if (in_fragmented_record) {
  146|      0|          // This can be caused by the writer dying immediately after
  147|      0|          // writing a physical record but before completing the next; don't
  148|      0|          // treat it as a corruption, just ignore the entire logical record.
  149|      0|          scratch->clear();
  150|      0|        }
  151|      0|        return false;
  152|      0|
  153|      0|      case kBadRecord:
  154|      0|        if (in_fragmented_record) {
  155|      0|          ReportCorruption(scratch->size(), "error in middle of record");
  156|      0|          in_fragmented_record = false;
  157|      0|          scratch->clear();
  158|      0|        }
  159|      0|        break;
  160|      0|
  161|      0|      default: {
  162|      0|        char buf[40];
  163|      0|        snprintf(buf, sizeof(buf), "unknown record type %u", record_type);
  164|      0|        ReportCorruption(
  165|      0|            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),
  166|      0|            buf);
  167|      0|        in_fragmented_record = false;
  168|      0|        scratch->clear();
  169|      0|        break;
  170|      0|      }
  171|      0|    }
  172|      0|  }
  173|      0|  return false;
  174|      0|}
  175|       |
  176|      0|uint64_t Reader::LastRecordOffset() { return last_record_offset_; }
  177|       |
  178|      0|void Reader::ReportCorruption(uint64_t bytes, const char* reason) {
  179|      0|  ReportDrop(bytes, Status::Corruption(reason));
  180|      0|}
  181|       |
  182|      0|void Reader::ReportDrop(uint64_t bytes, const Status& reason) {
  183|      0|  if (reporter_ != nullptr &&
  184|      0|      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {
  185|      0|    reporter_->Corruption(static_cast<size_t>(bytes), reason);
  186|      0|  }
  187|      0|}
  188|       |
  189|      0|unsigned int Reader::ReadPhysicalRecord(Slice* result) {
  190|      0|  while (true) {
  191|      0|    if (buffer_.size() < kHeaderSize) {
  192|      0|      if (!eof_) {
  193|      0|        // Last read was a full read, so this is a trailer to skip
  194|      0|        buffer_.clear();
  195|      0|        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
  196|      0|        end_of_buffer_offset_ += buffer_.size();
  197|      0|        if (!status.ok()) {
  198|      0|          buffer_.clear();
  199|      0|          ReportDrop(kBlockSize, status);
  200|      0|          eof_ = true;
  201|      0|          return kEof;
  202|      0|        } else if (buffer_.size() < kBlockSize) {
  203|      0|          eof_ = true;
  204|      0|        }
  205|      0|        continue;
  206|      0|      } else {
  207|      0|        // Note that if buffer_ is non-empty, we have a truncated header at the
  208|      0|        // end of the file, which can be caused by the writer crashing in the
  209|      0|        // middle of writing the header. Instead of considering this an error,
  210|      0|        // just report EOF.
  211|      0|        buffer_.clear();
  212|      0|        return kEof;
  213|      0|      }
  214|      0|    }
  215|      0|
  216|      0|    // Parse the header
  217|      0|    const char* header = buffer_.data();
  218|      0|    const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;
  219|      0|    const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;
  220|      0|    const unsigned int type = header[6];
  221|      0|    const uint32_t length = a | (b << 8);
  222|      0|    if (kHeaderSize + length > buffer_.size()) {
  223|      0|      size_t drop_size = buffer_.size();
  224|      0|      buffer_.clear();
  225|      0|      if (!eof_) {
  226|      0|        ReportCorruption(drop_size, "bad record length");
  227|      0|        return kBadRecord;
  228|      0|      }
  229|      0|      // If the end of the file has been reached without reading |length| bytes
  230|      0|      // of payload, assume the writer died in the middle of writing the record.
  231|      0|      // Don't report a corruption.
  232|      0|      return kEof;
  233|      0|    }
  234|      0|
  235|      0|    if (type == kZeroType && length == 0) {
  236|      0|      // Skip zero length record without reporting any drops since
  237|      0|      // such records are produced by the mmap based writing code in
  238|      0|      // env_posix.cc that preallocates file regions.
  239|      0|      buffer_.clear();
  240|      0|      return kBadRecord;
  241|      0|    }
  242|      0|
  243|      0|    // Check crc
  244|      0|    if (checksum_) {
  245|      0|      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));
  246|      0|      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);
  247|      0|      if (actual_crc != expected_crc) {
  248|      0|        // Drop the rest of the buffer since "length" itself may have
  249|      0|        // been corrupted and if we trust it, we could find some
  250|      0|        // fragment of a real log record that just happens to look
  251|      0|        // like a valid log record.
  252|      0|        size_t drop_size = buffer_.size();
  253|      0|        buffer_.clear();
  254|      0|        ReportCorruption(drop_size, "checksum mismatch");
  255|      0|        return kBadRecord;
  256|      0|      }
  257|      0|    }
  258|      0|
  259|      0|    buffer_.remove_prefix(kHeaderSize + length);
  260|      0|
  261|      0|    // Skip physical record that started before initial_offset_
  262|      0|    if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <
  263|      0|        initial_offset_) {
  264|      0|      result->clear();
  265|      0|      return kBadRecord;
  266|      0|    }
  267|      0|
  268|      0|    *result = Slice(header + kHeaderSize, length);
  269|      0|    return type;
  270|      0|  }
  271|      0|}
  272|       |
  273|       |}  // namespace log
  274|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/log_writer.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/log_writer.h"
    6|       |
    7|       |#include <stdint.h>
    8|       |
    9|       |#include "leveldb/env.h"
   10|       |#include "util/coding.h"
   11|       |#include "util/crc32c.h"
   12|       |
   13|       |namespace leveldb {
   14|       |namespace log {
   15|       |
   16|      0|static void InitTypeCrc(uint32_t* type_crc) {
   17|      0|  for (int i = 0; i <= kMaxRecordType; i++) {
   18|      0|    char t = static_cast<char>(i);
   19|      0|    type_crc[i] = crc32c::Value(&t, 1);
   20|      0|  }
   21|      0|}
   22|       |
   23|      0|Writer::Writer(WritableFile* dest) : dest_(dest), block_offset_(0) {
   24|      0|  InitTypeCrc(type_crc_);
   25|      0|}
   26|       |
   27|       |Writer::Writer(WritableFile* dest, uint64_t dest_length)
   28|      0|    : dest_(dest), block_offset_(dest_length % kBlockSize) {
   29|      0|  InitTypeCrc(type_crc_);
   30|      0|}
   31|       |
   32|      0|Writer::~Writer() {}
   33|       |
   34|      0|Status Writer::AddRecord(const Slice& slice) {
   35|      0|  const char* ptr = slice.data();
   36|      0|  size_t left = slice.size();
   37|      0|
   38|      0|  // Fragment the record if necessary and emit it.  Note that if slice
   39|      0|  // is empty, we still want to iterate once to emit a single
   40|      0|  // zero-length record
   41|      0|  Status s;
   42|      0|  bool begin = true;
   43|      0|  do {
   44|      0|    const int leftover = kBlockSize - block_offset_;
   45|      0|    assert(leftover >= 0);
   46|      0|    if (leftover < kHeaderSize) {
   47|      0|      // Switch to a new block
   48|      0|      if (leftover > 0) {
   49|      0|        // Fill the trailer (literal below relies on kHeaderSize being 7)
   50|      0|        static_assert(kHeaderSize == 7, "");
   51|      0|        dest_->Append(Slice("\x00\x00\x00\x00\x00\x00", leftover));
   52|      0|      }
   53|      0|      block_offset_ = 0;
   54|      0|    }
   55|      0|
   56|      0|    // Invariant: we never leave < kHeaderSize bytes in a block.
   57|      0|    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);
   58|      0|
   59|      0|    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
   60|      0|    const size_t fragment_length = (left < avail) ? left : avail;
   61|      0|
   62|      0|    RecordType type;
   63|      0|    const bool end = (left == fragment_length);
   64|      0|    if (begin && end) {
   65|      0|      type = kFullType;
   66|      0|    } else if (begin) {
   67|      0|      type = kFirstType;
   68|      0|    } else if (end) {
   69|      0|      type = kLastType;
   70|      0|    } else {
   71|      0|      type = kMiddleType;
   72|      0|    }
   73|      0|
   74|      0|    s = EmitPhysicalRecord(type, ptr, fragment_length);
   75|      0|    ptr += fragment_length;
   76|      0|    left -= fragment_length;
   77|      0|    begin = false;
   78|      0|  } while (s.ok() && left > 0);
   79|      0|  return s;
   80|      0|}
   81|       |
   82|       |Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr,
   83|      0|                                  size_t length) {
   84|      0|  assert(length <= 0xffff);  // Must fit in two bytes
   85|      0|  assert(block_offset_ + kHeaderSize + length <= kBlockSize);
   86|      0|
   87|      0|  // Format the header
   88|      0|  char buf[kHeaderSize];
   89|      0|  buf[4] = static_cast<char>(length & 0xff);
   90|      0|  buf[5] = static_cast<char>(length >> 8);
   91|      0|  buf[6] = static_cast<char>(t);
   92|      0|
   93|      0|  // Compute the crc of the record type and the payload.
   94|      0|  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, length);
   95|      0|  crc = crc32c::Mask(crc);  // Adjust for storage
   96|      0|  EncodeFixed32(buf, crc);
   97|      0|
   98|      0|  // Write the header and the payload
   99|      0|  Status s = dest_->Append(Slice(buf, kHeaderSize));
  100|      0|  if (s.ok()) {
  101|      0|    s = dest_->Append(Slice(ptr, length));
  102|      0|    if (s.ok()) {
  103|      0|      s = dest_->Flush();
  104|      0|    }
  105|      0|  }
  106|      0|  block_offset_ += kHeaderSize + length;
  107|      0|  return s;
  108|      0|}
  109|       |
  110|       |}  // namespace log
  111|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/memtable.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/memtable.h"
    6|       |#include "db/dbformat.h"
    7|       |#include "leveldb/comparator.h"
    8|       |#include "leveldb/env.h"
    9|       |#include "leveldb/iterator.h"
   10|       |#include "util/coding.h"
   11|       |
   12|       |namespace leveldb {
   13|       |
   14|      0|static Slice GetLengthPrefixedSlice(const char* data) {
   15|      0|  uint32_t len;
   16|      0|  const char* p = data;
   17|      0|  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume "p" is not corrupted
   18|      0|  return Slice(p, len);
   19|      0|}
   20|       |
   21|       |MemTable::MemTable(const InternalKeyComparator& comparator)
   22|      0|    : comparator_(comparator), refs_(0), table_(comparator_, &arena_) {}
   23|       |
   24|      0|MemTable::~MemTable() { assert(refs_ == 0); }
   25|       |
   26|      0|size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }
   27|       |
   28|       |int MemTable::KeyComparator::operator()(const char* aptr,
   29|      0|                                        const char* bptr) const {
   30|      0|  // Internal keys are encoded as length-prefixed strings.
   31|      0|  Slice a = GetLengthPrefixedSlice(aptr);
   32|      0|  Slice b = GetLengthPrefixedSlice(bptr);
   33|      0|  return comparator.Compare(a, b);
   34|      0|}
   35|       |
   36|       |// Encode a suitable internal key target for "target" and return it.
   37|       |// Uses *scratch as scratch space, and the returned pointer will point
   38|       |// into this scratch space.
   39|      0|static const char* EncodeKey(std::string* scratch, const Slice& target) {
   40|      0|  scratch->clear();
   41|      0|  PutVarint32(scratch, target.size());
   42|      0|  scratch->append(target.data(), target.size());
   43|      0|  return scratch->data();
   44|      0|}
   45|       |
   46|       |class MemTableIterator : public Iterator {
   47|       | public:
   48|      0|  explicit MemTableIterator(MemTable::Table* table) : iter_(table) {}
   49|       |
   50|      0|  virtual bool Valid() const { return iter_.Valid(); }
   51|      0|  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }
   52|      0|  virtual void SeekToFirst() { iter_.SeekToFirst(); }
   53|      0|  virtual void SeekToLast() { iter_.SeekToLast(); }
   54|      0|  virtual void Next() { iter_.Next(); }
   55|      0|  virtual void Prev() { iter_.Prev(); }
   56|      0|  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }
   57|      0|  virtual Slice value() const {
   58|      0|    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
   59|      0|    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
   60|      0|  }
   61|       |
   62|      0|  virtual Status status() const { return Status::OK(); }
   63|       |
   64|       | private:
   65|       |  MemTable::Table::Iterator iter_;
   66|       |  std::string tmp_;  // For passing to EncodeKey
   67|       |
   68|       |  // No copying allowed
   69|       |  MemTableIterator(const MemTableIterator&);
   70|       |  void operator=(const MemTableIterator&);
   71|       |};
   72|       |
   73|      0|Iterator* MemTable::NewIterator() { return new MemTableIterator(&table_); }
   74|       |
   75|       |void MemTable::Add(SequenceNumber s, ValueType type, const Slice& key,
   76|      0|                   const Slice& value) {
   77|      0|  // Format of an entry is concatenation of:
   78|      0|  //  key_size     : varint32 of internal_key.size()
   79|      0|  //  key bytes    : char[internal_key.size()]
   80|      0|  //  value_size   : varint32 of value.size()
   81|      0|  //  value bytes  : char[value.size()]
   82|      0|  size_t key_size = key.size();
   83|      0|  size_t val_size = value.size();
   84|      0|  size_t internal_key_size = key_size + 8;
   85|      0|  const size_t encoded_len = VarintLength(internal_key_size) +
   86|      0|                             internal_key_size + VarintLength(val_size) +
   87|      0|                             val_size;
   88|      0|  char* buf = arena_.Allocate(encoded_len);
   89|      0|  char* p = EncodeVarint32(buf, internal_key_size);
   90|      0|  memcpy(p, key.data(), key_size);
   91|      0|  p += key_size;
   92|      0|  EncodeFixed64(p, (s << 8) | type);
   93|      0|  p += 8;
   94|      0|  p = EncodeVarint32(p, val_size);
   95|      0|  memcpy(p, value.data(), val_size);
   96|      0|  assert(p + val_size == buf + encoded_len);
   97|      0|  table_.Insert(buf);
   98|      0|}
   99|       |
  100|      0|bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {
  101|      0|  Slice memkey = key.memtable_key();
  102|      0|  Table::Iterator iter(&table_);
  103|      0|  iter.Seek(memkey.data());
  104|      0|  if (iter.Valid()) {
  105|      0|    // entry format is:
  106|      0|    //    klength  varint32
  107|      0|    //    userkey  char[klength]
  108|      0|    //    tag      uint64
  109|      0|    //    vlength  varint32
  110|      0|    //    value    char[vlength]
  111|      0|    // Check that it belongs to same user key.  We do not check the
  112|      0|    // sequence number since the Seek() call above should have skipped
  113|      0|    // all entries with overly large sequence numbers.
  114|      0|    const char* entry = iter.key();
  115|      0|    uint32_t key_length;
  116|      0|    const char* key_ptr = GetVarint32Ptr(entry, entry + 5, &key_length);
  117|      0|    if (comparator_.comparator.user_comparator()->Compare(
  118|      0|            Slice(key_ptr, key_length - 8), key.user_key()) == 0) {
  119|      0|      // Correct user key
  120|      0|      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
  121|      0|      switch (static_cast<ValueType>(tag & 0xff)) {
  122|      0|        case kTypeValue: {
  123|      0|          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
  124|      0|          value->assign(v.data(), v.size());
  125|      0|          return true;
  126|      0|        }
  127|      0|        case kTypeDeletion:
  128|      0|          *s = Status::NotFound(Slice());
  129|      0|          return true;
  130|      0|      }
  131|      0|    }
  132|      0|  }
  133|      0|  return false;
  134|      0|}
  135|       |
  136|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/memtable.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_MEMTABLE_H_
    6|       |#define STORAGE_LEVELDB_DB_MEMTABLE_H_
    7|       |
    8|       |#include <string>
    9|       |
   10|       |#include "db/dbformat.h"
   11|       |#include "db/skiplist.h"
   12|       |#include "leveldb/db.h"
   13|       |#include "util/arena.h"
   14|       |
   15|       |namespace leveldb {
   16|       |
   17|       |class InternalKeyComparator;
   18|       |class MemTableIterator;
   19|       |
   20|       |class MemTable {
   21|       | public:
   22|       |  // MemTables are reference counted.  The initial reference count
   23|       |  // is zero and the caller must call Ref() at least once.
   24|       |  explicit MemTable(const InternalKeyComparator& comparator);
   25|       |
   26|       |  MemTable(const MemTable&) = delete;
   27|       |  MemTable& operator=(const MemTable&) = delete;
   28|       |
   29|       |  // Increase reference count.
   30|      0|  void Ref() { ++refs_; }
   31|       |
   32|       |  // Drop reference count.  Delete if no more references exist.
   33|      0|  void Unref() {
   34|      0|    --refs_;
   35|      0|    assert(refs_ >= 0);
   36|      0|    if (refs_ <= 0) {
   37|      0|      delete this;
   38|      0|    }
   39|      0|  }
   40|       |
   41|       |  // Returns an estimate of the number of bytes of data in use by this
   42|       |  // data structure. It is safe to call when MemTable is being modified.
   43|       |  size_t ApproximateMemoryUsage();
   44|       |
   45|       |  // Return an iterator that yields the contents of the memtable.
   46|       |  //
   47|       |  // The caller must ensure that the underlying MemTable remains live
   48|       |  // while the returned iterator is live.  The keys returned by this
   49|       |  // iterator are internal keys encoded by AppendInternalKey in the
   50|       |  // db/format.{h,cc} module.
   51|       |  Iterator* NewIterator();
   52|       |
   53|       |  // Add an entry into memtable that maps key to value at the
   54|       |  // specified sequence number and with the specified type.
   55|       |  // Typically value will be empty if type==kTypeDeletion.
   56|       |  void Add(SequenceNumber seq, ValueType type, const Slice& key,
   57|       |           const Slice& value);
   58|       |
   59|       |  // If memtable contains a value for key, store it in *value and return true.
   60|       |  // If memtable contains a deletion for key, store a NotFound() error
   61|       |  // in *status and return true.
   62|       |  // Else, return false.
   63|       |  bool Get(const LookupKey& key, std::string* value, Status* s);
   64|       |
   65|       | private:
   66|       |  friend class MemTableIterator;
   67|       |  friend class MemTableBackwardIterator;
   68|       |
   69|       |  struct KeyComparator {
   70|       |    const InternalKeyComparator comparator;
   71|      0|    explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) {}
   72|       |    int operator()(const char* a, const char* b) const;
   73|       |  };
   74|       |
   75|       |  typedef SkipList<const char*, KeyComparator> Table;
   76|       |
   77|       |  ~MemTable();  // Private since only Unref() should be used to delete it
   78|       |
   79|       |  KeyComparator comparator_;
   80|       |  int refs_;
   81|       |  Arena arena_;
   82|       |  Table table_;
   83|       |};
   84|       |
   85|       |}  // namespace leveldb
   86|       |
   87|       |#endif  // STORAGE_LEVELDB_DB_MEMTABLE_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/skiplist.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_
    6|       |#define STORAGE_LEVELDB_DB_SKIPLIST_H_
    7|       |
    8|       |// Thread safety
    9|       |// -------------
   10|       |//
   11|       |// Writes require external synchronization, most likely a mutex.
   12|       |// Reads require a guarantee that the SkipList will not be destroyed
   13|       |// while the read is in progress.  Apart from that, reads progress
   14|       |// without any internal locking or synchronization.
   15|       |//
   16|       |// Invariants:
   17|       |//
   18|       |// (1) Allocated nodes are never deleted until the SkipList is
   19|       |// destroyed.  This is trivially guaranteed by the code since we
   20|       |// never delete any skip list nodes.
   21|       |//
   22|       |// (2) The contents of a Node except for the next/prev pointers are
   23|       |// immutable after the Node has been linked into the SkipList.
   24|       |// Only Insert() modifies the list, and it is careful to initialize
   25|       |// a node and use release-stores to publish the nodes in one or
   26|       |// more lists.
   27|       |//
   28|       |// ... prev vs. next pointer ordering ...
   29|       |
   30|       |#include <atomic>
   31|       |#include <cassert>
   32|       |#include <cstdlib>
   33|       |
   34|       |#include "util/arena.h"
   35|       |#include "util/random.h"
   36|       |
   37|       |namespace leveldb {
   38|       |
   39|       |class Arena;
   40|       |
   41|       |template <typename Key, class Comparator>
   42|       |class SkipList {
   43|       | private:
   44|       |  struct Node;
   45|       |
   46|       | public:
   47|       |  // Create a new SkipList object that will use "cmp" for comparing keys,
   48|       |  // and will allocate memory using "*arena".  Objects allocated in the arena
   49|       |  // must remain allocated for the lifetime of the skiplist object.
   50|       |  explicit SkipList(Comparator cmp, Arena* arena);
   51|       |
   52|       |  SkipList(const SkipList&) = delete;
   53|       |  SkipList& operator=(const SkipList&) = delete;
   54|       |
   55|       |  // Insert key into the list.
   56|       |  // REQUIRES: nothing that compares equal to key is currently in the list.
   57|       |  void Insert(const Key& key);
   58|       |
   59|       |  // Returns true iff an entry that compares equal to key is in the list.
   60|       |  bool Contains(const Key& key) const;
   61|       |
   62|       |  // Iteration over the contents of a skip list
   63|       |  class Iterator {
   64|       |   public:
   65|       |    // Initialize an iterator over the specified list.
   66|       |    // The returned iterator is not valid.
   67|       |    explicit Iterator(const SkipList* list);
   68|       |
   69|       |    // Returns true iff the iterator is positioned at a valid node.
   70|       |    bool Valid() const;
   71|       |
   72|       |    // Returns the key at the current position.
   73|       |    // REQUIRES: Valid()
   74|       |    const Key& key() const;
   75|       |
   76|       |    // Advances to the next position.
   77|       |    // REQUIRES: Valid()
   78|       |    void Next();
   79|       |
   80|       |    // Advances to the previous position.
   81|       |    // REQUIRES: Valid()
   82|       |    void Prev();
   83|       |
   84|       |    // Advance to the first entry with a key >= target
   85|       |    void Seek(const Key& target);
   86|       |
   87|       |    // Position at the first entry in list.
   88|       |    // Final state of iterator is Valid() iff list is not empty.
   89|       |    void SeekToFirst();
   90|       |
   91|       |    // Position at the last entry in list.
   92|       |    // Final state of iterator is Valid() iff list is not empty.
   93|       |    void SeekToLast();
   94|       |
   95|       |   private:
   96|       |    const SkipList* list_;
   97|       |    Node* node_;
   98|       |    // Intentionally copyable
   99|       |  };
  100|       |
  101|       | private:
  102|       |  enum { kMaxHeight = 12 };
  103|       |
  104|      0|  inline int GetMaxHeight() const {
  105|      0|    return max_height_.load(std::memory_order_relaxed);
  106|      0|  }
  107|       |
  108|       |  Node* NewNode(const Key& key, int height);
  109|       |  int RandomHeight();
  110|      0|  bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }
  111|       |
  112|       |  // Return true if key is greater than the data stored in "n"
  113|       |  bool KeyIsAfterNode(const Key& key, Node* n) const;
  114|       |
  115|       |  // Return the earliest node that comes at or after key.
  116|       |  // Return nullptr if there is no such node.
  117|       |  //
  118|       |  // If prev is non-null, fills prev[level] with pointer to previous
  119|       |  // node at "level" for every level in [0..max_height_-1].
  120|       |  Node* FindGreaterOrEqual(const Key& key, Node** prev) const;
  121|       |
  122|       |  // Return the latest node with a key < key.
  123|       |  // Return head_ if there is no such node.
  124|       |  Node* FindLessThan(const Key& key) const;
  125|       |
  126|       |  // Return the last node in the list.
  127|       |  // Return head_ if list is empty.
  128|       |  Node* FindLast() const;
  129|       |
  130|       |  // Immutable after construction
  131|       |  Comparator const compare_;
  132|       |  Arena* const arena_;  // Arena used for allocations of nodes
  133|       |
  134|       |  Node* const head_;
  135|       |
  136|       |  // Modified only by Insert().  Read racily by readers, but stale
  137|       |  // values are ok.
  138|       |  std::atomic<int> max_height_;  // Height of the entire list
  139|       |
  140|       |  // Read/written only by Insert().
  141|       |  Random rnd_;
  142|       |};
  143|       |
  144|       |// Implementation details follow
  145|       |template <typename Key, class Comparator>
  146|       |struct SkipList<Key, Comparator>::Node {
  147|      0|  explicit Node(const Key& k) : key(k) {}
  148|       |
  149|       |  Key const key;
  150|       |
  151|       |  // Accessors/mutators for links.  Wrapped in methods so we can
  152|       |  // add the appropriate barriers as necessary.
  153|      0|  Node* Next(int n) {
  154|      0|    assert(n >= 0);
  155|      0|    // Use an 'acquire load' so that we observe a fully initialized
  156|      0|    // version of the returned Node.
  157|      0|    return next_[n].load(std::memory_order_acquire);
  158|      0|  }
  159|      0|  void SetNext(int n, Node* x) {
  160|      0|    assert(n >= 0);
  161|      0|    // Use a 'release store' so that anybody who reads through this
  162|      0|    // pointer observes a fully initialized version of the inserted node.
  163|      0|    next_[n].store(x, std::memory_order_release);
  164|      0|  }
  165|       |
  166|       |  // No-barrier variants that can be safely used in a few locations.
  167|      0|  Node* NoBarrier_Next(int n) {
  168|      0|    assert(n >= 0);
  169|      0|    return next_[n].load(std::memory_order_relaxed);
  170|      0|  }
  171|      0|  void NoBarrier_SetNext(int n, Node* x) {
  172|      0|    assert(n >= 0);
  173|      0|    next_[n].store(x, std::memory_order_relaxed);
  174|      0|  }
  175|       |
  176|       | private:
  177|       |  // Array of length equal to the node height.  next_[0] is lowest level link.
  178|       |  std::atomic<Node*> next_[1];
  179|       |};
  180|       |
  181|       |template <typename Key, class Comparator>
  182|       |typename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::NewNode(
  183|      0|    const Key& key, int height) {
  184|      0|  char* const node_memory = arena_->AllocateAligned(
  185|      0|      sizeof(Node) + sizeof(std::atomic<Node*>) * (height - 1));
  186|      0|  return new (node_memory) Node(key);
  187|      0|}
  188|       |
  189|       |template <typename Key, class Comparator>
  190|      0|inline SkipList<Key, Comparator>::Iterator::Iterator(const SkipList* list) {
  191|      0|  list_ = list;
  192|      0|  node_ = nullptr;
  193|      0|}
  194|       |
  195|       |template <typename Key, class Comparator>
  196|      0|inline bool SkipList<Key, Comparator>::Iterator::Valid() const {
  197|      0|  return node_ != nullptr;
  198|      0|}
  199|       |
  200|       |template <typename Key, class Comparator>
  201|      0|inline const Key& SkipList<Key, Comparator>::Iterator::key() const {
  202|      0|  assert(Valid());
  203|      0|  return node_->key;
  204|      0|}
  205|       |
  206|       |template <typename Key, class Comparator>
  207|      0|inline void SkipList<Key, Comparator>::Iterator::Next() {
  208|      0|  assert(Valid());
  209|      0|  node_ = node_->Next(0);
  210|      0|}
  211|       |
  212|       |template <typename Key, class Comparator>
  213|      0|inline void SkipList<Key, Comparator>::Iterator::Prev() {
  214|      0|  // Instead of using explicit "prev" links, we just search for the
  215|      0|  // last node that falls before key.
  216|      0|  assert(Valid());
  217|      0|  node_ = list_->FindLessThan(node_->key);
  218|      0|  if (node_ == list_->head_) {
  219|      0|    node_ = nullptr;
  220|      0|  }
  221|      0|}
  222|       |
  223|       |template <typename Key, class Comparator>
  224|      0|inline void SkipList<Key, Comparator>::Iterator::Seek(const Key& target) {
  225|      0|  node_ = list_->FindGreaterOrEqual(target, nullptr);
  226|      0|}
  227|       |
  228|       |template <typename Key, class Comparator>
  229|      0|inline void SkipList<Key, Comparator>::Iterator::SeekToFirst() {
  230|      0|  node_ = list_->head_->Next(0);
  231|      0|}
  232|       |
  233|       |template <typename Key, class Comparator>
  234|      0|inline void SkipList<Key, Comparator>::Iterator::SeekToLast() {
  235|      0|  node_ = list_->FindLast();
  236|      0|  if (node_ == list_->head_) {
  237|      0|    node_ = nullptr;
  238|      0|  }
  239|      0|}
  240|       |
  241|       |template <typename Key, class Comparator>
  242|      0|int SkipList<Key, Comparator>::RandomHeight() {
  243|      0|  // Increase height with probability 1 in kBranching
  244|      0|  static const unsigned int kBranching = 4;
  245|      0|  int height = 1;
  246|      0|  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {
  247|      0|    height++;
  248|      0|  }
  249|      0|  assert(height > 0);
  250|      0|  assert(height <= kMaxHeight);
  251|      0|  return height;
  252|      0|}
  253|       |
  254|       |template <typename Key, class Comparator>
  255|      0|bool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {
  256|      0|  // null n is considered infinite
  257|      0|  return (n != nullptr) && (compare_(n->key, key) < 0);
  258|      0|}
  259|       |
  260|       |template <typename Key, class Comparator>
  261|       |typename SkipList<Key, Comparator>::Node*
  262|       |SkipList<Key, Comparator>::FindGreaterOrEqual(const Key& key,
  263|      0|                                              Node** prev) const {
  264|      0|  Node* x = head_;
  265|      0|  int level = GetMaxHeight() - 1;
  266|      0|  while (true) {
  267|      0|    Node* next = x->Next(level);
  268|      0|    if (KeyIsAfterNode(key, next)) {
  269|      0|      // Keep searching in this list
  270|      0|      x = next;
  271|      0|    } else {
  272|      0|      if (prev != nullptr) prev[level] = x;
  273|      0|      if (level == 0) {
  274|      0|        return next;
  275|      0|      } else {
  276|      0|        // Switch to next list
  277|      0|        level--;
  278|      0|      }
  279|      0|    }
  280|      0|  }
  281|      0|}
  282|       |
  283|       |template <typename Key, class Comparator>
  284|       |typename SkipList<Key, Comparator>::Node*
  285|      0|SkipList<Key, Comparator>::FindLessThan(const Key& key) const {
  286|      0|  Node* x = head_;
  287|      0|  int level = GetMaxHeight() - 1;
  288|      0|  while (true) {
  289|      0|    assert(x == head_ || compare_(x->key, key) < 0);
  290|      0|    Node* next = x->Next(level);
  291|      0|    if (next == nullptr || compare_(next->key, key) >= 0) {
  292|      0|      if (level == 0) {
  293|      0|        return x;
  294|      0|      } else {
  295|      0|        // Switch to next list
  296|      0|        level--;
  297|      0|      }
  298|      0|    } else {
  299|      0|      x = next;
  300|      0|    }
  301|      0|  }
  302|      0|}
  303|       |
  304|       |template <typename Key, class Comparator>
  305|       |typename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::FindLast()
  306|      0|    const {
  307|      0|  Node* x = head_;
  308|      0|  int level = GetMaxHeight() - 1;
  309|      0|  while (true) {
  310|      0|    Node* next = x->Next(level);
  311|      0|    if (next == nullptr) {
  312|      0|      if (level == 0) {
  313|      0|        return x;
  314|      0|      } else {
  315|      0|        // Switch to next list
  316|      0|        level--;
  317|      0|      }
  318|      0|    } else {
  319|      0|      x = next;
  320|      0|    }
  321|      0|  }
  322|      0|}
  323|       |
  324|       |template <typename Key, class Comparator>
  325|       |SkipList<Key, Comparator>::SkipList(Comparator cmp, Arena* arena)
  326|       |    : compare_(cmp),
  327|       |      arena_(arena),
  328|       |      head_(NewNode(0 /* any key will do */, kMaxHeight)),
  329|       |      max_height_(1),
  330|      0|      rnd_(0xdeadbeef) {
  331|      0|  for (int i = 0; i < kMaxHeight; i++) {
  332|      0|    head_->SetNext(i, nullptr);
  333|      0|  }
  334|      0|}
  335|       |
  336|       |template <typename Key, class Comparator>
  337|      0|void SkipList<Key, Comparator>::Insert(const Key& key) {
  338|      0|  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  339|      0|  // here since Insert() is externally synchronized.
  340|      0|  Node* prev[kMaxHeight];
  341|      0|  Node* x = FindGreaterOrEqual(key, prev);
  342|      0|
  343|      0|  // Our data structure does not allow duplicate insertion
  344|      0|  assert(x == nullptr || !Equal(key, x->key));
  345|      0|
  346|      0|  int height = RandomHeight();
  347|      0|  if (height > GetMaxHeight()) {
  348|      0|    for (int i = GetMaxHeight(); i < height; i++) {
  349|      0|      prev[i] = head_;
  350|      0|    }
  351|      0|    // It is ok to mutate max_height_ without any synchronization
  352|      0|    // with concurrent readers.  A concurrent reader that observes
  353|      0|    // the new value of max_height_ will see either the old value of
  354|      0|    // new level pointers from head_ (nullptr), or a new value set in
  355|      0|    // the loop below.  In the former case the reader will
  356|      0|    // immediately drop to the next level since nullptr sorts after all
  357|      0|    // keys.  In the latter case the reader will use the new node.
  358|      0|    max_height_.store(height, std::memory_order_relaxed);
  359|      0|  }
  360|      0|
  361|      0|  x = NewNode(key, height);
  362|      0|  for (int i = 0; i < height; i++) {
  363|      0|    // NoBarrier_SetNext() suffices since we will add a barrier when
  364|      0|    // we publish a pointer to "x" in prev[i].
  365|      0|    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));
  366|      0|    prev[i]->SetNext(i, x);
  367|      0|  }
  368|      0|}
  369|       |
  370|       |template <typename Key, class Comparator>
  371|       |bool SkipList<Key, Comparator>::Contains(const Key& key) const {
  372|       |  Node* x = FindGreaterOrEqual(key, nullptr);
  373|       |  if (x != nullptr && Equal(key, x->key)) {
  374|       |    return true;
  375|       |  } else {
  376|       |    return false;
  377|       |  }
  378|       |}
  379|       |
  380|       |}  // namespace leveldb
  381|       |
  382|       |#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/snapshot.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_SNAPSHOT_H_
    6|       |#define STORAGE_LEVELDB_DB_SNAPSHOT_H_
    7|       |
    8|       |#include "db/dbformat.h"
    9|       |#include "leveldb/db.h"
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|       |class SnapshotList;
   14|       |
   15|       |// Snapshots are kept in a doubly-linked list in the DB.
   16|       |// Each SnapshotImpl corresponds to a particular sequence number.
   17|       |class SnapshotImpl : public Snapshot {
   18|       | public:
   19|       |  SnapshotImpl(SequenceNumber sequence_number)
   20|      0|      : sequence_number_(sequence_number) {}
   21|       |
   22|      0|  SequenceNumber sequence_number() const { return sequence_number_; }
   23|       |
   24|       | private:
   25|       |  friend class SnapshotList;
   26|       |
   27|       |  // SnapshotImpl is kept in a doubly-linked circular list. The SnapshotList
   28|       |  // implementation operates on the next/previous fields direcly.
   29|       |  SnapshotImpl* prev_;
   30|       |  SnapshotImpl* next_;
   31|       |
   32|       |  const SequenceNumber sequence_number_;
   33|       |
   34|       |#if !defined(NDEBUG)
   35|       |  SnapshotList* list_ = nullptr;
   36|       |#endif  // !defined(NDEBUG)
   37|       |};
   38|       |
   39|       |class SnapshotList {
   40|       | public:
   41|      0|  SnapshotList() : head_(0) {
   42|      0|    head_.prev_ = &head_;
   43|      0|    head_.next_ = &head_;
   44|      0|  }
   45|       |
   46|      0|  bool empty() const { return head_.next_ == &head_; }
   47|      0|  SnapshotImpl* oldest() const {
   48|      0|    assert(!empty());
   49|      0|    return head_.next_;
   50|      0|  }
   51|      0|  SnapshotImpl* newest() const {
   52|      0|    assert(!empty());
   53|      0|    return head_.prev_;
   54|      0|  }
   55|       |
   56|       |  // Creates a SnapshotImpl and appends it to the end of the list.
   57|      0|  SnapshotImpl* New(SequenceNumber sequence_number) {
   58|      0|    assert(empty() || newest()->sequence_number_ <= sequence_number);
   59|      0|
   60|      0|    SnapshotImpl* snapshot = new SnapshotImpl(sequence_number);
   61|      0|
   62|      0|#if !defined(NDEBUG)
   63|      0|    snapshot->list_ = this;
   64|      0|#endif  // !defined(NDEBUG)
   65|      0|    snapshot->next_ = &head_;
   66|      0|    snapshot->prev_ = head_.prev_;
   67|      0|    snapshot->prev_->next_ = snapshot;
   68|      0|    snapshot->next_->prev_ = snapshot;
   69|      0|    return snapshot;
   70|      0|  }
   71|       |
   72|       |  // Removes a SnapshotImpl from this list.
   73|       |  //
   74|       |  // The snapshot must have been created by calling New() on this list.
   75|       |  //
   76|       |  // The snapshot pointer should not be const, because its memory is
   77|       |  // deallocated. However, that would force us to change DB::ReleaseSnapshot(),
   78|       |  // which is in the API, and currently takes a const Snapshot.
   79|      0|  void Delete(const SnapshotImpl* snapshot) {
   80|      0|#if !defined(NDEBUG)
   81|      0|    assert(snapshot->list_ == this);
   82|      0|#endif  // !defined(NDEBUG)
   83|      0|    snapshot->prev_->next_ = snapshot->next_;
   84|      0|    snapshot->next_->prev_ = snapshot->prev_;
   85|      0|    delete snapshot;
   86|      0|  }
   87|       |
   88|       | private:
   89|       |  // Dummy head of doubly-linked list of snapshots
   90|       |  SnapshotImpl head_;
   91|       |};
   92|       |
   93|       |}  // namespace leveldb
   94|       |
   95|       |#endif  // STORAGE_LEVELDB_DB_SNAPSHOT_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/table_cache.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/table_cache.h"
    6|       |
    7|       |#include "db/filename.h"
    8|       |#include "leveldb/env.h"
    9|       |#include "leveldb/table.h"
   10|       |#include "util/coding.h"
   11|       |
   12|       |namespace leveldb {
   13|       |
   14|       |struct TableAndFile {
   15|       |  RandomAccessFile* file;
   16|       |  Table* table;
   17|       |};
   18|       |
   19|      0|static void DeleteEntry(const Slice& key, void* value) {
   20|      0|  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);
   21|      0|  delete tf->table;
   22|      0|  delete tf->file;
   23|      0|  delete tf;
   24|      0|}
   25|       |
   26|      0|static void UnrefEntry(void* arg1, void* arg2) {
   27|      0|  Cache* cache = reinterpret_cast<Cache*>(arg1);
   28|      0|  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);
   29|      0|  cache->Release(h);
   30|      0|}
   31|       |
   32|       |TableCache::TableCache(const std::string& dbname, const Options& options,
   33|       |                       int entries)
   34|       |    : env_(options.env),
   35|       |      dbname_(dbname),
   36|       |      options_(options),
   37|      0|      cache_(NewLRUCache(entries)) {}
   38|       |
   39|      0|TableCache::~TableCache() { delete cache_; }
   40|       |
   41|       |Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,
   42|      0|                             Cache::Handle** handle) {
   43|      0|  Status s;
   44|      0|  char buf[sizeof(file_number)];
   45|      0|  EncodeFixed64(buf, file_number);
   46|      0|  Slice key(buf, sizeof(buf));
   47|      0|  *handle = cache_->Lookup(key);
   48|      0|  if (*handle == nullptr) {
   49|      0|    std::string fname = TableFileName(dbname_, file_number);
   50|      0|    RandomAccessFile* file = nullptr;
   51|      0|    Table* table = nullptr;
   52|      0|    s = env_->NewRandomAccessFile(fname, &file);
   53|      0|    if (!s.ok()) {
   54|      0|      std::string old_fname = SSTTableFileName(dbname_, file_number);
   55|      0|      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
   56|      0|        s = Status::OK();
   57|      0|      }
   58|      0|    }
   59|      0|    if (s.ok()) {
   60|      0|      s = Table::Open(options_, file, file_size, &table);
   61|      0|    }
   62|      0|
   63|      0|    if (!s.ok()) {
   64|      0|      assert(table == nullptr);
   65|      0|      delete file;
   66|      0|      // We do not cache error results so that if the error is transient,
   67|      0|      // or somebody repairs the file, we recover automatically.
   68|      0|    } else {
   69|      0|      TableAndFile* tf = new TableAndFile;
   70|      0|      tf->file = file;
   71|      0|      tf->table = table;
   72|      0|      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);
   73|      0|    }
   74|      0|  }
   75|      0|  return s;
   76|      0|}
   77|       |
   78|       |Iterator* TableCache::NewIterator(const ReadOptions& options,
   79|       |                                  uint64_t file_number, uint64_t file_size,
   80|      0|                                  Table** tableptr) {
   81|      0|  if (tableptr != nullptr) {
   82|      0|    *tableptr = nullptr;
   83|      0|  }
   84|      0|
   85|      0|  Cache::Handle* handle = nullptr;
   86|      0|  Status s = FindTable(file_number, file_size, &handle);
   87|      0|  if (!s.ok()) {
   88|      0|    return NewErrorIterator(s);
   89|      0|  }
   90|      0|
   91|      0|  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
   92|      0|  Iterator* result = table->NewIterator(options);
   93|      0|  result->RegisterCleanup(&UnrefEntry, cache_, handle);
   94|      0|  if (tableptr != nullptr) {
   95|      0|    *tableptr = table;
   96|      0|  }
   97|      0|  return result;
   98|      0|}
   99|       |
  100|       |Status TableCache::Get(const ReadOptions& options, uint64_t file_number,
  101|       |                       uint64_t file_size, const Slice& k, void* arg,
  102|       |                       void (*handle_result)(void*, const Slice&,
  103|      0|                                             const Slice&)) {
  104|      0|  Cache::Handle* handle = nullptr;
  105|      0|  Status s = FindTable(file_number, file_size, &handle);
  106|      0|  if (s.ok()) {
  107|      0|    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
  108|      0|    s = t->InternalGet(options, k, arg, handle_result);
  109|      0|    cache_->Release(handle);
  110|      0|  }
  111|      0|  return s;
  112|      0|}
  113|       |
  114|      0|void TableCache::Evict(uint64_t file_number) {
  115|      0|  char buf[sizeof(file_number)];
  116|      0|  EncodeFixed64(buf, file_number);
  117|      0|  cache_->Erase(Slice(buf, sizeof(buf)));
  118|      0|}
  119|       |
  120|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/version_edit.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/version_edit.h"
    6|       |
    7|       |#include "db/version_set.h"
    8|       |#include "util/coding.h"
    9|       |
   10|       |namespace leveldb {
   11|       |
   12|       |// Tag numbers for serialized VersionEdit.  These numbers are written to
   13|       |// disk and should not be changed.
   14|       |enum Tag {
   15|       |  kComparator = 1,
   16|       |  kLogNumber = 2,
   17|       |  kNextFileNumber = 3,
   18|       |  kLastSequence = 4,
   19|       |  kCompactPointer = 5,
   20|       |  kDeletedFile = 6,
   21|       |  kNewFile = 7,
   22|       |  // 8 was used for large value refs
   23|       |  kPrevLogNumber = 9
   24|       |};
   25|       |
   26|      0|void VersionEdit::Clear() {
   27|      0|  comparator_.clear();
   28|      0|  log_number_ = 0;
   29|      0|  prev_log_number_ = 0;
   30|      0|  last_sequence_ = 0;
   31|      0|  next_file_number_ = 0;
   32|      0|  has_comparator_ = false;
   33|      0|  has_log_number_ = false;
   34|      0|  has_prev_log_number_ = false;
   35|      0|  has_next_file_number_ = false;
   36|      0|  has_last_sequence_ = false;
   37|      0|  deleted_files_.clear();
   38|      0|  new_files_.clear();
   39|      0|}
   40|       |
   41|      0|void VersionEdit::EncodeTo(std::string* dst) const {
   42|      0|  if (has_comparator_) {
   43|      0|    PutVarint32(dst, kComparator);
   44|      0|    PutLengthPrefixedSlice(dst, comparator_);
   45|      0|  }
   46|      0|  if (has_log_number_) {
   47|      0|    PutVarint32(dst, kLogNumber);
   48|      0|    PutVarint64(dst, log_number_);
   49|      0|  }
   50|      0|  if (has_prev_log_number_) {
   51|      0|    PutVarint32(dst, kPrevLogNumber);
   52|      0|    PutVarint64(dst, prev_log_number_);
   53|      0|  }
   54|      0|  if (has_next_file_number_) {
   55|      0|    PutVarint32(dst, kNextFileNumber);
   56|      0|    PutVarint64(dst, next_file_number_);
   57|      0|  }
   58|      0|  if (has_last_sequence_) {
   59|      0|    PutVarint32(dst, kLastSequence);
   60|      0|    PutVarint64(dst, last_sequence_);
   61|      0|  }
   62|      0|
   63|      0|  for (size_t i = 0; i < compact_pointers_.size(); i++) {
   64|      0|    PutVarint32(dst, kCompactPointer);
   65|      0|    PutVarint32(dst, compact_pointers_[i].first);  // level
   66|      0|    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
   67|      0|  }
   68|      0|
   69|      0|  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
   70|      0|       iter != deleted_files_.end(); ++iter) {
   71|      0|    PutVarint32(dst, kDeletedFile);
   72|      0|    PutVarint32(dst, iter->first);   // level
   73|      0|    PutVarint64(dst, iter->second);  // file number
   74|      0|  }
   75|      0|
   76|      0|  for (size_t i = 0; i < new_files_.size(); i++) {
   77|      0|    const FileMetaData& f = new_files_[i].second;
   78|      0|    PutVarint32(dst, kNewFile);
   79|      0|    PutVarint32(dst, new_files_[i].first);  // level
   80|      0|    PutVarint64(dst, f.number);
   81|      0|    PutVarint64(dst, f.file_size);
   82|      0|    PutLengthPrefixedSlice(dst, f.smallest.Encode());
   83|      0|    PutLengthPrefixedSlice(dst, f.largest.Encode());
   84|      0|  }
   85|      0|}
   86|       |
   87|      0|static bool GetInternalKey(Slice* input, InternalKey* dst) {
   88|      0|  Slice str;
   89|      0|  if (GetLengthPrefixedSlice(input, &str)) {
   90|      0|    dst->DecodeFrom(str);
   91|      0|    return true;
   92|      0|  } else {
   93|      0|    return false;
   94|      0|  }
   95|      0|}
   96|       |
   97|      0|static bool GetLevel(Slice* input, int* level) {
   98|      0|  uint32_t v;
   99|      0|  if (GetVarint32(input, &v) && v < config::kNumLevels) {
  100|      0|    *level = v;
  101|      0|    return true;
  102|      0|  } else {
  103|      0|    return false;
  104|      0|  }
  105|      0|}
  106|       |
  107|      0|Status VersionEdit::DecodeFrom(const Slice& src) {
  108|      0|  Clear();
  109|      0|  Slice input = src;
  110|      0|  const char* msg = nullptr;
  111|      0|  uint32_t tag;
  112|      0|
  113|      0|  // Temporary storage for parsing
  114|      0|  int level;
  115|      0|  uint64_t number;
  116|      0|  FileMetaData f;
  117|      0|  Slice str;
  118|      0|  InternalKey key;
  119|      0|
  120|      0|  while (msg == nullptr && GetVarint32(&input, &tag)) {
  121|      0|    switch (tag) {
  122|      0|      case kComparator:
  123|      0|        if (GetLengthPrefixedSlice(&input, &str)) {
  124|      0|          comparator_ = str.ToString();
  125|      0|          has_comparator_ = true;
  126|      0|        } else {
  127|      0|          msg = "comparator name";
  128|      0|        }
  129|      0|        break;
  130|      0|
  131|      0|      case kLogNumber:
  132|      0|        if (GetVarint64(&input, &log_number_)) {
  133|      0|          has_log_number_ = true;
  134|      0|        } else {
  135|      0|          msg = "log number";
  136|      0|        }
  137|      0|        break;
  138|      0|
  139|      0|      case kPrevLogNumber:
  140|      0|        if (GetVarint64(&input, &prev_log_number_)) {
  141|      0|          has_prev_log_number_ = true;
  142|      0|        } else {
  143|      0|          msg = "previous log number";
  144|      0|        }
  145|      0|        break;
  146|      0|
  147|      0|      case kNextFileNumber:
  148|      0|        if (GetVarint64(&input, &next_file_number_)) {
  149|      0|          has_next_file_number_ = true;
  150|      0|        } else {
  151|      0|          msg = "next file number";
  152|      0|        }
  153|      0|        break;
  154|      0|
  155|      0|      case kLastSequence:
  156|      0|        if (GetVarint64(&input, &last_sequence_)) {
  157|      0|          has_last_sequence_ = true;
  158|      0|        } else {
  159|      0|          msg = "last sequence number";
  160|      0|        }
  161|      0|        break;
  162|      0|
  163|      0|      case kCompactPointer:
  164|      0|        if (GetLevel(&input, &level) && GetInternalKey(&input, &key)) {
  165|      0|          compact_pointers_.push_back(std::make_pair(level, key));
  166|      0|        } else {
  167|      0|          msg = "compaction pointer";
  168|      0|        }
  169|      0|        break;
  170|      0|
  171|      0|      case kDeletedFile:
  172|      0|        if (GetLevel(&input, &level) && GetVarint64(&input, &number)) {
  173|      0|          deleted_files_.insert(std::make_pair(level, number));
  174|      0|        } else {
  175|      0|          msg = "deleted file";
  176|      0|        }
  177|      0|        break;
  178|      0|
  179|      0|      case kNewFile:
  180|      0|        if (GetLevel(&input, &level) && GetVarint64(&input, &f.number) &&
  181|      0|            GetVarint64(&input, &f.file_size) &&
  182|      0|            GetInternalKey(&input, &f.smallest) &&
  183|      0|            GetInternalKey(&input, &f.largest)) {
  184|      0|          new_files_.push_back(std::make_pair(level, f));
  185|      0|        } else {
  186|      0|          msg = "new-file entry";
  187|      0|        }
  188|      0|        break;
  189|      0|
  190|      0|      default:
  191|      0|        msg = "unknown tag";
  192|      0|        break;
  193|      0|    }
  194|      0|  }
  195|      0|
  196|      0|  if (msg == nullptr && !input.empty()) {
  197|      0|    msg = "invalid tag";
  198|      0|  }
  199|      0|
  200|      0|  Status result;
  201|      0|  if (msg != nullptr) {
  202|      0|    result = Status::Corruption("VersionEdit", msg);
  203|      0|  }
  204|      0|  return result;
  205|      0|}
  206|       |
  207|      0|std::string VersionEdit::DebugString() const {
  208|      0|  std::string r;
  209|      0|  r.append("VersionEdit {");
  210|      0|  if (has_comparator_) {
  211|      0|    r.append("\n  Comparator: ");
  212|      0|    r.append(comparator_);
  213|      0|  }
  214|      0|  if (has_log_number_) {
  215|      0|    r.append("\n  LogNumber: ");
  216|      0|    AppendNumberTo(&r, log_number_);
  217|      0|  }
  218|      0|  if (has_prev_log_number_) {
  219|      0|    r.append("\n  PrevLogNumber: ");
  220|      0|    AppendNumberTo(&r, prev_log_number_);
  221|      0|  }
  222|      0|  if (has_next_file_number_) {
  223|      0|    r.append("\n  NextFile: ");
  224|      0|    AppendNumberTo(&r, next_file_number_);
  225|      0|  }
  226|      0|  if (has_last_sequence_) {
  227|      0|    r.append("\n  LastSeq: ");
  228|      0|    AppendNumberTo(&r, last_sequence_);
  229|      0|  }
  230|      0|  for (size_t i = 0; i < compact_pointers_.size(); i++) {
  231|      0|    r.append("\n  CompactPointer: ");
  232|      0|    AppendNumberTo(&r, compact_pointers_[i].first);
  233|      0|    r.append(" ");
  234|      0|    r.append(compact_pointers_[i].second.DebugString());
  235|      0|  }
  236|      0|  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
  237|      0|       iter != deleted_files_.end(); ++iter) {
  238|      0|    r.append("\n  DeleteFile: ");
  239|      0|    AppendNumberTo(&r, iter->first);
  240|      0|    r.append(" ");
  241|      0|    AppendNumberTo(&r, iter->second);
  242|      0|  }
  243|      0|  for (size_t i = 0; i < new_files_.size(); i++) {
  244|      0|    const FileMetaData& f = new_files_[i].second;
  245|      0|    r.append("\n  AddFile: ");
  246|      0|    AppendNumberTo(&r, new_files_[i].first);
  247|      0|    r.append(" ");
  248|      0|    AppendNumberTo(&r, f.number);
  249|      0|    r.append(" ");
  250|      0|    AppendNumberTo(&r, f.file_size);
  251|      0|    r.append(" ");
  252|      0|    r.append(f.smallest.DebugString());
  253|      0|    r.append(" .. ");
  254|      0|    r.append(f.largest.DebugString());
  255|      0|  }
  256|      0|  r.append("\n}\n");
  257|      0|  return r;
  258|      0|}
  259|       |
  260|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/version_edit.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_VERSION_EDIT_H_
    6|       |#define STORAGE_LEVELDB_DB_VERSION_EDIT_H_
    7|       |
    8|       |#include <set>
    9|       |#include <utility>
   10|       |#include <vector>
   11|       |
   12|       |#include "db/dbformat.h"
   13|       |
   14|       |namespace leveldb {
   15|       |
   16|       |class VersionSet;
   17|       |
   18|       |struct FileMetaData {
   19|      0|  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) {}
   20|       |
   21|       |  int refs;
   22|       |  int allowed_seeks;  // Seeks allowed until compaction
   23|       |  uint64_t number;
   24|       |  uint64_t file_size;    // File size in bytes
   25|       |  InternalKey smallest;  // Smallest internal key served by table
   26|       |  InternalKey largest;   // Largest internal key served by table
   27|       |};
   28|       |
   29|       |class VersionEdit {
   30|       | public:
   31|      0|  VersionEdit() { Clear(); }
   32|      0|  ~VersionEdit() {}
   33|       |
   34|       |  void Clear();
   35|       |
   36|      0|  void SetComparatorName(const Slice& name) {
   37|      0|    has_comparator_ = true;
   38|      0|    comparator_ = name.ToString();
   39|      0|  }
   40|      0|  void SetLogNumber(uint64_t num) {
   41|      0|    has_log_number_ = true;
   42|      0|    log_number_ = num;
   43|      0|  }
   44|      0|  void SetPrevLogNumber(uint64_t num) {
   45|      0|    has_prev_log_number_ = true;
   46|      0|    prev_log_number_ = num;
   47|      0|  }
   48|      0|  void SetNextFile(uint64_t num) {
   49|      0|    has_next_file_number_ = true;
   50|      0|    next_file_number_ = num;
   51|      0|  }
   52|      0|  void SetLastSequence(SequenceNumber seq) {
   53|      0|    has_last_sequence_ = true;
   54|      0|    last_sequence_ = seq;
   55|      0|  }
   56|      0|  void SetCompactPointer(int level, const InternalKey& key) {
   57|      0|    compact_pointers_.push_back(std::make_pair(level, key));
   58|      0|  }
   59|       |
   60|       |  // Add the specified file at the specified number.
   61|       |  // REQUIRES: This version has not been saved (see VersionSet::SaveTo)
   62|       |  // REQUIRES: "smallest" and "largest" are smallest and largest keys in file
   63|       |  void AddFile(int level, uint64_t file, uint64_t file_size,
   64|      0|               const InternalKey& smallest, const InternalKey& largest) {
   65|      0|    FileMetaData f;
   66|      0|    f.number = file;
   67|      0|    f.file_size = file_size;
   68|      0|    f.smallest = smallest;
   69|      0|    f.largest = largest;
   70|      0|    new_files_.push_back(std::make_pair(level, f));
   71|      0|  }
   72|       |
   73|       |  // Delete the specified "file" from the specified "level".
   74|      0|  void DeleteFile(int level, uint64_t file) {
   75|      0|    deleted_files_.insert(std::make_pair(level, file));
   76|      0|  }
   77|       |
   78|       |  void EncodeTo(std::string* dst) const;
   79|       |  Status DecodeFrom(const Slice& src);
   80|       |
   81|       |  std::string DebugString() const;
   82|       |
   83|       | private:
   84|       |  friend class VersionSet;
   85|       |
   86|       |  typedef std::set<std::pair<int, uint64_t> > DeletedFileSet;
   87|       |
   88|       |  std::string comparator_;
   89|       |  uint64_t log_number_;
   90|       |  uint64_t prev_log_number_;
   91|       |  uint64_t next_file_number_;
   92|       |  SequenceNumber last_sequence_;
   93|       |  bool has_comparator_;
   94|       |  bool has_log_number_;
   95|       |  bool has_prev_log_number_;
   96|       |  bool has_next_file_number_;
   97|       |  bool has_last_sequence_;
   98|       |
   99|       |  std::vector<std::pair<int, InternalKey> > compact_pointers_;
  100|       |  DeletedFileSet deleted_files_;
  101|       |  std::vector<std::pair<int, FileMetaData> > new_files_;
  102|       |};
  103|       |
  104|       |}  // namespace leveldb
  105|       |
  106|       |#endif  // STORAGE_LEVELDB_DB_VERSION_EDIT_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/version_set.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "db/version_set.h"
    6|       |
    7|       |#include <stdio.h>
    8|       |
    9|       |#include <algorithm>
   10|       |
   11|       |#include "db/filename.h"
   12|       |#include "db/log_reader.h"
   13|       |#include "db/log_writer.h"
   14|       |#include "db/memtable.h"
   15|       |#include "db/table_cache.h"
   16|       |#include "leveldb/env.h"
   17|       |#include "leveldb/table_builder.h"
   18|       |#include "table/merger.h"
   19|       |#include "table/two_level_iterator.h"
   20|       |#include "util/coding.h"
   21|       |#include "util/logging.h"
   22|       |
   23|       |namespace leveldb {
   24|       |
   25|      0|static size_t TargetFileSize(const Options* options) {
   26|      0|  return options->max_file_size;
   27|      0|}
   28|       |
   29|       |// Maximum bytes of overlaps in grandparent (i.e., level+2) before we
   30|       |// stop building a single file in a level->level+1 compaction.
   31|      0|static int64_t MaxGrandParentOverlapBytes(const Options* options) {
   32|      0|  return 10 * TargetFileSize(options);
   33|      0|}
   34|       |
   35|       |// Maximum number of bytes in all compacted files.  We avoid expanding
   36|       |// the lower level file set of a compaction if it would make the
   37|       |// total compaction cover more than this many bytes.
   38|      0|static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {
   39|      0|  return 25 * TargetFileSize(options);
   40|      0|}
   41|       |
   42|      0|static double MaxBytesForLevel(const Options* options, int level) {
   43|      0|  // Note: the result for level zero is not really used since we set
   44|      0|  // the level-0 compaction threshold based on number of files.
   45|      0|
   46|      0|  // Result for both level-0 and level-1
   47|      0|  double result = 10. * 1048576.0;
   48|      0|  while (level > 1) {
   49|      0|    result *= 10;
   50|      0|    level--;
   51|      0|  }
   52|      0|  return result;
   53|      0|}
   54|       |
   55|      0|static uint64_t MaxFileSizeForLevel(const Options* options, int level) {
   56|      0|  // We could vary per level to reduce number of files?
   57|      0|  return TargetFileSize(options);
   58|      0|}
   59|       |
   60|      0|static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {
   61|      0|  int64_t sum = 0;
   62|      0|  for (size_t i = 0; i < files.size(); i++) {
   63|      0|    sum += files[i]->file_size;
   64|      0|  }
   65|      0|  return sum;
   66|      0|}
   67|       |
   68|      0|Version::~Version() {
   69|      0|  assert(refs_ == 0);
   70|      0|
   71|      0|  // Remove from linked list
   72|      0|  prev_->next_ = next_;
   73|      0|  next_->prev_ = prev_;
   74|      0|
   75|      0|  // Drop references to files
   76|      0|  for (int level = 0; level < config::kNumLevels; level++) {
   77|      0|    for (size_t i = 0; i < files_[level].size(); i++) {
   78|      0|      FileMetaData* f = files_[level][i];
   79|      0|      assert(f->refs > 0);
   80|      0|      f->refs--;
   81|      0|      if (f->refs <= 0) {
   82|      0|        delete f;
   83|      0|      }
   84|      0|    }
   85|      0|  }
   86|      0|}
   87|       |
   88|       |int FindFile(const InternalKeyComparator& icmp,
   89|      0|             const std::vector<FileMetaData*>& files, const Slice& key) {
   90|      0|  uint32_t left = 0;
   91|      0|  uint32_t right = files.size();
   92|      0|  while (left < right) {
   93|      0|    uint32_t mid = (left + right) / 2;
   94|      0|    const FileMetaData* f = files[mid];
   95|      0|    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
   96|      0|      // Key at "mid.largest" is < "target".  Therefore all
   97|      0|      // files at or before "mid" are uninteresting.
   98|      0|      left = mid + 1;
   99|      0|    } else {
  100|      0|      // Key at "mid.largest" is >= "target".  Therefore all files
  101|      0|      // after "mid" are uninteresting.
  102|      0|      right = mid;
  103|      0|    }
  104|      0|  }
  105|      0|  return right;
  106|      0|}
  107|       |
  108|       |static bool AfterFile(const Comparator* ucmp, const Slice* user_key,
  109|      0|                      const FileMetaData* f) {
  110|      0|  // null user_key occurs before all keys and is therefore never after *f
  111|      0|  return (user_key != nullptr &&
  112|      0|          ucmp->Compare(*user_key, f->largest.user_key()) > 0);
  113|      0|}
  114|       |
  115|       |static bool BeforeFile(const Comparator* ucmp, const Slice* user_key,
  116|      0|                       const FileMetaData* f) {
  117|      0|  // null user_key occurs after all keys and is therefore never before *f
  118|      0|  return (user_key != nullptr &&
  119|      0|          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);
  120|      0|}
  121|       |
  122|       |bool SomeFileOverlapsRange(const InternalKeyComparator& icmp,
  123|       |                           bool disjoint_sorted_files,
  124|       |                           const std::vector<FileMetaData*>& files,
  125|       |                           const Slice* smallest_user_key,
  126|      0|                           const Slice* largest_user_key) {
  127|      0|  const Comparator* ucmp = icmp.user_comparator();
  128|      0|  if (!disjoint_sorted_files) {
  129|      0|    // Need to check against all files
  130|      0|    for (size_t i = 0; i < files.size(); i++) {
  131|      0|      const FileMetaData* f = files[i];
  132|      0|      if (AfterFile(ucmp, smallest_user_key, f) ||
  133|      0|          BeforeFile(ucmp, largest_user_key, f)) {
  134|      0|        // No overlap
  135|      0|      } else {
  136|      0|        return true;  // Overlap
  137|      0|      }
  138|      0|    }
  139|      0|    return false;
  140|      0|  }
  141|      0|
  142|      0|  // Binary search over file list
  143|      0|  uint32_t index = 0;
  144|      0|  if (smallest_user_key != nullptr) {
  145|      0|    // Find the earliest possible internal key for smallest_user_key
  146|      0|    InternalKey small_key(*smallest_user_key, kMaxSequenceNumber,
  147|      0|                          kValueTypeForSeek);
  148|      0|    index = FindFile(icmp, files, small_key.Encode());
  149|      0|  }
  150|      0|
  151|      0|  if (index >= files.size()) {
  152|      0|    // beginning of range is after all files, so no overlap.
  153|      0|    return false;
  154|      0|  }
  155|      0|
  156|      0|  return !BeforeFile(ucmp, largest_user_key, files[index]);
  157|      0|}
  158|       |
  159|       |// An internal iterator.  For a given version/level pair, yields
  160|       |// information about the files in the level.  For a given entry, key()
  161|       |// is the largest key that occurs in the file, and value() is an
  162|       |// 16-byte value containing the file number and file size, both
  163|       |// encoded using EncodeFixed64.
  164|       |class Version::LevelFileNumIterator : public Iterator {
  165|       | public:
  166|       |  LevelFileNumIterator(const InternalKeyComparator& icmp,
  167|       |                       const std::vector<FileMetaData*>* flist)
  168|      0|      : icmp_(icmp), flist_(flist), index_(flist->size()) {  // Marks as invalid
  169|      0|  }
  170|      0|  virtual bool Valid() const { return index_ < flist_->size(); }
  171|      0|  virtual void Seek(const Slice& target) {
  172|      0|    index_ = FindFile(icmp_, *flist_, target);
  173|      0|  }
  174|      0|  virtual void SeekToFirst() { index_ = 0; }
  175|      0|  virtual void SeekToLast() {
  176|      0|    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  177|      0|  }
  178|      0|  virtual void Next() {
  179|      0|    assert(Valid());
  180|      0|    index_++;
  181|      0|  }
  182|      0|  virtual void Prev() {
  183|      0|    assert(Valid());
  184|      0|    if (index_ == 0) {
  185|      0|      index_ = flist_->size();  // Marks as invalid
  186|      0|    } else {
  187|      0|      index_--;
  188|      0|    }
  189|      0|  }
  190|      0|  Slice key() const {
  191|      0|    assert(Valid());
  192|      0|    return (*flist_)[index_]->largest.Encode();
  193|      0|  }
  194|      0|  Slice value() const {
  195|      0|    assert(Valid());
  196|      0|    EncodeFixed64(value_buf_, (*flist_)[index_]->number);
  197|      0|    EncodeFixed64(value_buf_ + 8, (*flist_)[index_]->file_size);
  198|      0|    return Slice(value_buf_, sizeof(value_buf_));
  199|      0|  }
  200|      0|  virtual Status status() const { return Status::OK(); }
  201|       |
  202|       | private:
  203|       |  const InternalKeyComparator icmp_;
  204|       |  const std::vector<FileMetaData*>* const flist_;
  205|       |  uint32_t index_;
  206|       |
  207|       |  // Backing store for value().  Holds the file number and size.
  208|       |  mutable char value_buf_[16];
  209|       |};
  210|       |
  211|       |static Iterator* GetFileIterator(void* arg, const ReadOptions& options,
  212|      0|                                 const Slice& file_value) {
  213|      0|  TableCache* cache = reinterpret_cast<TableCache*>(arg);
  214|      0|  if (file_value.size() != 16) {
  215|      0|    return NewErrorIterator(
  216|      0|        Status::Corruption("FileReader invoked with unexpected value"));
  217|      0|  } else {
  218|      0|    return cache->NewIterator(options, DecodeFixed64(file_value.data()),
  219|      0|                              DecodeFixed64(file_value.data() + 8));
  220|      0|  }
  221|      0|}
  222|       |
  223|       |Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,
  224|      0|                                            int level) const {
  225|      0|  return NewTwoLevelIterator(
  226|      0|      new LevelFileNumIterator(vset_->icmp_, &files_[level]), &GetFileIterator,
  227|      0|      vset_->table_cache_, options);
  228|      0|}
  229|       |
  230|       |void Version::AddIterators(const ReadOptions& options,
  231|      0|                           std::vector<Iterator*>* iters) {
  232|      0|  // Merge all level zero files together since they may overlap
  233|      0|  for (size_t i = 0; i < files_[0].size(); i++) {
  234|      0|    iters->push_back(vset_->table_cache_->NewIterator(
  235|      0|        options, files_[0][i]->number, files_[0][i]->file_size));
  236|      0|  }
  237|      0|
  238|      0|  // For levels > 0, we can use a concatenating iterator that sequentially
  239|      0|  // walks through the non-overlapping files in the level, opening them
  240|      0|  // lazily.
  241|      0|  for (int level = 1; level < config::kNumLevels; level++) {
  242|      0|    if (!files_[level].empty()) {
  243|      0|      iters->push_back(NewConcatenatingIterator(options, level));
  244|      0|    }
  245|      0|  }
  246|      0|}
  247|       |
  248|       |// Callback from TableCache::Get()
  249|       |namespace {
  250|       |enum SaverState {
  251|       |  kNotFound,
  252|       |  kFound,
  253|       |  kDeleted,
  254|       |  kCorrupt,
  255|       |};
  256|       |struct Saver {
  257|       |  SaverState state;
  258|       |  const Comparator* ucmp;
  259|       |  Slice user_key;
  260|       |  std::string* value;
  261|       |};
  262|       |}  // namespace
  263|      0|static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {
  264|      0|  Saver* s = reinterpret_cast<Saver*>(arg);
  265|      0|  ParsedInternalKey parsed_key;
  266|      0|  if (!ParseInternalKey(ikey, &parsed_key)) {
  267|      0|    s->state = kCorrupt;
  268|      0|  } else {
  269|      0|    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
  270|      0|      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
  271|      0|      if (s->state == kFound) {
  272|      0|        s->value->assign(v.data(), v.size());
  273|      0|      }
  274|      0|    }
  275|      0|  }
  276|      0|}
  277|       |
  278|      0|static bool NewestFirst(FileMetaData* a, FileMetaData* b) {
  279|      0|  return a->number > b->number;
  280|      0|}
  281|       |
  282|       |void Version::ForEachOverlapping(Slice user_key, Slice internal_key, void* arg,
  283|      0|                                 bool (*func)(void*, int, FileMetaData*)) {
  284|      0|  // TODO(sanjay): Change Version::Get() to use this function.
  285|      0|  const Comparator* ucmp = vset_->icmp_.user_comparator();
  286|      0|
  287|      0|  // Search level-0 in order from newest to oldest.
  288|      0|  std::vector<FileMetaData*> tmp;
  289|      0|  tmp.reserve(files_[0].size());
  290|      0|  for (uint32_t i = 0; i < files_[0].size(); i++) {
  291|      0|    FileMetaData* f = files_[0][i];
  292|      0|    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
  293|      0|        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
  294|      0|      tmp.push_back(f);
  295|      0|    }
  296|      0|  }
  297|      0|  if (!tmp.empty()) {
  298|      0|    std::sort(tmp.begin(), tmp.end(), NewestFirst);
  299|      0|    for (uint32_t i = 0; i < tmp.size(); i++) {
  300|      0|      if (!(*func)(arg, 0, tmp[i])) {
  301|      0|        return;
  302|      0|      }
  303|      0|    }
  304|      0|  }
  305|      0|
  306|      0|  // Search other levels.
  307|      0|  for (int level = 1; level < config::kNumLevels; level++) {
  308|      0|    size_t num_files = files_[level].size();
  309|      0|    if (num_files == 0) continue;
  310|      0|
  311|      0|    // Binary search to find earliest index whose largest key >= internal_key.
  312|      0|    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);
  313|      0|    if (index < num_files) {
  314|      0|      FileMetaData* f = files_[level][index];
  315|      0|      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {
  316|      0|        // All of "f" is past any data for user_key
  317|      0|      } else {
  318|      0|        if (!(*func)(arg, level, f)) {
  319|      0|          return;
  320|      0|        }
  321|      0|      }
  322|      0|    }
  323|      0|  }
  324|      0|}
  325|       |
  326|       |Status Version::Get(const ReadOptions& options, const LookupKey& k,
  327|      0|                    std::string* value, GetStats* stats) {
  328|      0|  Slice ikey = k.internal_key();
  329|      0|  Slice user_key = k.user_key();
  330|      0|  const Comparator* ucmp = vset_->icmp_.user_comparator();
  331|      0|  Status s;
  332|      0|
  333|      0|  stats->seek_file = nullptr;
  334|      0|  stats->seek_file_level = -1;
  335|      0|  FileMetaData* last_file_read = nullptr;
  336|      0|  int last_file_read_level = -1;
  337|      0|
  338|      0|  // We can search level-by-level since entries never hop across
  339|      0|  // levels.  Therefore we are guaranteed that if we find data
  340|      0|  // in a smaller level, later levels are irrelevant.
  341|      0|  std::vector<FileMetaData*> tmp;
  342|      0|  FileMetaData* tmp2;
  343|      0|  for (int level = 0; level < config::kNumLevels; level++) {
  344|      0|    size_t num_files = files_[level].size();
  345|      0|    if (num_files == 0) continue;
  346|      0|
  347|      0|    // Get the list of files to search in this level
  348|      0|    FileMetaData* const* files = &files_[level][0];
  349|      0|    if (level == 0) {
  350|      0|      // Level-0 files may overlap each other.  Find all files that
  351|      0|      // overlap user_key and process them in order from newest to oldest.
  352|      0|      tmp.reserve(num_files);
  353|      0|      for (uint32_t i = 0; i < num_files; i++) {
  354|      0|        FileMetaData* f = files[i];
  355|      0|        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
  356|      0|            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
  357|      0|          tmp.push_back(f);
  358|      0|        }
  359|      0|      }
  360|      0|      if (tmp.empty()) continue;
  361|      0|
  362|      0|      std::sort(tmp.begin(), tmp.end(), NewestFirst);
  363|      0|      files = &tmp[0];
  364|      0|      num_files = tmp.size();
  365|      0|    } else {
  366|      0|      // Binary search to find earliest index whose largest key >= ikey.
  367|      0|      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);
  368|      0|      if (index >= num_files) {
  369|      0|        files = nullptr;
  370|      0|        num_files = 0;
  371|      0|      } else {
  372|      0|        tmp2 = files[index];
  373|      0|        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {
  374|      0|          // All of "tmp2" is past any data for user_key
  375|      0|          files = nullptr;
  376|      0|          num_files = 0;
  377|      0|        } else {
  378|      0|          files = &tmp2;
  379|      0|          num_files = 1;
  380|      0|        }
  381|      0|      }
  382|      0|    }
  383|      0|
  384|      0|    for (uint32_t i = 0; i < num_files; ++i) {
  385|      0|      if (last_file_read != nullptr && stats->seek_file == nullptr) {
  386|      0|        // We have had more than one seek for this read.  Charge the 1st file.
  387|      0|        stats->seek_file = last_file_read;
  388|      0|        stats->seek_file_level = last_file_read_level;
  389|      0|      }
  390|      0|
  391|      0|      FileMetaData* f = files[i];
  392|      0|      last_file_read = f;
  393|      0|      last_file_read_level = level;
  394|      0|
  395|      0|      Saver saver;
  396|      0|      saver.state = kNotFound;
  397|      0|      saver.ucmp = ucmp;
  398|      0|      saver.user_key = user_key;
  399|      0|      saver.value = value;
  400|      0|      s = vset_->table_cache_->Get(options, f->number, f->file_size, ikey,
  401|      0|                                   &saver, SaveValue);
  402|      0|      if (!s.ok()) {
  403|      0|        return s;
  404|      0|      }
  405|      0|      switch (saver.state) {
  406|      0|        case kNotFound:
  407|      0|          break;  // Keep searching in other files
  408|      0|        case kFound:
  409|      0|          return s;
  410|      0|        case kDeleted:
  411|      0|          s = Status::NotFound(Slice());  // Use empty error message for speed
  412|      0|          return s;
  413|      0|        case kCorrupt:
  414|      0|          s = Status::Corruption("corrupted key for ", user_key);
  415|      0|          return s;
  416|      0|      }
  417|      0|    }
  418|      0|  }
  419|      0|
  420|      0|  return Status::NotFound(Slice());  // Use an empty error message for speed
  421|      0|}
  422|       |
  423|      0|bool Version::UpdateStats(const GetStats& stats) {
  424|      0|  FileMetaData* f = stats.seek_file;
  425|      0|  if (f != nullptr) {
  426|      0|    f->allowed_seeks--;
  427|      0|    if (f->allowed_seeks <= 0 && file_to_compact_ == nullptr) {
  428|      0|      file_to_compact_ = f;
  429|      0|      file_to_compact_level_ = stats.seek_file_level;
  430|      0|      return true;
  431|      0|    }
  432|      0|  }
  433|      0|  return false;
  434|      0|}
  435|       |
  436|      0|bool Version::RecordReadSample(Slice internal_key) {
  437|      0|  ParsedInternalKey ikey;
  438|      0|  if (!ParseInternalKey(internal_key, &ikey)) {
  439|      0|    return false;
  440|      0|  }
  441|      0|
  442|      0|  struct State {
  443|      0|    GetStats stats;  // Holds first matching file
  444|      0|    int matches;
  445|      0|
  446|      0|    static bool Match(void* arg, int level, FileMetaData* f) {
  447|      0|      State* state = reinterpret_cast<State*>(arg);
  448|      0|      state->matches++;
  449|      0|      if (state->matches == 1) {
  450|      0|        // Remember first match.
  451|      0|        state->stats.seek_file = f;
  452|      0|        state->stats.seek_file_level = level;
  453|      0|      }
  454|      0|      // We can stop iterating once we have a second match.
  455|      0|      return state->matches < 2;
  456|      0|    }
  457|      0|  };
  458|      0|
  459|      0|  State state;
  460|      0|  state.matches = 0;
  461|      0|  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);
  462|      0|
  463|      0|  // Must have at least two matches since we want to merge across
  464|      0|  // files. But what if we have a single file that contains many
  465|      0|  // overwrites and deletions?  Should we have another mechanism for
  466|      0|  // finding such files?
  467|      0|  if (state.matches >= 2) {
  468|      0|    // 1MB cost is about 1 seek (see comment in Builder::Apply).
  469|      0|    return UpdateStats(state.stats);
  470|      0|  }
  471|      0|  return false;
  472|      0|}
  473|       |
  474|      0|void Version::Ref() { ++refs_; }
  475|       |
  476|      0|void Version::Unref() {
  477|      0|  assert(this != &vset_->dummy_versions_);
  478|      0|  assert(refs_ >= 1);
  479|      0|  --refs_;
  480|      0|  if (refs_ == 0) {
  481|      0|    delete this;
  482|      0|  }
  483|      0|}
  484|       |
  485|       |bool Version::OverlapInLevel(int level, const Slice* smallest_user_key,
  486|      0|                             const Slice* largest_user_key) {
  487|      0|  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],
  488|      0|                               smallest_user_key, largest_user_key);
  489|      0|}
  490|       |
  491|       |int Version::PickLevelForMemTableOutput(const Slice& smallest_user_key,
  492|      0|                                        const Slice& largest_user_key) {
  493|      0|  int level = 0;
  494|      0|  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {
  495|      0|    // Push to next level if there is no overlap in next level,
  496|      0|    // and the #bytes overlapping in the level after that are limited.
  497|      0|    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
  498|      0|    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
  499|      0|    std::vector<FileMetaData*> overlaps;
  500|      0|    while (level < config::kMaxMemCompactLevel) {
  501|      0|      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
  502|      0|        break;
  503|      0|      }
  504|      0|      if (level + 2 < config::kNumLevels) {
  505|      0|        // Check that file does not overlap too many grandparent bytes.
  506|      0|        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
  507|      0|        const int64_t sum = TotalFileSize(overlaps);
  508|      0|        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
  509|      0|          break;
  510|      0|        }
  511|      0|      }
  512|      0|      level++;
  513|      0|    }
  514|      0|  }
  515|      0|  return level;
  516|      0|}
  517|       |
  518|       |// Store in "*inputs" all files in "level" that overlap [begin,end]
  519|       |void Version::GetOverlappingInputs(int level, const InternalKey* begin,
  520|       |                                   const InternalKey* end,
  521|      0|                                   std::vector<FileMetaData*>* inputs) {
  522|      0|  assert(level >= 0);
  523|      0|  assert(level < config::kNumLevels);
  524|      0|  inputs->clear();
  525|      0|  Slice user_begin, user_end;
  526|      0|  if (begin != nullptr) {
  527|      0|    user_begin = begin->user_key();
  528|      0|  }
  529|      0|  if (end != nullptr) {
  530|      0|    user_end = end->user_key();
  531|      0|  }
  532|      0|  const Comparator* user_cmp = vset_->icmp_.user_comparator();
  533|      0|  for (size_t i = 0; i < files_[level].size();) {
  534|      0|    FileMetaData* f = files_[level][i++];
  535|      0|    const Slice file_start = f->smallest.user_key();
  536|      0|    const Slice file_limit = f->largest.user_key();
  537|      0|    if (begin != nullptr && user_cmp->Compare(file_limit, user_begin) < 0) {
  538|      0|      // "f" is completely before specified range; skip it
  539|      0|    } else if (end != nullptr && user_cmp->Compare(file_start, user_end) > 0) {
  540|      0|      // "f" is completely after specified range; skip it
  541|      0|    } else {
  542|      0|      inputs->push_back(f);
  543|      0|      if (level == 0) {
  544|      0|        // Level-0 files may overlap each other.  So check if the newly
  545|      0|        // added file has expanded the range.  If so, restart search.
  546|      0|        if (begin != nullptr && user_cmp->Compare(file_start, user_begin) < 0) {
  547|      0|          user_begin = file_start;
  548|      0|          inputs->clear();
  549|      0|          i = 0;
  550|      0|        } else if (end != nullptr &&
  551|      0|                   user_cmp->Compare(file_limit, user_end) > 0) {
  552|      0|          user_end = file_limit;
  553|      0|          inputs->clear();
  554|      0|          i = 0;
  555|      0|        }
  556|      0|      }
  557|      0|    }
  558|      0|  }
  559|      0|}
  560|       |
  561|      0|std::string Version::DebugString() const {
  562|      0|  std::string r;
  563|      0|  for (int level = 0; level < config::kNumLevels; level++) {
  564|      0|    // E.g.,
  565|      0|    //   --- level 1 ---
  566|      0|    //   17:123['a' .. 'd']
  567|      0|    //   20:43['e' .. 'g']
  568|      0|    r.append("--- level ");
  569|      0|    AppendNumberTo(&r, level);
  570|      0|    r.append(" ---\n");
  571|      0|    const std::vector<FileMetaData*>& files = files_[level];
  572|      0|    for (size_t i = 0; i < files.size(); i++) {
  573|      0|      r.push_back(' ');
  574|      0|      AppendNumberTo(&r, files[i]->number);
  575|      0|      r.push_back(':');
  576|      0|      AppendNumberTo(&r, files[i]->file_size);
  577|      0|      r.append("[");
  578|      0|      r.append(files[i]->smallest.DebugString());
  579|      0|      r.append(" .. ");
  580|      0|      r.append(files[i]->largest.DebugString());
  581|      0|      r.append("]\n");
  582|      0|    }
  583|      0|  }
  584|      0|  return r;
  585|      0|}
  586|       |
  587|       |// A helper class so we can efficiently apply a whole sequence
  588|       |// of edits to a particular state without creating intermediate
  589|       |// Versions that contain full copies of the intermediate state.
  590|       |class VersionSet::Builder {
  591|       | private:
  592|       |  // Helper to sort by v->files_[file_number].smallest
  593|       |  struct BySmallestKey {
  594|       |    const InternalKeyComparator* internal_comparator;
  595|       |
  596|      0|    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
  597|      0|      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
  598|      0|      if (r != 0) {
  599|      0|        return (r < 0);
  600|      0|      } else {
  601|      0|        // Break ties by file number
  602|      0|        return (f1->number < f2->number);
  603|      0|      }
  604|      0|    }
  605|       |  };
  606|       |
  607|       |  typedef std::set<FileMetaData*, BySmallestKey> FileSet;
  608|       |  struct LevelState {
  609|       |    std::set<uint64_t> deleted_files;
  610|       |    FileSet* added_files;
  611|       |  };
  612|       |
  613|       |  VersionSet* vset_;
  614|       |  Version* base_;
  615|       |  LevelState levels_[config::kNumLevels];
  616|       |
  617|       | public:
  618|       |  // Initialize a builder with the files from *base and other info from *vset
  619|      0|  Builder(VersionSet* vset, Version* base) : vset_(vset), base_(base) {
  620|      0|    base_->Ref();
  621|      0|    BySmallestKey cmp;
  622|      0|    cmp.internal_comparator = &vset_->icmp_;
  623|      0|    for (int level = 0; level < config::kNumLevels; level++) {
  624|      0|      levels_[level].added_files = new FileSet(cmp);
  625|      0|    }
  626|      0|  }
  627|       |
  628|      0|  ~Builder() {
  629|      0|    for (int level = 0; level < config::kNumLevels; level++) {
  630|      0|      const FileSet* added = levels_[level].added_files;
  631|      0|      std::vector<FileMetaData*> to_unref;
  632|      0|      to_unref.reserve(added->size());
  633|      0|      for (FileSet::const_iterator it = added->begin(); it != added->end();
  634|      0|           ++it) {
  635|      0|        to_unref.push_back(*it);
  636|      0|      }
  637|      0|      delete added;
  638|      0|      for (uint32_t i = 0; i < to_unref.size(); i++) {
  639|      0|        FileMetaData* f = to_unref[i];
  640|      0|        f->refs--;
  641|      0|        if (f->refs <= 0) {
  642|      0|          delete f;
  643|      0|        }
  644|      0|      }
  645|      0|    }
  646|      0|    base_->Unref();
  647|      0|  }
  648|       |
  649|       |  // Apply all of the edits in *edit to the current state.
  650|      0|  void Apply(VersionEdit* edit) {
  651|      0|    // Update compaction pointers
  652|      0|    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {
  653|      0|      const int level = edit->compact_pointers_[i].first;
  654|      0|      vset_->compact_pointer_[level] =
  655|      0|          edit->compact_pointers_[i].second.Encode().ToString();
  656|      0|    }
  657|      0|
  658|      0|    // Delete files
  659|      0|    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;
  660|      0|    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
  661|      0|         iter != del.end(); ++iter) {
  662|      0|      const int level = iter->first;
  663|      0|      const uint64_t number = iter->second;
  664|      0|      levels_[level].deleted_files.insert(number);
  665|      0|    }
  666|      0|
  667|      0|    // Add new files
  668|      0|    for (size_t i = 0; i < edit->new_files_.size(); i++) {
  669|      0|      const int level = edit->new_files_[i].first;
  670|      0|      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
  671|      0|      f->refs = 1;
  672|      0|
  673|      0|      // We arrange to automatically compact this file after
  674|      0|      // a certain number of seeks.  Let's assume:
  675|      0|      //   (1) One seek costs 10ms
  676|      0|      //   (2) Writing or reading 1MB costs 10ms (100MB/s)
  677|      0|      //   (3) A compaction of 1MB does 25MB of IO:
  678|      0|      //         1MB read from this level
  679|      0|      //         10-12MB read from next level (boundaries may be misaligned)
  680|      0|      //         10-12MB written to next level
  681|      0|      // This implies that 25 seeks cost the same as the compaction
  682|      0|      // of 1MB of data.  I.e., one seek costs approximately the
  683|      0|      // same as the compaction of 40KB of data.  We are a little
  684|      0|      // conservative and allow approximately one seek for every 16KB
  685|      0|      // of data before triggering a compaction.
  686|      0|      f->allowed_seeks = static_cast<int>((f->file_size / 16384U));
  687|      0|      if (f->allowed_seeks < 100) f->allowed_seeks = 100;
  688|      0|
  689|      0|      levels_[level].deleted_files.erase(f->number);
  690|      0|      levels_[level].added_files->insert(f);
  691|      0|    }
  692|      0|  }
  693|       |
  694|       |  // Save the current state in *v.
  695|      0|  void SaveTo(Version* v) {
  696|      0|    BySmallestKey cmp;
  697|      0|    cmp.internal_comparator = &vset_->icmp_;
  698|      0|    for (int level = 0; level < config::kNumLevels; level++) {
  699|      0|      // Merge the set of added files with the set of pre-existing files.
  700|      0|      // Drop any deleted files.  Store the result in *v.
  701|      0|      const std::vector<FileMetaData*>& base_files = base_->files_[level];
  702|      0|      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
  703|      0|      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
  704|      0|      const FileSet* added = levels_[level].added_files;
  705|      0|      v->files_[level].reserve(base_files.size() + added->size());
  706|      0|      for (FileSet::const_iterator added_iter = added->begin();
  707|      0|           added_iter != added->end(); ++added_iter) {
  708|      0|        // Add all smaller files listed in base_
  709|      0|        for (std::vector<FileMetaData*>::const_iterator bpos =
  710|      0|                 std::upper_bound(base_iter, base_end, *added_iter, cmp);
  711|      0|             base_iter != bpos; ++base_iter) {
  712|      0|          MaybeAddFile(v, level, *base_iter);
  713|      0|        }
  714|      0|
  715|      0|        MaybeAddFile(v, level, *added_iter);
  716|      0|      }
  717|      0|
  718|      0|      // Add remaining base files
  719|      0|      for (; base_iter != base_end; ++base_iter) {
  720|      0|        MaybeAddFile(v, level, *base_iter);
  721|      0|      }
  722|      0|
  723|      0|#ifndef NDEBUG
  724|      0|      // Make sure there is no overlap in levels > 0
  725|      0|      if (level > 0) {
  726|      0|        for (uint32_t i = 1; i < v->files_[level].size(); i++) {
  727|      0|          const InternalKey& prev_end = v->files_[level][i - 1]->largest;
  728|      0|          const InternalKey& this_begin = v->files_[level][i]->smallest;
  729|      0|          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {
  730|      0|            fprintf(stderr, "overlapping ranges in same level %s vs. %s\n",
  731|      0|                    prev_end.DebugString().c_str(),
  732|      0|                    this_begin.DebugString().c_str());
  733|      0|            abort();
  734|      0|          }
  735|      0|        }
  736|      0|      }
  737|      0|#endif
  738|      0|    }
  739|      0|  }
  740|       |
  741|      0|  void MaybeAddFile(Version* v, int level, FileMetaData* f) {
  742|      0|    if (levels_[level].deleted_files.count(f->number) > 0) {
  743|      0|      // File is deleted: do nothing
  744|      0|    } else {
  745|      0|      std::vector<FileMetaData*>* files = &v->files_[level];
  746|      0|      if (level > 0 && !files->empty()) {
  747|      0|        // Must not overlap
  748|      0|        assert(vset_->icmp_.Compare((*files)[files->size() - 1]->largest,
  749|      0|                                    f->smallest) < 0);
  750|      0|      }
  751|      0|      f->refs++;
  752|      0|      files->push_back(f);
  753|      0|    }
  754|      0|  }
  755|       |};
  756|       |
  757|       |VersionSet::VersionSet(const std::string& dbname, const Options* options,
  758|       |                       TableCache* table_cache,
  759|       |                       const InternalKeyComparator* cmp)
  760|       |    : env_(options->env),
  761|       |      dbname_(dbname),
  762|       |      options_(options),
  763|       |      table_cache_(table_cache),
  764|       |      icmp_(*cmp),
  765|       |      next_file_number_(2),
  766|       |      manifest_file_number_(0),  // Filled by Recover()
  767|       |      last_sequence_(0),
  768|       |      log_number_(0),
  769|       |      prev_log_number_(0),
  770|       |      descriptor_file_(nullptr),
  771|       |      descriptor_log_(nullptr),
  772|       |      dummy_versions_(this),
  773|      0|      current_(nullptr) {
  774|      0|  AppendVersion(new Version(this));
  775|      0|}
  776|       |
  777|      0|VersionSet::~VersionSet() {
  778|      0|  current_->Unref();
  779|      0|  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty
  780|      0|  delete descriptor_log_;
  781|      0|  delete descriptor_file_;
  782|      0|}
  783|       |
  784|      0|void VersionSet::AppendVersion(Version* v) {
  785|      0|  // Make "v" current
  786|      0|  assert(v->refs_ == 0);
  787|      0|  assert(v != current_);
  788|      0|  if (current_ != nullptr) {
  789|      0|    current_->Unref();
  790|      0|  }
  791|      0|  current_ = v;
  792|      0|  v->Ref();
  793|      0|
  794|      0|  // Append to linked list
  795|      0|  v->prev_ = dummy_versions_.prev_;
  796|      0|  v->next_ = &dummy_versions_;
  797|      0|  v->prev_->next_ = v;
  798|      0|  v->next_->prev_ = v;
  799|      0|}
  800|       |
  801|      0|Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {
  802|      0|  if (edit->has_log_number_) {
  803|      0|    assert(edit->log_number_ >= log_number_);
  804|      0|    assert(edit->log_number_ < next_file_number_);
  805|      0|  } else {
  806|      0|    edit->SetLogNumber(log_number_);
  807|      0|  }
  808|      0|
  809|      0|  if (!edit->has_prev_log_number_) {
  810|      0|    edit->SetPrevLogNumber(prev_log_number_);
  811|      0|  }
  812|      0|
  813|      0|  edit->SetNextFile(next_file_number_);
  814|      0|  edit->SetLastSequence(last_sequence_);
  815|      0|
  816|      0|  Version* v = new Version(this);
  817|      0|  {
  818|      0|    Builder builder(this, current_);
  819|      0|    builder.Apply(edit);
  820|      0|    builder.SaveTo(v);
  821|      0|  }
  822|      0|  Finalize(v);
  823|      0|
  824|      0|  // Initialize new descriptor log file if necessary by creating
  825|      0|  // a temporary file that contains a snapshot of the current version.
  826|      0|  std::string new_manifest_file;
  827|      0|  Status s;
  828|      0|  if (descriptor_log_ == nullptr) {
  829|      0|    // No reason to unlock *mu here since we only hit this path in the
  830|      0|    // first call to LogAndApply (when opening the database).
  831|      0|    assert(descriptor_file_ == nullptr);
  832|      0|    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
  833|      0|    edit->SetNextFile(next_file_number_);
  834|      0|    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);
  835|      0|    if (s.ok()) {
  836|      0|      descriptor_log_ = new log::Writer(descriptor_file_);
  837|      0|      s = WriteSnapshot(descriptor_log_);
  838|      0|    }
  839|      0|  }
  840|      0|
  841|      0|  // Unlock during expensive MANIFEST log write
  842|      0|  {
  843|      0|    mu->Unlock();
  844|      0|
  845|      0|    // Write new record to MANIFEST log
  846|      0|    if (s.ok()) {
  847|      0|      std::string record;
  848|      0|      edit->EncodeTo(&record);
  849|      0|      s = descriptor_log_->AddRecord(record);
  850|      0|      if (s.ok()) {
  851|      0|        s = descriptor_file_->Sync();
  852|      0|      }
  853|      0|      if (!s.ok()) {
  854|      0|        Log(options_->info_log, "MANIFEST write: %s\n", s.ToString().c_str());
  855|      0|      }
  856|      0|    }
  857|      0|
  858|      0|    // If we just created a new descriptor file, install it by writing a
  859|      0|    // new CURRENT file that points to it.
  860|      0|    if (s.ok() && !new_manifest_file.empty()) {
  861|      0|      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
  862|      0|    }
  863|      0|
  864|      0|    mu->Lock();
  865|      0|  }
  866|      0|
  867|      0|  // Install the new version
  868|      0|  if (s.ok()) {
  869|      0|    AppendVersion(v);
  870|      0|    log_number_ = edit->log_number_;
  871|      0|    prev_log_number_ = edit->prev_log_number_;
  872|      0|  } else {
  873|      0|    delete v;
  874|      0|    if (!new_manifest_file.empty()) {
  875|      0|      delete descriptor_log_;
  876|      0|      delete descriptor_file_;
  877|      0|      descriptor_log_ = nullptr;
  878|      0|      descriptor_file_ = nullptr;
  879|      0|      env_->DeleteFile(new_manifest_file);
  880|      0|    }
  881|      0|  }
  882|      0|
  883|      0|  return s;
  884|      0|}
  885|       |
  886|      0|Status VersionSet::Recover(bool* save_manifest) {
  887|      0|  struct LogReporter : public log::Reader::Reporter {
  888|      0|    Status* status;
  889|      0|    virtual void Corruption(size_t bytes, const Status& s) {
  890|      0|      if (this->status->ok()) *this->status = s;
  891|      0|    }
  892|      0|  };
  893|      0|
  894|      0|  // Read "CURRENT" file, which contains a pointer to the current manifest file
  895|      0|  std::string current;
  896|      0|  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);
  897|      0|  if (!s.ok()) {
  898|      0|    return s;
  899|      0|  }
  900|      0|  if (current.empty() || current[current.size() - 1] != '\n') {
  901|      0|    return Status::Corruption("CURRENT file does not end with newline");
  902|      0|  }
  903|      0|  current.resize(current.size() - 1);
  904|      0|
  905|      0|  std::string dscname = dbname_ + "/" + current;
  906|      0|  SequentialFile* file;
  907|      0|  s = env_->NewSequentialFile(dscname, &file);
  908|      0|  if (!s.ok()) {
  909|      0|    if (s.IsNotFound()) {
  910|      0|      return Status::Corruption("CURRENT points to a non-existent file",
  911|      0|                                s.ToString());
  912|      0|    }
  913|      0|    return s;
  914|      0|  }
  915|      0|
  916|      0|  bool have_log_number = false;
  917|      0|  bool have_prev_log_number = false;
  918|      0|  bool have_next_file = false;
  919|      0|  bool have_last_sequence = false;
  920|      0|  uint64_t next_file = 0;
  921|      0|  uint64_t last_sequence = 0;
  922|      0|  uint64_t log_number = 0;
  923|      0|  uint64_t prev_log_number = 0;
  924|      0|  Builder builder(this, current_);
  925|      0|
  926|      0|  {
  927|      0|    LogReporter reporter;
  928|      0|    reporter.status = &s;
  929|      0|    log::Reader reader(file, &reporter, true /*checksum*/,
  930|      0|                       0 /*initial_offset*/);
  931|      0|    Slice record;
  932|      0|    std::string scratch;
  933|      0|    while (reader.ReadRecord(&record, &scratch) && s.ok()) {
  934|      0|      VersionEdit edit;
  935|      0|      s = edit.DecodeFrom(record);
  936|      0|      if (s.ok()) {
  937|      0|        if (edit.has_comparator_ &&
  938|      0|            edit.comparator_ != icmp_.user_comparator()->Name()) {
  939|      0|          s = Status::InvalidArgument(
  940|      0|              edit.comparator_ + " does not match existing comparator ",
  941|      0|              icmp_.user_comparator()->Name());
  942|      0|        }
  943|      0|      }
  944|      0|
  945|      0|      if (s.ok()) {
  946|      0|        builder.Apply(&edit);
  947|      0|      }
  948|      0|
  949|      0|      if (edit.has_log_number_) {
  950|      0|        log_number = edit.log_number_;
  951|      0|        have_log_number = true;
  952|      0|      }
  953|      0|
  954|      0|      if (edit.has_prev_log_number_) {
  955|      0|        prev_log_number = edit.prev_log_number_;
  956|      0|        have_prev_log_number = true;
  957|      0|      }
  958|      0|
  959|      0|      if (edit.has_next_file_number_) {
  960|      0|        next_file = edit.next_file_number_;
  961|      0|        have_next_file = true;
  962|      0|      }
  963|      0|
  964|      0|      if (edit.has_last_sequence_) {
  965|      0|        last_sequence = edit.last_sequence_;
  966|      0|        have_last_sequence = true;
  967|      0|      }
  968|      0|    }
  969|      0|  }
  970|      0|  delete file;
  971|      0|  file = nullptr;
  972|      0|
  973|      0|  if (s.ok()) {
  974|      0|    if (!have_next_file) {
  975|      0|      s = Status::Corruption("no meta-nextfile entry in descriptor");
  976|      0|    } else if (!have_log_number) {
  977|      0|      s = Status::Corruption("no meta-lognumber entry in descriptor");
  978|      0|    } else if (!have_last_sequence) {
  979|      0|      s = Status::Corruption("no last-sequence-number entry in descriptor");
  980|      0|    }
  981|      0|
  982|      0|    if (!have_prev_log_number) {
  983|      0|      prev_log_number = 0;
  984|      0|    }
  985|      0|
  986|      0|    MarkFileNumberUsed(prev_log_number);
  987|      0|    MarkFileNumberUsed(log_number);
  988|      0|  }
  989|      0|
  990|      0|  if (s.ok()) {
  991|      0|    Version* v = new Version(this);
  992|      0|    builder.SaveTo(v);
  993|      0|    // Install recovered version
  994|      0|    Finalize(v);
  995|      0|    AppendVersion(v);
  996|      0|    manifest_file_number_ = next_file;
  997|      0|    next_file_number_ = next_file + 1;
  998|      0|    last_sequence_ = last_sequence;
  999|      0|    log_number_ = log_number;
 1000|      0|    prev_log_number_ = prev_log_number;
 1001|      0|
 1002|      0|    // See if we can reuse the existing MANIFEST file.
 1003|      0|    if (ReuseManifest(dscname, current)) {
 1004|      0|      // No need to save new manifest
 1005|      0|    } else {
 1006|      0|      *save_manifest = true;
 1007|      0|    }
 1008|      0|  }
 1009|      0|
 1010|      0|  return s;
 1011|      0|}
 1012|       |
 1013|       |bool VersionSet::ReuseManifest(const std::string& dscname,
 1014|      0|                               const std::string& dscbase) {
 1015|      0|  if (!options_->reuse_logs) {
 1016|      0|    return false;
 1017|      0|  }
 1018|      0|  FileType manifest_type;
 1019|      0|  uint64_t manifest_number;
 1020|      0|  uint64_t manifest_size;
 1021|      0|  if (!ParseFileName(dscbase, &manifest_number, &manifest_type) ||
 1022|      0|      manifest_type != kDescriptorFile ||
 1023|      0|      !env_->GetFileSize(dscname, &manifest_size).ok() ||
 1024|      0|      // Make new compacted MANIFEST if old one is too big
 1025|      0|      manifest_size >= TargetFileSize(options_)) {
 1026|      0|    return false;
 1027|      0|  }
 1028|      0|
 1029|      0|  assert(descriptor_file_ == nullptr);
 1030|      0|  assert(descriptor_log_ == nullptr);
 1031|      0|  Status r = env_->NewAppendableFile(dscname, &descriptor_file_);
 1032|      0|  if (!r.ok()) {
 1033|      0|    Log(options_->info_log, "Reuse MANIFEST: %s\n", r.ToString().c_str());
 1034|      0|    assert(descriptor_file_ == nullptr);
 1035|      0|    return false;
 1036|      0|  }
 1037|      0|
 1038|      0|  Log(options_->info_log, "Reusing MANIFEST %s\n", dscname.c_str());
 1039|      0|  descriptor_log_ = new log::Writer(descriptor_file_, manifest_size);
 1040|      0|  manifest_file_number_ = manifest_number;
 1041|      0|  return true;
 1042|      0|}
 1043|       |
 1044|      0|void VersionSet::MarkFileNumberUsed(uint64_t number) {
 1045|      0|  if (next_file_number_ <= number) {
 1046|      0|    next_file_number_ = number + 1;
 1047|      0|  }
 1048|      0|}
 1049|       |
 1050|      0|void VersionSet::Finalize(Version* v) {
 1051|      0|  // Precomputed best level for next compaction
 1052|      0|  int best_level = -1;
 1053|      0|  double best_score = -1;
 1054|      0|
 1055|      0|  for (int level = 0; level < config::kNumLevels - 1; level++) {
 1056|      0|    double score;
 1057|      0|    if (level == 0) {
 1058|      0|      // We treat level-0 specially by bounding the number of files
 1059|      0|      // instead of number of bytes for two reasons:
 1060|      0|      //
 1061|      0|      // (1) With larger write-buffer sizes, it is nice not to do too
 1062|      0|      // many level-0 compactions.
 1063|      0|      //
 1064|      0|      // (2) The files in level-0 are merged on every read and
 1065|      0|      // therefore we wish to avoid too many files when the individual
 1066|      0|      // file size is small (perhaps because of a small write-buffer
 1067|      0|      // setting, or very high compression ratios, or lots of
 1068|      0|      // overwrites/deletions).
 1069|      0|      score = v->files_[level].size() /
 1070|      0|              static_cast<double>(config::kL0_CompactionTrigger);
 1071|      0|    } else {
 1072|      0|      // Compute the ratio of current size to size limit.
 1073|      0|      const uint64_t level_bytes = TotalFileSize(v->files_[level]);
 1074|      0|      score =
 1075|      0|          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);
 1076|      0|    }
 1077|      0|
 1078|      0|    if (score > best_score) {
 1079|      0|      best_level = level;
 1080|      0|      best_score = score;
 1081|      0|    }
 1082|      0|  }
 1083|      0|
 1084|      0|  v->compaction_level_ = best_level;
 1085|      0|  v->compaction_score_ = best_score;
 1086|      0|}
 1087|       |
 1088|      0|Status VersionSet::WriteSnapshot(log::Writer* log) {
 1089|      0|  // TODO: Break up into multiple records to reduce memory usage on recovery?
 1090|      0|
 1091|      0|  // Save metadata
 1092|      0|  VersionEdit edit;
 1093|      0|  edit.SetComparatorName(icmp_.user_comparator()->Name());
 1094|      0|
 1095|      0|  // Save compaction pointers
 1096|      0|  for (int level = 0; level < config::kNumLevels; level++) {
 1097|      0|    if (!compact_pointer_[level].empty()) {
 1098|      0|      InternalKey key;
 1099|      0|      key.DecodeFrom(compact_pointer_[level]);
 1100|      0|      edit.SetCompactPointer(level, key);
 1101|      0|    }
 1102|      0|  }
 1103|      0|
 1104|      0|  // Save files
 1105|      0|  for (int level = 0; level < config::kNumLevels; level++) {
 1106|      0|    const std::vector<FileMetaData*>& files = current_->files_[level];
 1107|      0|    for (size_t i = 0; i < files.size(); i++) {
 1108|      0|      const FileMetaData* f = files[i];
 1109|      0|      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
 1110|      0|    }
 1111|      0|  }
 1112|      0|
 1113|      0|  std::string record;
 1114|      0|  edit.EncodeTo(&record);
 1115|      0|  return log->AddRecord(record);
 1116|      0|}
 1117|       |
 1118|      0|int VersionSet::NumLevelFiles(int level) const {
 1119|      0|  assert(level >= 0);
 1120|      0|  assert(level < config::kNumLevels);
 1121|      0|  return current_->files_[level].size();
 1122|      0|}
 1123|       |
 1124|      0|const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {
 1125|      0|  // Update code if kNumLevels changes
 1126|      0|  static_assert(config::kNumLevels == 7, "");
 1127|      0|  snprintf(scratch->buffer, sizeof(scratch->buffer),
 1128|      0|           "files[ %d %d %d %d %d %d %d ]", int(current_->files_[0].size()),
 1129|      0|           int(current_->files_[1].size()), int(current_->files_[2].size()),
 1130|      0|           int(current_->files_[3].size()), int(current_->files_[4].size()),
 1131|      0|           int(current_->files_[5].size()), int(current_->files_[6].size()));
 1132|      0|  return scratch->buffer;
 1133|      0|}
 1134|       |
 1135|      0|uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {
 1136|      0|  uint64_t result = 0;
 1137|      0|  for (int level = 0; level < config::kNumLevels; level++) {
 1138|      0|    const std::vector<FileMetaData*>& files = v->files_[level];
 1139|      0|    for (size_t i = 0; i < files.size(); i++) {
 1140|      0|      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
 1141|      0|        // Entire file is before "ikey", so just add the file size
 1142|      0|        result += files[i]->file_size;
 1143|      0|      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
 1144|      0|        // Entire file is after "ikey", so ignore
 1145|      0|        if (level > 0) {
 1146|      0|          // Files other than level 0 are sorted by meta->smallest, so
 1147|      0|          // no further files in this level will contain data for
 1148|      0|          // "ikey".
 1149|      0|          break;
 1150|      0|        }
 1151|      0|      } else {
 1152|      0|        // "ikey" falls in the range for this table.  Add the
 1153|      0|        // approximate offset of "ikey" within the table.
 1154|      0|        Table* tableptr;
 1155|      0|        Iterator* iter = table_cache_->NewIterator(
 1156|      0|            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);
 1157|      0|        if (tableptr != nullptr) {
 1158|      0|          result += tableptr->ApproximateOffsetOf(ikey.Encode());
 1159|      0|        }
 1160|      0|        delete iter;
 1161|      0|      }
 1162|      0|    }
 1163|      0|  }
 1164|      0|  return result;
 1165|      0|}
 1166|       |
 1167|      0|void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {
 1168|      0|  for (Version* v = dummy_versions_.next_; v != &dummy_versions_;
 1169|      0|       v = v->next_) {
 1170|      0|    for (int level = 0; level < config::kNumLevels; level++) {
 1171|      0|      const std::vector<FileMetaData*>& files = v->files_[level];
 1172|      0|      for (size_t i = 0; i < files.size(); i++) {
 1173|      0|        live->insert(files[i]->number);
 1174|      0|      }
 1175|      0|    }
 1176|      0|  }
 1177|      0|}
 1178|       |
 1179|      0|int64_t VersionSet::NumLevelBytes(int level) const {
 1180|      0|  assert(level >= 0);
 1181|      0|  assert(level < config::kNumLevels);
 1182|      0|  return TotalFileSize(current_->files_[level]);
 1183|      0|}
 1184|       |
 1185|      0|int64_t VersionSet::MaxNextLevelOverlappingBytes() {
 1186|      0|  int64_t result = 0;
 1187|      0|  std::vector<FileMetaData*> overlaps;
 1188|      0|  for (int level = 1; level < config::kNumLevels - 1; level++) {
 1189|      0|    for (size_t i = 0; i < current_->files_[level].size(); i++) {
 1190|      0|      const FileMetaData* f = current_->files_[level][i];
 1191|      0|      current_->GetOverlappingInputs(level + 1, &f->smallest, &f->largest,
 1192|      0|                                     &overlaps);
 1193|      0|      const int64_t sum = TotalFileSize(overlaps);
 1194|      0|      if (sum > result) {
 1195|      0|        result = sum;
 1196|      0|      }
 1197|      0|    }
 1198|      0|  }
 1199|      0|  return result;
 1200|      0|}
 1201|       |
 1202|       |// Stores the minimal range that covers all entries in inputs in
 1203|       |// *smallest, *largest.
 1204|       |// REQUIRES: inputs is not empty
 1205|       |void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,
 1206|      0|                          InternalKey* smallest, InternalKey* largest) {
 1207|      0|  assert(!inputs.empty());
 1208|      0|  smallest->Clear();
 1209|      0|  largest->Clear();
 1210|      0|  for (size_t i = 0; i < inputs.size(); i++) {
 1211|      0|    FileMetaData* f = inputs[i];
 1212|      0|    if (i == 0) {
 1213|      0|      *smallest = f->smallest;
 1214|      0|      *largest = f->largest;
 1215|      0|    } else {
 1216|      0|      if (icmp_.Compare(f->smallest, *smallest) < 0) {
 1217|      0|        *smallest = f->smallest;
 1218|      0|      }
 1219|      0|      if (icmp_.Compare(f->largest, *largest) > 0) {
 1220|      0|        *largest = f->largest;
 1221|      0|      }
 1222|      0|    }
 1223|      0|  }
 1224|      0|}
 1225|       |
 1226|       |// Stores the minimal range that covers all entries in inputs1 and inputs2
 1227|       |// in *smallest, *largest.
 1228|       |// REQUIRES: inputs is not empty
 1229|       |void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,
 1230|       |                           const std::vector<FileMetaData*>& inputs2,
 1231|      0|                           InternalKey* smallest, InternalKey* largest) {
 1232|      0|  std::vector<FileMetaData*> all = inputs1;
 1233|      0|  all.insert(all.end(), inputs2.begin(), inputs2.end());
 1234|      0|  GetRange(all, smallest, largest);
 1235|      0|}
 1236|       |
 1237|      0|Iterator* VersionSet::MakeInputIterator(Compaction* c) {
 1238|      0|  ReadOptions options;
 1239|      0|  options.verify_checksums = options_->paranoid_checks;
 1240|      0|  options.fill_cache = false;
 1241|      0|
 1242|      0|  // Level-0 files have to be merged together.  For other levels,
 1243|      0|  // we will make a concatenating iterator per level.
 1244|      0|  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
 1245|      0|  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);
 1246|      0|  Iterator** list = new Iterator*[space];
 1247|      0|  int num = 0;
 1248|      0|  for (int which = 0; which < 2; which++) {
 1249|      0|    if (!c->inputs_[which].empty()) {
 1250|      0|      if (c->level() + which == 0) {
 1251|      0|        const std::vector<FileMetaData*>& files = c->inputs_[which];
 1252|      0|        for (size_t i = 0; i < files.size(); i++) {
 1253|      0|          list[num++] = table_cache_->NewIterator(options, files[i]->number,
 1254|      0|                                                  files[i]->file_size);
 1255|      0|        }
 1256|      0|      } else {
 1257|      0|        // Create concatenating iterator for the files from this level
 1258|      0|        list[num++] = NewTwoLevelIterator(
 1259|      0|            new Version::LevelFileNumIterator(icmp_, &c->inputs_[which]),
 1260|      0|            &GetFileIterator, table_cache_, options);
 1261|      0|      }
 1262|      0|    }
 1263|      0|  }
 1264|      0|  assert(num <= space);
 1265|      0|  Iterator* result = NewMergingIterator(&icmp_, list, num);
 1266|      0|  delete[] list;
 1267|      0|  return result;
 1268|      0|}
 1269|       |
 1270|      0|Compaction* VersionSet::PickCompaction() {
 1271|      0|  Compaction* c;
 1272|      0|  int level;
 1273|      0|
 1274|      0|  // We prefer compactions triggered by too much data in a level over
 1275|      0|  // the compactions triggered by seeks.
 1276|      0|  const bool size_compaction = (current_->compaction_score_ >= 1);
 1277|      0|  const bool seek_compaction = (current_->file_to_compact_ != nullptr);
 1278|      0|  if (size_compaction) {
 1279|      0|    level = current_->compaction_level_;
 1280|      0|    assert(level >= 0);
 1281|      0|    assert(level + 1 < config::kNumLevels);
 1282|      0|    c = new Compaction(options_, level);
 1283|      0|
 1284|      0|    // Pick the first file that comes after compact_pointer_[level]
 1285|      0|    for (size_t i = 0; i < current_->files_[level].size(); i++) {
 1286|      0|      FileMetaData* f = current_->files_[level][i];
 1287|      0|      if (compact_pointer_[level].empty() ||
 1288|      0|          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
 1289|      0|        c->inputs_[0].push_back(f);
 1290|      0|        break;
 1291|      0|      }
 1292|      0|    }
 1293|      0|    if (c->inputs_[0].empty()) {
 1294|      0|      // Wrap-around to the beginning of the key space
 1295|      0|      c->inputs_[0].push_back(current_->files_[level][0]);
 1296|      0|    }
 1297|      0|  } else if (seek_compaction) {
 1298|      0|    level = current_->file_to_compact_level_;
 1299|      0|    c = new Compaction(options_, level);
 1300|      0|    c->inputs_[0].push_back(current_->file_to_compact_);
 1301|      0|  } else {
 1302|      0|    return nullptr;
 1303|      0|  }
 1304|      0|
 1305|      0|  c->input_version_ = current_;
 1306|      0|  c->input_version_->Ref();
 1307|      0|
 1308|      0|  // Files in level 0 may overlap each other, so pick up all overlapping ones
 1309|      0|  if (level == 0) {
 1310|      0|    InternalKey smallest, largest;
 1311|      0|    GetRange(c->inputs_[0], &smallest, &largest);
 1312|      0|    // Note that the next call will discard the file we placed in
 1313|      0|    // c->inputs_[0] earlier and replace it with an overlapping set
 1314|      0|    // which will include the picked file.
 1315|      0|    current_->GetOverlappingInputs(0, &smallest, &largest, &c->inputs_[0]);
 1316|      0|    assert(!c->inputs_[0].empty());
 1317|      0|  }
 1318|      0|
 1319|      0|  SetupOtherInputs(c);
 1320|      0|
 1321|      0|  return c;
 1322|      0|}
 1323|       |
 1324|       |// Finds the largest key in a vector of files. Returns true if files it not
 1325|       |// empty.
 1326|       |bool FindLargestKey(const InternalKeyComparator& icmp,
 1327|       |                    const std::vector<FileMetaData*>& files,
 1328|      0|                    InternalKey* largest_key) {
 1329|      0|  if (files.empty()) {
 1330|      0|    return false;
 1331|      0|  }
 1332|      0|  *largest_key = files[0]->largest;
 1333|      0|  for (size_t i = 1; i < files.size(); ++i) {
 1334|      0|    FileMetaData* f = files[i];
 1335|      0|    if (icmp.Compare(f->largest, *largest_key) > 0) {
 1336|      0|      *largest_key = f->largest;
 1337|      0|    }
 1338|      0|  }
 1339|      0|  return true;
 1340|      0|}
 1341|       |
 1342|       |// Finds minimum file b2=(l2, u2) in level file for which l2 > u1 and
 1343|       |// user_key(l2) = user_key(u1)
 1344|       |FileMetaData* FindSmallestBoundaryFile(
 1345|       |    const InternalKeyComparator& icmp,
 1346|       |    const std::vector<FileMetaData*>& level_files,
 1347|      0|    const InternalKey& largest_key) {
 1348|      0|  const Comparator* user_cmp = icmp.user_comparator();
 1349|      0|  FileMetaData* smallest_boundary_file = nullptr;
 1350|      0|  for (size_t i = 0; i < level_files.size(); ++i) {
 1351|      0|    FileMetaData* f = level_files[i];
 1352|      0|    if (icmp.Compare(f->smallest, largest_key) > 0 &&
 1353|      0|        user_cmp->Compare(f->smallest.user_key(), largest_key.user_key()) ==
 1354|      0|            0) {
 1355|      0|      if (smallest_boundary_file == nullptr ||
 1356|      0|          icmp.Compare(f->smallest, smallest_boundary_file->smallest) < 0) {
 1357|      0|        smallest_boundary_file = f;
 1358|      0|      }
 1359|      0|    }
 1360|      0|  }
 1361|      0|  return smallest_boundary_file;
 1362|      0|}
 1363|       |
 1364|       |// Extracts the largest file b1 from |compaction_files| and then searches for a
 1365|       |// b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a
 1366|       |// file b2 (known as a boundary file) it adds it to |compaction_files| and then
 1367|       |// searches again using this new upper bound.
 1368|       |//
 1369|       |// If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and
 1370|       |// user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a
 1371|       |// subsequent get operation will yield an incorrect result because it will
 1372|       |// return the record from b2 in level i rather than from b1 because it searches
 1373|       |// level by level for records matching the supplied user key.
 1374|       |//
 1375|       |// parameters:
 1376|       |//   in     level_files:      List of files to search for boundary files.
 1377|       |//   in/out compaction_files: List of files to extend by adding boundary files.
 1378|       |void AddBoundaryInputs(const InternalKeyComparator& icmp,
 1379|       |                       const std::vector<FileMetaData*>& level_files,
 1380|      0|                       std::vector<FileMetaData*>* compaction_files) {
 1381|      0|  InternalKey largest_key;
 1382|      0|
 1383|      0|  // Quick return if compaction_files is empty.
 1384|      0|  if (!FindLargestKey(icmp, *compaction_files, &largest_key)) {
 1385|      0|    return;
 1386|      0|  }
 1387|      0|
 1388|      0|  bool continue_searching = true;
 1389|      0|  while (continue_searching) {
 1390|      0|    FileMetaData* smallest_boundary_file =
 1391|      0|        FindSmallestBoundaryFile(icmp, level_files, largest_key);
 1392|      0|
 1393|      0|    // If a boundary file was found advance largest_key, otherwise we're done.
 1394|      0|    if (smallest_boundary_file != NULL) {
 1395|      0|      compaction_files->push_back(smallest_boundary_file);
 1396|      0|      largest_key = smallest_boundary_file->largest;
 1397|      0|    } else {
 1398|      0|      continue_searching = false;
 1399|      0|    }
 1400|      0|  }
 1401|      0|}
 1402|       |
 1403|      0|void VersionSet::SetupOtherInputs(Compaction* c) {
 1404|      0|  const int level = c->level();
 1405|      0|  InternalKey smallest, largest;
 1406|      0|
 1407|      0|  AddBoundaryInputs(icmp_, current_->files_[level], &c->inputs_[0]);
 1408|      0|  GetRange(c->inputs_[0], &smallest, &largest);
 1409|      0|
 1410|      0|  current_->GetOverlappingInputs(level + 1, &smallest, &largest,
 1411|      0|                                 &c->inputs_[1]);
 1412|      0|
 1413|      0|  // Get entire range covered by compaction
 1414|      0|  InternalKey all_start, all_limit;
 1415|      0|  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);
 1416|      0|
 1417|      0|  // See if we can grow the number of inputs in "level" without
 1418|      0|  // changing the number of "level+1" files we pick up.
 1419|      0|  if (!c->inputs_[1].empty()) {
 1420|      0|    std::vector<FileMetaData*> expanded0;
 1421|      0|    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
 1422|      0|    AddBoundaryInputs(icmp_, current_->files_[level], &expanded0);
 1423|      0|    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
 1424|      0|    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
 1425|      0|    const int64_t expanded0_size = TotalFileSize(expanded0);
 1426|      0|    if (expanded0.size() > c->inputs_[0].size() &&
 1427|      0|        inputs1_size + expanded0_size <
 1428|      0|            ExpandedCompactionByteSizeLimit(options_)) {
 1429|      0|      InternalKey new_start, new_limit;
 1430|      0|      GetRange(expanded0, &new_start, &new_limit);
 1431|      0|      std::vector<FileMetaData*> expanded1;
 1432|      0|      current_->GetOverlappingInputs(level + 1, &new_start, &new_limit,
 1433|      0|                                     &expanded1);
 1434|      0|      if (expanded1.size() == c->inputs_[1].size()) {
 1435|      0|        Log(options_->info_log,
 1436|      0|            "Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n",
 1437|      0|            level, int(c->inputs_[0].size()), int(c->inputs_[1].size()),
 1438|      0|            long(inputs0_size), long(inputs1_size), int(expanded0.size()),
 1439|      0|            int(expanded1.size()), long(expanded0_size), long(inputs1_size));
 1440|      0|        smallest = new_start;
 1441|      0|        largest = new_limit;
 1442|      0|        c->inputs_[0] = expanded0;
 1443|      0|        c->inputs_[1] = expanded1;
 1444|      0|        GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);
 1445|      0|      }
 1446|      0|    }
 1447|      0|  }
 1448|      0|
 1449|      0|  // Compute the set of grandparent files that overlap this compaction
 1450|      0|  // (parent == level+1; grandparent == level+2)
 1451|      0|  if (level + 2 < config::kNumLevels) {
 1452|      0|    current_->GetOverlappingInputs(level + 2, &all_start, &all_limit,
 1453|      0|                                   &c->grandparents_);
 1454|      0|  }
 1455|      0|
 1456|      0|  // Update the place where we will do the next compaction for this level.
 1457|      0|  // We update this immediately instead of waiting for the VersionEdit
 1458|      0|  // to be applied so that if the compaction fails, we will try a different
 1459|      0|  // key range next time.
 1460|      0|  compact_pointer_[level] = largest.Encode().ToString();
 1461|      0|  c->edit_.SetCompactPointer(level, largest);
 1462|      0|}
 1463|       |
 1464|       |Compaction* VersionSet::CompactRange(int level, const InternalKey* begin,
 1465|      0|                                     const InternalKey* end) {
 1466|      0|  std::vector<FileMetaData*> inputs;
 1467|      0|  current_->GetOverlappingInputs(level, begin, end, &inputs);
 1468|      0|  if (inputs.empty()) {
 1469|      0|    return nullptr;
 1470|      0|  }
 1471|      0|
 1472|      0|  // Avoid compacting too much in one shot in case the range is large.
 1473|      0|  // But we cannot do this for level-0 since level-0 files can overlap
 1474|      0|  // and we must not pick one file and drop another older file if the
 1475|      0|  // two files overlap.
 1476|      0|  if (level > 0) {
 1477|      0|    const uint64_t limit = MaxFileSizeForLevel(options_, level);
 1478|      0|    uint64_t total = 0;
 1479|      0|    for (size_t i = 0; i < inputs.size(); i++) {
 1480|      0|      uint64_t s = inputs[i]->file_size;
 1481|      0|      total += s;
 1482|      0|      if (total >= limit) {
 1483|      0|        inputs.resize(i + 1);
 1484|      0|        break;
 1485|      0|      }
 1486|      0|    }
 1487|      0|  }
 1488|      0|
 1489|      0|  Compaction* c = new Compaction(options_, level);
 1490|      0|  c->input_version_ = current_;
 1491|      0|  c->input_version_->Ref();
 1492|      0|  c->inputs_[0] = inputs;
 1493|      0|  SetupOtherInputs(c);
 1494|      0|  return c;
 1495|      0|}
 1496|       |
 1497|       |Compaction::Compaction(const Options* options, int level)
 1498|       |    : level_(level),
 1499|       |      max_output_file_size_(MaxFileSizeForLevel(options, level)),
 1500|       |      input_version_(nullptr),
 1501|       |      grandparent_index_(0),
 1502|       |      seen_key_(false),
 1503|      0|      overlapped_bytes_(0) {
 1504|      0|  for (int i = 0; i < config::kNumLevels; i++) {
 1505|      0|    level_ptrs_[i] = 0;
 1506|      0|  }
 1507|      0|}
 1508|       |
 1509|      0|Compaction::~Compaction() {
 1510|      0|  if (input_version_ != nullptr) {
 1511|      0|    input_version_->Unref();
 1512|      0|  }
 1513|      0|}
 1514|       |
 1515|      0|bool Compaction::IsTrivialMove() const {
 1516|      0|  const VersionSet* vset = input_version_->vset_;
 1517|      0|  // Avoid a move if there is lots of overlapping grandparent data.
 1518|      0|  // Otherwise, the move could create a parent file that will require
 1519|      0|  // a very expensive merge later on.
 1520|      0|  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&
 1521|      0|          TotalFileSize(grandparents_) <=
 1522|      0|              MaxGrandParentOverlapBytes(vset->options_));
 1523|      0|}
 1524|       |
 1525|      0|void Compaction::AddInputDeletions(VersionEdit* edit) {
 1526|      0|  for (int which = 0; which < 2; which++) {
 1527|      0|    for (size_t i = 0; i < inputs_[which].size(); i++) {
 1528|      0|      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
 1529|      0|    }
 1530|      0|  }
 1531|      0|}
 1532|       |
 1533|      0|bool Compaction::IsBaseLevelForKey(const Slice& user_key) {
 1534|      0|  // Maybe use binary search to find right entry instead of linear search?
 1535|      0|  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();
 1536|      0|  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {
 1537|      0|    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
 1538|      0|    for (; level_ptrs_[lvl] < files.size();) {
 1539|      0|      FileMetaData* f = files[level_ptrs_[lvl]];
 1540|      0|      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
 1541|      0|        // We've advanced far enough
 1542|      0|        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
 1543|      0|          // Key falls in this file's range, so definitely not base level
 1544|      0|          return false;
 1545|      0|        }
 1546|      0|        break;
 1547|      0|      }
 1548|      0|      level_ptrs_[lvl]++;
 1549|      0|    }
 1550|      0|  }
 1551|      0|  return true;
 1552|      0|}
 1553|       |
 1554|      0|bool Compaction::ShouldStopBefore(const Slice& internal_key) {
 1555|      0|  const VersionSet* vset = input_version_->vset_;
 1556|      0|  // Scan to find earliest grandparent file that contains key.
 1557|      0|  const InternalKeyComparator* icmp = &vset->icmp_;
 1558|      0|  while (grandparent_index_ < grandparents_.size() &&
 1559|      0|         icmp->Compare(internal_key,
 1560|      0|                       grandparents_[grandparent_index_]->largest.Encode()) >
 1561|      0|             0) {
 1562|      0|    if (seen_key_) {
 1563|      0|      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
 1564|      0|    }
 1565|      0|    grandparent_index_++;
 1566|      0|  }
 1567|      0|  seen_key_ = true;
 1568|      0|
 1569|      0|  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {
 1570|      0|    // Too much overlap for current output; start new output
 1571|      0|    overlapped_bytes_ = 0;
 1572|      0|    return true;
 1573|      0|  } else {
 1574|      0|    return false;
 1575|      0|  }
 1576|      0|}
 1577|       |
 1578|      0|void Compaction::ReleaseInputs() {
 1579|      0|  if (input_version_ != nullptr) {
 1580|      0|    input_version_->Unref();
 1581|      0|    input_version_ = nullptr;
 1582|      0|  }
 1583|      0|}
 1584|       |
 1585|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/version_set.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// The representation of a DBImpl consists of a set of Versions.  The
    6|       |// newest version is called "current".  Older versions may be kept
    7|       |// around to provide a consistent view to live iterators.
    8|       |//
    9|       |// Each Version keeps track of a set of Table files per level.  The
   10|       |// entire set of versions is maintained in a VersionSet.
   11|       |//
   12|       |// Version,VersionSet are thread-compatible, but require external
   13|       |// synchronization on all accesses.
   14|       |
   15|       |#ifndef STORAGE_LEVELDB_DB_VERSION_SET_H_
   16|       |#define STORAGE_LEVELDB_DB_VERSION_SET_H_
   17|       |
   18|       |#include <map>
   19|       |#include <set>
   20|       |#include <vector>
   21|       |
   22|       |#include "db/dbformat.h"
   23|       |#include "db/version_edit.h"
   24|       |#include "port/port.h"
   25|       |#include "port/thread_annotations.h"
   26|       |
   27|       |namespace leveldb {
   28|       |
   29|       |namespace log {
   30|       |class Writer;
   31|       |}
   32|       |
   33|       |class Compaction;
   34|       |class Iterator;
   35|       |class MemTable;
   36|       |class TableBuilder;
   37|       |class TableCache;
   38|       |class Version;
   39|       |class VersionSet;
   40|       |class WritableFile;
   41|       |
   42|       |// Return the smallest index i such that files[i]->largest >= key.
   43|       |// Return files.size() if there is no such file.
   44|       |// REQUIRES: "files" contains a sorted list of non-overlapping files.
   45|       |int FindFile(const InternalKeyComparator& icmp,
   46|       |             const std::vector<FileMetaData*>& files, const Slice& key);
   47|       |
   48|       |// Returns true iff some file in "files" overlaps the user key range
   49|       |// [*smallest,*largest].
   50|       |// smallest==nullptr represents a key smaller than all keys in the DB.
   51|       |// largest==nullptr represents a key largest than all keys in the DB.
   52|       |// REQUIRES: If disjoint_sorted_files, files[] contains disjoint ranges
   53|       |//           in sorted order.
   54|       |bool SomeFileOverlapsRange(const InternalKeyComparator& icmp,
   55|       |                           bool disjoint_sorted_files,
   56|       |                           const std::vector<FileMetaData*>& files,
   57|       |                           const Slice* smallest_user_key,
   58|       |                           const Slice* largest_user_key);
   59|       |
   60|       |class Version {
   61|       | public:
   62|       |  // Lookup the value for key.  If found, store it in *val and
   63|       |  // return OK.  Else return a non-OK status.  Fills *stats.
   64|       |  // REQUIRES: lock is not held
   65|       |  struct GetStats {
   66|       |    FileMetaData* seek_file;
   67|       |    int seek_file_level;
   68|       |  };
   69|       |
   70|       |  // Append to *iters a sequence of iterators that will
   71|       |  // yield the contents of this Version when merged together.
   72|       |  // REQUIRES: This version has been saved (see VersionSet::SaveTo)
   73|       |  void AddIterators(const ReadOptions&, std::vector<Iterator*>* iters);
   74|       |
   75|       |  Status Get(const ReadOptions&, const LookupKey& key, std::string* val,
   76|       |             GetStats* stats);
   77|       |
   78|       |  // Adds "stats" into the current state.  Returns true if a new
   79|       |  // compaction may need to be triggered, false otherwise.
   80|       |  // REQUIRES: lock is held
   81|       |  bool UpdateStats(const GetStats& stats);
   82|       |
   83|       |  // Record a sample of bytes read at the specified internal key.
   84|       |  // Samples are taken approximately once every config::kReadBytesPeriod
   85|       |  // bytes.  Returns true if a new compaction may need to be triggered.
   86|       |  // REQUIRES: lock is held
   87|       |  bool RecordReadSample(Slice key);
   88|       |
   89|       |  // Reference count management (so Versions do not disappear out from
   90|       |  // under live iterators)
   91|       |  void Ref();
   92|       |  void Unref();
   93|       |
   94|       |  void GetOverlappingInputs(
   95|       |      int level,
   96|       |      const InternalKey* begin,  // nullptr means before all keys
   97|       |      const InternalKey* end,    // nullptr means after all keys
   98|       |      std::vector<FileMetaData*>* inputs);
   99|       |
  100|       |  // Returns true iff some file in the specified level overlaps
  101|       |  // some part of [*smallest_user_key,*largest_user_key].
  102|       |  // smallest_user_key==nullptr represents a key smaller than all the DB's keys.
  103|       |  // largest_user_key==nullptr represents a key largest than all the DB's keys.
  104|       |  bool OverlapInLevel(int level, const Slice* smallest_user_key,
  105|       |                      const Slice* largest_user_key);
  106|       |
  107|       |  // Return the level at which we should place a new memtable compaction
  108|       |  // result that covers the range [smallest_user_key,largest_user_key].
  109|       |  int PickLevelForMemTableOutput(const Slice& smallest_user_key,
  110|       |                                 const Slice& largest_user_key);
  111|       |
  112|      0|  int NumFiles(int level) const { return files_[level].size(); }
  113|       |
  114|       |  // Return a human readable string that describes this version's contents.
  115|       |  std::string DebugString() const;
  116|       |
  117|       | private:
  118|       |  friend class Compaction;
  119|       |  friend class VersionSet;
  120|       |
  121|       |  class LevelFileNumIterator;
  122|       |
  123|       |  explicit Version(VersionSet* vset)
  124|       |      : vset_(vset),
  125|       |        next_(this),
  126|       |        prev_(this),
  127|       |        refs_(0),
  128|       |        file_to_compact_(nullptr),
  129|       |        file_to_compact_level_(-1),
  130|       |        compaction_score_(-1),
  131|      0|        compaction_level_(-1) {}
  132|       |
  133|       |  Version(const Version&) = delete;
  134|       |  Version& operator=(const Version&) = delete;
  135|       |
  136|       |  ~Version();
  137|       |
  138|       |  Iterator* NewConcatenatingIterator(const ReadOptions&, int level) const;
  139|       |
  140|       |  // Call func(arg, level, f) for every file that overlaps user_key in
  141|       |  // order from newest to oldest.  If an invocation of func returns
  142|       |  // false, makes no more calls.
  143|       |  //
  144|       |  // REQUIRES: user portion of internal_key == user_key.
  145|       |  void ForEachOverlapping(Slice user_key, Slice internal_key, void* arg,
  146|       |                          bool (*func)(void*, int, FileMetaData*));
  147|       |
  148|       |  VersionSet* vset_;  // VersionSet to which this Version belongs
  149|       |  Version* next_;     // Next version in linked list
  150|       |  Version* prev_;     // Previous version in linked list
  151|       |  int refs_;          // Number of live refs to this version
  152|       |
  153|       |  // List of files per level
  154|       |  std::vector<FileMetaData*> files_[config::kNumLevels];
  155|       |
  156|       |  // Next file to compact based on seek stats.
  157|       |  FileMetaData* file_to_compact_;
  158|       |  int file_to_compact_level_;
  159|       |
  160|       |  // Level that should be compacted next and its compaction score.
  161|       |  // Score < 1 means compaction is not strictly needed.  These fields
  162|       |  // are initialized by Finalize().
  163|       |  double compaction_score_;
  164|       |  int compaction_level_;
  165|       |};
  166|       |
  167|       |class VersionSet {
  168|       | public:
  169|       |  VersionSet(const std::string& dbname, const Options* options,
  170|       |             TableCache* table_cache, const InternalKeyComparator*);
  171|       |  VersionSet(const VersionSet&) = delete;
  172|       |  VersionSet& operator=(const VersionSet&) = delete;
  173|       |
  174|       |  ~VersionSet();
  175|       |
  176|       |  // Apply *edit to the current version to form a new descriptor that
  177|       |  // is both saved to persistent state and installed as the new
  178|       |  // current version.  Will release *mu while actually writing to the file.
  179|       |  // REQUIRES: *mu is held on entry.
  180|       |  // REQUIRES: no other thread concurrently calls LogAndApply()
  181|       |  Status LogAndApply(VersionEdit* edit, port::Mutex* mu)
  182|       |      EXCLUSIVE_LOCKS_REQUIRED(mu);
  183|       |
  184|       |  // Recover the last saved descriptor from persistent storage.
  185|       |  Status Recover(bool* save_manifest);
  186|       |
  187|       |  // Return the current version.
  188|      0|  Version* current() const { return current_; }
  189|       |
  190|       |  // Return the current manifest file number
  191|      0|  uint64_t ManifestFileNumber() const { return manifest_file_number_; }
  192|       |
  193|       |  // Allocate and return a new file number
  194|      0|  uint64_t NewFileNumber() { return next_file_number_++; }
  195|       |
  196|       |  // Arrange to reuse "file_number" unless a newer file number has
  197|       |  // already been allocated.
  198|       |  // REQUIRES: "file_number" was returned by a call to NewFileNumber().
  199|      0|  void ReuseFileNumber(uint64_t file_number) {
  200|      0|    if (next_file_number_ == file_number + 1) {
  201|      0|      next_file_number_ = file_number;
  202|      0|    }
  203|      0|  }
  204|       |
  205|       |  // Return the number of Table files at the specified level.
  206|       |  int NumLevelFiles(int level) const;
  207|       |
  208|       |  // Return the combined file size of all files at the specified level.
  209|       |  int64_t NumLevelBytes(int level) const;
  210|       |
  211|       |  // Return the last sequence number.
  212|      0|  uint64_t LastSequence() const { return last_sequence_; }
  213|       |
  214|       |  // Set the last sequence number to s.
  215|      0|  void SetLastSequence(uint64_t s) {
  216|      0|    assert(s >= last_sequence_);
  217|      0|    last_sequence_ = s;
  218|      0|  }
  219|       |
  220|       |  // Mark the specified file number as used.
  221|       |  void MarkFileNumberUsed(uint64_t number);
  222|       |
  223|       |  // Return the current log file number.
  224|      0|  uint64_t LogNumber() const { return log_number_; }
  225|       |
  226|       |  // Return the log file number for the log file that is currently
  227|       |  // being compacted, or zero if there is no such log file.
  228|      0|  uint64_t PrevLogNumber() const { return prev_log_number_; }
  229|       |
  230|       |  // Pick level and inputs for a new compaction.
  231|       |  // Returns nullptr if there is no compaction to be done.
  232|       |  // Otherwise returns a pointer to a heap-allocated object that
  233|       |  // describes the compaction.  Caller should delete the result.
  234|       |  Compaction* PickCompaction();
  235|       |
  236|       |  // Return a compaction object for compacting the range [begin,end] in
  237|       |  // the specified level.  Returns nullptr if there is nothing in that
  238|       |  // level that overlaps the specified range.  Caller should delete
  239|       |  // the result.
  240|       |  Compaction* CompactRange(int level, const InternalKey* begin,
  241|       |                           const InternalKey* end);
  242|       |
  243|       |  // Return the maximum overlapping data (in bytes) at next level for any
  244|       |  // file at a level >= 1.
  245|       |  int64_t MaxNextLevelOverlappingBytes();
  246|       |
  247|       |  // Create an iterator that reads over the compaction inputs for "*c".
  248|       |  // The caller should delete the iterator when no longer needed.
  249|       |  Iterator* MakeInputIterator(Compaction* c);
  250|       |
  251|       |  // Returns true iff some level needs a compaction.
  252|      0|  bool NeedsCompaction() const {
  253|      0|    Version* v = current_;
  254|      0|    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != nullptr);
  255|      0|  }
  256|       |
  257|       |  // Add all files listed in any live version to *live.
  258|       |  // May also mutate some internal state.
  259|       |  void AddLiveFiles(std::set<uint64_t>* live);
  260|       |
  261|       |  // Return the approximate offset in the database of the data for
  262|       |  // "key" as of version "v".
  263|       |  uint64_t ApproximateOffsetOf(Version* v, const InternalKey& key);
  264|       |
  265|       |  // Return a human-readable short (single-line) summary of the number
  266|       |  // of files per level.  Uses *scratch as backing store.
  267|       |  struct LevelSummaryStorage {
  268|       |    char buffer[100];
  269|       |  };
  270|       |  const char* LevelSummary(LevelSummaryStorage* scratch) const;
  271|       |
  272|       | private:
  273|       |  class Builder;
  274|       |
  275|       |  friend class Compaction;
  276|       |  friend class Version;
  277|       |
  278|       |  bool ReuseManifest(const std::string& dscname, const std::string& dscbase);
  279|       |
  280|       |  void Finalize(Version* v);
  281|       |
  282|       |  void GetRange(const std::vector<FileMetaData*>& inputs, InternalKey* smallest,
  283|       |                InternalKey* largest);
  284|       |
  285|       |  void GetRange2(const std::vector<FileMetaData*>& inputs1,
  286|       |                 const std::vector<FileMetaData*>& inputs2,
  287|       |                 InternalKey* smallest, InternalKey* largest);
  288|       |
  289|       |  void SetupOtherInputs(Compaction* c);
  290|       |
  291|       |  // Save current contents to *log
  292|       |  Status WriteSnapshot(log::Writer* log);
  293|       |
  294|       |  void AppendVersion(Version* v);
  295|       |
  296|       |  Env* const env_;
  297|       |  const std::string dbname_;
  298|       |  const Options* const options_;
  299|       |  TableCache* const table_cache_;
  300|       |  const InternalKeyComparator icmp_;
  301|       |  uint64_t next_file_number_;
  302|       |  uint64_t manifest_file_number_;
  303|       |  uint64_t last_sequence_;
  304|       |  uint64_t log_number_;
  305|       |  uint64_t prev_log_number_;  // 0 or backing store for memtable being compacted
  306|       |
  307|       |  // Opened lazily
  308|       |  WritableFile* descriptor_file_;
  309|       |  log::Writer* descriptor_log_;
  310|       |  Version dummy_versions_;  // Head of circular doubly-linked list of versions.
  311|       |  Version* current_;        // == dummy_versions_.prev_
  312|       |
  313|       |  // Per-level key at which the next compaction at that level should start.
  314|       |  // Either an empty string, or a valid InternalKey.
  315|       |  std::string compact_pointer_[config::kNumLevels];
  316|       |};
  317|       |
  318|       |// A Compaction encapsulates information about a compaction.
  319|       |class Compaction {
  320|       | public:
  321|       |  ~Compaction();
  322|       |
  323|       |  // Return the level that is being compacted.  Inputs from "level"
  324|       |  // and "level+1" will be merged to produce a set of "level+1" files.
  325|      0|  int level() const { return level_; }
  326|       |
  327|       |  // Return the object that holds the edits to the descriptor done
  328|       |  // by this compaction.
  329|      0|  VersionEdit* edit() { return &edit_; }
  330|       |
  331|       |  // "which" must be either 0 or 1
  332|      0|  int num_input_files(int which) const { return inputs_[which].size(); }
  333|       |
  334|       |  // Return the ith input file at "level()+which" ("which" must be 0 or 1).
  335|      0|  FileMetaData* input(int which, int i) const { return inputs_[which][i]; }
  336|       |
  337|       |  // Maximum size of files to build during this compaction.
  338|      0|  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }
  339|       |
  340|       |  // Is this a trivial compaction that can be implemented by just
  341|       |  // moving a single input file to the next level (no merging or splitting)
  342|       |  bool IsTrivialMove() const;
  343|       |
  344|       |  // Add all inputs to this compaction as delete operations to *edit.
  345|       |  void AddInputDeletions(VersionEdit* edit);
  346|       |
  347|       |  // Returns true if the information we have available guarantees that
  348|       |  // the compaction is producing data in "level+1" for which no data exists
  349|       |  // in levels greater than "level+1".
  350|       |  bool IsBaseLevelForKey(const Slice& user_key);
  351|       |
  352|       |  // Returns true iff we should stop building the current output
  353|       |  // before processing "internal_key".
  354|       |  bool ShouldStopBefore(const Slice& internal_key);
  355|       |
  356|       |  // Release the input version for the compaction, once the compaction
  357|       |  // is successful.
  358|       |  void ReleaseInputs();
  359|       |
  360|       | private:
  361|       |  friend class Version;
  362|       |  friend class VersionSet;
  363|       |
  364|       |  Compaction(const Options* options, int level);
  365|       |
  366|       |  int level_;
  367|       |  uint64_t max_output_file_size_;
  368|       |  Version* input_version_;
  369|       |  VersionEdit edit_;
  370|       |
  371|       |  // Each compaction reads inputs from "level_" and "level_+1"
  372|       |  std::vector<FileMetaData*> inputs_[2];  // The two sets of inputs
  373|       |
  374|       |  // State used to check for number of overlapping grandparent files
  375|       |  // (parent == level_ + 1, grandparent == level_ + 2)
  376|       |  std::vector<FileMetaData*> grandparents_;
  377|       |  size_t grandparent_index_;  // Index in grandparent_starts_
  378|       |  bool seen_key_;             // Some output key has been seen
  379|       |  int64_t overlapped_bytes_;  // Bytes of overlap between current output
  380|       |                              // and grandparent files
  381|       |
  382|       |  // State for implementing IsBaseLevelForKey
  383|       |
  384|       |  // level_ptrs_ holds indices into input_version_->levels_: our state
  385|       |  // is that we are positioned at one of the file ranges for each
  386|       |  // higher level than the ones involved in this compaction (i.e. for
  387|       |  // all L >= level_ + 2).
  388|       |  size_t level_ptrs_[config::kNumLevels];
  389|       |};
  390|       |
  391|       |}  // namespace leveldb
  392|       |
  393|       |#endif  // STORAGE_LEVELDB_DB_VERSION_SET_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/write_batch.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// WriteBatch::rep_ :=
    6|       |//    sequence: fixed64
    7|       |//    count: fixed32
    8|       |//    data: record[count]
    9|       |// record :=
   10|       |//    kTypeValue varstring varstring         |
   11|       |//    kTypeDeletion varstring
   12|       |// varstring :=
   13|       |//    len: varint32
   14|       |//    data: uint8[len]
   15|       |
   16|       |#include "leveldb/write_batch.h"
   17|       |
   18|       |#include "db/dbformat.h"
   19|       |#include "db/memtable.h"
   20|       |#include "db/write_batch_internal.h"
   21|       |#include "leveldb/db.h"
   22|       |#include "util/coding.h"
   23|       |
   24|       |namespace leveldb {
   25|       |
   26|       |// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.
   27|       |static const size_t kHeader = 12;
   28|       |
   29|      0|WriteBatch::WriteBatch() { Clear(); }
   30|       |
   31|      0|WriteBatch::~WriteBatch() {}
   32|       |
   33|      0|WriteBatch::Handler::~Handler() {}
   34|       |
   35|      0|void WriteBatch::Clear() {
   36|      0|  rep_.clear();
   37|      0|  rep_.resize(kHeader);
   38|      0|}
   39|       |
   40|      0|size_t WriteBatch::ApproximateSize() const { return rep_.size(); }
   41|       |
   42|      0|Status WriteBatch::Iterate(Handler* handler) const {
   43|      0|  Slice input(rep_);
   44|      0|  if (input.size() < kHeader) {
   45|      0|    return Status::Corruption("malformed WriteBatch (too small)");
   46|      0|  }
   47|      0|
   48|      0|  input.remove_prefix(kHeader);
   49|      0|  Slice key, value;
   50|      0|  int found = 0;
   51|      0|  while (!input.empty()) {
   52|      0|    found++;
   53|      0|    char tag = input[0];
   54|      0|    input.remove_prefix(1);
   55|      0|    switch (tag) {
   56|      0|      case kTypeValue:
   57|      0|        if (GetLengthPrefixedSlice(&input, &key) &&
   58|      0|            GetLengthPrefixedSlice(&input, &value)) {
   59|      0|          handler->Put(key, value);
   60|      0|        } else {
   61|      0|          return Status::Corruption("bad WriteBatch Put");
   62|      0|        }
   63|      0|        break;
   64|      0|      case kTypeDeletion:
   65|      0|        if (GetLengthPrefixedSlice(&input, &key)) {
   66|      0|          handler->Delete(key);
   67|      0|        } else {
   68|      0|          return Status::Corruption("bad WriteBatch Delete");
   69|      0|        }
   70|      0|        break;
   71|      0|      default:
   72|      0|        return Status::Corruption("unknown WriteBatch tag");
   73|      0|    }
   74|      0|  }
   75|      0|  if (found != WriteBatchInternal::Count(this)) {
   76|      0|    return Status::Corruption("WriteBatch has wrong count");
   77|      0|  } else {
   78|      0|    return Status::OK();
   79|      0|  }
   80|      0|}
   81|       |
   82|      0|int WriteBatchInternal::Count(const WriteBatch* b) {
   83|      0|  return DecodeFixed32(b->rep_.data() + 8);
   84|      0|}
   85|       |
   86|      0|void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
   87|      0|  EncodeFixed32(&b->rep_[8], n);
   88|      0|}
   89|       |
   90|      0|SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
   91|      0|  return SequenceNumber(DecodeFixed64(b->rep_.data()));
   92|      0|}
   93|       |
   94|      0|void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
   95|      0|  EncodeFixed64(&b->rep_[0], seq);
   96|      0|}
   97|       |
   98|      0|void WriteBatch::Put(const Slice& key, const Slice& value) {
   99|      0|  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  100|      0|  rep_.push_back(static_cast<char>(kTypeValue));
  101|      0|  PutLengthPrefixedSlice(&rep_, key);
  102|      0|  PutLengthPrefixedSlice(&rep_, value);
  103|      0|}
  104|       |
  105|      0|void WriteBatch::Delete(const Slice& key) {
  106|      0|  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  107|      0|  rep_.push_back(static_cast<char>(kTypeDeletion));
  108|      0|  PutLengthPrefixedSlice(&rep_, key);
  109|      0|}
  110|       |
  111|      0|void WriteBatch::Append(const WriteBatch& source) {
  112|      0|  WriteBatchInternal::Append(this, &source);
  113|      0|}
  114|       |
  115|       |namespace {
  116|       |class MemTableInserter : public WriteBatch::Handler {
  117|       | public:
  118|       |  SequenceNumber sequence_;
  119|       |  MemTable* mem_;
  120|       |
  121|      0|  virtual void Put(const Slice& key, const Slice& value) {
  122|      0|    mem_->Add(sequence_, kTypeValue, key, value);
  123|      0|    sequence_++;
  124|      0|  }
  125|      0|  virtual void Delete(const Slice& key) {
  126|      0|    mem_->Add(sequence_, kTypeDeletion, key, Slice());
  127|      0|    sequence_++;
  128|      0|  }
  129|       |};
  130|       |}  // namespace
  131|       |
  132|      0|Status WriteBatchInternal::InsertInto(const WriteBatch* b, MemTable* memtable) {
  133|      0|  MemTableInserter inserter;
  134|      0|  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  135|      0|  inserter.mem_ = memtable;
  136|      0|  return b->Iterate(&inserter);
  137|      0|}
  138|       |
  139|      0|void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
  140|      0|  assert(contents.size() >= kHeader);
  141|      0|  b->rep_.assign(contents.data(), contents.size());
  142|      0|}
  143|       |
  144|      0|void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
  145|      0|  SetCount(dst, Count(dst) + Count(src));
  146|      0|  assert(src->rep_.size() >= kHeader);
  147|      0|  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
  148|      0|}
  149|       |
  150|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/db/write_batch_internal.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_
    6|       |#define STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_
    7|       |
    8|       |#include "db/dbformat.h"
    9|       |#include "leveldb/write_batch.h"
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|       |class MemTable;
   14|       |
   15|       |// WriteBatchInternal provides static methods for manipulating a
   16|       |// WriteBatch that we don't want in the public WriteBatch interface.
   17|       |class WriteBatchInternal {
   18|       | public:
   19|       |  // Return the number of entries in the batch.
   20|       |  static int Count(const WriteBatch* batch);
   21|       |
   22|       |  // Set the count for the number of entries in the batch.
   23|       |  static void SetCount(WriteBatch* batch, int n);
   24|       |
   25|       |  // Return the sequence number for the start of this batch.
   26|       |  static SequenceNumber Sequence(const WriteBatch* batch);
   27|       |
   28|       |  // Store the specified number as the sequence number for the start of
   29|       |  // this batch.
   30|       |  static void SetSequence(WriteBatch* batch, SequenceNumber seq);
   31|       |
   32|      0|  static Slice Contents(const WriteBatch* batch) { return Slice(batch->rep_); }
   33|       |
   34|      0|  static size_t ByteSize(const WriteBatch* batch) { return batch->rep_.size(); }
   35|       |
   36|       |  static void SetContents(WriteBatch* batch, const Slice& contents);
   37|       |
   38|       |  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);
   39|       |
   40|       |  static void Append(WriteBatch* dst, const WriteBatch* src);
   41|       |};
   42|       |
   43|       |}  // namespace leveldb
   44|       |
   45|       |#endif  // STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/port/port_stdcxx.h:
    1|       |// Copyright (c) 2018 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_PORT_PORT_STDCXX_H_
    6|       |#define STORAGE_LEVELDB_PORT_PORT_STDCXX_H_
    7|       |
    8|       |// port/port_config.h availability is automatically detected via __has_include
    9|       |// in newer compilers. If LEVELDB_HAS_PORT_CONFIG_H is defined, it overrides the
   10|       |// configuration detection.
   11|       |#if defined(LEVELDB_HAS_PORT_CONFIG_H)
   12|       |
   13|       |#if LEVELDB_HAS_PORT_CONFIG_H
   14|       |#include "port/port_config.h"
   15|       |#endif  // LEVELDB_HAS_PORT_CONFIG_H
   16|       |
   17|       |#elif defined(__has_include)
   18|       |
   19|       |#if __has_include("port/port_config.h")
   20|       |#include "port/port_config.h"
   21|       |#endif  // __has_include("port/port_config.h")
   22|       |
   23|       |#endif  // defined(LEVELDB_HAS_PORT_CONFIG_H)
   24|       |
   25|       |#if HAVE_CRC32C
   26|       |#include <crc32c/crc32c.h>
   27|       |#endif  // HAVE_CRC32C
   28|       |#if HAVE_SNAPPY
   29|       |#include <snappy.h>
   30|       |#endif  // HAVE_SNAPPY
   31|       |
   32|       |#include <cassert>
   33|       |#include <condition_variable>  // NOLINT
   34|       |#include <cstddef>
   35|       |#include <cstdint>
   36|       |#include <mutex>  // NOLINT
   37|       |#include <string>
   38|       |
   39|       |#include "port/thread_annotations.h"
   40|       |
   41|       |namespace leveldb {
   42|       |namespace port {
   43|       |
   44|       |static const bool kLittleEndian = !LEVELDB_IS_BIG_ENDIAN;
   45|       |
   46|       |class CondVar;
   47|       |
   48|       |// Thinly wraps std::mutex.
   49|       |class LOCKABLE Mutex {
   50|       | public:
   51|      0|  Mutex() = default;
   52|      0|  ~Mutex() = default;
   53|       |
   54|       |  Mutex(const Mutex&) = delete;
   55|       |  Mutex& operator=(const Mutex&) = delete;
   56|       |
   57|      0|  void Lock() EXCLUSIVE_LOCK_FUNCTION() { mu_.lock(); }
   58|      0|  void Unlock() UNLOCK_FUNCTION() { mu_.unlock(); }
   59|      0|  void AssertHeld() ASSERT_EXCLUSIVE_LOCK() {}
   60|       |
   61|       | private:
   62|       |  friend class CondVar;
   63|       |  std::mutex mu_;
   64|       |};
   65|       |
   66|       |// Thinly wraps std::condition_variable.
   67|       |class CondVar {
   68|       | public:
   69|      0|  explicit CondVar(Mutex* mu) : mu_(mu) { assert(mu != nullptr); }
   70|      0|  ~CondVar() = default;
   71|       |
   72|       |  CondVar(const CondVar&) = delete;
   73|       |  CondVar& operator=(const CondVar&) = delete;
   74|       |
   75|      0|  void Wait() {
   76|      0|    std::unique_lock<std::mutex> lock(mu_->mu_, std::adopt_lock);
   77|      0|    cv_.wait(lock);
   78|      0|    lock.release();
   79|      0|  }
   80|      0|  void Signal() { cv_.notify_one(); }
   81|      0|  void SignalAll() { cv_.notify_all(); }
   82|       |
   83|       | private:
   84|       |  std::condition_variable cv_;
   85|       |  Mutex* const mu_;
   86|       |};
   87|       |
   88|       |inline bool Snappy_Compress(const char* input, size_t length,
   89|      0|                            std::string* output) {
   90|       |#if HAVE_SNAPPY
   91|       |  output->resize(snappy::MaxCompressedLength(length));
   92|       |  size_t outlen;
   93|       |  snappy::RawCompress(input, length, &(*output)[0], &outlen);
   94|       |  output->resize(outlen);
   95|       |  return true;
   96|       |#else
   97|       |  // Silence compiler warnings about unused arguments.
   98|      0|  (void)input;
   99|      0|  (void)length;
  100|      0|  (void)output;
  101|      0|#endif  // HAVE_SNAPPY
  102|      0|
  103|      0|  return false;
  104|      0|}
  105|       |
  106|       |inline bool Snappy_GetUncompressedLength(const char* input, size_t length,
  107|      0|                                         size_t* result) {
  108|       |#if HAVE_SNAPPY
  109|       |  return snappy::GetUncompressedLength(input, length, result);
  110|       |#else
  111|       |  // Silence compiler warnings about unused arguments.
  112|      0|  (void)input;
  113|      0|  (void)length;
  114|      0|  (void)result;
  115|      0|  return false;
  116|      0|#endif  // HAVE_SNAPPY
  117|      0|}
  118|       |
  119|      0|inline bool Snappy_Uncompress(const char* input, size_t length, char* output) {
  120|       |#if HAVE_SNAPPY
  121|       |  return snappy::RawUncompress(input, length, output);
  122|       |#else
  123|       |  // Silence compiler warnings about unused arguments.
  124|      0|  (void)input;
  125|      0|  (void)length;
  126|      0|  (void)output;
  127|      0|  return false;
  128|      0|#endif  // HAVE_SNAPPY
  129|      0|}
  130|       |
  131|      0|inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {
  132|      0|  // Silence compiler warnings about unused arguments.
  133|      0|  (void)func;
  134|      0|  (void)arg;
  135|      0|  return false;
  136|      0|}
  137|       |
  138|      0|inline uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {
  139|       |#if HAVE_CRC32C
  140|       |  return ::crc32c::Extend(crc, reinterpret_cast<const uint8_t*>(buf), size);
  141|       |#else
  142|       |  // Silence compiler warnings about unused arguments.
  143|      0|  (void)crc;
  144|      0|  (void)buf;
  145|      0|  (void)size;
  146|      0|  return 0;
  147|      0|#endif  // HAVE_CRC32C
  148|      0|}
  149|       |
  150|       |}  // namespace port
  151|       |}  // namespace leveldb
  152|       |
  153|       |#endif  // STORAGE_LEVELDB_PORT_PORT_STDCXX_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/block.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// Decodes the blocks generated by block_builder.cc.
    6|       |
    7|       |#include "table/block.h"
    8|       |
    9|       |#include <algorithm>
   10|       |#include <vector>
   11|       |
   12|       |#include "leveldb/comparator.h"
   13|       |#include "table/format.h"
   14|       |#include "util/coding.h"
   15|       |#include "util/logging.h"
   16|       |
   17|       |namespace leveldb {
   18|       |
   19|      0|inline uint32_t Block::NumRestarts() const {
   20|      0|  assert(size_ >= sizeof(uint32_t));
   21|      0|  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
   22|      0|}
   23|       |
   24|       |Block::Block(const BlockContents& contents)
   25|       |    : data_(contents.data.data()),
   26|       |      size_(contents.data.size()),
   27|      0|      owned_(contents.heap_allocated) {
   28|      0|  if (size_ < sizeof(uint32_t)) {
   29|      0|    size_ = 0;  // Error marker
   30|      0|  } else {
   31|      0|    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
   32|      0|    if (NumRestarts() > max_restarts_allowed) {
   33|      0|      // The size is too small for NumRestarts()
   34|      0|      size_ = 0;
   35|      0|    } else {
   36|      0|      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
   37|      0|    }
   38|      0|  }
   39|      0|}
   40|       |
   41|      0|Block::~Block() {
   42|      0|  if (owned_) {
   43|      0|    delete[] data_;
   44|      0|  }
   45|      0|}
   46|       |
   47|       |// Helper routine: decode the next block entry starting at "p",
   48|       |// storing the number of shared key bytes, non_shared key bytes,
   49|       |// and the length of the value in "*shared", "*non_shared", and
   50|       |// "*value_length", respectively.  Will not dereference past "limit".
   51|       |//
   52|       |// If any errors are detected, returns nullptr.  Otherwise, returns a
   53|       |// pointer to the key delta (just past the three decoded values).
   54|       |static inline const char* DecodeEntry(const char* p, const char* limit,
   55|       |                                      uint32_t* shared, uint32_t* non_shared,
   56|      0|                                      uint32_t* value_length) {
   57|      0|  if (limit - p < 3) return nullptr;
   58|      0|  *shared = reinterpret_cast<const unsigned char*>(p)[0];
   59|      0|  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
   60|      0|  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
   61|      0|  if ((*shared | *non_shared | *value_length) < 128) {
   62|      0|    // Fast path: all three values are encoded in one byte each
   63|      0|    p += 3;
   64|      0|  } else {
   65|      0|    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
   66|      0|    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
   67|      0|    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
   68|      0|  }
   69|      0|
   70|      0|  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
   71|      0|    return nullptr;
   72|      0|  }
   73|      0|  return p;
   74|      0|}
   75|       |
   76|       |class Block::Iter : public Iterator {
   77|       | private:
   78|       |  const Comparator* const comparator_;
   79|       |  const char* const data_;       // underlying block contents
   80|       |  uint32_t const restarts_;      // Offset of restart array (list of fixed32)
   81|       |  uint32_t const num_restarts_;  // Number of uint32_t entries in restart array
   82|       |
   83|       |  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
   84|       |  uint32_t current_;
   85|       |  uint32_t restart_index_;  // Index of restart block in which current_ falls
   86|       |  std::string key_;
   87|       |  Slice value_;
   88|       |  Status status_;
   89|       |
   90|      0|  inline int Compare(const Slice& a, const Slice& b) const {
   91|      0|    return comparator_->Compare(a, b);
   92|      0|  }
   93|       |
   94|       |  // Return the offset in data_ just past the end of the current entry.
   95|      0|  inline uint32_t NextEntryOffset() const {
   96|      0|    return (value_.data() + value_.size()) - data_;
   97|      0|  }
   98|       |
   99|      0|  uint32_t GetRestartPoint(uint32_t index) {
  100|      0|    assert(index < num_restarts_);
  101|      0|    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  102|      0|  }
  103|       |
  104|      0|  void SeekToRestartPoint(uint32_t index) {
  105|      0|    key_.clear();
  106|      0|    restart_index_ = index;
  107|      0|    // current_ will be fixed by ParseNextKey();
  108|      0|
  109|      0|    // ParseNextKey() starts at the end of value_, so set value_ accordingly
  110|      0|    uint32_t offset = GetRestartPoint(index);
  111|      0|    value_ = Slice(data_ + offset, 0);
  112|      0|  }
  113|       |
  114|       | public:
  115|       |  Iter(const Comparator* comparator, const char* data, uint32_t restarts,
  116|       |       uint32_t num_restarts)
  117|       |      : comparator_(comparator),
  118|       |        data_(data),
  119|       |        restarts_(restarts),
  120|       |        num_restarts_(num_restarts),
  121|       |        current_(restarts_),
  122|      0|        restart_index_(num_restarts_) {
  123|      0|    assert(num_restarts_ > 0);
  124|      0|  }
  125|       |
  126|      0|  virtual bool Valid() const { return current_ < restarts_; }
  127|      0|  virtual Status status() const { return status_; }
  128|      0|  virtual Slice key() const {
  129|      0|    assert(Valid());
  130|      0|    return key_;
  131|      0|  }
  132|      0|  virtual Slice value() const {
  133|      0|    assert(Valid());
  134|      0|    return value_;
  135|      0|  }
  136|       |
  137|      0|  virtual void Next() {
  138|      0|    assert(Valid());
  139|      0|    ParseNextKey();
  140|      0|  }
  141|       |
  142|      0|  virtual void Prev() {
  143|      0|    assert(Valid());
  144|      0|
  145|      0|    // Scan backwards to a restart point before current_
  146|      0|    const uint32_t original = current_;
  147|      0|    while (GetRestartPoint(restart_index_) >= original) {
  148|      0|      if (restart_index_ == 0) {
  149|      0|        // No more entries
  150|      0|        current_ = restarts_;
  151|      0|        restart_index_ = num_restarts_;
  152|      0|        return;
  153|      0|      }
  154|      0|      restart_index_--;
  155|      0|    }
  156|      0|
  157|      0|    SeekToRestartPoint(restart_index_);
  158|      0|    do {
  159|      0|      // Loop until end of current entry hits the start of original entry
  160|      0|    } while (ParseNextKey() && NextEntryOffset() < original);
  161|      0|  }
  162|       |
  163|      0|  virtual void Seek(const Slice& target) {
  164|      0|    // Binary search in restart array to find the last restart point
  165|      0|    // with a key < target
  166|      0|    uint32_t left = 0;
  167|      0|    uint32_t right = num_restarts_ - 1;
  168|      0|    while (left < right) {
  169|      0|      uint32_t mid = (left + right + 1) / 2;
  170|      0|      uint32_t region_offset = GetRestartPoint(mid);
  171|      0|      uint32_t shared, non_shared, value_length;
  172|      0|      const char* key_ptr =
  173|      0|          DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
  174|      0|                      &non_shared, &value_length);
  175|      0|      if (key_ptr == nullptr || (shared != 0)) {
  176|      0|        CorruptionError();
  177|      0|        return;
  178|      0|      }
  179|      0|      Slice mid_key(key_ptr, non_shared);
  180|      0|      if (Compare(mid_key, target) < 0) {
  181|      0|        // Key at "mid" is smaller than "target".  Therefore all
  182|      0|        // blocks before "mid" are uninteresting.
  183|      0|        left = mid;
  184|      0|      } else {
  185|      0|        // Key at "mid" is >= "target".  Therefore all blocks at or
  186|      0|        // after "mid" are uninteresting.
  187|      0|        right = mid - 1;
  188|      0|      }
  189|      0|    }
  190|      0|
  191|      0|    // Linear search (within restart block) for first key >= target
  192|      0|    SeekToRestartPoint(left);
  193|      0|    while (true) {
  194|      0|      if (!ParseNextKey()) {
  195|      0|        return;
  196|      0|      }
  197|      0|      if (Compare(key_, target) >= 0) {
  198|      0|        return;
  199|      0|      }
  200|      0|    }
  201|      0|  }
  202|       |
  203|      0|  virtual void SeekToFirst() {
  204|      0|    SeekToRestartPoint(0);
  205|      0|    ParseNextKey();
  206|      0|  }
  207|       |
  208|      0|  virtual void SeekToLast() {
  209|      0|    SeekToRestartPoint(num_restarts_ - 1);
  210|      0|    while (ParseNextKey() && NextEntryOffset() < restarts_) {
  211|      0|      // Keep skipping
  212|      0|    }
  213|      0|  }
  214|       |
  215|       | private:
  216|      0|  void CorruptionError() {
  217|      0|    current_ = restarts_;
  218|      0|    restart_index_ = num_restarts_;
  219|      0|    status_ = Status::Corruption("bad entry in block");
  220|      0|    key_.clear();
  221|      0|    value_.clear();
  222|      0|  }
  223|       |
  224|      0|  bool ParseNextKey() {
  225|      0|    current_ = NextEntryOffset();
  226|      0|    const char* p = data_ + current_;
  227|      0|    const char* limit = data_ + restarts_;  // Restarts come right after data
  228|      0|    if (p >= limit) {
  229|      0|      // No more entries to return.  Mark as invalid.
  230|      0|      current_ = restarts_;
  231|      0|      restart_index_ = num_restarts_;
  232|      0|      return false;
  233|      0|    }
  234|      0|
  235|      0|    // Decode next entry
  236|      0|    uint32_t shared, non_shared, value_length;
  237|      0|    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
  238|      0|    if (p == nullptr || key_.size() < shared) {
  239|      0|      CorruptionError();
  240|      0|      return false;
  241|      0|    } else {
  242|      0|      key_.resize(shared);
  243|      0|      key_.append(p, non_shared);
  244|      0|      value_ = Slice(p + non_shared, value_length);
  245|      0|      while (restart_index_ + 1 < num_restarts_ &&
  246|      0|             GetRestartPoint(restart_index_ + 1) < current_) {
  247|      0|        ++restart_index_;
  248|      0|      }
  249|      0|      return true;
  250|      0|    }
  251|      0|  }
  252|       |};
  253|       |
  254|      0|Iterator* Block::NewIterator(const Comparator* comparator) {
  255|      0|  if (size_ < sizeof(uint32_t)) {
  256|      0|    return NewErrorIterator(Status::Corruption("bad block contents"));
  257|      0|  }
  258|      0|  const uint32_t num_restarts = NumRestarts();
  259|      0|  if (num_restarts == 0) {
  260|      0|    return NewEmptyIterator();
  261|      0|  } else {
  262|      0|    return new Iter(comparator, data_, restart_offset_, num_restarts);
  263|      0|  }
  264|      0|}
  265|       |
  266|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/block.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_TABLE_BLOCK_H_
    6|       |#define STORAGE_LEVELDB_TABLE_BLOCK_H_
    7|       |
    8|       |#include <stddef.h>
    9|       |#include <stdint.h>
   10|       |
   11|       |#include "leveldb/iterator.h"
   12|       |
   13|       |namespace leveldb {
   14|       |
   15|       |struct BlockContents;
   16|       |class Comparator;
   17|       |
   18|       |class Block {
   19|       | public:
   20|       |  // Initialize the block with the specified contents.
   21|       |  explicit Block(const BlockContents& contents);
   22|       |
   23|       |  Block(const Block&) = delete;
   24|       |  Block& operator=(const Block&) = delete;
   25|       |
   26|       |  ~Block();
   27|       |
   28|      0|  size_t size() const { return size_; }
   29|       |  Iterator* NewIterator(const Comparator* comparator);
   30|       |
   31|       | private:
   32|       |  class Iter;
   33|       |
   34|       |  uint32_t NumRestarts() const;
   35|       |
   36|       |  const char* data_;
   37|       |  size_t size_;
   38|       |  uint32_t restart_offset_;  // Offset in data_ of restart array
   39|       |  bool owned_;               // Block owns data_[]
   40|       |};
   41|       |
   42|       |}  // namespace leveldb
   43|       |
   44|       |#endif  // STORAGE_LEVELDB_TABLE_BLOCK_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/block_builder.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// BlockBuilder generates blocks where keys are prefix-compressed:
    6|       |//
    7|       |// When we store a key, we drop the prefix shared with the previous
    8|       |// string.  This helps reduce the space requirement significantly.
    9|       |// Furthermore, once every K keys, we do not apply the prefix
   10|       |// compression and store the entire key.  We call this a "restart
   11|       |// point".  The tail end of the block stores the offsets of all of the
   12|       |// restart points, and can be used to do a binary search when looking
   13|       |// for a particular key.  Values are stored as-is (without compression)
   14|       |// immediately following the corresponding key.
   15|       |//
   16|       |// An entry for a particular key-value pair has the form:
   17|       |//     shared_bytes: varint32
   18|       |//     unshared_bytes: varint32
   19|       |//     value_length: varint32
   20|       |//     key_delta: char[unshared_bytes]
   21|       |//     value: char[value_length]
   22|       |// shared_bytes == 0 for restart points.
   23|       |//
   24|       |// The trailer of the block has the form:
   25|       |//     restarts: uint32[num_restarts]
   26|       |//     num_restarts: uint32
   27|       |// restarts[i] contains the offset within the block of the ith restart point.
   28|       |
   29|       |#include "table/block_builder.h"
   30|       |
   31|       |#include <assert.h>
   32|       |
   33|       |#include <algorithm>
   34|       |
   35|       |#include "leveldb/comparator.h"
   36|       |#include "leveldb/table_builder.h"
   37|       |#include "util/coding.h"
   38|       |
   39|       |namespace leveldb {
   40|       |
   41|       |BlockBuilder::BlockBuilder(const Options* options)
   42|      0|    : options_(options), restarts_(), counter_(0), finished_(false) {
   43|      0|  assert(options->block_restart_interval >= 1);
   44|      0|  restarts_.push_back(0);  // First restart point is at offset 0
   45|      0|}
   46|       |
   47|      0|void BlockBuilder::Reset() {
   48|      0|  buffer_.clear();
   49|      0|  restarts_.clear();
   50|      0|  restarts_.push_back(0);  // First restart point is at offset 0
   51|      0|  counter_ = 0;
   52|      0|  finished_ = false;
   53|      0|  last_key_.clear();
   54|      0|}
   55|       |
   56|      0|size_t BlockBuilder::CurrentSizeEstimate() const {
   57|      0|  return (buffer_.size() +                       // Raw data buffer
   58|      0|          restarts_.size() * sizeof(uint32_t) +  // Restart array
   59|      0|          sizeof(uint32_t));                     // Restart array length
   60|      0|}
   61|       |
   62|      0|Slice BlockBuilder::Finish() {
   63|      0|  // Append restart array
   64|      0|  for (size_t i = 0; i < restarts_.size(); i++) {
   65|      0|    PutFixed32(&buffer_, restarts_[i]);
   66|      0|  }
   67|      0|  PutFixed32(&buffer_, restarts_.size());
   68|      0|  finished_ = true;
   69|      0|  return Slice(buffer_);
   70|      0|}
   71|       |
   72|      0|void BlockBuilder::Add(const Slice& key, const Slice& value) {
   73|      0|  Slice last_key_piece(last_key_);
   74|      0|  assert(!finished_);
   75|      0|  assert(counter_ <= options_->block_restart_interval);
   76|      0|  assert(buffer_.empty()  // No values yet?
   77|      0|         || options_->comparator->Compare(key, last_key_piece) > 0);
   78|      0|  size_t shared = 0;
   79|      0|  if (counter_ < options_->block_restart_interval) {
   80|      0|    // See how much sharing to do with previous string
   81|      0|    const size_t min_length = std::min(last_key_piece.size(), key.size());
   82|      0|    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
   83|      0|      shared++;
   84|      0|    }
   85|      0|  } else {
   86|      0|    // Restart compression
   87|      0|    restarts_.push_back(buffer_.size());
   88|      0|    counter_ = 0;
   89|      0|  }
   90|      0|  const size_t non_shared = key.size() - shared;
   91|      0|
   92|      0|  // Add "<shared><non_shared><value_size>" to buffer_
   93|      0|  PutVarint32(&buffer_, shared);
   94|      0|  PutVarint32(&buffer_, non_shared);
   95|      0|  PutVarint32(&buffer_, value.size());
   96|      0|
   97|      0|  // Add string delta to buffer_ followed by value
   98|      0|  buffer_.append(key.data() + shared, non_shared);
   99|      0|  buffer_.append(value.data(), value.size());
  100|      0|
  101|      0|  // Update state
  102|      0|  last_key_.resize(shared);
  103|      0|  last_key_.append(key.data() + shared, non_shared);
  104|      0|  assert(Slice(last_key_) == key);
  105|      0|  counter_++;
  106|      0|}
  107|       |
  108|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/block_builder.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_
    6|       |#define STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_
    7|       |
    8|       |#include <stdint.h>
    9|       |
   10|       |#include <vector>
   11|       |
   12|       |#include "leveldb/slice.h"
   13|       |
   14|       |namespace leveldb {
   15|       |
   16|       |struct Options;
   17|       |
   18|       |class BlockBuilder {
   19|       | public:
   20|       |  explicit BlockBuilder(const Options* options);
   21|       |
   22|       |  BlockBuilder(const BlockBuilder&) = delete;
   23|       |  BlockBuilder& operator=(const BlockBuilder&) = delete;
   24|       |
   25|       |  // Reset the contents as if the BlockBuilder was just constructed.
   26|       |  void Reset();
   27|       |
   28|       |  // REQUIRES: Finish() has not been called since the last call to Reset().
   29|       |  // REQUIRES: key is larger than any previously added key
   30|       |  void Add(const Slice& key, const Slice& value);
   31|       |
   32|       |  // Finish building the block and return a slice that refers to the
   33|       |  // block contents.  The returned slice will remain valid for the
   34|       |  // lifetime of this builder or until Reset() is called.
   35|       |  Slice Finish();
   36|       |
   37|       |  // Returns an estimate of the current (uncompressed) size of the block
   38|       |  // we are building.
   39|       |  size_t CurrentSizeEstimate() const;
   40|       |
   41|       |  // Return true iff no entries have been added since the last Reset()
   42|      0|  bool empty() const { return buffer_.empty(); }
   43|       |
   44|       | private:
   45|       |  const Options* options_;
   46|       |  std::string buffer_;              // Destination buffer
   47|       |  std::vector<uint32_t> restarts_;  // Restart points
   48|       |  int counter_;                     // Number of entries emitted since restart
   49|       |  bool finished_;                   // Has Finish() been called?
   50|       |  std::string last_key_;
   51|       |};
   52|       |
   53|       |}  // namespace leveldb
   54|       |
   55|       |#endif  // STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/filter_block.cc:
    1|       |// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "table/filter_block.h"
    6|       |
    7|       |#include "leveldb/filter_policy.h"
    8|       |#include "util/coding.h"
    9|       |
   10|       |namespace leveldb {
   11|       |
   12|       |// See doc/table_format.md for an explanation of the filter block format.
   13|       |
   14|       |// Generate new filter every 2KB of data
   15|       |static const size_t kFilterBaseLg = 11;
   16|       |static const size_t kFilterBase = 1 << kFilterBaseLg;
   17|       |
   18|       |FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)
   19|      0|    : policy_(policy) {}
   20|       |
   21|      0|void FilterBlockBuilder::StartBlock(uint64_t block_offset) {
   22|      0|  uint64_t filter_index = (block_offset / kFilterBase);
   23|      0|  assert(filter_index >= filter_offsets_.size());
   24|      0|  while (filter_index > filter_offsets_.size()) {
   25|      0|    GenerateFilter();
   26|      0|  }
   27|      0|}
   28|       |
   29|      0|void FilterBlockBuilder::AddKey(const Slice& key) {
   30|      0|  Slice k = key;
   31|      0|  start_.push_back(keys_.size());
   32|      0|  keys_.append(k.data(), k.size());
   33|      0|}
   34|       |
   35|      0|Slice FilterBlockBuilder::Finish() {
   36|      0|  if (!start_.empty()) {
   37|      0|    GenerateFilter();
   38|      0|  }
   39|      0|
   40|      0|  // Append array of per-filter offsets
   41|      0|  const uint32_t array_offset = result_.size();
   42|      0|  for (size_t i = 0; i < filter_offsets_.size(); i++) {
   43|      0|    PutFixed32(&result_, filter_offsets_[i]);
   44|      0|  }
   45|      0|
   46|      0|  PutFixed32(&result_, array_offset);
   47|      0|  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
   48|      0|  return Slice(result_);
   49|      0|}
   50|       |
   51|      0|void FilterBlockBuilder::GenerateFilter() {
   52|      0|  const size_t num_keys = start_.size();
   53|      0|  if (num_keys == 0) {
   54|      0|    // Fast path if there are no keys for this filter
   55|      0|    filter_offsets_.push_back(result_.size());
   56|      0|    return;
   57|      0|  }
   58|      0|
   59|      0|  // Make list of keys from flattened key structure
   60|      0|  start_.push_back(keys_.size());  // Simplify length computation
   61|      0|  tmp_keys_.resize(num_keys);
   62|      0|  for (size_t i = 0; i < num_keys; i++) {
   63|      0|    const char* base = keys_.data() + start_[i];
   64|      0|    size_t length = start_[i + 1] - start_[i];
   65|      0|    tmp_keys_[i] = Slice(base, length);
   66|      0|  }
   67|      0|
   68|      0|  // Generate filter for current set of keys and append to result_.
   69|      0|  filter_offsets_.push_back(result_.size());
   70|      0|  policy_->CreateFilter(&tmp_keys_[0], static_cast<int>(num_keys), &result_);
   71|      0|
   72|      0|  tmp_keys_.clear();
   73|      0|  keys_.clear();
   74|      0|  start_.clear();
   75|      0|}
   76|       |
   77|       |FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
   78|       |                                     const Slice& contents)
   79|      0|    : policy_(policy), data_(nullptr), offset_(nullptr), num_(0), base_lg_(0) {
   80|      0|  size_t n = contents.size();
   81|      0|  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
   82|      0|  base_lg_ = contents[n - 1];
   83|      0|  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
   84|      0|  if (last_word > n - 5) return;
   85|      0|  data_ = contents.data();
   86|      0|  offset_ = data_ + last_word;
   87|      0|  num_ = (n - 5 - last_word) / 4;
   88|      0|}
   89|       |
   90|      0|bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {
   91|      0|  uint64_t index = block_offset >> base_lg_;
   92|      0|  if (index < num_) {
   93|      0|    uint32_t start = DecodeFixed32(offset_ + index * 4);
   94|      0|    uint32_t limit = DecodeFixed32(offset_ + index * 4 + 4);
   95|      0|    if (start <= limit && limit <= static_cast<size_t>(offset_ - data_)) {
   96|      0|      Slice filter = Slice(data_ + start, limit - start);
   97|      0|      return policy_->KeyMayMatch(key, filter);
   98|      0|    } else if (start == limit) {
   99|      0|      // Empty filters do not match any keys
  100|      0|      return false;
  101|      0|    }
  102|      0|  }
  103|      0|  return true;  // Errors are treated as potential matches
  104|      0|}
  105|       |
  106|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/format.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "table/format.h"
    6|       |
    7|       |#include "leveldb/env.h"
    8|       |#include "port/port.h"
    9|       |#include "table/block.h"
   10|       |#include "util/coding.h"
   11|       |#include "util/crc32c.h"
   12|       |
   13|       |namespace leveldb {
   14|       |
   15|      0|void BlockHandle::EncodeTo(std::string* dst) const {
   16|      0|  // Sanity check that all fields have been set
   17|      0|  assert(offset_ != ~static_cast<uint64_t>(0));
   18|      0|  assert(size_ != ~static_cast<uint64_t>(0));
   19|      0|  PutVarint64(dst, offset_);
   20|      0|  PutVarint64(dst, size_);
   21|      0|}
   22|       |
   23|      0|Status BlockHandle::DecodeFrom(Slice* input) {
   24|      0|  if (GetVarint64(input, &offset_) && GetVarint64(input, &size_)) {
   25|      0|    return Status::OK();
   26|      0|  } else {
   27|      0|    return Status::Corruption("bad block handle");
   28|      0|  }
   29|      0|}
   30|       |
   31|      0|void Footer::EncodeTo(std::string* dst) const {
   32|      0|  const size_t original_size = dst->size();
   33|      0|  metaindex_handle_.EncodeTo(dst);
   34|      0|  index_handle_.EncodeTo(dst);
   35|      0|  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
   36|      0|  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));
   37|      0|  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));
   38|      0|  assert(dst->size() == original_size + kEncodedLength);
   39|      0|  (void)original_size;  // Disable unused variable warning.
   40|      0|}
   41|       |
   42|      0|Status Footer::DecodeFrom(Slice* input) {
   43|      0|  const char* magic_ptr = input->data() + kEncodedLength - 8;
   44|      0|  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
   45|      0|  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
   46|      0|  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |
   47|      0|                          (static_cast<uint64_t>(magic_lo)));
   48|      0|  if (magic != kTableMagicNumber) {
   49|      0|    return Status::Corruption("not an sstable (bad magic number)");
   50|      0|  }
   51|      0|
   52|      0|  Status result = metaindex_handle_.DecodeFrom(input);
   53|      0|  if (result.ok()) {
   54|      0|    result = index_handle_.DecodeFrom(input);
   55|      0|  }
   56|      0|  if (result.ok()) {
   57|      0|    // We skip over any leftover data (just padding for now) in "input"
   58|      0|    const char* end = magic_ptr + 8;
   59|      0|    *input = Slice(end, input->data() + input->size() - end);
   60|      0|  }
   61|      0|  return result;
   62|      0|}
   63|       |
   64|       |Status ReadBlock(RandomAccessFile* file, const ReadOptions& options,
   65|      0|                 const BlockHandle& handle, BlockContents* result) {
   66|      0|  result->data = Slice();
   67|      0|  result->cachable = false;
   68|      0|  result->heap_allocated = false;
   69|      0|
   70|      0|  // Read the block contents as well as the type/crc footer.
   71|      0|  // See table_builder.cc for the code that built this structure.
   72|      0|  size_t n = static_cast<size_t>(handle.size());
   73|      0|  char* buf = new char[n + kBlockTrailerSize];
   74|      0|  Slice contents;
   75|      0|  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);
   76|      0|  if (!s.ok()) {
   77|      0|    delete[] buf;
   78|      0|    return s;
   79|      0|  }
   80|      0|  if (contents.size() != n + kBlockTrailerSize) {
   81|      0|    delete[] buf;
   82|      0|    return Status::Corruption("truncated block read");
   83|      0|  }
   84|      0|
   85|      0|  // Check the crc of the type and the block contents
   86|      0|  const char* data = contents.data();  // Pointer to where Read put the data
   87|      0|  if (options.verify_checksums) {
   88|      0|    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));
   89|      0|    const uint32_t actual = crc32c::Value(data, n + 1);
   90|      0|    if (actual != crc) {
   91|      0|      delete[] buf;
   92|      0|      s = Status::Corruption("block checksum mismatch");
   93|      0|      return s;
   94|      0|    }
   95|      0|  }
   96|      0|
   97|      0|  switch (data[n]) {
   98|      0|    case kNoCompression:
   99|      0|      if (data != buf) {
  100|      0|        // File implementation gave us pointer to some other data.
  101|      0|        // Use it directly under the assumption that it will be live
  102|      0|        // while the file is open.
  103|      0|        delete[] buf;
  104|      0|        result->data = Slice(data, n);
  105|      0|        result->heap_allocated = false;
  106|      0|        result->cachable = false;  // Do not double-cache
  107|      0|      } else {
  108|      0|        result->data = Slice(buf, n);
  109|      0|        result->heap_allocated = true;
  110|      0|        result->cachable = true;
  111|      0|      }
  112|      0|
  113|      0|      // Ok
  114|      0|      break;
  115|      0|    case kSnappyCompression: {
  116|      0|      size_t ulength = 0;
  117|      0|      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {
  118|      0|        delete[] buf;
  119|      0|        return Status::Corruption("corrupted compressed block contents");
  120|      0|      }
  121|      0|      char* ubuf = new char[ulength];
  122|      0|      if (!port::Snappy_Uncompress(data, n, ubuf)) {
  123|      0|        delete[] buf;
  124|      0|        delete[] ubuf;
  125|      0|        return Status::Corruption("corrupted compressed block contents");
  126|      0|      }
  127|      0|      delete[] buf;
  128|      0|      result->data = Slice(ubuf, ulength);
  129|      0|      result->heap_allocated = true;
  130|      0|      result->cachable = true;
  131|      0|      break;
  132|      0|    }
  133|      0|    default:
  134|      0|      delete[] buf;
  135|      0|      return Status::Corruption("bad block type");
  136|      0|  }
  137|      0|
  138|      0|  return Status::OK();
  139|      0|}
  140|       |
  141|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/format.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_TABLE_FORMAT_H_
    6|       |#define STORAGE_LEVELDB_TABLE_FORMAT_H_
    7|       |
    8|       |#include <stdint.h>
    9|       |
   10|       |#include <string>
   11|       |
   12|       |#include "leveldb/slice.h"
   13|       |#include "leveldb/status.h"
   14|       |#include "leveldb/table_builder.h"
   15|       |
   16|       |namespace leveldb {
   17|       |
   18|       |class Block;
   19|       |class RandomAccessFile;
   20|       |struct ReadOptions;
   21|       |
   22|       |// BlockHandle is a pointer to the extent of a file that stores a data
   23|       |// block or a meta block.
   24|       |class BlockHandle {
   25|       | public:
   26|       |  // Maximum encoding length of a BlockHandle
   27|       |  enum { kMaxEncodedLength = 10 + 10 };
   28|       |
   29|       |  BlockHandle();
   30|       |
   31|       |  // The offset of the block in the file.
   32|      0|  uint64_t offset() const { return offset_; }
   33|      0|  void set_offset(uint64_t offset) { offset_ = offset; }
   34|       |
   35|       |  // The size of the stored block
   36|      0|  uint64_t size() const { return size_; }
   37|      0|  void set_size(uint64_t size) { size_ = size; }
   38|       |
   39|       |  void EncodeTo(std::string* dst) const;
   40|       |  Status DecodeFrom(Slice* input);
   41|       |
   42|       | private:
   43|       |  uint64_t offset_;
   44|       |  uint64_t size_;
   45|       |};
   46|       |
   47|       |// Footer encapsulates the fixed information stored at the tail
   48|       |// end of every table file.
   49|       |class Footer {
   50|       | public:
   51|       |  // Encoded length of a Footer.  Note that the serialization of a
   52|       |  // Footer will always occupy exactly this many bytes.  It consists
   53|       |  // of two block handles and a magic number.
   54|       |  enum { kEncodedLength = 2 * BlockHandle::kMaxEncodedLength + 8 };
   55|       |
   56|      0|  Footer() {}
   57|       |
   58|       |  // The block handle for the metaindex block of the table
   59|      0|  const BlockHandle& metaindex_handle() const { return metaindex_handle_; }
   60|      0|  void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; }
   61|       |
   62|       |  // The block handle for the index block of the table
   63|      0|  const BlockHandle& index_handle() const { return index_handle_; }
   64|      0|  void set_index_handle(const BlockHandle& h) { index_handle_ = h; }
   65|       |
   66|       |  void EncodeTo(std::string* dst) const;
   67|       |  Status DecodeFrom(Slice* input);
   68|       |
   69|       | private:
   70|       |  BlockHandle metaindex_handle_;
   71|       |  BlockHandle index_handle_;
   72|       |};
   73|       |
   74|       |// kTableMagicNumber was picked by running
   75|       |//    echo http://code.google.com/p/leveldb/ | sha1sum
   76|       |// and taking the leading 64 bits.
   77|       |static const uint64_t kTableMagicNumber = 0xdb4775248b80fb57ull;
   78|       |
   79|       |// 1-byte type + 32-bit crc
   80|       |static const size_t kBlockTrailerSize = 5;
   81|       |
   82|       |struct BlockContents {
   83|       |  Slice data;           // Actual contents of data
   84|       |  bool cachable;        // True iff data can be cached
   85|       |  bool heap_allocated;  // True iff caller should delete[] data.data()
   86|       |};
   87|       |
   88|       |// Read the block identified by "handle" from "file".  On failure
   89|       |// return non-OK.  On success fill *result and return OK.
   90|       |Status ReadBlock(RandomAccessFile* file, const ReadOptions& options,
   91|       |                 const BlockHandle& handle, BlockContents* result);
   92|       |
   93|       |// Implementation details follow.  Clients should ignore,
   94|       |
   95|       |inline BlockHandle::BlockHandle()
   96|      0|    : offset_(~static_cast<uint64_t>(0)), size_(~static_cast<uint64_t>(0)) {}
   97|       |
   98|       |}  // namespace leveldb
   99|       |
  100|       |#endif  // STORAGE_LEVELDB_TABLE_FORMAT_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/iterator.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/iterator.h"
    6|       |
    7|       |namespace leveldb {
    8|       |
    9|      0|Iterator::Iterator() {
   10|      0|  cleanup_head_.function = nullptr;
   11|      0|  cleanup_head_.next = nullptr;
   12|      0|}
   13|       |
   14|      0|Iterator::~Iterator() {
   15|      0|  if (!cleanup_head_.IsEmpty()) {
   16|      0|    cleanup_head_.Run();
   17|      0|    for (CleanupNode* node = cleanup_head_.next; node != nullptr;) {
   18|      0|      node->Run();
   19|      0|      CleanupNode* next_node = node->next;
   20|      0|      delete node;
   21|      0|      node = next_node;
   22|      0|    }
   23|      0|  }
   24|      0|}
   25|       |
   26|      0|void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {
   27|      0|  assert(func != nullptr);
   28|      0|  CleanupNode* node;
   29|      0|  if (cleanup_head_.IsEmpty()) {
   30|      0|    node = &cleanup_head_;
   31|      0|  } else {
   32|      0|    node = new CleanupNode();
   33|      0|    node->next = cleanup_head_.next;
   34|      0|    cleanup_head_.next = node;
   35|      0|  }
   36|      0|  node->function = func;
   37|      0|  node->arg1 = arg1;
   38|      0|  node->arg2 = arg2;
   39|      0|}
   40|       |
   41|       |namespace {
   42|       |
   43|       |class EmptyIterator : public Iterator {
   44|       | public:
   45|      0|  EmptyIterator(const Status& s) : status_(s) {}
   46|      0|  ~EmptyIterator() override = default;
   47|       |
   48|      0|  bool Valid() const override { return false; }
   49|      0|  void Seek(const Slice& target) override {}
   50|      0|  void SeekToFirst() override {}
   51|      0|  void SeekToLast() override {}
   52|      0|  void Next() override { assert(false); }
   53|      0|  void Prev() override { assert(false); }
   54|      0|  Slice key() const override {
   55|      0|    assert(false);
   56|      0|    return Slice();
   57|      0|  }
   58|      0|  Slice value() const override {
   59|      0|    assert(false);
   60|      0|    return Slice();
   61|      0|  }
   62|      0|  Status status() const override { return status_; }
   63|       |
   64|       | private:
   65|       |  Status status_;
   66|       |};
   67|       |
   68|       |}  // anonymous namespace
   69|       |
   70|      0|Iterator* NewEmptyIterator() { return new EmptyIterator(Status::OK()); }
   71|       |
   72|      0|Iterator* NewErrorIterator(const Status& status) {
   73|      0|  return new EmptyIterator(status);
   74|      0|}
   75|       |
   76|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/iterator_wrapper.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_
    6|       |#define STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_
    7|       |
    8|       |#include "leveldb/iterator.h"
    9|       |#include "leveldb/slice.h"
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|       |// A internal wrapper class with an interface similar to Iterator that
   14|       |// caches the valid() and key() results for an underlying iterator.
   15|       |// This can help avoid virtual function calls and also gives better
   16|       |// cache locality.
   17|       |class IteratorWrapper {
   18|       | public:
   19|      0|  IteratorWrapper() : iter_(nullptr), valid_(false) {}
   20|      0|  explicit IteratorWrapper(Iterator* iter) : iter_(nullptr) { Set(iter); }
   21|      0|  ~IteratorWrapper() { delete iter_; }
   22|      0|  Iterator* iter() const { return iter_; }
   23|       |
   24|       |  // Takes ownership of "iter" and will delete it when destroyed, or
   25|       |  // when Set() is invoked again.
   26|      0|  void Set(Iterator* iter) {
   27|      0|    delete iter_;
   28|      0|    iter_ = iter;
   29|      0|    if (iter_ == nullptr) {
   30|      0|      valid_ = false;
   31|      0|    } else {
   32|      0|      Update();
   33|      0|    }
   34|      0|  }
   35|       |
   36|       |  // Iterator interface methods
   37|      0|  bool Valid() const { return valid_; }
   38|      0|  Slice key() const {
   39|      0|    assert(Valid());
   40|      0|    return key_;
   41|      0|  }
   42|      0|  Slice value() const {
   43|      0|    assert(Valid());
   44|      0|    return iter_->value();
   45|      0|  }
   46|       |  // Methods below require iter() != nullptr
   47|      0|  Status status() const {
   48|      0|    assert(iter_);
   49|      0|    return iter_->status();
   50|      0|  }
   51|      0|  void Next() {
   52|      0|    assert(iter_);
   53|      0|    iter_->Next();
   54|      0|    Update();
   55|      0|  }
   56|      0|  void Prev() {
   57|      0|    assert(iter_);
   58|      0|    iter_->Prev();
   59|      0|    Update();
   60|      0|  }
   61|      0|  void Seek(const Slice& k) {
   62|      0|    assert(iter_);
   63|      0|    iter_->Seek(k);
   64|      0|    Update();
   65|      0|  }
   66|      0|  void SeekToFirst() {
   67|      0|    assert(iter_);
   68|      0|    iter_->SeekToFirst();
   69|      0|    Update();
   70|      0|  }
   71|      0|  void SeekToLast() {
   72|      0|    assert(iter_);
   73|      0|    iter_->SeekToLast();
   74|      0|    Update();
   75|      0|  }
   76|       |
   77|       | private:
   78|      0|  void Update() {
   79|      0|    valid_ = iter_->Valid();
   80|      0|    if (valid_) {
   81|      0|      key_ = iter_->key();
   82|      0|    }
   83|      0|  }
   84|       |
   85|       |  Iterator* iter_;
   86|       |  bool valid_;
   87|       |  Slice key_;
   88|       |};
   89|       |
   90|       |}  // namespace leveldb
   91|       |
   92|       |#endif  // STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/merger.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "table/merger.h"
    6|       |
    7|       |#include "leveldb/comparator.h"
    8|       |#include "leveldb/iterator.h"
    9|       |#include "table/iterator_wrapper.h"
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|       |namespace {
   14|       |class MergingIterator : public Iterator {
   15|       | public:
   16|       |  MergingIterator(const Comparator* comparator, Iterator** children, int n)
   17|       |      : comparator_(comparator),
   18|       |        children_(new IteratorWrapper[n]),
   19|       |        n_(n),
   20|       |        current_(nullptr),
   21|      0|        direction_(kForward) {
   22|      0|    for (int i = 0; i < n; i++) {
   23|      0|      children_[i].Set(children[i]);
   24|      0|    }
   25|      0|  }
   26|       |
   27|      0|  virtual ~MergingIterator() { delete[] children_; }
   28|       |
   29|      0|  virtual bool Valid() const { return (current_ != nullptr); }
   30|       |
   31|      0|  virtual void SeekToFirst() {
   32|      0|    for (int i = 0; i < n_; i++) {
   33|      0|      children_[i].SeekToFirst();
   34|      0|    }
   35|      0|    FindSmallest();
   36|      0|    direction_ = kForward;
   37|      0|  }
   38|       |
   39|      0|  virtual void SeekToLast() {
   40|      0|    for (int i = 0; i < n_; i++) {
   41|      0|      children_[i].SeekToLast();
   42|      0|    }
   43|      0|    FindLargest();
   44|      0|    direction_ = kReverse;
   45|      0|  }
   46|       |
   47|      0|  virtual void Seek(const Slice& target) {
   48|      0|    for (int i = 0; i < n_; i++) {
   49|      0|      children_[i].Seek(target);
   50|      0|    }
   51|      0|    FindSmallest();
   52|      0|    direction_ = kForward;
   53|      0|  }
   54|       |
   55|      0|  virtual void Next() {
   56|      0|    assert(Valid());
   57|      0|
   58|      0|    // Ensure that all children are positioned after key().
   59|      0|    // If we are moving in the forward direction, it is already
   60|      0|    // true for all of the non-current_ children since current_ is
   61|      0|    // the smallest child and key() == current_->key().  Otherwise,
   62|      0|    // we explicitly position the non-current_ children.
   63|      0|    if (direction_ != kForward) {
   64|      0|      for (int i = 0; i < n_; i++) {
   65|      0|        IteratorWrapper* child = &children_[i];
   66|      0|        if (child != current_) {
   67|      0|          child->Seek(key());
   68|      0|          if (child->Valid() &&
   69|      0|              comparator_->Compare(key(), child->key()) == 0) {
   70|      0|            child->Next();
   71|      0|          }
   72|      0|        }
   73|      0|      }
   74|      0|      direction_ = kForward;
   75|      0|    }
   76|      0|
   77|      0|    current_->Next();
   78|      0|    FindSmallest();
   79|      0|  }
   80|       |
   81|      0|  virtual void Prev() {
   82|      0|    assert(Valid());
   83|      0|
   84|      0|    // Ensure that all children are positioned before key().
   85|      0|    // If we are moving in the reverse direction, it is already
   86|      0|    // true for all of the non-current_ children since current_ is
   87|      0|    // the largest child and key() == current_->key().  Otherwise,
   88|      0|    // we explicitly position the non-current_ children.
   89|      0|    if (direction_ != kReverse) {
   90|      0|      for (int i = 0; i < n_; i++) {
   91|      0|        IteratorWrapper* child = &children_[i];
   92|      0|        if (child != current_) {
   93|      0|          child->Seek(key());
   94|      0|          if (child->Valid()) {
   95|      0|            // Child is at first entry >= key().  Step back one to be < key()
   96|      0|            child->Prev();
   97|      0|          } else {
   98|      0|            // Child has no entries >= key().  Position at last entry.
   99|      0|            child->SeekToLast();
  100|      0|          }
  101|      0|        }
  102|      0|      }
  103|      0|      direction_ = kReverse;
  104|      0|    }
  105|      0|
  106|      0|    current_->Prev();
  107|      0|    FindLargest();
  108|      0|  }
  109|       |
  110|      0|  virtual Slice key() const {
  111|      0|    assert(Valid());
  112|      0|    return current_->key();
  113|      0|  }
  114|       |
  115|      0|  virtual Slice value() const {
  116|      0|    assert(Valid());
  117|      0|    return current_->value();
  118|      0|  }
  119|       |
  120|      0|  virtual Status status() const {
  121|      0|    Status status;
  122|      0|    for (int i = 0; i < n_; i++) {
  123|      0|      status = children_[i].status();
  124|      0|      if (!status.ok()) {
  125|      0|        break;
  126|      0|      }
  127|      0|    }
  128|      0|    return status;
  129|      0|  }
  130|       |
  131|       | private:
  132|       |  // Which direction is the iterator moving?
  133|       |  enum Direction { kForward, kReverse };
  134|       |
  135|       |  void FindSmallest();
  136|       |  void FindLargest();
  137|       |
  138|       |  // We might want to use a heap in case there are lots of children.
  139|       |  // For now we use a simple array since we expect a very small number
  140|       |  // of children in leveldb.
  141|       |  const Comparator* comparator_;
  142|       |  IteratorWrapper* children_;
  143|       |  int n_;
  144|       |  IteratorWrapper* current_;
  145|       |  Direction direction_;
  146|       |};
  147|       |
  148|      0|void MergingIterator::FindSmallest() {
  149|      0|  IteratorWrapper* smallest = nullptr;
  150|      0|  for (int i = 0; i < n_; i++) {
  151|      0|    IteratorWrapper* child = &children_[i];
  152|      0|    if (child->Valid()) {
  153|      0|      if (smallest == nullptr) {
  154|      0|        smallest = child;
  155|      0|      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
  156|      0|        smallest = child;
  157|      0|      }
  158|      0|    }
  159|      0|  }
  160|      0|  current_ = smallest;
  161|      0|}
  162|       |
  163|      0|void MergingIterator::FindLargest() {
  164|      0|  IteratorWrapper* largest = nullptr;
  165|      0|  for (int i = n_ - 1; i >= 0; i--) {
  166|      0|    IteratorWrapper* child = &children_[i];
  167|      0|    if (child->Valid()) {
  168|      0|      if (largest == nullptr) {
  169|      0|        largest = child;
  170|      0|      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
  171|      0|        largest = child;
  172|      0|      }
  173|      0|    }
  174|      0|  }
  175|      0|  current_ = largest;
  176|      0|}
  177|       |}  // namespace
  178|       |
  179|       |Iterator* NewMergingIterator(const Comparator* comparator, Iterator** children,
  180|      0|                             int n) {
  181|      0|  assert(n >= 0);
  182|      0|  if (n == 0) {
  183|      0|    return NewEmptyIterator();
  184|      0|  } else if (n == 1) {
  185|      0|    return children[0];
  186|      0|  } else {
  187|      0|    return new MergingIterator(comparator, children, n);
  188|      0|  }
  189|      0|}
  190|       |
  191|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/table.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/table.h"
    6|       |
    7|       |#include "leveldb/cache.h"
    8|       |#include "leveldb/comparator.h"
    9|       |#include "leveldb/env.h"
   10|       |#include "leveldb/filter_policy.h"
   11|       |#include "leveldb/options.h"
   12|       |#include "table/block.h"
   13|       |#include "table/filter_block.h"
   14|       |#include "table/format.h"
   15|       |#include "table/two_level_iterator.h"
   16|       |#include "util/coding.h"
   17|       |
   18|       |namespace leveldb {
   19|       |
   20|       |struct Table::Rep {
   21|      0|  ~Rep() {
   22|      0|    delete filter;
   23|      0|    delete[] filter_data;
   24|      0|    delete index_block;
   25|      0|  }
   26|       |
   27|       |  Options options;
   28|       |  Status status;
   29|       |  RandomAccessFile* file;
   30|       |  uint64_t cache_id;
   31|       |  FilterBlockReader* filter;
   32|       |  const char* filter_data;
   33|       |
   34|       |  BlockHandle metaindex_handle;  // Handle to metaindex_block: saved from footer
   35|       |  Block* index_block;
   36|       |};
   37|       |
   38|       |Status Table::Open(const Options& options, RandomAccessFile* file,
   39|      0|                   uint64_t size, Table** table) {
   40|      0|  *table = nullptr;
   41|      0|  if (size < Footer::kEncodedLength) {
   42|      0|    return Status::Corruption("file is too short to be an sstable");
   43|      0|  }
   44|      0|
   45|      0|  char footer_space[Footer::kEncodedLength];
   46|      0|  Slice footer_input;
   47|      0|  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
   48|      0|                        &footer_input, footer_space);
   49|      0|  if (!s.ok()) return s;
   50|      0|
   51|      0|  Footer footer;
   52|      0|  s = footer.DecodeFrom(&footer_input);
   53|      0|  if (!s.ok()) return s;
   54|      0|
   55|      0|  // Read the index block
   56|      0|  BlockContents index_block_contents;
   57|      0|  if (s.ok()) {
   58|      0|    ReadOptions opt;
   59|      0|    if (options.paranoid_checks) {
   60|      0|      opt.verify_checksums = true;
   61|      0|    }
   62|      0|    s = ReadBlock(file, opt, footer.index_handle(), &index_block_contents);
   63|      0|  }
   64|      0|
   65|      0|  if (s.ok()) {
   66|      0|    // We've successfully read the footer and the index block: we're
   67|      0|    // ready to serve requests.
   68|      0|    Block* index_block = new Block(index_block_contents);
   69|      0|    Rep* rep = new Table::Rep;
   70|      0|    rep->options = options;
   71|      0|    rep->file = file;
   72|      0|    rep->metaindex_handle = footer.metaindex_handle();
   73|      0|    rep->index_block = index_block;
   74|      0|    rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);
   75|      0|    rep->filter_data = nullptr;
   76|      0|    rep->filter = nullptr;
   77|      0|    *table = new Table(rep);
   78|      0|    (*table)->ReadMeta(footer);
   79|      0|  }
   80|      0|
   81|      0|  return s;
   82|      0|}
   83|       |
   84|      0|void Table::ReadMeta(const Footer& footer) {
   85|      0|  if (rep_->options.filter_policy == nullptr) {
   86|      0|    return;  // Do not need any metadata
   87|      0|  }
   88|      0|
   89|      0|  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates
   90|      0|  // it is an empty block.
   91|      0|  ReadOptions opt;
   92|      0|  if (rep_->options.paranoid_checks) {
   93|      0|    opt.verify_checksums = true;
   94|      0|  }
   95|      0|  BlockContents contents;
   96|      0|  if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {
   97|      0|    // Do not propagate errors since meta info is not needed for operation
   98|      0|    return;
   99|      0|  }
  100|      0|  Block* meta = new Block(contents);
  101|      0|
  102|      0|  Iterator* iter = meta->NewIterator(BytewiseComparator());
  103|      0|  std::string key = "filter.";
  104|      0|  key.append(rep_->options.filter_policy->Name());
  105|      0|  iter->Seek(key);
  106|      0|  if (iter->Valid() && iter->key() == Slice(key)) {
  107|      0|    ReadFilter(iter->value());
  108|      0|  }
  109|      0|  delete iter;
  110|      0|  delete meta;
  111|      0|}
  112|       |
  113|      0|void Table::ReadFilter(const Slice& filter_handle_value) {
  114|      0|  Slice v = filter_handle_value;
  115|      0|  BlockHandle filter_handle;
  116|      0|  if (!filter_handle.DecodeFrom(&v).ok()) {
  117|      0|    return;
  118|      0|  }
  119|      0|
  120|      0|  // We might want to unify with ReadBlock() if we start
  121|      0|  // requiring checksum verification in Table::Open.
  122|      0|  ReadOptions opt;
  123|      0|  if (rep_->options.paranoid_checks) {
  124|      0|    opt.verify_checksums = true;
  125|      0|  }
  126|      0|  BlockContents block;
  127|      0|  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {
  128|      0|    return;
  129|      0|  }
  130|      0|  if (block.heap_allocated) {
  131|      0|    rep_->filter_data = block.data.data();  // Will need to delete later
  132|      0|  }
  133|      0|  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);
  134|      0|}
  135|       |
  136|      0|Table::~Table() { delete rep_; }
  137|       |
  138|      0|static void DeleteBlock(void* arg, void* ignored) {
  139|      0|  delete reinterpret_cast<Block*>(arg);
  140|      0|}
  141|       |
  142|      0|static void DeleteCachedBlock(const Slice& key, void* value) {
  143|      0|  Block* block = reinterpret_cast<Block*>(value);
  144|      0|  delete block;
  145|      0|}
  146|       |
  147|      0|static void ReleaseBlock(void* arg, void* h) {
  148|      0|  Cache* cache = reinterpret_cast<Cache*>(arg);
  149|      0|  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);
  150|      0|  cache->Release(handle);
  151|      0|}
  152|       |
  153|       |// Convert an index iterator value (i.e., an encoded BlockHandle)
  154|       |// into an iterator over the contents of the corresponding block.
  155|       |Iterator* Table::BlockReader(void* arg, const ReadOptions& options,
  156|      0|                             const Slice& index_value) {
  157|      0|  Table* table = reinterpret_cast<Table*>(arg);
  158|      0|  Cache* block_cache = table->rep_->options.block_cache;
  159|      0|  Block* block = nullptr;
  160|      0|  Cache::Handle* cache_handle = nullptr;
  161|      0|
  162|      0|  BlockHandle handle;
  163|      0|  Slice input = index_value;
  164|      0|  Status s = handle.DecodeFrom(&input);
  165|      0|  // We intentionally allow extra stuff in index_value so that we
  166|      0|  // can add more features in the future.
  167|      0|
  168|      0|  if (s.ok()) {
  169|      0|    BlockContents contents;
  170|      0|    if (block_cache != nullptr) {
  171|      0|      char cache_key_buffer[16];
  172|      0|      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
  173|      0|      EncodeFixed64(cache_key_buffer + 8, handle.offset());
  174|      0|      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
  175|      0|      cache_handle = block_cache->Lookup(key);
  176|      0|      if (cache_handle != nullptr) {
  177|      0|        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
  178|      0|      } else {
  179|      0|        s = ReadBlock(table->rep_->file, options, handle, &contents);
  180|      0|        if (s.ok()) {
  181|      0|          block = new Block(contents);
  182|      0|          if (contents.cachable && options.fill_cache) {
  183|      0|            cache_handle = block_cache->Insert(key, block, block->size(),
  184|      0|                                               &DeleteCachedBlock);
  185|      0|          }
  186|      0|        }
  187|      0|      }
  188|      0|    } else {
  189|      0|      s = ReadBlock(table->rep_->file, options, handle, &contents);
  190|      0|      if (s.ok()) {
  191|      0|        block = new Block(contents);
  192|      0|      }
  193|      0|    }
  194|      0|  }
  195|      0|
  196|      0|  Iterator* iter;
  197|      0|  if (block != nullptr) {
  198|      0|    iter = block->NewIterator(table->rep_->options.comparator);
  199|      0|    if (cache_handle == nullptr) {
  200|      0|      iter->RegisterCleanup(&DeleteBlock, block, nullptr);
  201|      0|    } else {
  202|      0|      iter->RegisterCleanup(&ReleaseBlock, block_cache, cache_handle);
  203|      0|    }
  204|      0|  } else {
  205|      0|    iter = NewErrorIterator(s);
  206|      0|  }
  207|      0|  return iter;
  208|      0|}
  209|       |
  210|      0|Iterator* Table::NewIterator(const ReadOptions& options) const {
  211|      0|  return NewTwoLevelIterator(
  212|      0|      rep_->index_block->NewIterator(rep_->options.comparator),
  213|      0|      &Table::BlockReader, const_cast<Table*>(this), options);
  214|      0|}
  215|       |
  216|       |Status Table::InternalGet(const ReadOptions& options, const Slice& k, void* arg,
  217|       |                          void (*handle_result)(void*, const Slice&,
  218|      0|                                                const Slice&)) {
  219|      0|  Status s;
  220|      0|  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);
  221|      0|  iiter->Seek(k);
  222|      0|  if (iiter->Valid()) {
  223|      0|    Slice handle_value = iiter->value();
  224|      0|    FilterBlockReader* filter = rep_->filter;
  225|      0|    BlockHandle handle;
  226|      0|    if (filter != nullptr && handle.DecodeFrom(&handle_value).ok() &&
  227|      0|        !filter->KeyMayMatch(handle.offset(), k)) {
  228|      0|      // Not found
  229|      0|    } else {
  230|      0|      Iterator* block_iter = BlockReader(this, options, iiter->value());
  231|      0|      block_iter->Seek(k);
  232|      0|      if (block_iter->Valid()) {
  233|      0|        (*handle_result)(arg, block_iter->key(), block_iter->value());
  234|      0|      }
  235|      0|      s = block_iter->status();
  236|      0|      delete block_iter;
  237|      0|    }
  238|      0|  }
  239|      0|  if (s.ok()) {
  240|      0|    s = iiter->status();
  241|      0|  }
  242|      0|  delete iiter;
  243|      0|  return s;
  244|      0|}
  245|       |
  246|      0|uint64_t Table::ApproximateOffsetOf(const Slice& key) const {
  247|      0|  Iterator* index_iter =
  248|      0|      rep_->index_block->NewIterator(rep_->options.comparator);
  249|      0|  index_iter->Seek(key);
  250|      0|  uint64_t result;
  251|      0|  if (index_iter->Valid()) {
  252|      0|    BlockHandle handle;
  253|      0|    Slice input = index_iter->value();
  254|      0|    Status s = handle.DecodeFrom(&input);
  255|      0|    if (s.ok()) {
  256|      0|      result = handle.offset();
  257|      0|    } else {
  258|      0|      // Strange: we can't decode the block handle in the index block.
  259|      0|      // We'll just return the offset of the metaindex block, which is
  260|      0|      // close to the whole file size for this case.
  261|      0|      result = rep_->metaindex_handle.offset();
  262|      0|    }
  263|      0|  } else {
  264|      0|    // key is past the last key in the file.  Approximate the offset
  265|      0|    // by returning the offset of the metaindex block (which is
  266|      0|    // right near the end of the file).
  267|      0|    result = rep_->metaindex_handle.offset();
  268|      0|  }
  269|      0|  delete index_iter;
  270|      0|  return result;
  271|      0|}
  272|       |
  273|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/table_builder.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/table_builder.h"
    6|       |
    7|       |#include <assert.h>
    8|       |
    9|       |#include "leveldb/comparator.h"
   10|       |#include "leveldb/env.h"
   11|       |#include "leveldb/filter_policy.h"
   12|       |#include "leveldb/options.h"
   13|       |#include "table/block_builder.h"
   14|       |#include "table/filter_block.h"
   15|       |#include "table/format.h"
   16|       |#include "util/coding.h"
   17|       |#include "util/crc32c.h"
   18|       |
   19|       |namespace leveldb {
   20|       |
   21|       |struct TableBuilder::Rep {
   22|       |  Rep(const Options& opt, WritableFile* f)
   23|       |      : options(opt),
   24|       |        index_block_options(opt),
   25|       |        file(f),
   26|       |        offset(0),
   27|       |        data_block(&options),
   28|       |        index_block(&index_block_options),
   29|       |        num_entries(0),
   30|       |        closed(false),
   31|       |        filter_block(opt.filter_policy == nullptr
   32|       |                         ? nullptr
   33|       |                         : new FilterBlockBuilder(opt.filter_policy)),
   34|      0|        pending_index_entry(false) {
   35|      0|    index_block_options.block_restart_interval = 1;
   36|      0|  }
   37|       |
   38|       |  Options options;
   39|       |  Options index_block_options;
   40|       |  WritableFile* file;
   41|       |  uint64_t offset;
   42|       |  Status status;
   43|       |  BlockBuilder data_block;
   44|       |  BlockBuilder index_block;
   45|       |  std::string last_key;
   46|       |  int64_t num_entries;
   47|       |  bool closed;  // Either Finish() or Abandon() has been called.
   48|       |  FilterBlockBuilder* filter_block;
   49|       |
   50|       |  // We do not emit the index entry for a block until we have seen the
   51|       |  // first key for the next data block.  This allows us to use shorter
   52|       |  // keys in the index block.  For example, consider a block boundary
   53|       |  // between the keys "the quick brown fox" and "the who".  We can use
   54|       |  // "the r" as the key for the index block entry since it is >= all
   55|       |  // entries in the first block and < all entries in subsequent
   56|       |  // blocks.
   57|       |  //
   58|       |  // Invariant: r->pending_index_entry is true only if data_block is empty.
   59|       |  bool pending_index_entry;
   60|       |  BlockHandle pending_handle;  // Handle to add to index block
   61|       |
   62|       |  std::string compressed_output;
   63|       |};
   64|       |
   65|       |TableBuilder::TableBuilder(const Options& options, WritableFile* file)
   66|      0|    : rep_(new Rep(options, file)) {
   67|      0|  if (rep_->filter_block != nullptr) {
   68|      0|    rep_->filter_block->StartBlock(0);
   69|      0|  }
   70|      0|}
   71|       |
   72|      0|TableBuilder::~TableBuilder() {
   73|      0|  assert(rep_->closed);  // Catch errors where caller forgot to call Finish()
   74|      0|  delete rep_->filter_block;
   75|      0|  delete rep_;
   76|      0|}
   77|       |
   78|      0|Status TableBuilder::ChangeOptions(const Options& options) {
   79|      0|  // Note: if more fields are added to Options, update
   80|      0|  // this function to catch changes that should not be allowed to
   81|      0|  // change in the middle of building a Table.
   82|      0|  if (options.comparator != rep_->options.comparator) {
   83|      0|    return Status::InvalidArgument("changing comparator while building table");
   84|      0|  }
   85|      0|
   86|      0|  // Note that any live BlockBuilders point to rep_->options and therefore
   87|      0|  // will automatically pick up the updated options.
   88|      0|  rep_->options = options;
   89|      0|  rep_->index_block_options = options;
   90|      0|  rep_->index_block_options.block_restart_interval = 1;
   91|      0|  return Status::OK();
   92|      0|}
   93|       |
   94|      0|void TableBuilder::Add(const Slice& key, const Slice& value) {
   95|      0|  Rep* r = rep_;
   96|      0|  assert(!r->closed);
   97|      0|  if (!ok()) return;
   98|      0|  if (r->num_entries > 0) {
   99|      0|    assert(r->options.comparator->Compare(key, Slice(r->last_key)) > 0);
  100|      0|  }
  101|      0|
  102|      0|  if (r->pending_index_entry) {
  103|      0|    assert(r->data_block.empty());
  104|      0|    r->options.comparator->FindShortestSeparator(&r->last_key, key);
  105|      0|    std::string handle_encoding;
  106|      0|    r->pending_handle.EncodeTo(&handle_encoding);
  107|      0|    r->index_block.Add(r->last_key, Slice(handle_encoding));
  108|      0|    r->pending_index_entry = false;
  109|      0|  }
  110|      0|
  111|      0|  if (r->filter_block != nullptr) {
  112|      0|    r->filter_block->AddKey(key);
  113|      0|  }
  114|      0|
  115|      0|  r->last_key.assign(key.data(), key.size());
  116|      0|  r->num_entries++;
  117|      0|  r->data_block.Add(key, value);
  118|      0|
  119|      0|  const size_t estimated_block_size = r->data_block.CurrentSizeEstimate();
  120|      0|  if (estimated_block_size >= r->options.block_size) {
  121|      0|    Flush();
  122|      0|  }
  123|      0|}
  124|       |
  125|      0|void TableBuilder::Flush() {
  126|      0|  Rep* r = rep_;
  127|      0|  assert(!r->closed);
  128|      0|  if (!ok()) return;
  129|      0|  if (r->data_block.empty()) return;
  130|      0|  assert(!r->pending_index_entry);
  131|      0|  WriteBlock(&r->data_block, &r->pending_handle);
  132|      0|  if (ok()) {
  133|      0|    r->pending_index_entry = true;
  134|      0|    r->status = r->file->Flush();
  135|      0|  }
  136|      0|  if (r->filter_block != nullptr) {
  137|      0|    r->filter_block->StartBlock(r->offset);
  138|      0|  }
  139|      0|}
  140|       |
  141|      0|void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {
  142|      0|  // File format contains a sequence of blocks where each block has:
  143|      0|  //    block_data: uint8[n]
  144|      0|  //    type: uint8
  145|      0|  //    crc: uint32
  146|      0|  assert(ok());
  147|      0|  Rep* r = rep_;
  148|      0|  Slice raw = block->Finish();
  149|      0|
  150|      0|  Slice block_contents;
  151|      0|  CompressionType type = r->options.compression;
  152|      0|  // TODO(postrelease): Support more compression options: zlib?
  153|      0|  switch (type) {
  154|      0|    case kNoCompression:
  155|      0|      block_contents = raw;
  156|      0|      break;
  157|      0|
  158|      0|    case kSnappyCompression: {
  159|      0|      std::string* compressed = &r->compressed_output;
  160|      0|      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
  161|      0|          compressed->size() < raw.size() - (raw.size() / 8u)) {
  162|      0|        block_contents = *compressed;
  163|      0|      } else {
  164|      0|        // Snappy not supported, or compressed less than 12.5%, so just
  165|      0|        // store uncompressed form
  166|      0|        block_contents = raw;
  167|      0|        type = kNoCompression;
  168|      0|      }
  169|      0|      break;
  170|      0|    }
  171|      0|  }
  172|      0|  WriteRawBlock(block_contents, type, handle);
  173|      0|  r->compressed_output.clear();
  174|      0|  block->Reset();
  175|      0|}
  176|       |
  177|       |void TableBuilder::WriteRawBlock(const Slice& block_contents,
  178|      0|                                 CompressionType type, BlockHandle* handle) {
  179|      0|  Rep* r = rep_;
  180|      0|  handle->set_offset(r->offset);
  181|      0|  handle->set_size(block_contents.size());
  182|      0|  r->status = r->file->Append(block_contents);
  183|      0|  if (r->status.ok()) {
  184|      0|    char trailer[kBlockTrailerSize];
  185|      0|    trailer[0] = type;
  186|      0|    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
  187|      0|    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
  188|      0|    EncodeFixed32(trailer + 1, crc32c::Mask(crc));
  189|      0|    r->status = r->file->Append(Slice(trailer, kBlockTrailerSize));
  190|      0|    if (r->status.ok()) {
  191|      0|      r->offset += block_contents.size() + kBlockTrailerSize;
  192|      0|    }
  193|      0|  }
  194|      0|}
  195|       |
  196|      0|Status TableBuilder::status() const { return rep_->status; }
  197|       |
  198|      0|Status TableBuilder::Finish() {
  199|      0|  Rep* r = rep_;
  200|      0|  Flush();
  201|      0|  assert(!r->closed);
  202|      0|  r->closed = true;
  203|      0|
  204|      0|  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;
  205|      0|
  206|      0|  // Write filter block
  207|      0|  if (ok() && r->filter_block != nullptr) {
  208|      0|    WriteRawBlock(r->filter_block->Finish(), kNoCompression,
  209|      0|                  &filter_block_handle);
  210|      0|  }
  211|      0|
  212|      0|  // Write metaindex block
  213|      0|  if (ok()) {
  214|      0|    BlockBuilder meta_index_block(&r->options);
  215|      0|    if (r->filter_block != nullptr) {
  216|      0|      // Add mapping from "filter.Name" to location of filter data
  217|      0|      std::string key = "filter.";
  218|      0|      key.append(r->options.filter_policy->Name());
  219|      0|      std::string handle_encoding;
  220|      0|      filter_block_handle.EncodeTo(&handle_encoding);
  221|      0|      meta_index_block.Add(key, handle_encoding);
  222|      0|    }
  223|      0|
  224|      0|    // TODO(postrelease): Add stats and other meta blocks
  225|      0|    WriteBlock(&meta_index_block, &metaindex_block_handle);
  226|      0|  }
  227|      0|
  228|      0|  // Write index block
  229|      0|  if (ok()) {
  230|      0|    if (r->pending_index_entry) {
  231|      0|      r->options.comparator->FindShortSuccessor(&r->last_key);
  232|      0|      std::string handle_encoding;
  233|      0|      r->pending_handle.EncodeTo(&handle_encoding);
  234|      0|      r->index_block.Add(r->last_key, Slice(handle_encoding));
  235|      0|      r->pending_index_entry = false;
  236|      0|    }
  237|      0|    WriteBlock(&r->index_block, &index_block_handle);
  238|      0|  }
  239|      0|
  240|      0|  // Write footer
  241|      0|  if (ok()) {
  242|      0|    Footer footer;
  243|      0|    footer.set_metaindex_handle(metaindex_block_handle);
  244|      0|    footer.set_index_handle(index_block_handle);
  245|      0|    std::string footer_encoding;
  246|      0|    footer.EncodeTo(&footer_encoding);
  247|      0|    r->status = r->file->Append(footer_encoding);
  248|      0|    if (r->status.ok()) {
  249|      0|      r->offset += footer_encoding.size();
  250|      0|    }
  251|      0|  }
  252|      0|  return r->status;
  253|      0|}
  254|       |
  255|      0|void TableBuilder::Abandon() {
  256|      0|  Rep* r = rep_;
  257|      0|  assert(!r->closed);
  258|      0|  r->closed = true;
  259|      0|}
  260|       |
  261|      0|uint64_t TableBuilder::NumEntries() const { return rep_->num_entries; }
  262|       |
  263|      0|uint64_t TableBuilder::FileSize() const { return rep_->offset; }
  264|       |
  265|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/table/two_level_iterator.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "table/two_level_iterator.h"
    6|       |
    7|       |#include "leveldb/table.h"
    8|       |#include "table/block.h"
    9|       |#include "table/format.h"
   10|       |#include "table/iterator_wrapper.h"
   11|       |
   12|       |namespace leveldb {
   13|       |
   14|       |namespace {
   15|       |
   16|       |typedef Iterator* (*BlockFunction)(void*, const ReadOptions&, const Slice&);
   17|       |
   18|       |class TwoLevelIterator : public Iterator {
   19|       | public:
   20|       |  TwoLevelIterator(Iterator* index_iter, BlockFunction block_function,
   21|       |                   void* arg, const ReadOptions& options);
   22|       |
   23|       |  virtual ~TwoLevelIterator();
   24|       |
   25|       |  virtual void Seek(const Slice& target);
   26|       |  virtual void SeekToFirst();
   27|       |  virtual void SeekToLast();
   28|       |  virtual void Next();
   29|       |  virtual void Prev();
   30|       |
   31|      0|  virtual bool Valid() const { return data_iter_.Valid(); }
   32|      0|  virtual Slice key() const {
   33|      0|    assert(Valid());
   34|      0|    return data_iter_.key();
   35|      0|  }
   36|      0|  virtual Slice value() const {
   37|      0|    assert(Valid());
   38|      0|    return data_iter_.value();
   39|      0|  }
   40|      0|  virtual Status status() const {
   41|      0|    // It'd be nice if status() returned a const Status& instead of a Status
   42|      0|    if (!index_iter_.status().ok()) {
   43|      0|      return index_iter_.status();
   44|      0|    } else if (data_iter_.iter() != nullptr && !data_iter_.status().ok()) {
   45|      0|      return data_iter_.status();
   46|      0|    } else {
   47|      0|      return status_;
   48|      0|    }
   49|      0|  }
   50|       |
   51|       | private:
   52|      0|  void SaveError(const Status& s) {
   53|      0|    if (status_.ok() && !s.ok()) status_ = s;
   54|      0|  }
   55|       |  void SkipEmptyDataBlocksForward();
   56|       |  void SkipEmptyDataBlocksBackward();
   57|       |  void SetDataIterator(Iterator* data_iter);
   58|       |  void InitDataBlock();
   59|       |
   60|       |  BlockFunction block_function_;
   61|       |  void* arg_;
   62|       |  const ReadOptions options_;
   63|       |  Status status_;
   64|       |  IteratorWrapper index_iter_;
   65|       |  IteratorWrapper data_iter_;  // May be nullptr
   66|       |  // If data_iter_ is non-null, then "data_block_handle_" holds the
   67|       |  // "index_value" passed to block_function_ to create the data_iter_.
   68|       |  std::string data_block_handle_;
   69|       |};
   70|       |
   71|       |TwoLevelIterator::TwoLevelIterator(Iterator* index_iter,
   72|       |                                   BlockFunction block_function, void* arg,
   73|       |                                   const ReadOptions& options)
   74|       |    : block_function_(block_function),
   75|       |      arg_(arg),
   76|       |      options_(options),
   77|       |      index_iter_(index_iter),
   78|      0|      data_iter_(nullptr) {}
   79|       |
   80|      0|TwoLevelIterator::~TwoLevelIterator() {}
   81|       |
   82|      0|void TwoLevelIterator::Seek(const Slice& target) {
   83|      0|  index_iter_.Seek(target);
   84|      0|  InitDataBlock();
   85|      0|  if (data_iter_.iter() != nullptr) data_iter_.Seek(target);
   86|      0|  SkipEmptyDataBlocksForward();
   87|      0|}
   88|       |
   89|      0|void TwoLevelIterator::SeekToFirst() {
   90|      0|  index_iter_.SeekToFirst();
   91|      0|  InitDataBlock();
   92|      0|  if (data_iter_.iter() != nullptr) data_iter_.SeekToFirst();
   93|      0|  SkipEmptyDataBlocksForward();
   94|      0|}
   95|       |
   96|      0|void TwoLevelIterator::SeekToLast() {
   97|      0|  index_iter_.SeekToLast();
   98|      0|  InitDataBlock();
   99|      0|  if (data_iter_.iter() != nullptr) data_iter_.SeekToLast();
  100|      0|  SkipEmptyDataBlocksBackward();
  101|      0|}
  102|       |
  103|      0|void TwoLevelIterator::Next() {
  104|      0|  assert(Valid());
  105|      0|  data_iter_.Next();
  106|      0|  SkipEmptyDataBlocksForward();
  107|      0|}
  108|       |
  109|      0|void TwoLevelIterator::Prev() {
  110|      0|  assert(Valid());
  111|      0|  data_iter_.Prev();
  112|      0|  SkipEmptyDataBlocksBackward();
  113|      0|}
  114|       |
  115|      0|void TwoLevelIterator::SkipEmptyDataBlocksForward() {
  116|      0|  while (data_iter_.iter() == nullptr || !data_iter_.Valid()) {
  117|      0|    // Move to next block
  118|      0|    if (!index_iter_.Valid()) {
  119|      0|      SetDataIterator(nullptr);
  120|      0|      return;
  121|      0|    }
  122|      0|    index_iter_.Next();
  123|      0|    InitDataBlock();
  124|      0|    if (data_iter_.iter() != nullptr) data_iter_.SeekToFirst();
  125|      0|  }
  126|      0|}
  127|       |
  128|      0|void TwoLevelIterator::SkipEmptyDataBlocksBackward() {
  129|      0|  while (data_iter_.iter() == nullptr || !data_iter_.Valid()) {
  130|      0|    // Move to next block
  131|      0|    if (!index_iter_.Valid()) {
  132|      0|      SetDataIterator(nullptr);
  133|      0|      return;
  134|      0|    }
  135|      0|    index_iter_.Prev();
  136|      0|    InitDataBlock();
  137|      0|    if (data_iter_.iter() != nullptr) data_iter_.SeekToLast();
  138|      0|  }
  139|      0|}
  140|       |
  141|      0|void TwoLevelIterator::SetDataIterator(Iterator* data_iter) {
  142|      0|  if (data_iter_.iter() != nullptr) SaveError(data_iter_.status());
  143|      0|  data_iter_.Set(data_iter);
  144|      0|}
  145|       |
  146|      0|void TwoLevelIterator::InitDataBlock() {
  147|      0|  if (!index_iter_.Valid()) {
  148|      0|    SetDataIterator(nullptr);
  149|      0|  } else {
  150|      0|    Slice handle = index_iter_.value();
  151|      0|    if (data_iter_.iter() != nullptr &&
  152|      0|        handle.compare(data_block_handle_) == 0) {
  153|      0|      // data_iter_ is already constructed with this iterator, so
  154|      0|      // no need to change anything
  155|      0|    } else {
  156|      0|      Iterator* iter = (*block_function_)(arg_, options_, handle);
  157|      0|      data_block_handle_.assign(handle.data(), handle.size());
  158|      0|      SetDataIterator(iter);
  159|      0|    }
  160|      0|  }
  161|      0|}
  162|       |
  163|       |}  // namespace
  164|       |
  165|       |Iterator* NewTwoLevelIterator(Iterator* index_iter,
  166|       |                              BlockFunction block_function, void* arg,
  167|      0|                              const ReadOptions& options) {
  168|      0|  return new TwoLevelIterator(index_iter, block_function, arg, options);
  169|      0|}
  170|       |
  171|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/arena.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "util/arena.h"
    6|       |
    7|       |namespace leveldb {
    8|       |
    9|       |static const int kBlockSize = 4096;
   10|       |
   11|       |Arena::Arena()
   12|      0|    : alloc_ptr_(nullptr), alloc_bytes_remaining_(0), memory_usage_(0) {}
   13|       |
   14|      0|Arena::~Arena() {
   15|      0|  for (size_t i = 0; i < blocks_.size(); i++) {
   16|      0|    delete[] blocks_[i];
   17|      0|  }
   18|      0|}
   19|       |
   20|      0|char* Arena::AllocateFallback(size_t bytes) {
   21|      0|  if (bytes > kBlockSize / 4) {
   22|      0|    // Object is more than a quarter of our block size.  Allocate it separately
   23|      0|    // to avoid wasting too much space in leftover bytes.
   24|      0|    char* result = AllocateNewBlock(bytes);
   25|      0|    return result;
   26|      0|  }
   27|      0|
   28|      0|  // We waste the remaining space in the current block.
   29|      0|  alloc_ptr_ = AllocateNewBlock(kBlockSize);
   30|      0|  alloc_bytes_remaining_ = kBlockSize;
   31|      0|
   32|      0|  char* result = alloc_ptr_;
   33|      0|  alloc_ptr_ += bytes;
   34|      0|  alloc_bytes_remaining_ -= bytes;
   35|      0|  return result;
   36|      0|}
   37|       |
   38|      0|char* Arena::AllocateAligned(size_t bytes) {
   39|      0|  const int align = (sizeof(void*) > 8) ? sizeof(void*) : 8;
   40|      0|  static_assert((align & (align - 1)) == 0,
   41|      0|                "Pointer size should be a power of 2");
   42|      0|  size_t current_mod = reinterpret_cast<uintptr_t>(alloc_ptr_) & (align - 1);
   43|      0|  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
   44|      0|  size_t needed = bytes + slop;
   45|      0|  char* result;
   46|      0|  if (needed <= alloc_bytes_remaining_) {
   47|      0|    result = alloc_ptr_ + slop;
   48|      0|    alloc_ptr_ += needed;
   49|      0|    alloc_bytes_remaining_ -= needed;
   50|      0|  } else {
   51|      0|    // AllocateFallback always returned aligned memory
   52|      0|    result = AllocateFallback(bytes);
   53|      0|  }
   54|      0|  assert((reinterpret_cast<uintptr_t>(result) & (align - 1)) == 0);
   55|      0|  return result;
   56|      0|}
   57|       |
   58|      0|char* Arena::AllocateNewBlock(size_t block_bytes) {
   59|      0|  char* result = new char[block_bytes];
   60|      0|  blocks_.push_back(result);
   61|      0|  memory_usage_.fetch_add(block_bytes + sizeof(char*),
   62|      0|                          std::memory_order_relaxed);
   63|      0|  return result;
   64|      0|}
   65|       |
   66|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/arena.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_UTIL_ARENA_H_
    6|       |#define STORAGE_LEVELDB_UTIL_ARENA_H_
    7|       |
    8|       |#include <atomic>
    9|       |#include <cassert>
   10|       |#include <cstddef>
   11|       |#include <cstdint>
   12|       |#include <vector>
   13|       |
   14|       |namespace leveldb {
   15|       |
   16|       |class Arena {
   17|       | public:
   18|       |  Arena();
   19|       |
   20|       |  Arena(const Arena&) = delete;
   21|       |  Arena& operator=(const Arena&) = delete;
   22|       |
   23|       |  ~Arena();
   24|       |
   25|       |  // Return a pointer to a newly allocated memory block of "bytes" bytes.
   26|       |  char* Allocate(size_t bytes);
   27|       |
   28|       |  // Allocate memory with the normal alignment guarantees provided by malloc.
   29|       |  char* AllocateAligned(size_t bytes);
   30|       |
   31|       |  // Returns an estimate of the total memory usage of data allocated
   32|       |  // by the arena.
   33|      0|  size_t MemoryUsage() const {
   34|      0|    return memory_usage_.load(std::memory_order_relaxed);
   35|      0|  }
   36|       |
   37|       | private:
   38|       |  char* AllocateFallback(size_t bytes);
   39|       |  char* AllocateNewBlock(size_t block_bytes);
   40|       |
   41|       |  // Allocation state
   42|       |  char* alloc_ptr_;
   43|       |  size_t alloc_bytes_remaining_;
   44|       |
   45|       |  // Array of new[] allocated memory blocks
   46|       |  std::vector<char*> blocks_;
   47|       |
   48|       |  // Total memory usage of the arena.
   49|       |  //
   50|       |  // TODO(costan): This member is accessed via atomics, but the others are
   51|       |  //               accessed without any locking. Is this OK?
   52|       |  std::atomic<size_t> memory_usage_;
   53|       |};
   54|       |
   55|      0|inline char* Arena::Allocate(size_t bytes) {
   56|      0|  // The semantics of what to return are a bit messy if we allow
   57|      0|  // 0-byte allocations, so we disallow them here (we don't need
   58|      0|  // them for our internal use).
   59|      0|  assert(bytes > 0);
   60|      0|  if (bytes <= alloc_bytes_remaining_) {
   61|      0|    char* result = alloc_ptr_;
   62|      0|    alloc_ptr_ += bytes;
   63|      0|    alloc_bytes_remaining_ -= bytes;
   64|      0|    return result;
   65|      0|  }
   66|      0|  return AllocateFallback(bytes);
   67|      0|}
   68|       |
   69|       |}  // namespace leveldb
   70|       |
   71|       |#endif  // STORAGE_LEVELDB_UTIL_ARENA_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/cache.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include <assert.h>
    6|       |#include <stdio.h>
    7|       |#include <stdlib.h>
    8|       |
    9|       |#include "leveldb/cache.h"
   10|       |#include "port/port.h"
   11|       |#include "port/thread_annotations.h"
   12|       |#include "util/hash.h"
   13|       |#include "util/mutexlock.h"
   14|       |
   15|       |namespace leveldb {
   16|       |
   17|      0|Cache::~Cache() {}
   18|       |
   19|       |namespace {
   20|       |
   21|       |// LRU cache implementation
   22|       |//
   23|       |// Cache entries have an "in_cache" boolean indicating whether the cache has a
   24|       |// reference on the entry.  The only ways that this can become false without the
   25|       |// entry being passed to its "deleter" are via Erase(), via Insert() when
   26|       |// an element with a duplicate key is inserted, or on destruction of the cache.
   27|       |//
   28|       |// The cache keeps two linked lists of items in the cache.  All items in the
   29|       |// cache are in one list or the other, and never both.  Items still referenced
   30|       |// by clients but erased from the cache are in neither list.  The lists are:
   31|       |// - in-use:  contains the items currently referenced by clients, in no
   32|       |//   particular order.  (This list is used for invariant checking.  If we
   33|       |//   removed the check, elements that would otherwise be on this list could be
   34|       |//   left as disconnected singleton lists.)
   35|       |// - LRU:  contains the items not currently referenced by clients, in LRU order
   36|       |// Elements are moved between these lists by the Ref() and Unref() methods,
   37|       |// when they detect an element in the cache acquiring or losing its only
   38|       |// external reference.
   39|       |
   40|       |// An entry is a variable length heap-allocated structure.  Entries
   41|       |// are kept in a circular doubly linked list ordered by access time.
   42|       |struct LRUHandle {
   43|       |  void* value;
   44|       |  void (*deleter)(const Slice&, void* value);
   45|       |  LRUHandle* next_hash;
   46|       |  LRUHandle* next;
   47|       |  LRUHandle* prev;
   48|       |  size_t charge;  // TODO(opt): Only allow uint32_t?
   49|       |  size_t key_length;
   50|       |  bool in_cache;     // Whether entry is in the cache.
   51|       |  uint32_t refs;     // References, including cache reference, if present.
   52|       |  uint32_t hash;     // Hash of key(); used for fast sharding and comparisons
   53|       |  char key_data[1];  // Beginning of key
   54|       |
   55|      0|  Slice key() const {
   56|      0|    // next_ is only equal to this if the LRU handle is the list head of an
   57|      0|    // empty list. List heads never have meaningful keys.
   58|      0|    assert(next != this);
   59|      0|
   60|      0|    return Slice(key_data, key_length);
   61|      0|  }
   62|       |};
   63|       |
   64|       |// We provide our own simple hash table since it removes a whole bunch
   65|       |// of porting hacks and is also faster than some of the built-in hash
   66|       |// table implementations in some of the compiler/runtime combinations
   67|       |// we have tested.  E.g., readrandom speeds up by ~5% over the g++
   68|       |// 4.4.3's builtin hashtable.
   69|       |class HandleTable {
   70|       | public:
   71|      0|  HandleTable() : length_(0), elems_(0), list_(nullptr) { Resize(); }
   72|      0|  ~HandleTable() { delete[] list_; }
   73|       |
   74|      0|  LRUHandle* Lookup(const Slice& key, uint32_t hash) {
   75|      0|    return *FindPointer(key, hash);
   76|      0|  }
   77|       |
   78|      0|  LRUHandle* Insert(LRUHandle* h) {
   79|      0|    LRUHandle** ptr = FindPointer(h->key(), h->hash);
   80|      0|    LRUHandle* old = *ptr;
   81|      0|    h->next_hash = (old == nullptr ? nullptr : old->next_hash);
   82|      0|    *ptr = h;
   83|      0|    if (old == nullptr) {
   84|      0|      ++elems_;
   85|      0|      if (elems_ > length_) {
   86|      0|        // Since each cache entry is fairly large, we aim for a small
   87|      0|        // average linked list length (<= 1).
   88|      0|        Resize();
   89|      0|      }
   90|      0|    }
   91|      0|    return old;
   92|      0|  }
   93|       |
   94|      0|  LRUHandle* Remove(const Slice& key, uint32_t hash) {
   95|      0|    LRUHandle** ptr = FindPointer(key, hash);
   96|      0|    LRUHandle* result = *ptr;
   97|      0|    if (result != nullptr) {
   98|      0|      *ptr = result->next_hash;
   99|      0|      --elems_;
  100|      0|    }
  101|      0|    return result;
  102|      0|  }
  103|       |
  104|       | private:
  105|       |  // The table consists of an array of buckets where each bucket is
  106|       |  // a linked list of cache entries that hash into the bucket.
  107|       |  uint32_t length_;
  108|       |  uint32_t elems_;
  109|       |  LRUHandle** list_;
  110|       |
  111|       |  // Return a pointer to slot that points to a cache entry that
  112|       |  // matches key/hash.  If there is no such cache entry, return a
  113|       |  // pointer to the trailing slot in the corresponding linked list.
  114|      0|  LRUHandle** FindPointer(const Slice& key, uint32_t hash) {
  115|      0|    LRUHandle** ptr = &list_[hash & (length_ - 1)];
  116|      0|    while (*ptr != nullptr && ((*ptr)->hash != hash || key != (*ptr)->key())) {
  117|      0|      ptr = &(*ptr)->next_hash;
  118|      0|    }
  119|      0|    return ptr;
  120|      0|  }
  121|       |
  122|      0|  void Resize() {
  123|      0|    uint32_t new_length = 4;
  124|      0|    while (new_length < elems_) {
  125|      0|      new_length *= 2;
  126|      0|    }
  127|      0|    LRUHandle** new_list = new LRUHandle*[new_length];
  128|      0|    memset(new_list, 0, sizeof(new_list[0]) * new_length);
  129|      0|    uint32_t count = 0;
  130|      0|    for (uint32_t i = 0; i < length_; i++) {
  131|      0|      LRUHandle* h = list_[i];
  132|      0|      while (h != nullptr) {
  133|      0|        LRUHandle* next = h->next_hash;
  134|      0|        uint32_t hash = h->hash;
  135|      0|        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
  136|      0|        h->next_hash = *ptr;
  137|      0|        *ptr = h;
  138|      0|        h = next;
  139|      0|        count++;
  140|      0|      }
  141|      0|    }
  142|      0|    assert(elems_ == count);
  143|      0|    delete[] list_;
  144|      0|    list_ = new_list;
  145|      0|    length_ = new_length;
  146|      0|  }
  147|       |};
  148|       |
  149|       |// A single shard of sharded cache.
  150|       |class LRUCache {
  151|       | public:
  152|       |  LRUCache();
  153|       |  ~LRUCache();
  154|       |
  155|       |  // Separate from constructor so caller can easily make an array of LRUCache
  156|      0|  void SetCapacity(size_t capacity) { capacity_ = capacity; }
  157|       |
  158|       |  // Like Cache methods, but with an extra "hash" parameter.
  159|       |  Cache::Handle* Insert(const Slice& key, uint32_t hash, void* value,
  160|       |                        size_t charge,
  161|       |                        void (*deleter)(const Slice& key, void* value));
  162|       |  Cache::Handle* Lookup(const Slice& key, uint32_t hash);
  163|       |  void Release(Cache::Handle* handle);
  164|       |  void Erase(const Slice& key, uint32_t hash);
  165|       |  void Prune();
  166|      0|  size_t TotalCharge() const {
  167|      0|    MutexLock l(&mutex_);
  168|      0|    return usage_;
  169|      0|  }
  170|       |
  171|       | private:
  172|       |  void LRU_Remove(LRUHandle* e);
  173|       |  void LRU_Append(LRUHandle* list, LRUHandle* e);
  174|       |  void Ref(LRUHandle* e);
  175|       |  void Unref(LRUHandle* e);
  176|       |  bool FinishErase(LRUHandle* e) EXCLUSIVE_LOCKS_REQUIRED(mutex_);
  177|       |
  178|       |  // Initialized before use.
  179|       |  size_t capacity_;
  180|       |
  181|       |  // mutex_ protects the following state.
  182|       |  mutable port::Mutex mutex_;
  183|       |  size_t usage_ GUARDED_BY(mutex_);
  184|       |
  185|       |  // Dummy head of LRU list.
  186|       |  // lru.prev is newest entry, lru.next is oldest entry.
  187|       |  // Entries have refs==1 and in_cache==true.
  188|       |  LRUHandle lru_ GUARDED_BY(mutex_);
  189|       |
  190|       |  // Dummy head of in-use list.
  191|       |  // Entries are in use by clients, and have refs >= 2 and in_cache==true.
  192|       |  LRUHandle in_use_ GUARDED_BY(mutex_);
  193|       |
  194|       |  HandleTable table_ GUARDED_BY(mutex_);
  195|       |};
  196|       |
  197|      0|LRUCache::LRUCache() : capacity_(0), usage_(0) {
  198|      0|  // Make empty circular linked lists.
  199|      0|  lru_.next = &lru_;
  200|      0|  lru_.prev = &lru_;
  201|      0|  in_use_.next = &in_use_;
  202|      0|  in_use_.prev = &in_use_;
  203|      0|}
  204|       |
  205|      0|LRUCache::~LRUCache() {
  206|      0|  assert(in_use_.next == &in_use_);  // Error if caller has an unreleased handle
  207|      0|  for (LRUHandle* e = lru_.next; e != &lru_;) {
  208|      0|    LRUHandle* next = e->next;
  209|      0|    assert(e->in_cache);
  210|      0|    e->in_cache = false;
  211|      0|    assert(e->refs == 1);  // Invariant of lru_ list.
  212|      0|    Unref(e);
  213|      0|    e = next;
  214|      0|  }
  215|      0|}
  216|       |
  217|      0|void LRUCache::Ref(LRUHandle* e) {
  218|      0|  if (e->refs == 1 && e->in_cache) {  // If on lru_ list, move to in_use_ list.
  219|      0|    LRU_Remove(e);
  220|      0|    LRU_Append(&in_use_, e);
  221|      0|  }
  222|      0|  e->refs++;
  223|      0|}
  224|       |
  225|      0|void LRUCache::Unref(LRUHandle* e) {
  226|      0|  assert(e->refs > 0);
  227|      0|  e->refs--;
  228|      0|  if (e->refs == 0) {  // Deallocate.
  229|      0|    assert(!e->in_cache);
  230|      0|    (*e->deleter)(e->key(), e->value);
  231|      0|    free(e);
  232|      0|  } else if (e->in_cache && e->refs == 1) {
  233|      0|    // No longer in use; move to lru_ list.
  234|      0|    LRU_Remove(e);
  235|      0|    LRU_Append(&lru_, e);
  236|      0|  }
  237|      0|}
  238|       |
  239|      0|void LRUCache::LRU_Remove(LRUHandle* e) {
  240|      0|  e->next->prev = e->prev;
  241|      0|  e->prev->next = e->next;
  242|      0|}
  243|       |
  244|      0|void LRUCache::LRU_Append(LRUHandle* list, LRUHandle* e) {
  245|      0|  // Make "e" newest entry by inserting just before *list
  246|      0|  e->next = list;
  247|      0|  e->prev = list->prev;
  248|      0|  e->prev->next = e;
  249|      0|  e->next->prev = e;
  250|      0|}
  251|       |
  252|      0|Cache::Handle* LRUCache::Lookup(const Slice& key, uint32_t hash) {
  253|      0|  MutexLock l(&mutex_);
  254|      0|  LRUHandle* e = table_.Lookup(key, hash);
  255|      0|  if (e != nullptr) {
  256|      0|    Ref(e);
  257|      0|  }
  258|      0|  return reinterpret_cast<Cache::Handle*>(e);
  259|      0|}
  260|       |
  261|      0|void LRUCache::Release(Cache::Handle* handle) {
  262|      0|  MutexLock l(&mutex_);
  263|      0|  Unref(reinterpret_cast<LRUHandle*>(handle));
  264|      0|}
  265|       |
  266|       |Cache::Handle* LRUCache::Insert(const Slice& key, uint32_t hash, void* value,
  267|       |                                size_t charge,
  268|       |                                void (*deleter)(const Slice& key,
  269|      0|                                                void* value)) {
  270|      0|  MutexLock l(&mutex_);
  271|      0|
  272|      0|  LRUHandle* e =
  273|      0|      reinterpret_cast<LRUHandle*>(malloc(sizeof(LRUHandle) - 1 + key.size()));
  274|      0|  e->value = value;
  275|      0|  e->deleter = deleter;
  276|      0|  e->charge = charge;
  277|      0|  e->key_length = key.size();
  278|      0|  e->hash = hash;
  279|      0|  e->in_cache = false;
  280|      0|  e->refs = 1;  // for the returned handle.
  281|      0|  memcpy(e->key_data, key.data(), key.size());
  282|      0|
  283|      0|  if (capacity_ > 0) {
  284|      0|    e->refs++;  // for the cache's reference.
  285|      0|    e->in_cache = true;
  286|      0|    LRU_Append(&in_use_, e);
  287|      0|    usage_ += charge;
  288|      0|    FinishErase(table_.Insert(e));
  289|      0|  } else {  // don't cache. (capacity_==0 is supported and turns off caching.)
  290|      0|    // next is read by key() in an assert, so it must be initialized
  291|      0|    e->next = nullptr;
  292|      0|  }
  293|      0|  while (usage_ > capacity_ && lru_.next != &lru_) {
  294|      0|    LRUHandle* old = lru_.next;
  295|      0|    assert(old->refs == 1);
  296|      0|    bool erased = FinishErase(table_.Remove(old->key(), old->hash));
  297|      0|    if (!erased) {  // to avoid unused variable when compiled NDEBUG
  298|      0|      assert(erased);
  299|      0|    }
  300|      0|  }
  301|      0|
  302|      0|  return reinterpret_cast<Cache::Handle*>(e);
  303|      0|}
  304|       |
  305|       |// If e != nullptr, finish removing *e from the cache; it has already been
  306|       |// removed from the hash table.  Return whether e != nullptr.
  307|      0|bool LRUCache::FinishErase(LRUHandle* e) {
  308|      0|  if (e != nullptr) {
  309|      0|    assert(e->in_cache);
  310|      0|    LRU_Remove(e);
  311|      0|    e->in_cache = false;
  312|      0|    usage_ -= e->charge;
  313|      0|    Unref(e);
  314|      0|  }
  315|      0|  return e != nullptr;
  316|      0|}
  317|       |
  318|      0|void LRUCache::Erase(const Slice& key, uint32_t hash) {
  319|      0|  MutexLock l(&mutex_);
  320|      0|  FinishErase(table_.Remove(key, hash));
  321|      0|}
  322|       |
  323|      0|void LRUCache::Prune() {
  324|      0|  MutexLock l(&mutex_);
  325|      0|  while (lru_.next != &lru_) {
  326|      0|    LRUHandle* e = lru_.next;
  327|      0|    assert(e->refs == 1);
  328|      0|    bool erased = FinishErase(table_.Remove(e->key(), e->hash));
  329|      0|    if (!erased) {  // to avoid unused variable when compiled NDEBUG
  330|      0|      assert(erased);
  331|      0|    }
  332|      0|  }
  333|      0|}
  334|       |
  335|       |static const int kNumShardBits = 4;
  336|       |static const int kNumShards = 1 << kNumShardBits;
  337|       |
  338|       |class ShardedLRUCache : public Cache {
  339|       | private:
  340|       |  LRUCache shard_[kNumShards];
  341|       |  port::Mutex id_mutex_;
  342|       |  uint64_t last_id_;
  343|       |
  344|      0|  static inline uint32_t HashSlice(const Slice& s) {
  345|      0|    return Hash(s.data(), s.size(), 0);
  346|      0|  }
  347|       |
  348|      0|  static uint32_t Shard(uint32_t hash) { return hash >> (32 - kNumShardBits); }
  349|       |
  350|       | public:
  351|      0|  explicit ShardedLRUCache(size_t capacity) : last_id_(0) {
  352|      0|    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
  353|      0|    for (int s = 0; s < kNumShards; s++) {
  354|      0|      shard_[s].SetCapacity(per_shard);
  355|      0|    }
  356|      0|  }
  357|      0|  virtual ~ShardedLRUCache() {}
  358|       |  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
  359|      0|                         void (*deleter)(const Slice& key, void* value)) {
  360|      0|    const uint32_t hash = HashSlice(key);
  361|      0|    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  362|      0|  }
  363|      0|  virtual Handle* Lookup(const Slice& key) {
  364|      0|    const uint32_t hash = HashSlice(key);
  365|      0|    return shard_[Shard(hash)].Lookup(key, hash);
  366|      0|  }
  367|      0|  virtual void Release(Handle* handle) {
  368|      0|    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);
  369|      0|    shard_[Shard(h->hash)].Release(handle);
  370|      0|  }
  371|      0|  virtual void Erase(const Slice& key) {
  372|      0|    const uint32_t hash = HashSlice(key);
  373|      0|    shard_[Shard(hash)].Erase(key, hash);
  374|      0|  }
  375|      0|  virtual void* Value(Handle* handle) {
  376|      0|    return reinterpret_cast<LRUHandle*>(handle)->value;
  377|      0|  }
  378|      0|  virtual uint64_t NewId() {
  379|      0|    MutexLock l(&id_mutex_);
  380|      0|    return ++(last_id_);
  381|      0|  }
  382|      0|  virtual void Prune() {
  383|      0|    for (int s = 0; s < kNumShards; s++) {
  384|      0|      shard_[s].Prune();
  385|      0|    }
  386|      0|  }
  387|      0|  virtual size_t TotalCharge() const {
  388|      0|    size_t total = 0;
  389|      0|    for (int s = 0; s < kNumShards; s++) {
  390|      0|      total += shard_[s].TotalCharge();
  391|      0|    }
  392|      0|    return total;
  393|      0|  }
  394|       |};
  395|       |
  396|       |}  // end anonymous namespace
  397|       |
  398|      0|Cache* NewLRUCache(size_t capacity) { return new ShardedLRUCache(capacity); }
  399|       |
  400|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/coding.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "util/coding.h"
    6|       |
    7|       |namespace leveldb {
    8|       |
    9|      0|void EncodeFixed32(char* dst, uint32_t value) {
   10|      0|  if (port::kLittleEndian) {
   11|      0|    memcpy(dst, &value, sizeof(value));
   12|      0|  } else {
   13|      0|    dst[0] = value & 0xff;
   14|      0|    dst[1] = (value >> 8) & 0xff;
   15|      0|    dst[2] = (value >> 16) & 0xff;
   16|      0|    dst[3] = (value >> 24) & 0xff;
   17|      0|  }
   18|      0|}
   19|       |
   20|      0|void EncodeFixed64(char* dst, uint64_t value) {
   21|      0|  if (port::kLittleEndian) {
   22|      0|    memcpy(dst, &value, sizeof(value));
   23|      0|  } else {
   24|      0|    dst[0] = value & 0xff;
   25|      0|    dst[1] = (value >> 8) & 0xff;
   26|      0|    dst[2] = (value >> 16) & 0xff;
   27|      0|    dst[3] = (value >> 24) & 0xff;
   28|      0|    dst[4] = (value >> 32) & 0xff;
   29|      0|    dst[5] = (value >> 40) & 0xff;
   30|      0|    dst[6] = (value >> 48) & 0xff;
   31|      0|    dst[7] = (value >> 56) & 0xff;
   32|      0|  }
   33|      0|}
   34|       |
   35|      0|void PutFixed32(std::string* dst, uint32_t value) {
   36|      0|  char buf[sizeof(value)];
   37|      0|  EncodeFixed32(buf, value);
   38|      0|  dst->append(buf, sizeof(buf));
   39|      0|}
   40|       |
   41|      0|void PutFixed64(std::string* dst, uint64_t value) {
   42|      0|  char buf[sizeof(value)];
   43|      0|  EncodeFixed64(buf, value);
   44|      0|  dst->append(buf, sizeof(buf));
   45|      0|}
   46|       |
   47|      0|char* EncodeVarint32(char* dst, uint32_t v) {
   48|      0|  // Operate on characters as unsigneds
   49|      0|  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
   50|      0|  static const int B = 128;
   51|      0|  if (v < (1 << 7)) {
   52|      0|    *(ptr++) = v;
   53|      0|  } else if (v < (1 << 14)) {
   54|      0|    *(ptr++) = v | B;
   55|      0|    *(ptr++) = v >> 7;
   56|      0|  } else if (v < (1 << 21)) {
   57|      0|    *(ptr++) = v | B;
   58|      0|    *(ptr++) = (v >> 7) | B;
   59|      0|    *(ptr++) = v >> 14;
   60|      0|  } else if (v < (1 << 28)) {
   61|      0|    *(ptr++) = v | B;
   62|      0|    *(ptr++) = (v >> 7) | B;
   63|      0|    *(ptr++) = (v >> 14) | B;
   64|      0|    *(ptr++) = v >> 21;
   65|      0|  } else {
   66|      0|    *(ptr++) = v | B;
   67|      0|    *(ptr++) = (v >> 7) | B;
   68|      0|    *(ptr++) = (v >> 14) | B;
   69|      0|    *(ptr++) = (v >> 21) | B;
   70|      0|    *(ptr++) = v >> 28;
   71|      0|  }
   72|      0|  return reinterpret_cast<char*>(ptr);
   73|      0|}
   74|       |
   75|      0|void PutVarint32(std::string* dst, uint32_t v) {
   76|      0|  char buf[5];
   77|      0|  char* ptr = EncodeVarint32(buf, v);
   78|      0|  dst->append(buf, ptr - buf);
   79|      0|}
   80|       |
   81|      0|char* EncodeVarint64(char* dst, uint64_t v) {
   82|      0|  static const int B = 128;
   83|      0|  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
   84|      0|  while (v >= B) {
   85|      0|    *(ptr++) = v | B;
   86|      0|    v >>= 7;
   87|      0|  }
   88|      0|  *(ptr++) = static_cast<unsigned char>(v);
   89|      0|  return reinterpret_cast<char*>(ptr);
   90|      0|}
   91|       |
   92|      0|void PutVarint64(std::string* dst, uint64_t v) {
   93|      0|  char buf[10];
   94|      0|  char* ptr = EncodeVarint64(buf, v);
   95|      0|  dst->append(buf, ptr - buf);
   96|      0|}
   97|       |
   98|      0|void PutLengthPrefixedSlice(std::string* dst, const Slice& value) {
   99|      0|  PutVarint32(dst, value.size());
  100|      0|  dst->append(value.data(), value.size());
  101|      0|}
  102|       |
  103|      0|int VarintLength(uint64_t v) {
  104|      0|  int len = 1;
  105|      0|  while (v >= 128) {
  106|      0|    v >>= 7;
  107|      0|    len++;
  108|      0|  }
  109|      0|  return len;
  110|      0|}
  111|       |
  112|       |const char* GetVarint32PtrFallback(const char* p, const char* limit,
  113|      0|                                   uint32_t* value) {
  114|      0|  uint32_t result = 0;
  115|      0|  for (uint32_t shift = 0; shift <= 28 && p < limit; shift += 7) {
  116|      0|    uint32_t byte = *(reinterpret_cast<const unsigned char*>(p));
  117|      0|    p++;
  118|      0|    if (byte & 128) {
  119|      0|      // More bytes are present
  120|      0|      result |= ((byte & 127) << shift);
  121|      0|    } else {
  122|      0|      result |= (byte << shift);
  123|      0|      *value = result;
  124|      0|      return reinterpret_cast<const char*>(p);
  125|      0|    }
  126|      0|  }
  127|      0|  return nullptr;
  128|      0|}
  129|       |
  130|      0|bool GetVarint32(Slice* input, uint32_t* value) {
  131|      0|  const char* p = input->data();
  132|      0|  const char* limit = p + input->size();
  133|      0|  const char* q = GetVarint32Ptr(p, limit, value);
  134|      0|  if (q == nullptr) {
  135|      0|    return false;
  136|      0|  } else {
  137|      0|    *input = Slice(q, limit - q);
  138|      0|    return true;
  139|      0|  }
  140|      0|}
  141|       |
  142|      0|const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* value) {
  143|      0|  uint64_t result = 0;
  144|      0|  for (uint32_t shift = 0; shift <= 63 && p < limit; shift += 7) {
  145|      0|    uint64_t byte = *(reinterpret_cast<const unsigned char*>(p));
  146|      0|    p++;
  147|      0|    if (byte & 128) {
  148|      0|      // More bytes are present
  149|      0|      result |= ((byte & 127) << shift);
  150|      0|    } else {
  151|      0|      result |= (byte << shift);
  152|      0|      *value = result;
  153|      0|      return reinterpret_cast<const char*>(p);
  154|      0|    }
  155|      0|  }
  156|      0|  return nullptr;
  157|      0|}
  158|       |
  159|      0|bool GetVarint64(Slice* input, uint64_t* value) {
  160|      0|  const char* p = input->data();
  161|      0|  const char* limit = p + input->size();
  162|      0|  const char* q = GetVarint64Ptr(p, limit, value);
  163|      0|  if (q == nullptr) {
  164|      0|    return false;
  165|      0|  } else {
  166|      0|    *input = Slice(q, limit - q);
  167|      0|    return true;
  168|      0|  }
  169|      0|}
  170|       |
  171|       |const char* GetLengthPrefixedSlice(const char* p, const char* limit,
  172|      0|                                   Slice* result) {
  173|      0|  uint32_t len;
  174|      0|  p = GetVarint32Ptr(p, limit, &len);
  175|      0|  if (p == nullptr) return nullptr;
  176|      0|  if (p + len > limit) return nullptr;
  177|      0|  *result = Slice(p, len);
  178|      0|  return p + len;
  179|      0|}
  180|       |
  181|      0|bool GetLengthPrefixedSlice(Slice* input, Slice* result) {
  182|      0|  uint32_t len;
  183|      0|  if (GetVarint32(input, &len) && input->size() >= len) {
  184|      0|    *result = Slice(input->data(), len);
  185|      0|    input->remove_prefix(len);
  186|      0|    return true;
  187|      0|  } else {
  188|      0|    return false;
  189|      0|  }
  190|      0|}
  191|       |
  192|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/coding.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// Endian-neutral encoding:
    6|       |// * Fixed-length numbers are encoded with least-significant byte first
    7|       |// * In addition we support variable length "varint" encoding
    8|       |// * Strings are encoded prefixed by their length in varint format
    9|       |
   10|       |#ifndef STORAGE_LEVELDB_UTIL_CODING_H_
   11|       |#define STORAGE_LEVELDB_UTIL_CODING_H_
   12|       |
   13|       |#include <stdint.h>
   14|       |#include <string.h>
   15|       |
   16|       |#include <string>
   17|       |
   18|       |#include "leveldb/slice.h"
   19|       |#include "port/port.h"
   20|       |
   21|       |namespace leveldb {
   22|       |
   23|       |// Standard Put... routines append to a string
   24|       |void PutFixed32(std::string* dst, uint32_t value);
   25|       |void PutFixed64(std::string* dst, uint64_t value);
   26|       |void PutVarint32(std::string* dst, uint32_t value);
   27|       |void PutVarint64(std::string* dst, uint64_t value);
   28|       |void PutLengthPrefixedSlice(std::string* dst, const Slice& value);
   29|       |
   30|       |// Standard Get... routines parse a value from the beginning of a Slice
   31|       |// and advance the slice past the parsed value.
   32|       |bool GetVarint32(Slice* input, uint32_t* value);
   33|       |bool GetVarint64(Slice* input, uint64_t* value);
   34|       |bool GetLengthPrefixedSlice(Slice* input, Slice* result);
   35|       |
   36|       |// Pointer-based variants of GetVarint...  These either store a value
   37|       |// in *v and return a pointer just past the parsed value, or return
   38|       |// nullptr on error.  These routines only look at bytes in the range
   39|       |// [p..limit-1]
   40|       |const char* GetVarint32Ptr(const char* p, const char* limit, uint32_t* v);
   41|       |const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* v);
   42|       |
   43|       |// Returns the length of the varint32 or varint64 encoding of "v"
   44|       |int VarintLength(uint64_t v);
   45|       |
   46|       |// Lower-level versions of Put... that write directly into a character buffer
   47|       |// REQUIRES: dst has enough space for the value being written
   48|       |void EncodeFixed32(char* dst, uint32_t value);
   49|       |void EncodeFixed64(char* dst, uint64_t value);
   50|       |
   51|       |// Lower-level versions of Put... that write directly into a character buffer
   52|       |// and return a pointer just past the last byte written.
   53|       |// REQUIRES: dst has enough space for the value being written
   54|       |char* EncodeVarint32(char* dst, uint32_t value);
   55|       |char* EncodeVarint64(char* dst, uint64_t value);
   56|       |
   57|       |// Lower-level versions of Get... that read directly from a character buffer
   58|       |// without any bounds checking.
   59|       |
   60|      0|inline uint32_t DecodeFixed32(const char* ptr) {
   61|      0|  if (port::kLittleEndian) {
   62|      0|    // Load the raw bytes
   63|      0|    uint32_t result;
   64|      0|    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
   65|      0|    return result;
   66|      0|  } else {
   67|      0|    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0]))) |
   68|      0|            (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8) |
   69|      0|            (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16) |
   70|      0|            (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));
   71|      0|  }
   72|      0|}
   73|       |
   74|      0|inline uint64_t DecodeFixed64(const char* ptr) {
   75|      0|  if (port::kLittleEndian) {
   76|      0|    // Load the raw bytes
   77|      0|    uint64_t result;
   78|      0|    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
   79|      0|    return result;
   80|      0|  } else {
   81|      0|    uint64_t lo = DecodeFixed32(ptr);
   82|      0|    uint64_t hi = DecodeFixed32(ptr + 4);
   83|      0|    return (hi << 32) | lo;
   84|      0|  }
   85|      0|}
   86|       |
   87|       |// Internal routine for use by fallback path of GetVarint32Ptr
   88|       |const char* GetVarint32PtrFallback(const char* p, const char* limit,
   89|       |                                   uint32_t* value);
   90|       |inline const char* GetVarint32Ptr(const char* p, const char* limit,
   91|      0|                                  uint32_t* value) {
   92|      0|  if (p < limit) {
   93|      0|    uint32_t result = *(reinterpret_cast<const unsigned char*>(p));
   94|      0|    if ((result & 128) == 0) {
   95|      0|      *value = result;
   96|      0|      return p + 1;
   97|      0|    }
   98|      0|  }
   99|      0|  return GetVarint32PtrFallback(p, limit, value);
  100|      0|}
  101|       |
  102|       |}  // namespace leveldb
  103|       |
  104|       |#endif  // STORAGE_LEVELDB_UTIL_CODING_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/comparator.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include <algorithm>
    6|       |#include <cstdint>
    7|       |#include <string>
    8|       |
    9|       |#include "leveldb/comparator.h"
   10|       |#include "leveldb/slice.h"
   11|       |#include "util/logging.h"
   12|       |#include "util/no_destructor.h"
   13|       |
   14|       |namespace leveldb {
   15|       |
   16|      0|Comparator::~Comparator() {}
   17|       |
   18|       |namespace {
   19|       |class BytewiseComparatorImpl : public Comparator {
   20|       | public:
   21|      0|  BytewiseComparatorImpl() {}
   22|       |
   23|      0|  virtual const char* Name() const { return "leveldb.BytewiseComparator"; }
   24|       |
   25|      0|  virtual int Compare(const Slice& a, const Slice& b) const {
   26|      0|    return a.compare(b);
   27|      0|  }
   28|       |
   29|       |  virtual void FindShortestSeparator(std::string* start,
   30|      0|                                     const Slice& limit) const {
   31|      0|    // Find length of common prefix
   32|      0|    size_t min_length = std::min(start->size(), limit.size());
   33|      0|    size_t diff_index = 0;
   34|      0|    while ((diff_index < min_length) &&
   35|      0|           ((*start)[diff_index] == limit[diff_index])) {
   36|      0|      diff_index++;
   37|      0|    }
   38|      0|
   39|      0|    if (diff_index >= min_length) {
   40|      0|      // Do not shorten if one string is a prefix of the other
   41|      0|    } else {
   42|      0|      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
   43|      0|      if (diff_byte < static_cast<uint8_t>(0xff) &&
   44|      0|          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
   45|      0|        (*start)[diff_index]++;
   46|      0|        start->resize(diff_index + 1);
   47|      0|        assert(Compare(*start, limit) < 0);
   48|      0|      }
   49|      0|    }
   50|      0|  }
   51|       |
   52|      0|  virtual void FindShortSuccessor(std::string* key) const {
   53|      0|    // Find first character that can be incremented
   54|      0|    size_t n = key->size();
   55|      0|    for (size_t i = 0; i < n; i++) {
   56|      0|      const uint8_t byte = (*key)[i];
   57|      0|      if (byte != static_cast<uint8_t>(0xff)) {
   58|      0|        (*key)[i] = byte + 1;
   59|      0|        key->resize(i + 1);
   60|      0|        return;
   61|      0|      }
   62|      0|    }
   63|      0|    // *key is a run of 0xffs.  Leave it alone.
   64|      0|  }
   65|       |};
   66|       |}  // namespace
   67|       |
   68|      0|const Comparator* BytewiseComparator() {
   69|      0|  static NoDestructor<BytewiseComparatorImpl> singleton;
   70|      0|  return singleton.get();
   71|      0|}
   72|       |
   73|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/crc32c.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// A portable implementation of crc32c.
    6|       |
    7|       |#include "util/crc32c.h"
    8|       |
    9|       |#include <stddef.h>
   10|       |#include <stdint.h>
   11|       |
   12|       |#include "port/port.h"
   13|       |#include "util/coding.h"
   14|       |
   15|       |namespace leveldb {
   16|       |namespace crc32c {
   17|       |
   18|       |namespace {
   19|       |
   20|       |const uint32_t kByteExtensionTable[256] = {
   21|       |    0x00000000, 0xf26b8303, 0xe13b70f7, 0x1350f3f4, 0xc79a971f, 0x35f1141c,
   22|       |    0x26a1e7e8, 0xd4ca64eb, 0x8ad958cf, 0x78b2dbcc, 0x6be22838, 0x9989ab3b,
   23|       |    0x4d43cfd0, 0xbf284cd3, 0xac78bf27, 0x5e133c24, 0x105ec76f, 0xe235446c,
   24|       |    0xf165b798, 0x030e349b, 0xd7c45070, 0x25afd373, 0x36ff2087, 0xc494a384,
   25|       |    0x9a879fa0, 0x68ec1ca3, 0x7bbcef57, 0x89d76c54, 0x5d1d08bf, 0xaf768bbc,
   26|       |    0xbc267848, 0x4e4dfb4b, 0x20bd8ede, 0xd2d60ddd, 0xc186fe29, 0x33ed7d2a,
   27|       |    0xe72719c1, 0x154c9ac2, 0x061c6936, 0xf477ea35, 0xaa64d611, 0x580f5512,
   28|       |    0x4b5fa6e6, 0xb93425e5, 0x6dfe410e, 0x9f95c20d, 0x8cc531f9, 0x7eaeb2fa,
   29|       |    0x30e349b1, 0xc288cab2, 0xd1d83946, 0x23b3ba45, 0xf779deae, 0x05125dad,
   30|       |    0x1642ae59, 0xe4292d5a, 0xba3a117e, 0x4851927d, 0x5b016189, 0xa96ae28a,
   31|       |    0x7da08661, 0x8fcb0562, 0x9c9bf696, 0x6ef07595, 0x417b1dbc, 0xb3109ebf,
   32|       |    0xa0406d4b, 0x522bee48, 0x86e18aa3, 0x748a09a0, 0x67dafa54, 0x95b17957,
   33|       |    0xcba24573, 0x39c9c670, 0x2a993584, 0xd8f2b687, 0x0c38d26c, 0xfe53516f,
   34|       |    0xed03a29b, 0x1f682198, 0x5125dad3, 0xa34e59d0, 0xb01eaa24, 0x42752927,
   35|       |    0x96bf4dcc, 0x64d4cecf, 0x77843d3b, 0x85efbe38, 0xdbfc821c, 0x2997011f,
   36|       |    0x3ac7f2eb, 0xc8ac71e8, 0x1c661503, 0xee0d9600, 0xfd5d65f4, 0x0f36e6f7,
   37|       |    0x61c69362, 0x93ad1061, 0x80fde395, 0x72966096, 0xa65c047d, 0x5437877e,
   38|       |    0x4767748a, 0xb50cf789, 0xeb1fcbad, 0x197448ae, 0x0a24bb5a, 0xf84f3859,
   39|       |    0x2c855cb2, 0xdeeedfb1, 0xcdbe2c45, 0x3fd5af46, 0x7198540d, 0x83f3d70e,
   40|       |    0x90a324fa, 0x62c8a7f9, 0xb602c312, 0x44694011, 0x5739b3e5, 0xa55230e6,
   41|       |    0xfb410cc2, 0x092a8fc1, 0x1a7a7c35, 0xe811ff36, 0x3cdb9bdd, 0xceb018de,
   42|       |    0xdde0eb2a, 0x2f8b6829, 0x82f63b78, 0x709db87b, 0x63cd4b8f, 0x91a6c88c,
   43|       |    0x456cac67, 0xb7072f64, 0xa457dc90, 0x563c5f93, 0x082f63b7, 0xfa44e0b4,
   44|       |    0xe9141340, 0x1b7f9043, 0xcfb5f4a8, 0x3dde77ab, 0x2e8e845f, 0xdce5075c,
   45|       |    0x92a8fc17, 0x60c37f14, 0x73938ce0, 0x81f80fe3, 0x55326b08, 0xa759e80b,
   46|       |    0xb4091bff, 0x466298fc, 0x1871a4d8, 0xea1a27db, 0xf94ad42f, 0x0b21572c,
   47|       |    0xdfeb33c7, 0x2d80b0c4, 0x3ed04330, 0xccbbc033, 0xa24bb5a6, 0x502036a5,
   48|       |    0x4370c551, 0xb11b4652, 0x65d122b9, 0x97baa1ba, 0x84ea524e, 0x7681d14d,
   49|       |    0x2892ed69, 0xdaf96e6a, 0xc9a99d9e, 0x3bc21e9d, 0xef087a76, 0x1d63f975,
   50|       |    0x0e330a81, 0xfc588982, 0xb21572c9, 0x407ef1ca, 0x532e023e, 0xa145813d,
   51|       |    0x758fe5d6, 0x87e466d5, 0x94b49521, 0x66df1622, 0x38cc2a06, 0xcaa7a905,
   52|       |    0xd9f75af1, 0x2b9cd9f2, 0xff56bd19, 0x0d3d3e1a, 0x1e6dcdee, 0xec064eed,
   53|       |    0xc38d26c4, 0x31e6a5c7, 0x22b65633, 0xd0ddd530, 0x0417b1db, 0xf67c32d8,
   54|       |    0xe52cc12c, 0x1747422f, 0x49547e0b, 0xbb3ffd08, 0xa86f0efc, 0x5a048dff,
   55|       |    0x8ecee914, 0x7ca56a17, 0x6ff599e3, 0x9d9e1ae0, 0xd3d3e1ab, 0x21b862a8,
   56|       |    0x32e8915c, 0xc083125f, 0x144976b4, 0xe622f5b7, 0xf5720643, 0x07198540,
   57|       |    0x590ab964, 0xab613a67, 0xb831c993, 0x4a5a4a90, 0x9e902e7b, 0x6cfbad78,
   58|       |    0x7fab5e8c, 0x8dc0dd8f, 0xe330a81a, 0x115b2b19, 0x020bd8ed, 0xf0605bee,
   59|       |    0x24aa3f05, 0xd6c1bc06, 0xc5914ff2, 0x37faccf1, 0x69e9f0d5, 0x9b8273d6,
   60|       |    0x88d28022, 0x7ab90321, 0xae7367ca, 0x5c18e4c9, 0x4f48173d, 0xbd23943e,
   61|       |    0xf36e6f75, 0x0105ec76, 0x12551f82, 0xe03e9c81, 0x34f4f86a, 0xc69f7b69,
   62|       |    0xd5cf889d, 0x27a40b9e, 0x79b737ba, 0x8bdcb4b9, 0x988c474d, 0x6ae7c44e,
   63|       |    0xbe2da0a5, 0x4c4623a6, 0x5f16d052, 0xad7d5351};
   64|       |
   65|       |const uint32_t kStrideExtensionTable0[256] = {
   66|       |    0x00000000, 0x30d23865, 0x61a470ca, 0x517648af, 0xc348e194, 0xf39ad9f1,
   67|       |    0xa2ec915e, 0x923ea93b, 0x837db5d9, 0xb3af8dbc, 0xe2d9c513, 0xd20bfd76,
   68|       |    0x4035544d, 0x70e76c28, 0x21912487, 0x11431ce2, 0x03171d43, 0x33c52526,
   69|       |    0x62b36d89, 0x526155ec, 0xc05ffcd7, 0xf08dc4b2, 0xa1fb8c1d, 0x9129b478,
   70|       |    0x806aa89a, 0xb0b890ff, 0xe1ced850, 0xd11ce035, 0x4322490e, 0x73f0716b,
   71|       |    0x228639c4, 0x125401a1, 0x062e3a86, 0x36fc02e3, 0x678a4a4c, 0x57587229,
   72|       |    0xc566db12, 0xf5b4e377, 0xa4c2abd8, 0x941093bd, 0x85538f5f, 0xb581b73a,
   73|       |    0xe4f7ff95, 0xd425c7f0, 0x461b6ecb, 0x76c956ae, 0x27bf1e01, 0x176d2664,
   74|       |    0x053927c5, 0x35eb1fa0, 0x649d570f, 0x544f6f6a, 0xc671c651, 0xf6a3fe34,
   75|       |    0xa7d5b69b, 0x97078efe, 0x8644921c, 0xb696aa79, 0xe7e0e2d6, 0xd732dab3,
   76|       |    0x450c7388, 0x75de4bed, 0x24a80342, 0x147a3b27, 0x0c5c750c, 0x3c8e4d69,
   77|       |    0x6df805c6, 0x5d2a3da3, 0xcf149498, 0xffc6acfd, 0xaeb0e452, 0x9e62dc37,
   78|       |    0x8f21c0d5, 0xbff3f8b0, 0xee85b01f, 0xde57887a, 0x4c692141, 0x7cbb1924,
   79|       |    0x2dcd518b, 0x1d1f69ee, 0x0f4b684f, 0x3f99502a, 0x6eef1885, 0x5e3d20e0,
   80|       |    0xcc0389db, 0xfcd1b1be, 0xada7f911, 0x9d75c174, 0x8c36dd96, 0xbce4e5f3,
   81|       |    0xed92ad5c, 0xdd409539, 0x4f7e3c02, 0x7fac0467, 0x2eda4cc8, 0x1e0874ad,
   82|       |    0x0a724f8a, 0x3aa077ef, 0x6bd63f40, 0x5b040725, 0xc93aae1e, 0xf9e8967b,
   83|       |    0xa89eded4, 0x984ce6b1, 0x890ffa53, 0xb9ddc236, 0xe8ab8a99, 0xd879b2fc,
   84|       |    0x4a471bc7, 0x7a9523a2, 0x2be36b0d, 0x1b315368, 0x096552c9, 0x39b76aac,
   85|       |    0x68c12203, 0x58131a66, 0xca2db35d, 0xfaff8b38, 0xab89c397, 0x9b5bfbf2,
   86|       |    0x8a18e710, 0xbacadf75, 0xebbc97da, 0xdb6eafbf, 0x49500684, 0x79823ee1,
   87|       |    0x28f4764e, 0x18264e2b, 0x18b8ea18, 0x286ad27d, 0x791c9ad2, 0x49cea2b7,
   88|       |    0xdbf00b8c, 0xeb2233e9, 0xba547b46, 0x8a864323, 0x9bc55fc1, 0xab1767a4,
   89|       |    0xfa612f0b, 0xcab3176e, 0x588dbe55, 0x685f8630, 0x3929ce9f, 0x09fbf6fa,
   90|       |    0x1baff75b, 0x2b7dcf3e, 0x7a0b8791, 0x4ad9bff4, 0xd8e716cf, 0xe8352eaa,
   91|       |    0xb9436605, 0x89915e60, 0x98d24282, 0xa8007ae7, 0xf9763248, 0xc9a40a2d,
   92|       |    0x5b9aa316, 0x6b489b73, 0x3a3ed3dc, 0x0aecebb9, 0x1e96d09e, 0x2e44e8fb,
   93|       |    0x7f32a054, 0x4fe09831, 0xddde310a, 0xed0c096f, 0xbc7a41c0, 0x8ca879a5,
   94|       |    0x9deb6547, 0xad395d22, 0xfc4f158d, 0xcc9d2de8, 0x5ea384d3, 0x6e71bcb6,
   95|       |    0x3f07f419, 0x0fd5cc7c, 0x1d81cddd, 0x2d53f5b8, 0x7c25bd17, 0x4cf78572,
   96|       |    0xdec92c49, 0xee1b142c, 0xbf6d5c83, 0x8fbf64e6, 0x9efc7804, 0xae2e4061,
   97|       |    0xff5808ce, 0xcf8a30ab, 0x5db49990, 0x6d66a1f5, 0x3c10e95a, 0x0cc2d13f,
   98|       |    0x14e49f14, 0x2436a771, 0x7540efde, 0x4592d7bb, 0xd7ac7e80, 0xe77e46e5,
   99|       |    0xb6080e4a, 0x86da362f, 0x97992acd, 0xa74b12a8, 0xf63d5a07, 0xc6ef6262,
  100|       |    0x54d1cb59, 0x6403f33c, 0x3575bb93, 0x05a783f6, 0x17f38257, 0x2721ba32,
  101|       |    0x7657f29d, 0x4685caf8, 0xd4bb63c3, 0xe4695ba6, 0xb51f1309, 0x85cd2b6c,
  102|       |    0x948e378e, 0xa45c0feb, 0xf52a4744, 0xc5f87f21, 0x57c6d61a, 0x6714ee7f,
  103|       |    0x3662a6d0, 0x06b09eb5, 0x12caa592, 0x22189df7, 0x736ed558, 0x43bced3d,
  104|       |    0xd1824406, 0xe1507c63, 0xb02634cc, 0x80f40ca9, 0x91b7104b, 0xa165282e,
  105|       |    0xf0136081, 0xc0c158e4, 0x52fff1df, 0x622dc9ba, 0x335b8115, 0x0389b970,
  106|       |    0x11ddb8d1, 0x210f80b4, 0x7079c81b, 0x40abf07e, 0xd2955945, 0xe2476120,
  107|       |    0xb331298f, 0x83e311ea, 0x92a00d08, 0xa272356d, 0xf3047dc2, 0xc3d645a7,
  108|       |    0x51e8ec9c, 0x613ad4f9, 0x304c9c56, 0x009ea433};
  109|       |
  110|       |const uint32_t kStrideExtensionTable1[256] = {
  111|       |    0x00000000, 0x54075546, 0xa80eaa8c, 0xfc09ffca, 0x55f123e9, 0x01f676af,
  112|       |    0xfdff8965, 0xa9f8dc23, 0xabe247d2, 0xffe51294, 0x03eced5e, 0x57ebb818,
  113|       |    0xfe13643b, 0xaa14317d, 0x561dceb7, 0x021a9bf1, 0x5228f955, 0x062fac13,
  114|       |    0xfa2653d9, 0xae21069f, 0x07d9dabc, 0x53de8ffa, 0xafd77030, 0xfbd02576,
  115|       |    0xf9cabe87, 0xadcdebc1, 0x51c4140b, 0x05c3414d, 0xac3b9d6e, 0xf83cc828,
  116|       |    0x043537e2, 0x503262a4, 0xa451f2aa, 0xf056a7ec, 0x0c5f5826, 0x58580d60,
  117|       |    0xf1a0d143, 0xa5a78405, 0x59ae7bcf, 0x0da92e89, 0x0fb3b578, 0x5bb4e03e,
  118|       |    0xa7bd1ff4, 0xf3ba4ab2, 0x5a429691, 0x0e45c3d7, 0xf24c3c1d, 0xa64b695b,
  119|       |    0xf6790bff, 0xa27e5eb9, 0x5e77a173, 0x0a70f435, 0xa3882816, 0xf78f7d50,
  120|       |    0x0b86829a, 0x5f81d7dc, 0x5d9b4c2d, 0x099c196b, 0xf595e6a1, 0xa192b3e7,
  121|       |    0x086a6fc4, 0x5c6d3a82, 0xa064c548, 0xf463900e, 0x4d4f93a5, 0x1948c6e3,
  122|       |    0xe5413929, 0xb1466c6f, 0x18beb04c, 0x4cb9e50a, 0xb0b01ac0, 0xe4b74f86,
  123|       |    0xe6add477, 0xb2aa8131, 0x4ea37efb, 0x1aa42bbd, 0xb35cf79e, 0xe75ba2d8,
  124|       |    0x1b525d12, 0x4f550854, 0x1f676af0, 0x4b603fb6, 0xb769c07c, 0xe36e953a,
  125|       |    0x4a964919, 0x1e911c5f, 0xe298e395, 0xb69fb6d3, 0xb4852d22, 0xe0827864,
  126|       |    0x1c8b87ae, 0x488cd2e8, 0xe1740ecb, 0xb5735b8d, 0x497aa447, 0x1d7df101,
  127|       |    0xe91e610f, 0xbd193449, 0x4110cb83, 0x15179ec5, 0xbcef42e6, 0xe8e817a0,
  128|       |    0x14e1e86a, 0x40e6bd2c, 0x42fc26dd, 0x16fb739b, 0xeaf28c51, 0xbef5d917,
  129|       |    0x170d0534, 0x430a5072, 0xbf03afb8, 0xeb04fafe, 0xbb36985a, 0xef31cd1c,
  130|       |    0x133832d6, 0x473f6790, 0xeec7bbb3, 0xbac0eef5, 0x46c9113f, 0x12ce4479,
  131|       |    0x10d4df88, 0x44d38ace, 0xb8da7504, 0xecdd2042, 0x4525fc61, 0x1122a927,
  132|       |    0xed2b56ed, 0xb92c03ab, 0x9a9f274a, 0xce98720c, 0x32918dc6, 0x6696d880,
  133|       |    0xcf6e04a3, 0x9b6951e5, 0x6760ae2f, 0x3367fb69, 0x317d6098, 0x657a35de,
  134|       |    0x9973ca14, 0xcd749f52, 0x648c4371, 0x308b1637, 0xcc82e9fd, 0x9885bcbb,
  135|       |    0xc8b7de1f, 0x9cb08b59, 0x60b97493, 0x34be21d5, 0x9d46fdf6, 0xc941a8b0,
  136|       |    0x3548577a, 0x614f023c, 0x635599cd, 0x3752cc8b, 0xcb5b3341, 0x9f5c6607,
  137|       |    0x36a4ba24, 0x62a3ef62, 0x9eaa10a8, 0xcaad45ee, 0x3eced5e0, 0x6ac980a6,
  138|       |    0x96c07f6c, 0xc2c72a2a, 0x6b3ff609, 0x3f38a34f, 0xc3315c85, 0x973609c3,
  139|       |    0x952c9232, 0xc12bc774, 0x3d2238be, 0x69256df8, 0xc0ddb1db, 0x94dae49d,
  140|       |    0x68d31b57, 0x3cd44e11, 0x6ce62cb5, 0x38e179f3, 0xc4e88639, 0x90efd37f,
  141|       |    0x39170f5c, 0x6d105a1a, 0x9119a5d0, 0xc51ef096, 0xc7046b67, 0x93033e21,
  142|       |    0x6f0ac1eb, 0x3b0d94ad, 0x92f5488e, 0xc6f21dc8, 0x3afbe202, 0x6efcb744,
  143|       |    0xd7d0b4ef, 0x83d7e1a9, 0x7fde1e63, 0x2bd94b25, 0x82219706, 0xd626c240,
  144|       |    0x2a2f3d8a, 0x7e2868cc, 0x7c32f33d, 0x2835a67b, 0xd43c59b1, 0x803b0cf7,
  145|       |    0x29c3d0d4, 0x7dc48592, 0x81cd7a58, 0xd5ca2f1e, 0x85f84dba, 0xd1ff18fc,
  146|       |    0x2df6e736, 0x79f1b270, 0xd0096e53, 0x840e3b15, 0x7807c4df, 0x2c009199,
  147|       |    0x2e1a0a68, 0x7a1d5f2e, 0x8614a0e4, 0xd213f5a2, 0x7beb2981, 0x2fec7cc7,
  148|       |    0xd3e5830d, 0x87e2d64b, 0x73814645, 0x27861303, 0xdb8fecc9, 0x8f88b98f,
  149|       |    0x267065ac, 0x727730ea, 0x8e7ecf20, 0xda799a66, 0xd8630197, 0x8c6454d1,
  150|       |    0x706dab1b, 0x246afe5d, 0x8d92227e, 0xd9957738, 0x259c88f2, 0x719bddb4,
  151|       |    0x21a9bf10, 0x75aeea56, 0x89a7159c, 0xdda040da, 0x74589cf9, 0x205fc9bf,
  152|       |    0xdc563675, 0x88516333, 0x8a4bf8c2, 0xde4cad84, 0x2245524e, 0x76420708,
  153|       |    0xdfbadb2b, 0x8bbd8e6d, 0x77b471a7, 0x23b324e1};
  154|       |
  155|       |const uint32_t kStrideExtensionTable2[256] = {
  156|       |    0x00000000, 0x678efd01, 0xcf1dfa02, 0xa8930703, 0x9bd782f5, 0xfc597ff4,
  157|       |    0x54ca78f7, 0x334485f6, 0x3243731b, 0x55cd8e1a, 0xfd5e8919, 0x9ad07418,
  158|       |    0xa994f1ee, 0xce1a0cef, 0x66890bec, 0x0107f6ed, 0x6486e636, 0x03081b37,
  159|       |    0xab9b1c34, 0xcc15e135, 0xff5164c3, 0x98df99c2, 0x304c9ec1, 0x57c263c0,
  160|       |    0x56c5952d, 0x314b682c, 0x99d86f2f, 0xfe56922e, 0xcd1217d8, 0xaa9cead9,
  161|       |    0x020fedda, 0x658110db, 0xc90dcc6c, 0xae83316d, 0x0610366e, 0x619ecb6f,
  162|       |    0x52da4e99, 0x3554b398, 0x9dc7b49b, 0xfa49499a, 0xfb4ebf77, 0x9cc04276,
  163|       |    0x34534575, 0x53ddb874, 0x60993d82, 0x0717c083, 0xaf84c780, 0xc80a3a81,
  164|       |    0xad8b2a5a, 0xca05d75b, 0x6296d058, 0x05182d59, 0x365ca8af, 0x51d255ae,
  165|       |    0xf94152ad, 0x9ecfafac, 0x9fc85941, 0xf846a440, 0x50d5a343, 0x375b5e42,
  166|       |    0x041fdbb4, 0x639126b5, 0xcb0221b6, 0xac8cdcb7, 0x97f7ee29, 0xf0791328,
  167|       |    0x58ea142b, 0x3f64e92a, 0x0c206cdc, 0x6bae91dd, 0xc33d96de, 0xa4b36bdf,
  168|       |    0xa5b49d32, 0xc23a6033, 0x6aa96730, 0x0d279a31, 0x3e631fc7, 0x59ede2c6,
  169|       |    0xf17ee5c5, 0x96f018c4, 0xf371081f, 0x94fff51e, 0x3c6cf21d, 0x5be20f1c,
  170|       |    0x68a68aea, 0x0f2877eb, 0xa7bb70e8, 0xc0358de9, 0xc1327b04, 0xa6bc8605,
  171|       |    0x0e2f8106, 0x69a17c07, 0x5ae5f9f1, 0x3d6b04f0, 0x95f803f3, 0xf276fef2,
  172|       |    0x5efa2245, 0x3974df44, 0x91e7d847, 0xf6692546, 0xc52da0b0, 0xa2a35db1,
  173|       |    0x0a305ab2, 0x6dbea7b3, 0x6cb9515e, 0x0b37ac5f, 0xa3a4ab5c, 0xc42a565d,
  174|       |    0xf76ed3ab, 0x90e02eaa, 0x387329a9, 0x5ffdd4a8, 0x3a7cc473, 0x5df23972,
  175|       |    0xf5613e71, 0x92efc370, 0xa1ab4686, 0xc625bb87, 0x6eb6bc84, 0x09384185,
  176|       |    0x083fb768, 0x6fb14a69, 0xc7224d6a, 0xa0acb06b, 0x93e8359d, 0xf466c89c,
  177|       |    0x5cf5cf9f, 0x3b7b329e, 0x2a03aaa3, 0x4d8d57a2, 0xe51e50a1, 0x8290ada0,
  178|       |    0xb1d42856, 0xd65ad557, 0x7ec9d254, 0x19472f55, 0x1840d9b8, 0x7fce24b9,
  179|       |    0xd75d23ba, 0xb0d3debb, 0x83975b4d, 0xe419a64c, 0x4c8aa14f, 0x2b045c4e,
  180|       |    0x4e854c95, 0x290bb194, 0x8198b697, 0xe6164b96, 0xd552ce60, 0xb2dc3361,
  181|       |    0x1a4f3462, 0x7dc1c963, 0x7cc63f8e, 0x1b48c28f, 0xb3dbc58c, 0xd455388d,
  182|       |    0xe711bd7b, 0x809f407a, 0x280c4779, 0x4f82ba78, 0xe30e66cf, 0x84809bce,
  183|       |    0x2c139ccd, 0x4b9d61cc, 0x78d9e43a, 0x1f57193b, 0xb7c41e38, 0xd04ae339,
  184|       |    0xd14d15d4, 0xb6c3e8d5, 0x1e50efd6, 0x79de12d7, 0x4a9a9721, 0x2d146a20,
  185|       |    0x85876d23, 0xe2099022, 0x878880f9, 0xe0067df8, 0x48957afb, 0x2f1b87fa,
  186|       |    0x1c5f020c, 0x7bd1ff0d, 0xd342f80e, 0xb4cc050f, 0xb5cbf3e2, 0xd2450ee3,
  187|       |    0x7ad609e0, 0x1d58f4e1, 0x2e1c7117, 0x49928c16, 0xe1018b15, 0x868f7614,
  188|       |    0xbdf4448a, 0xda7ab98b, 0x72e9be88, 0x15674389, 0x2623c67f, 0x41ad3b7e,
  189|       |    0xe93e3c7d, 0x8eb0c17c, 0x8fb73791, 0xe839ca90, 0x40aacd93, 0x27243092,
  190|       |    0x1460b564, 0x73ee4865, 0xdb7d4f66, 0xbcf3b267, 0xd972a2bc, 0xbefc5fbd,
  191|       |    0x166f58be, 0x71e1a5bf, 0x42a52049, 0x252bdd48, 0x8db8da4b, 0xea36274a,
  192|       |    0xeb31d1a7, 0x8cbf2ca6, 0x242c2ba5, 0x43a2d6a4, 0x70e65352, 0x1768ae53,
  193|       |    0xbffba950, 0xd8755451, 0x74f988e6, 0x137775e7, 0xbbe472e4, 0xdc6a8fe5,
  194|       |    0xef2e0a13, 0x88a0f712, 0x2033f011, 0x47bd0d10, 0x46bafbfd, 0x213406fc,
  195|       |    0x89a701ff, 0xee29fcfe, 0xdd6d7908, 0xbae38409, 0x1270830a, 0x75fe7e0b,
  196|       |    0x107f6ed0, 0x77f193d1, 0xdf6294d2, 0xb8ec69d3, 0x8ba8ec25, 0xec261124,
  197|       |    0x44b51627, 0x233beb26, 0x223c1dcb, 0x45b2e0ca, 0xed21e7c9, 0x8aaf1ac8,
  198|       |    0xb9eb9f3e, 0xde65623f, 0x76f6653c, 0x1178983d};
  199|       |
  200|       |const uint32_t kStrideExtensionTable3[256] = {
  201|       |    0x00000000, 0xf20c0dfe, 0xe1f46d0d, 0x13f860f3, 0xc604aceb, 0x3408a115,
  202|       |    0x27f0c1e6, 0xd5fccc18, 0x89e52f27, 0x7be922d9, 0x6811422a, 0x9a1d4fd4,
  203|       |    0x4fe183cc, 0xbded8e32, 0xae15eec1, 0x5c19e33f, 0x162628bf, 0xe42a2541,
  204|       |    0xf7d245b2, 0x05de484c, 0xd0228454, 0x222e89aa, 0x31d6e959, 0xc3dae4a7,
  205|       |    0x9fc30798, 0x6dcf0a66, 0x7e376a95, 0x8c3b676b, 0x59c7ab73, 0xabcba68d,
  206|       |    0xb833c67e, 0x4a3fcb80, 0x2c4c517e, 0xde405c80, 0xcdb83c73, 0x3fb4318d,
  207|       |    0xea48fd95, 0x1844f06b, 0x0bbc9098, 0xf9b09d66, 0xa5a97e59, 0x57a573a7,
  208|       |    0x445d1354, 0xb6511eaa, 0x63add2b2, 0x91a1df4c, 0x8259bfbf, 0x7055b241,
  209|       |    0x3a6a79c1, 0xc866743f, 0xdb9e14cc, 0x29921932, 0xfc6ed52a, 0x0e62d8d4,
  210|       |    0x1d9ab827, 0xef96b5d9, 0xb38f56e6, 0x41835b18, 0x527b3beb, 0xa0773615,
  211|       |    0x758bfa0d, 0x8787f7f3, 0x947f9700, 0x66739afe, 0x5898a2fc, 0xaa94af02,
  212|       |    0xb96ccff1, 0x4b60c20f, 0x9e9c0e17, 0x6c9003e9, 0x7f68631a, 0x8d646ee4,
  213|       |    0xd17d8ddb, 0x23718025, 0x3089e0d6, 0xc285ed28, 0x17792130, 0xe5752cce,
  214|       |    0xf68d4c3d, 0x048141c3, 0x4ebe8a43, 0xbcb287bd, 0xaf4ae74e, 0x5d46eab0,
  215|       |    0x88ba26a8, 0x7ab62b56, 0x694e4ba5, 0x9b42465b, 0xc75ba564, 0x3557a89a,
  216|       |    0x26afc869, 0xd4a3c597, 0x015f098f, 0xf3530471, 0xe0ab6482, 0x12a7697c,
  217|       |    0x74d4f382, 0x86d8fe7c, 0x95209e8f, 0x672c9371, 0xb2d05f69, 0x40dc5297,
  218|       |    0x53243264, 0xa1283f9a, 0xfd31dca5, 0x0f3dd15b, 0x1cc5b1a8, 0xeec9bc56,
  219|       |    0x3b35704e, 0xc9397db0, 0xdac11d43, 0x28cd10bd, 0x62f2db3d, 0x90fed6c3,
  220|       |    0x8306b630, 0x710abbce, 0xa4f677d6, 0x56fa7a28, 0x45021adb, 0xb70e1725,
  221|       |    0xeb17f41a, 0x191bf9e4, 0x0ae39917, 0xf8ef94e9, 0x2d1358f1, 0xdf1f550f,
  222|       |    0xcce735fc, 0x3eeb3802, 0xb13145f8, 0x433d4806, 0x50c528f5, 0xa2c9250b,
  223|       |    0x7735e913, 0x8539e4ed, 0x96c1841e, 0x64cd89e0, 0x38d46adf, 0xcad86721,
  224|       |    0xd92007d2, 0x2b2c0a2c, 0xfed0c634, 0x0cdccbca, 0x1f24ab39, 0xed28a6c7,
  225|       |    0xa7176d47, 0x551b60b9, 0x46e3004a, 0xb4ef0db4, 0x6113c1ac, 0x931fcc52,
  226|       |    0x80e7aca1, 0x72eba15f, 0x2ef24260, 0xdcfe4f9e, 0xcf062f6d, 0x3d0a2293,
  227|       |    0xe8f6ee8b, 0x1afae375, 0x09028386, 0xfb0e8e78, 0x9d7d1486, 0x6f711978,
  228|       |    0x7c89798b, 0x8e857475, 0x5b79b86d, 0xa975b593, 0xba8dd560, 0x4881d89e,
  229|       |    0x14983ba1, 0xe694365f, 0xf56c56ac, 0x07605b52, 0xd29c974a, 0x20909ab4,
  230|       |    0x3368fa47, 0xc164f7b9, 0x8b5b3c39, 0x795731c7, 0x6aaf5134, 0x98a35cca,
  231|       |    0x4d5f90d2, 0xbf539d2c, 0xacabfddf, 0x5ea7f021, 0x02be131e, 0xf0b21ee0,
  232|       |    0xe34a7e13, 0x114673ed, 0xc4babff5, 0x36b6b20b, 0x254ed2f8, 0xd742df06,
  233|       |    0xe9a9e704, 0x1ba5eafa, 0x085d8a09, 0xfa5187f7, 0x2fad4bef, 0xdda14611,
  234|       |    0xce5926e2, 0x3c552b1c, 0x604cc823, 0x9240c5dd, 0x81b8a52e, 0x73b4a8d0,
  235|       |    0xa64864c8, 0x54446936, 0x47bc09c5, 0xb5b0043b, 0xff8fcfbb, 0x0d83c245,
  236|       |    0x1e7ba2b6, 0xec77af48, 0x398b6350, 0xcb876eae, 0xd87f0e5d, 0x2a7303a3,
  237|       |    0x766ae09c, 0x8466ed62, 0x979e8d91, 0x6592806f, 0xb06e4c77, 0x42624189,
  238|       |    0x519a217a, 0xa3962c84, 0xc5e5b67a, 0x37e9bb84, 0x2411db77, 0xd61dd689,
  239|       |    0x03e11a91, 0xf1ed176f, 0xe215779c, 0x10197a62, 0x4c00995d, 0xbe0c94a3,
  240|       |    0xadf4f450, 0x5ff8f9ae, 0x8a0435b6, 0x78083848, 0x6bf058bb, 0x99fc5545,
  241|       |    0xd3c39ec5, 0x21cf933b, 0x3237f3c8, 0xc03bfe36, 0x15c7322e, 0xe7cb3fd0,
  242|       |    0xf4335f23, 0x063f52dd, 0x5a26b1e2, 0xa82abc1c, 0xbbd2dcef, 0x49ded111,
  243|       |    0x9c221d09, 0x6e2e10f7, 0x7dd67004, 0x8fda7dfa};
  244|       |
  245|       |// CRCs are pre- and post- conditioned by xoring with all ones.
  246|       |static constexpr const uint32_t kCRC32Xor = static_cast<uint32_t>(0xffffffffU);
  247|       |
  248|       |// Reads a little-endian 32-bit integer from a 32-bit-aligned buffer.
  249|      0|inline uint32_t ReadUint32LE(const uint8_t* buffer) {
  250|      0|  return DecodeFixed32(reinterpret_cast<const char*>(buffer));
  251|      0|}
  252|       |
  253|       |// Returns the smallest address >= the given address that is aligned to N bytes.
  254|       |//
  255|       |// N must be a power of two.
  256|       |template <int N>
  257|      0|constexpr inline const uint8_t* RoundUp(const uint8_t* pointer) {
  258|      0|  return reinterpret_cast<uint8_t*>(
  259|      0|      (reinterpret_cast<uintptr_t>(pointer) + (N - 1)) &
  260|      0|      ~static_cast<uintptr_t>(N - 1));
  261|      0|}
  262|       |
  263|       |}  // namespace
  264|       |
  265|       |// Determine if the CPU running this program can accelerate the CRC32C
  266|       |// calculation.
  267|      0|static bool CanAccelerateCRC32C() {
  268|      0|  // port::AcceleretedCRC32C returns zero when unable to accelerate.
  269|      0|  static const char kTestCRCBuffer[] = "TestCRCBuffer";
  270|      0|  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;
  271|      0|  static const uint32_t kTestCRCValue = 0xdcbc59fa;
  272|      0|
  273|      0|  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;
  274|      0|}
  275|       |
  276|      0|uint32_t Extend(uint32_t crc, const char* data, size_t n) {
  277|      0|  static bool accelerate = CanAccelerateCRC32C();
  278|      0|  if (accelerate) {
  279|      0|    return port::AcceleratedCRC32C(crc, data, n);
  280|      0|  }
  281|      0|
  282|      0|  const uint8_t* p = reinterpret_cast<const uint8_t*>(data);
  283|      0|  const uint8_t* e = p + n;
  284|      0|  uint32_t l = crc ^ kCRC32Xor;
  285|      0|
  286|      0|// Process one byte at a time.
  287|      0|#define STEP1                              \
  288|      0|  do {                                     \
  289|      0|    int c = (l & 0xff) ^ *p++;             \
  290|      0|    l = kByteExtensionTable[c] ^ (l >> 8); \
  291|      0|  } while (0)
  292|      0|
  293|      0|// Process one of the 4 strides of 4-byte data.
  294|      0|#define STEP4(s)                                                               \
  295|      0|  do {                                                                         \
  296|      0|    crc##s = ReadUint32LE(p + s * 4) ^ kStrideExtensionTable3[crc##s & 0xff] ^ \
  297|      0|             kStrideExtensionTable2[(crc##s >> 8) & 0xff] ^                    \
  298|      0|             kStrideExtensionTable1[(crc##s >> 16) & 0xff] ^                   \
  299|      0|             kStrideExtensionTable0[crc##s >> 24];                             \
  300|      0|  } while (0)
  301|      0|
  302|      0|// Process a 16-byte swath of 4 strides, each of which has 4 bytes of data.
  303|      0|#define STEP16 \
  304|      0|  do {         \
  305|      0|    STEP4(0);  \
  306|      0|    STEP4(1);  \
  307|      0|    STEP4(2);  \
  308|      0|    STEP4(3);  \
  309|      0|    p += 16;   \
  310|      0|  } while (0)
  311|      0|
  312|      0|// Process 4 bytes that were already loaded into a word.
  313|      0|#define STEP4W(w)                                   \
  314|      0|  do {                                              \
  315|      0|    w ^= l;                                         \
  316|      0|    for (size_t i = 0; i < 4; ++i) {                \
  317|      0|      w = (w >> 8) ^ kByteExtensionTable[w & 0xff]; \
  318|      0|    }                                               \
  319|      0|    l = w;                                          \
  320|      0|  } while (0)
  321|      0|
  322|      0|  // Point x at first 4-byte aligned byte in the buffer. This might be past the
  323|      0|  // end of the buffer.
  324|      0|  const uint8_t* x = RoundUp<4>(p);
  325|      0|  if (x <= e) {
  326|      0|    // Process bytes p is 4-byte aligned.
  327|      0|    while (p != x) {
  328|      0|      STEP1;
  329|      0|    }
  330|      0|  }
  331|      0|
  332|      0|  if ((e - p) >= 16) {
  333|      0|    // Load a 16-byte swath into the stride partial results.
  334|      0|    uint32_t crc0 = ReadUint32LE(p + 0 * 4) ^ l;
  335|      0|    uint32_t crc1 = ReadUint32LE(p + 1 * 4);
  336|      0|    uint32_t crc2 = ReadUint32LE(p + 2 * 4);
  337|      0|    uint32_t crc3 = ReadUint32LE(p + 3 * 4);
  338|      0|    p += 16;
  339|      0|
  340|      0|    // It is possible to get better speeds (at least on x86) by interleaving
  341|      0|    // prefetching 256 bytes ahead with processing 64 bytes at a time. See the
  342|      0|    // portable implementation in https://github.com/google/crc32c/.
  343|      0|
  344|      0|    // Process one 16-byte swath at a time.
  345|      0|    while ((e - p) >= 16) {
  346|      0|      STEP16;
  347|      0|    }
  348|      0|
  349|      0|    // Advance one word at a time as far as possible.
  350|      0|    while ((e - p) >= 4) {
  351|      0|      STEP4(0);
  352|      0|      uint32_t tmp = crc0;
  353|      0|      crc0 = crc1;
  354|      0|      crc1 = crc2;
  355|      0|      crc2 = crc3;
  356|      0|      crc3 = tmp;
  357|      0|      p += 4;
  358|      0|    }
  359|      0|
  360|      0|    // Combine the 4 partial stride results.
  361|      0|    l = 0;
  362|      0|    STEP4W(crc0);
  363|      0|    STEP4W(crc1);
  364|      0|    STEP4W(crc2);
  365|      0|    STEP4W(crc3);
  366|      0|  }
  367|      0|
  368|      0|  // Process the last few bytes.
  369|      0|  while (p != e) {
  370|      0|    STEP1;
  371|      0|  }
  372|      0|#undef STEP4W
  373|      0|#undef STEP16
  374|      0|#undef STEP4
  375|      0|#undef STEP1
  376|      0|  return l ^ kCRC32Xor;
  377|      0|}
  378|       |
  379|       |}  // namespace crc32c
  380|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/crc32c.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_UTIL_CRC32C_H_
    6|       |#define STORAGE_LEVELDB_UTIL_CRC32C_H_
    7|       |
    8|       |#include <stddef.h>
    9|       |#include <stdint.h>
   10|       |
   11|       |namespace leveldb {
   12|       |namespace crc32c {
   13|       |
   14|       |// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the
   15|       |// crc32c of some string A.  Extend() is often used to maintain the
   16|       |// crc32c of a stream of data.
   17|       |uint32_t Extend(uint32_t init_crc, const char* data, size_t n);
   18|       |
   19|       |// Return the crc32c of data[0,n-1]
   20|      0|inline uint32_t Value(const char* data, size_t n) { return Extend(0, data, n); }
   21|       |
   22|       |static const uint32_t kMaskDelta = 0xa282ead8ul;
   23|       |
   24|       |// Return a masked representation of crc.
   25|       |//
   26|       |// Motivation: it is problematic to compute the CRC of a string that
   27|       |// contains embedded CRCs.  Therefore we recommend that CRCs stored
   28|       |// somewhere (e.g., in files) should be masked before being stored.
   29|      0|inline uint32_t Mask(uint32_t crc) {
   30|      0|  // Rotate right by 15 bits and add a constant.
   31|      0|  return ((crc >> 15) | (crc << 17)) + kMaskDelta;
   32|      0|}
   33|       |
   34|       |// Return the crc whose masked representation is masked_crc.
   35|      0|inline uint32_t Unmask(uint32_t masked_crc) {
   36|      0|  uint32_t rot = masked_crc - kMaskDelta;
   37|      0|  return ((rot >> 17) | (rot << 15));
   38|      0|}
   39|       |
   40|       |}  // namespace crc32c
   41|       |}  // namespace leveldb
   42|       |
   43|       |#endif  // STORAGE_LEVELDB_UTIL_CRC32C_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/env.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/env.h"
    6|       |
    7|       |namespace leveldb {
    8|       |
    9|      0|Env::~Env() {}
   10|       |
   11|      0|Status Env::NewAppendableFile(const std::string& fname, WritableFile** result) {
   12|      0|  return Status::NotSupported("NewAppendableFile", fname);
   13|      0|}
   14|       |
   15|      0|SequentialFile::~SequentialFile() {}
   16|       |
   17|      0|RandomAccessFile::~RandomAccessFile() {}
   18|       |
   19|      0|WritableFile::~WritableFile() {}
   20|       |
   21|      0|Logger::~Logger() {}
   22|       |
   23|      0|FileLock::~FileLock() {}
   24|       |
   25|      0|void Log(Logger* info_log, const char* format, ...) {
   26|      0|  if (info_log != nullptr) {
   27|      0|    va_list ap;
   28|      0|    va_start(ap, format);
   29|      0|    info_log->Logv(format, ap);
   30|      0|    va_end(ap);
   31|      0|  }
   32|      0|}
   33|       |
   34|       |static Status DoWriteStringToFile(Env* env, const Slice& data,
   35|      0|                                  const std::string& fname, bool should_sync) {
   36|      0|  WritableFile* file;
   37|      0|  Status s = env->NewWritableFile(fname, &file);
   38|      0|  if (!s.ok()) {
   39|      0|    return s;
   40|      0|  }
   41|      0|  s = file->Append(data);
   42|      0|  if (s.ok() && should_sync) {
   43|      0|    s = file->Sync();
   44|      0|  }
   45|      0|  if (s.ok()) {
   46|      0|    s = file->Close();
   47|      0|  }
   48|      0|  delete file;  // Will auto-close if we did not close above
   49|      0|  if (!s.ok()) {
   50|      0|    env->DeleteFile(fname);
   51|      0|  }
   52|      0|  return s;
   53|      0|}
   54|       |
   55|       |Status WriteStringToFile(Env* env, const Slice& data,
   56|      0|                         const std::string& fname) {
   57|      0|  return DoWriteStringToFile(env, data, fname, false);
   58|      0|}
   59|       |
   60|       |Status WriteStringToFileSync(Env* env, const Slice& data,
   61|      0|                             const std::string& fname) {
   62|      0|  return DoWriteStringToFile(env, data, fname, true);
   63|      0|}
   64|       |
   65|      0|Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {
   66|      0|  data->clear();
   67|      0|  SequentialFile* file;
   68|      0|  Status s = env->NewSequentialFile(fname, &file);
   69|      0|  if (!s.ok()) {
   70|      0|    return s;
   71|      0|  }
   72|      0|  static const int kBufferSize = 8192;
   73|      0|  char* space = new char[kBufferSize];
   74|      0|  while (true) {
   75|      0|    Slice fragment;
   76|      0|    s = file->Read(kBufferSize, &fragment, space);
   77|      0|    if (!s.ok()) {
   78|      0|      break;
   79|      0|    }
   80|      0|    data->append(fragment.data(), fragment.size());
   81|      0|    if (fragment.empty()) {
   82|      0|      break;
   83|      0|    }
   84|      0|  }
   85|      0|  delete[] space;
   86|      0|  delete file;
   87|      0|  return s;
   88|      0|}
   89|       |
   90|      0|EnvWrapper::~EnvWrapper() {}
   91|       |
   92|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/env_posix.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include <dirent.h>
    6|       |#include <fcntl.h>
    7|       |#include <pthread.h>
    8|       |#include <sys/mman.h>
    9|       |#include <sys/resource.h>
   10|       |#include <sys/stat.h>
   11|       |#include <sys/time.h>
   12|       |#include <sys/types.h>
   13|       |#include <unistd.h>
   14|       |
   15|       |#include <atomic>
   16|       |#include <cerrno>
   17|       |#include <cstddef>
   18|       |#include <cstdint>
   19|       |#include <cstdio>
   20|       |#include <cstdlib>
   21|       |#include <cstring>
   22|       |#include <limits>
   23|       |#include <queue>
   24|       |#include <set>
   25|       |#include <string>
   26|       |#include <thread>
   27|       |#include <type_traits>
   28|       |#include <utility>
   29|       |
   30|       |#include "leveldb/env.h"
   31|       |#include "leveldb/slice.h"
   32|       |#include "leveldb/status.h"
   33|       |#include "port/port.h"
   34|       |#include "port/thread_annotations.h"
   35|       |#include "util/env_posix_test_helper.h"
   36|       |#include "util/posix_logger.h"
   37|       |
   38|       |namespace leveldb {
   39|       |
   40|       |namespace {
   41|       |
   42|       |// Set by EnvPosixTestHelper::SetReadOnlyMMapLimit() and MaxOpenFiles().
   43|       |int g_open_read_only_file_limit = -1;
   44|       |
   45|       |// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.
   46|       |constexpr const int kDefaultMmapLimit = (sizeof(void*) >= 8) ? 1000 : 0;
   47|       |
   48|       |// Can be set using EnvPosixTestHelper::SetReadOnlyMMapLimit.
   49|       |int g_mmap_limit = kDefaultMmapLimit;
   50|       |
   51|       |constexpr const size_t kWritableFileBufferSize = 65536;
   52|       |
   53|      0|Status PosixError(const std::string& context, int error_number) {
   54|      0|  if (error_number == ENOENT) {
   55|      0|    return Status::NotFound(context, std::strerror(error_number));
   56|      0|  } else {
   57|      0|    return Status::IOError(context, std::strerror(error_number));
   58|      0|  }
   59|      0|}
   60|       |
   61|       |// Helper class to limit resource usage to avoid exhaustion.
   62|       |// Currently used to limit read-only file descriptors and mmap file usage
   63|       |// so that we do not run out of file descriptors or virtual memory, or run into
   64|       |// kernel performance problems for very large databases.
   65|       |class Limiter {
   66|       | public:
   67|       |  // Limit maximum number of resources to |max_acquires|.
   68|      0|  Limiter(int max_acquires) : acquires_allowed_(max_acquires) {}
   69|       |
   70|       |  Limiter(const Limiter&) = delete;
   71|       |  Limiter operator=(const Limiter&) = delete;
   72|       |
   73|       |  // If another resource is available, acquire it and return true.
   74|       |  // Else return false.
   75|      0|  bool Acquire() {
   76|      0|    int old_acquires_allowed =
   77|      0|        acquires_allowed_.fetch_sub(1, std::memory_order_relaxed);
   78|      0|
   79|      0|    if (old_acquires_allowed > 0) return true;
   80|      0|
   81|      0|    acquires_allowed_.fetch_add(1, std::memory_order_relaxed);
   82|      0|    return false;
   83|      0|  }
   84|       |
   85|       |  // Release a resource acquired by a previous call to Acquire() that returned
   86|       |  // true.
   87|      0|  void Release() { acquires_allowed_.fetch_add(1, std::memory_order_relaxed); }
   88|       |
   89|       | private:
   90|       |  // The number of available resources.
   91|       |  //
   92|       |  // This is a counter and is not tied to the invariants of any other class, so
   93|       |  // it can be operated on safely using std::memory_order_relaxed.
   94|       |  std::atomic<int> acquires_allowed_;
   95|       |};
   96|       |
   97|       |// Implements sequential read access in a file using read().
   98|       |//
   99|       |// Instances of this class are thread-friendly but not thread-safe, as required
  100|       |// by the SequentialFile API.
  101|       |class PosixSequentialFile final : public SequentialFile {
  102|       | public:
  103|       |  PosixSequentialFile(std::string filename, int fd)
  104|      0|      : fd_(fd), filename_(filename) {}
  105|      0|  ~PosixSequentialFile() override { close(fd_); }
  106|       |
  107|      0|  Status Read(size_t n, Slice* result, char* scratch) override {
  108|      0|    Status status;
  109|      0|    while (true) {
  110|      0|      ::ssize_t read_size = ::read(fd_, scratch, n);
  111|      0|      if (read_size < 0) {  // Read error.
  112|      0|        if (errno == EINTR) {
  113|      0|          continue;  // Retry
  114|      0|        }
  115|      0|        status = PosixError(filename_, errno);
  116|      0|        break;
  117|      0|      }
  118|      0|      *result = Slice(scratch, read_size);
  119|      0|      break;
  120|      0|    }
  121|      0|    return status;
  122|      0|  }
  123|       |
  124|      0|  Status Skip(uint64_t n) override {
  125|      0|    if (::lseek(fd_, n, SEEK_CUR) == static_cast<off_t>(-1)) {
  126|      0|      return PosixError(filename_, errno);
  127|      0|    }
  128|      0|    return Status::OK();
  129|      0|  }
  130|       |
  131|       | private:
  132|       |  const int fd_;
  133|       |  const std::string filename_;
  134|       |};
  135|       |
  136|       |// Implements random read access in a file using pread().
  137|       |//
  138|       |// Instances of this class are thread-safe, as required by the RandomAccessFile
  139|       |// API. Instances are immutable and Read() only calls thread-safe library
  140|       |// functions.
  141|       |class PosixRandomAccessFile final : public RandomAccessFile {
  142|       | public:
  143|       |  // The new instance takes ownership of |fd|. |fd_limiter| must outlive this
  144|       |  // instance, and will be used to determine if .
  145|       |  PosixRandomAccessFile(std::string filename, int fd, Limiter* fd_limiter)
  146|       |      : has_permanent_fd_(fd_limiter->Acquire()),
  147|       |        fd_(has_permanent_fd_ ? fd : -1),
  148|       |        fd_limiter_(fd_limiter),
  149|      0|        filename_(std::move(filename)) {
  150|      0|    if (!has_permanent_fd_) {
  151|      0|      assert(fd_ == -1);
  152|      0|      ::close(fd);  // The file will be opened on every read.
  153|      0|    }
  154|      0|  }
  155|       |
  156|      0|  ~PosixRandomAccessFile() override {
  157|      0|    if (has_permanent_fd_) {
  158|      0|      assert(fd_ != -1);
  159|      0|      ::close(fd_);
  160|      0|      fd_limiter_->Release();
  161|      0|    }
  162|      0|  }
  163|       |
  164|       |  Status Read(uint64_t offset, size_t n, Slice* result,
  165|      0|              char* scratch) const override {
  166|      0|    int fd = fd_;
  167|      0|    if (!has_permanent_fd_) {
  168|      0|      fd = ::open(filename_.c_str(), O_RDONLY);
  169|      0|      if (fd < 0) {
  170|      0|        return PosixError(filename_, errno);
  171|      0|      }
  172|      0|    }
  173|      0|
  174|      0|    assert(fd != -1);
  175|      0|
  176|      0|    Status status;
  177|      0|    ssize_t read_size = ::pread(fd, scratch, n, static_cast<off_t>(offset));
  178|      0|    *result = Slice(scratch, (read_size < 0) ? 0 : read_size);
  179|      0|    if (read_size < 0) {
  180|      0|      // An error: return a non-ok status.
  181|      0|      status = PosixError(filename_, errno);
  182|      0|    }
  183|      0|    if (!has_permanent_fd_) {
  184|      0|      // Close the temporary file descriptor opened earlier.
  185|      0|      assert(fd != fd_);
  186|      0|      ::close(fd);
  187|      0|    }
  188|      0|    return status;
  189|      0|  }
  190|       |
  191|       | private:
  192|       |  const bool has_permanent_fd_;  // If false, the file is opened on every read.
  193|       |  const int fd_;                 // -1 if has_permanent_fd_ is false.
  194|       |  Limiter* const fd_limiter_;
  195|       |  const std::string filename_;
  196|       |};
  197|       |
  198|       |// Implements random read access in a file using mmap().
  199|       |//
  200|       |// Instances of this class are thread-safe, as required by the RandomAccessFile
  201|       |// API. Instances are immutable and Read() only calls thread-safe library
  202|       |// functions.
  203|       |class PosixMmapReadableFile final : public RandomAccessFile {
  204|       | public:
  205|       |  // mmap_base[0, length-1] points to the memory-mapped contents of the file. It
  206|       |  // must be the result of a successful call to mmap(). This instances takes
  207|       |  // over the ownership of the region.
  208|       |  //
  209|       |  // |mmap_limiter| must outlive this instance. The caller must have already
  210|       |  // aquired the right to use one mmap region, which will be released when this
  211|       |  // instance is destroyed.
  212|       |  PosixMmapReadableFile(std::string filename, char* mmap_base, size_t length,
  213|       |                        Limiter* mmap_limiter)
  214|       |      : mmap_base_(mmap_base),
  215|       |        length_(length),
  216|       |        mmap_limiter_(mmap_limiter),
  217|      0|        filename_(std::move(filename)) {}
  218|       |
  219|      0|  ~PosixMmapReadableFile() override {
  220|      0|    ::munmap(static_cast<void*>(mmap_base_), length_);
  221|      0|    mmap_limiter_->Release();
  222|      0|  }
  223|       |
  224|       |  Status Read(uint64_t offset, size_t n, Slice* result,
  225|      0|              char* scratch) const override {
  226|      0|    if (offset + n > length_) {
  227|      0|      *result = Slice();
  228|      0|      return PosixError(filename_, EINVAL);
  229|      0|    }
  230|      0|
  231|      0|    *result = Slice(mmap_base_ + offset, n);
  232|      0|    return Status::OK();
  233|      0|  }
  234|       |
  235|       | private:
  236|       |  char* const mmap_base_;
  237|       |  const size_t length_;
  238|       |  Limiter* const mmap_limiter_;
  239|       |  const std::string filename_;
  240|       |};
  241|       |
  242|       |class PosixWritableFile final : public WritableFile {
  243|       | public:
  244|       |  PosixWritableFile(std::string filename, int fd)
  245|       |      : pos_(0),
  246|       |        fd_(fd),
  247|       |        is_manifest_(IsManifest(filename)),
  248|       |        filename_(std::move(filename)),
  249|      0|        dirname_(Dirname(filename_)) {}
  250|       |
  251|      0|  ~PosixWritableFile() override {
  252|      0|    if (fd_ >= 0) {
  253|      0|      // Ignoring any potential errors
  254|      0|      Close();
  255|      0|    }
  256|      0|  }
  257|       |
  258|      0|  Status Append(const Slice& data) override {
  259|      0|    size_t write_size = data.size();
  260|      0|    const char* write_data = data.data();
  261|      0|
  262|      0|    // Fit as much as possible into buffer.
  263|      0|    size_t copy_size = std::min(write_size, kWritableFileBufferSize - pos_);
  264|      0|    std::memcpy(buf_ + pos_, write_data, copy_size);
  265|      0|    write_data += copy_size;
  266|      0|    write_size -= copy_size;
  267|      0|    pos_ += copy_size;
  268|      0|    if (write_size == 0) {
  269|      0|      return Status::OK();
  270|      0|    }
  271|      0|
  272|      0|    // Can't fit in buffer, so need to do at least one write.
  273|      0|    Status status = FlushBuffer();
  274|      0|    if (!status.ok()) {
  275|      0|      return status;
  276|      0|    }
  277|      0|
  278|      0|    // Small writes go to buffer, large writes are written directly.
  279|      0|    if (write_size < kWritableFileBufferSize) {
  280|      0|      std::memcpy(buf_, write_data, write_size);
  281|      0|      pos_ = write_size;
  282|      0|      return Status::OK();
  283|      0|    }
  284|      0|    return WriteUnbuffered(write_data, write_size);
  285|      0|  }
  286|       |
  287|      0|  Status Close() override {
  288|      0|    Status status = FlushBuffer();
  289|      0|    const int close_result = ::close(fd_);
  290|      0|    if (close_result < 0 && status.ok()) {
  291|      0|      status = PosixError(filename_, errno);
  292|      0|    }
  293|      0|    fd_ = -1;
  294|      0|    return status;
  295|      0|  }
  296|       |
  297|      0|  Status Flush() override { return FlushBuffer(); }
  298|       |
  299|      0|  Status Sync() override {
  300|      0|    // Ensure new files referred to by the manifest are in the filesystem.
  301|      0|    //
  302|      0|    // This needs to happen before the manifest file is flushed to disk, to
  303|      0|    // avoid crashing in a state where the manifest refers to files that are not
  304|      0|    // yet on disk.
  305|      0|    Status status = SyncDirIfManifest();
  306|      0|    if (!status.ok()) {
  307|      0|      return status;
  308|      0|    }
  309|      0|
  310|      0|    status = FlushBuffer();
  311|      0|    if (!status.ok()) {
  312|      0|      return status;
  313|      0|    }
  314|      0|
  315|      0|    return SyncFd(fd_, filename_);
  316|      0|  }
  317|       |
  318|       | private:
  319|      0|  Status FlushBuffer() {
  320|      0|    Status status = WriteUnbuffered(buf_, pos_);
  321|      0|    pos_ = 0;
  322|      0|    return status;
  323|      0|  }
  324|       |
  325|      0|  Status WriteUnbuffered(const char* data, size_t size) {
  326|      0|    while (size > 0) {
  327|      0|      ssize_t write_result = ::write(fd_, data, size);
  328|      0|      if (write_result < 0) {
  329|      0|        if (errno == EINTR) {
  330|      0|          continue;  // Retry
  331|      0|        }
  332|      0|        return PosixError(filename_, errno);
  333|      0|      }
  334|      0|      data += write_result;
  335|      0|      size -= write_result;
  336|      0|    }
  337|      0|    return Status::OK();
  338|      0|  }
  339|       |
  340|      0|  Status SyncDirIfManifest() {
  341|      0|    Status status;
  342|      0|    if (!is_manifest_) {
  343|      0|      return status;
  344|      0|    }
  345|      0|
  346|      0|    int fd = ::open(dirname_.c_str(), O_RDONLY);
  347|      0|    if (fd < 0) {
  348|      0|      status = PosixError(dirname_, errno);
  349|      0|    } else {
  350|      0|      status = SyncFd(fd, dirname_);
  351|      0|      ::close(fd);
  352|      0|    }
  353|      0|    return status;
  354|      0|  }
  355|       |
  356|       |  // Ensures that all the caches associated with the given file descriptor's
  357|       |  // data are flushed all the way to durable media, and can withstand power
  358|       |  // failures.
  359|       |  //
  360|       |  // The path argument is only used to populate the description string in the
  361|       |  // returned Status if an error occurs.
  362|      0|  static Status SyncFd(int fd, const std::string& fd_path) {
  363|      0|#if HAVE_FULLFSYNC
  364|      0|    // On macOS and iOS, fsync() doesn't guarantee durability past power
  365|      0|    // failures. fcntl(F_FULLFSYNC) is required for that purpose. Some
  366|      0|    // filesystems don't support fcntl(F_FULLFSYNC), and require a fallback to
  367|      0|    // fsync().
  368|      0|    if (::fcntl(fd, F_FULLFSYNC) == 0) {
  369|      0|      return Status::OK();
  370|      0|    }
  371|      0|#endif  // HAVE_FULLFSYNC
  372|      0|
  373|       |#if HAVE_FDATASYNC
  374|       |    bool sync_success = ::fdatasync(fd) == 0;
  375|       |#else
  376|      0|    bool sync_success = ::fsync(fd) == 0;
  377|      0|#endif  // HAVE_FDATASYNC
  378|      0|
  379|      0|    if (sync_success) {
  380|      0|      return Status::OK();
  381|      0|    }
  382|      0|    return PosixError(fd_path, errno);
  383|      0|  }
  384|       |
  385|       |  // Returns the directory name in a path pointing to a file.
  386|       |  //
  387|       |  // Returns "." if the path does not contain any directory separator.
  388|      0|  static std::string Dirname(const std::string& filename) {
  389|      0|    std::string::size_type separator_pos = filename.rfind('/');
  390|      0|    if (separator_pos == std::string::npos) {
  391|      0|      return std::string(".");
  392|      0|    }
  393|      0|    // The filename component should not contain a path separator. If it does,
  394|      0|    // the splitting was done incorrectly.
  395|      0|    assert(filename.find('/', separator_pos + 1) == std::string::npos);
  396|      0|
  397|      0|    return filename.substr(0, separator_pos);
  398|      0|  }
  399|       |
  400|       |  // Extracts the file name from a path pointing to a file.
  401|       |  //
  402|       |  // The returned Slice points to |filename|'s data buffer, so it is only valid
  403|       |  // while |filename| is alive and unchanged.
  404|      0|  static Slice Basename(const std::string& filename) {
  405|      0|    std::string::size_type separator_pos = filename.rfind('/');
  406|      0|    if (separator_pos == std::string::npos) {
  407|      0|      return Slice(filename);
  408|      0|    }
  409|      0|    // The filename component should not contain a path separator. If it does,
  410|      0|    // the splitting was done incorrectly.
  411|      0|    assert(filename.find('/', separator_pos + 1) == std::string::npos);
  412|      0|
  413|      0|    return Slice(filename.data() + separator_pos + 1,
  414|      0|                 filename.length() - separator_pos - 1);
  415|      0|  }
  416|       |
  417|       |  // True if the given file is a manifest file.
  418|      0|  static bool IsManifest(const std::string& filename) {
  419|      0|    return Basename(filename).starts_with("MANIFEST");
  420|      0|  }
  421|       |
  422|       |  // buf_[0, pos_ - 1] contains data to be written to fd_.
  423|       |  char buf_[kWritableFileBufferSize];
  424|       |  size_t pos_;
  425|       |  int fd_;
  426|       |
  427|       |  const bool is_manifest_;  // True if the file's name starts with MANIFEST.
  428|       |  const std::string filename_;
  429|       |  const std::string dirname_;  // The directory of filename_.
  430|       |};
  431|       |
  432|      0|int LockOrUnlock(int fd, bool lock) {
  433|      0|  errno = 0;
  434|      0|  struct ::flock file_lock_info;
  435|      0|  std::memset(&file_lock_info, 0, sizeof(file_lock_info));
  436|      0|  file_lock_info.l_type = (lock ? F_WRLCK : F_UNLCK);
  437|      0|  file_lock_info.l_whence = SEEK_SET;
  438|      0|  file_lock_info.l_start = 0;
  439|      0|  file_lock_info.l_len = 0;  // Lock/unlock entire file.
  440|      0|  return ::fcntl(fd, F_SETLK, &file_lock_info);
  441|      0|}
  442|       |
  443|       |// Instances are thread-safe because they are immutable.
  444|       |class PosixFileLock : public FileLock {
  445|       | public:
  446|       |  PosixFileLock(int fd, std::string filename)
  447|      0|      : fd_(fd), filename_(std::move(filename)) {}
  448|       |
  449|      0|  int fd() const { return fd_; }
  450|      0|  const std::string& filename() const { return filename_; }
  451|       |
  452|       | private:
  453|       |  const int fd_;
  454|       |  const std::string filename_;
  455|       |};
  456|       |
  457|       |// Tracks the files locked by PosixEnv::LockFile().
  458|       |//
  459|       |// We maintain a separate set instead of relying on fcntrl(F_SETLK) because
  460|       |// fcntl(F_SETLK) does not provide any protection against multiple uses from the
  461|       |// same process.
  462|       |//
  463|       |// Instances are thread-safe because all member data is guarded by a mutex.
  464|       |class PosixLockTable {
  465|       | public:
  466|      0|  bool Insert(const std::string& fname) LOCKS_EXCLUDED(mu_) {
  467|      0|    mu_.Lock();
  468|      0|    bool succeeded = locked_files_.insert(fname).second;
  469|      0|    mu_.Unlock();
  470|      0|    return succeeded;
  471|      0|  }
  472|      0|  void Remove(const std::string& fname) LOCKS_EXCLUDED(mu_) {
  473|      0|    mu_.Lock();
  474|      0|    locked_files_.erase(fname);
  475|      0|    mu_.Unlock();
  476|      0|  }
  477|       |
  478|       | private:
  479|       |  port::Mutex mu_;
  480|       |  std::set<std::string> locked_files_ GUARDED_BY(mu_);
  481|       |};
  482|       |
  483|       |class PosixEnv : public Env {
  484|       | public:
  485|       |  PosixEnv();
  486|      0|  ~PosixEnv() override {
  487|      0|    static char msg[] = "PosixEnv singleton destroyed. Unsupported behavior!\n";
  488|      0|    std::fwrite(msg, 1, sizeof(msg), stderr);
  489|      0|    std::abort();
  490|      0|  }
  491|       |
  492|       |  Status NewSequentialFile(const std::string& filename,
  493|      0|                           SequentialFile** result) override {
  494|      0|    int fd = ::open(filename.c_str(), O_RDONLY);
  495|      0|    if (fd < 0) {
  496|      0|      *result = nullptr;
  497|      0|      return PosixError(filename, errno);
  498|      0|    }
  499|      0|
  500|      0|    *result = new PosixSequentialFile(filename, fd);
  501|      0|    return Status::OK();
  502|      0|  }
  503|       |
  504|       |  Status NewRandomAccessFile(const std::string& filename,
  505|      0|                             RandomAccessFile** result) override {
  506|      0|    *result = nullptr;
  507|      0|    int fd = ::open(filename.c_str(), O_RDONLY);
  508|      0|    if (fd < 0) {
  509|      0|      return PosixError(filename, errno);
  510|      0|    }
  511|      0|
  512|      0|    if (!mmap_limiter_.Acquire()) {
  513|      0|      *result = new PosixRandomAccessFile(filename, fd, &fd_limiter_);
  514|      0|      return Status::OK();
  515|      0|    }
  516|      0|
  517|      0|    uint64_t file_size;
  518|      0|    Status status = GetFileSize(filename, &file_size);
  519|      0|    if (status.ok()) {
  520|      0|      void* mmap_base =
  521|      0|          ::mmap(/*addr=*/nullptr, file_size, PROT_READ, MAP_SHARED, fd, 0);
  522|      0|      if (mmap_base != MAP_FAILED) {
  523|      0|        *result = new PosixMmapReadableFile(filename,
  524|      0|                                            reinterpret_cast<char*>(mmap_base),
  525|      0|                                            file_size, &mmap_limiter_);
  526|      0|      } else {
  527|      0|        status = PosixError(filename, errno);
  528|      0|      }
  529|      0|    }
  530|      0|    ::close(fd);
  531|      0|    if (!status.ok()) {
  532|      0|      mmap_limiter_.Release();
  533|      0|    }
  534|      0|    return status;
  535|      0|  }
  536|       |
  537|       |  Status NewWritableFile(const std::string& filename,
  538|      0|                         WritableFile** result) override {
  539|      0|    int fd = ::open(filename.c_str(), O_TRUNC | O_WRONLY | O_CREAT, 0644);
  540|      0|    if (fd < 0) {
  541|      0|      *result = nullptr;
  542|      0|      return PosixError(filename, errno);
  543|      0|    }
  544|      0|
  545|      0|    *result = new PosixWritableFile(filename, fd);
  546|      0|    return Status::OK();
  547|      0|  }
  548|       |
  549|       |  Status NewAppendableFile(const std::string& filename,
  550|      0|                           WritableFile** result) override {
  551|      0|    int fd = ::open(filename.c_str(), O_APPEND | O_WRONLY | O_CREAT, 0644);
  552|      0|    if (fd < 0) {
  553|      0|      *result = nullptr;
  554|      0|      return PosixError(filename, errno);
  555|      0|    }
  556|      0|
  557|      0|    *result = new PosixWritableFile(filename, fd);
  558|      0|    return Status::OK();
  559|      0|  }
  560|       |
  561|      0|  bool FileExists(const std::string& filename) override {
  562|      0|    return ::access(filename.c_str(), F_OK) == 0;
  563|      0|  }
  564|       |
  565|       |  Status GetChildren(const std::string& directory_path,
  566|      0|                     std::vector<std::string>* result) override {
  567|      0|    result->clear();
  568|      0|    ::DIR* dir = ::opendir(directory_path.c_str());
  569|      0|    if (dir == nullptr) {
  570|      0|      return PosixError(directory_path, errno);
  571|      0|    }
  572|      0|    struct ::dirent* entry;
  573|      0|    while ((entry = ::readdir(dir)) != nullptr) {
  574|      0|      result->emplace_back(entry->d_name);
  575|      0|    }
  576|      0|    ::closedir(dir);
  577|      0|    return Status::OK();
  578|      0|  }
  579|       |
  580|      0|  Status DeleteFile(const std::string& filename) override {
  581|      0|    if (::unlink(filename.c_str()) != 0) {
  582|      0|      return PosixError(filename, errno);
  583|      0|    }
  584|      0|    return Status::OK();
  585|      0|  }
  586|       |
  587|      0|  Status CreateDir(const std::string& dirname) override {
  588|      0|    if (::mkdir(dirname.c_str(), 0755) != 0) {
  589|      0|      return PosixError(dirname, errno);
  590|      0|    }
  591|      0|    return Status::OK();
  592|      0|  }
  593|       |
  594|      0|  Status DeleteDir(const std::string& dirname) override {
  595|      0|    if (::rmdir(dirname.c_str()) != 0) {
  596|      0|      return PosixError(dirname, errno);
  597|      0|    }
  598|      0|    return Status::OK();
  599|      0|  }
  600|       |
  601|      0|  Status GetFileSize(const std::string& filename, uint64_t* size) override {
  602|      0|    struct ::stat file_stat;
  603|      0|    if (::stat(filename.c_str(), &file_stat) != 0) {
  604|      0|      *size = 0;
  605|      0|      return PosixError(filename, errno);
  606|      0|    }
  607|      0|    *size = file_stat.st_size;
  608|      0|    return Status::OK();
  609|      0|  }
  610|       |
  611|      0|  Status RenameFile(const std::string& from, const std::string& to) override {
  612|      0|    if (std::rename(from.c_str(), to.c_str()) != 0) {
  613|      0|      return PosixError(from, errno);
  614|      0|    }
  615|      0|    return Status::OK();
  616|      0|  }
  617|       |
  618|      0|  Status LockFile(const std::string& filename, FileLock** lock) override {
  619|      0|    *lock = nullptr;
  620|      0|
  621|      0|    int fd = ::open(filename.c_str(), O_RDWR | O_CREAT, 0644);
  622|      0|    if (fd < 0) {
  623|      0|      return PosixError(filename, errno);
  624|      0|    }
  625|      0|
  626|      0|    if (!locks_.Insert(filename)) {
  627|      0|      ::close(fd);
  628|      0|      return Status::IOError("lock " + filename, "already held by process");
  629|      0|    }
  630|      0|
  631|      0|    if (LockOrUnlock(fd, true) == -1) {
  632|      0|      int lock_errno = errno;
  633|      0|      ::close(fd);
  634|      0|      locks_.Remove(filename);
  635|      0|      return PosixError("lock " + filename, lock_errno);
  636|      0|    }
  637|      0|
  638|      0|    *lock = new PosixFileLock(fd, filename);
  639|      0|    return Status::OK();
  640|      0|  }
  641|       |
  642|      0|  Status UnlockFile(FileLock* lock) override {
  643|      0|    PosixFileLock* posix_file_lock = static_cast<PosixFileLock*>(lock);
  644|      0|    if (LockOrUnlock(posix_file_lock->fd(), false) == -1) {
  645|      0|      return PosixError("unlock " + posix_file_lock->filename(), errno);
  646|      0|    }
  647|      0|    locks_.Remove(posix_file_lock->filename());
  648|      0|    ::close(posix_file_lock->fd());
  649|      0|    delete posix_file_lock;
  650|      0|    return Status::OK();
  651|      0|  }
  652|       |
  653|       |  void Schedule(void (*background_work_function)(void* background_work_arg),
  654|       |                void* background_work_arg) override;
  655|       |
  656|       |  void StartThread(void (*thread_main)(void* thread_main_arg),
  657|       |                   void* thread_main_arg) override;
  658|       |
  659|      0|  Status GetTestDirectory(std::string* result) override {
  660|      0|    const char* env = std::getenv("TEST_TMPDIR");
  661|      0|    if (env && env[0] != '\0') {
  662|      0|      *result = env;
  663|      0|    } else {
  664|      0|      char buf[100];
  665|      0|      std::snprintf(buf, sizeof(buf), "/tmp/leveldbtest-%d",
  666|      0|                    static_cast<int>(::geteuid()));
  667|      0|      *result = buf;
  668|      0|    }
  669|      0|
  670|      0|    // The CreateDir status is ignored because the directory may already exist.
  671|      0|    CreateDir(*result);
  672|      0|
  673|      0|    return Status::OK();
  674|      0|  }
  675|       |
  676|      0|  Status NewLogger(const std::string& filename, Logger** result) override {
  677|      0|    std::FILE* fp = std::fopen(filename.c_str(), "w");
  678|      0|    if (fp == nullptr) {
  679|      0|      *result = nullptr;
  680|      0|      return PosixError(filename, errno);
  681|      0|    } else {
  682|      0|      *result = new PosixLogger(fp);
  683|      0|      return Status::OK();
  684|      0|    }
  685|      0|  }
  686|       |
  687|      0|  uint64_t NowMicros() override {
  688|      0|    static constexpr uint64_t kUsecondsPerSecond = 1000000;
  689|      0|    struct ::timeval tv;
  690|      0|    ::gettimeofday(&tv, nullptr);
  691|      0|    return static_cast<uint64_t>(tv.tv_sec) * kUsecondsPerSecond + tv.tv_usec;
  692|      0|  }
  693|       |
  694|      0|  void SleepForMicroseconds(int micros) override { ::usleep(micros); }
  695|       |
  696|       | private:
  697|       |  void BackgroundThreadMain();
  698|       |
  699|      0|  static void BackgroundThreadEntryPoint(PosixEnv* env) {
  700|      0|    env->BackgroundThreadMain();
  701|      0|  }
  702|       |
  703|       |  // Stores the work item data in a Schedule() call.
  704|       |  //
  705|       |  // Instances are constructed on the thread calling Schedule() and used on the
  706|       |  // background thread.
  707|       |  //
  708|       |  // This structure is thread-safe beacuse it is immutable.
  709|       |  struct BackgroundWorkItem {
  710|       |    explicit BackgroundWorkItem(void (*function)(void* arg), void* arg)
  711|      0|        : function(function), arg(arg) {}
  712|       |
  713|       |    void (*const function)(void*);
  714|       |    void* const arg;
  715|       |  };
  716|       |
  717|       |  port::Mutex background_work_mutex_;
  718|       |  port::CondVar background_work_cv_ GUARDED_BY(background_work_mutex_);
  719|       |  bool started_background_thread_ GUARDED_BY(background_work_mutex_);
  720|       |
  721|       |  std::queue<BackgroundWorkItem> background_work_queue_
  722|       |      GUARDED_BY(background_work_mutex_);
  723|       |
  724|       |  PosixLockTable locks_;  // Thread-safe.
  725|       |  Limiter mmap_limiter_;  // Thread-safe.
  726|       |  Limiter fd_limiter_;    // Thread-safe.
  727|       |};
  728|       |
  729|       |// Return the maximum number of concurrent mmaps.
  730|      0|int MaxMmaps() { return g_mmap_limit; }
  731|       |
  732|       |// Return the maximum number of read-only files to keep open.
  733|      0|int MaxOpenFiles() {
  734|      0|  if (g_open_read_only_file_limit >= 0) {
  735|      0|    return g_open_read_only_file_limit;
  736|      0|  }
  737|      0|  struct ::rlimit rlim;
  738|      0|  if (::getrlimit(RLIMIT_NOFILE, &rlim)) {
  739|      0|    // getrlimit failed, fallback to hard-coded default.
  740|      0|    g_open_read_only_file_limit = 50;
  741|      0|  } else if (rlim.rlim_cur == RLIM_INFINITY) {
  742|      0|    g_open_read_only_file_limit = std::numeric_limits<int>::max();
  743|      0|  } else {
  744|      0|    // Allow use of 20% of available file descriptors for read-only files.
  745|      0|    g_open_read_only_file_limit = rlim.rlim_cur / 5;
  746|      0|  }
  747|      0|  return g_open_read_only_file_limit;
  748|      0|}
  749|       |
  750|       |}  // namespace
  751|       |
  752|       |PosixEnv::PosixEnv()
  753|       |    : background_work_cv_(&background_work_mutex_),
  754|       |      started_background_thread_(false),
  755|       |      mmap_limiter_(MaxMmaps()),
  756|      0|      fd_limiter_(MaxOpenFiles()) {}
  757|       |
  758|       |void PosixEnv::Schedule(
  759|       |    void (*background_work_function)(void* background_work_arg),
  760|      0|    void* background_work_arg) {
  761|      0|  background_work_mutex_.Lock();
  762|      0|
  763|      0|  // Start the background thread, if we haven't done so already.
  764|      0|  if (!started_background_thread_) {
  765|      0|    started_background_thread_ = true;
  766|      0|    std::thread background_thread(PosixEnv::BackgroundThreadEntryPoint, this);
  767|      0|    background_thread.detach();
  768|      0|  }
  769|      0|
  770|      0|  // If the queue is empty, the background thread may be waiting for work.
  771|      0|  if (background_work_queue_.empty()) {
  772|      0|    background_work_cv_.Signal();
  773|      0|  }
  774|      0|
  775|      0|  background_work_queue_.emplace(background_work_function, background_work_arg);
  776|      0|  background_work_mutex_.Unlock();
  777|      0|}
  778|       |
  779|      0|void PosixEnv::BackgroundThreadMain() {
  780|      0|  while (true) {
  781|      0|    background_work_mutex_.Lock();
  782|      0|
  783|      0|    // Wait until there is work to be done.
  784|      0|    while (background_work_queue_.empty()) {
  785|      0|      background_work_cv_.Wait();
  786|      0|    }
  787|      0|
  788|      0|    assert(!background_work_queue_.empty());
  789|      0|    auto background_work_function = background_work_queue_.front().function;
  790|      0|    void* background_work_arg = background_work_queue_.front().arg;
  791|      0|    background_work_queue_.pop();
  792|      0|
  793|      0|    background_work_mutex_.Unlock();
  794|      0|    background_work_function(background_work_arg);
  795|      0|  }
  796|      0|}
  797|       |
  798|       |namespace {
  799|       |
  800|       |// Wraps an Env instance whose destructor is never created.
  801|       |//
  802|       |// Intended usage:
  803|       |//   using PlatformSingletonEnv = SingletonEnv<PlatformEnv>;
  804|       |//   void ConfigurePosixEnv(int param) {
  805|       |//     PlatformSingletonEnv::AssertEnvNotInitialized();
  806|       |//     // set global configuration flags.
  807|       |//   }
  808|       |//   Env* Env::Default() {
  809|       |//     static PlatformSingletonEnv default_env;
  810|       |//     return default_env.env();
  811|       |//   }
  812|       |template <typename EnvType>
  813|       |class SingletonEnv {
  814|       | public:
  815|      0|  SingletonEnv() {
  816|      0|#if !defined(NDEBUG)
  817|      0|    env_initialized_.store(true, std::memory_order::memory_order_relaxed);
  818|      0|#endif  // !defined(NDEBUG)
  819|      0|    static_assert(sizeof(env_storage_) >= sizeof(EnvType),
  820|      0|                  "env_storage_ will not fit the Env");
  821|      0|    static_assert(alignof(decltype(env_storage_)) >= alignof(EnvType),
  822|      0|                  "env_storage_ does not meet the Env's alignment needs");
  823|      0|    new (&env_storage_) EnvType();
  824|      0|  }
  825|       |  ~SingletonEnv() = default;
  826|       |
  827|       |  SingletonEnv(const SingletonEnv&) = delete;
  828|       |  SingletonEnv& operator=(const SingletonEnv&) = delete;
  829|       |
  830|      0|  Env* env() { return reinterpret_cast<Env*>(&env_storage_); }
  831|       |
  832|      0|  static void AssertEnvNotInitialized() {
  833|      0|#if !defined(NDEBUG)
  834|      0|    assert(!env_initialized_.load(std::memory_order::memory_order_relaxed));
  835|      0|#endif  // !defined(NDEBUG)
  836|      0|  }
  837|       |
  838|       | private:
  839|       |  typename std::aligned_storage<sizeof(EnvType), alignof(EnvType)>::type
  840|       |      env_storage_;
  841|       |#if !defined(NDEBUG)
  842|       |  static std::atomic<bool> env_initialized_;
  843|       |#endif  // !defined(NDEBUG)
  844|       |};
  845|       |
  846|       |#if !defined(NDEBUG)
  847|       |template <typename EnvType>
  848|       |std::atomic<bool> SingletonEnv<EnvType>::env_initialized_;
  849|       |#endif  // !defined(NDEBUG)
  850|       |
  851|       |using PosixDefaultEnv = SingletonEnv<PosixEnv>;
  852|       |
  853|       |}  // namespace
  854|       |
  855|       |void PosixEnv::StartThread(void (*thread_main)(void* thread_main_arg),
  856|      0|                           void* thread_main_arg) {
  857|      0|  std::thread new_thread(thread_main, thread_main_arg);
  858|      0|  new_thread.detach();
  859|      0|}
  860|       |
  861|      0|void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {
  862|      0|  PosixDefaultEnv::AssertEnvNotInitialized();
  863|      0|  g_open_read_only_file_limit = limit;
  864|      0|}
  865|       |
  866|      0|void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {
  867|      0|  PosixDefaultEnv::AssertEnvNotInitialized();
  868|      0|  g_mmap_limit = limit;
  869|      0|}
  870|       |
  871|      0|Env* Env::Default() {
  872|      0|  static PosixDefaultEnv env_container;
  873|      0|  return env_container.env();
  874|      0|}
  875|       |
  876|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/filter_policy.cc:
    1|       |// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/filter_policy.h"
    6|       |
    7|       |namespace leveldb {
    8|       |
    9|      0|FilterPolicy::~FilterPolicy() {}
   10|       |
   11|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/hash.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "util/hash.h"
    6|       |
    7|       |#include <string.h>
    8|       |
    9|       |#include "util/coding.h"
   10|       |
   11|       |// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through
   12|       |// between switch labels. The real definition should be provided externally.
   13|       |// This one is a fallback version for unsupported compilers.
   14|       |#ifndef FALLTHROUGH_INTENDED
   15|       |#define FALLTHROUGH_INTENDED \
   16|      0|  do {                       \
   17|      0|  } while (0)
   18|       |#endif
   19|       |
   20|       |namespace leveldb {
   21|       |
   22|      0|uint32_t Hash(const char* data, size_t n, uint32_t seed) {
   23|      0|  // Similar to murmur hash
   24|      0|  const uint32_t m = 0xc6a4a793;
   25|      0|  const uint32_t r = 24;
   26|      0|  const char* limit = data + n;
   27|      0|  uint32_t h = seed ^ (n * m);
   28|      0|
   29|      0|  // Pick up four bytes at a time
   30|      0|  while (data + 4 <= limit) {
   31|      0|    uint32_t w = DecodeFixed32(data);
   32|      0|    data += 4;
   33|      0|    h += w;
   34|      0|    h *= m;
   35|      0|    h ^= (h >> 16);
   36|      0|  }
   37|      0|
   38|      0|  // Pick up remaining bytes
   39|      0|  switch (limit - data) {
   40|      0|    case 3:
   41|      0|      h += static_cast<unsigned char>(data[2]) << 16;
   42|      0|      FALLTHROUGH_INTENDED;
   43|      0|    case 2:
   44|      0|      h += static_cast<unsigned char>(data[1]) << 8;
   45|      0|      FALLTHROUGH_INTENDED;
   46|      0|    case 1:
   47|      0|      h += static_cast<unsigned char>(data[0]);
   48|      0|      h *= m;
   49|      0|      h ^= (h >> r);
   50|      0|      break;
   51|      0|  }
   52|      0|  return h;
   53|      0|}
   54|       |
   55|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/logging.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "util/logging.h"
    6|       |
    7|       |#include <errno.h>
    8|       |#include <stdarg.h>
    9|       |#include <stdio.h>
   10|       |#include <stdlib.h>
   11|       |
   12|       |#include <limits>
   13|       |
   14|       |#include "leveldb/env.h"
   15|       |#include "leveldb/slice.h"
   16|       |
   17|       |namespace leveldb {
   18|       |
   19|      0|void AppendNumberTo(std::string* str, uint64_t num) {
   20|      0|  char buf[30];
   21|      0|  snprintf(buf, sizeof(buf), "%llu", (unsigned long long)num);
   22|      0|  str->append(buf);
   23|      0|}
   24|       |
   25|      0|void AppendEscapedStringTo(std::string* str, const Slice& value) {
   26|      0|  for (size_t i = 0; i < value.size(); i++) {
   27|      0|    char c = value[i];
   28|      0|    if (c >= ' ' && c <= '~') {
   29|      0|      str->push_back(c);
   30|      0|    } else {
   31|      0|      char buf[10];
   32|      0|      snprintf(buf, sizeof(buf), "\\x%02x",
   33|      0|               static_cast<unsigned int>(c) & 0xff);
   34|      0|      str->append(buf);
   35|      0|    }
   36|      0|  }
   37|      0|}
   38|       |
   39|      0|std::string NumberToString(uint64_t num) {
   40|      0|  std::string r;
   41|      0|  AppendNumberTo(&r, num);
   42|      0|  return r;
   43|      0|}
   44|       |
   45|      0|std::string EscapeString(const Slice& value) {
   46|      0|  std::string r;
   47|      0|  AppendEscapedStringTo(&r, value);
   48|      0|  return r;
   49|      0|}
   50|       |
   51|      0|bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {
   52|      0|  // Constants that will be optimized away.
   53|      0|  constexpr const uint64_t kMaxUint64 = std::numeric_limits<uint64_t>::max();
   54|      0|  constexpr const char kLastDigitOfMaxUint64 =
   55|      0|      '0' + static_cast<char>(kMaxUint64 % 10);
   56|      0|
   57|      0|  uint64_t value = 0;
   58|      0|
   59|      0|  // reinterpret_cast-ing from char* to unsigned char* to avoid signedness.
   60|      0|  const unsigned char* start =
   61|      0|      reinterpret_cast<const unsigned char*>(in->data());
   62|      0|
   63|      0|  const unsigned char* end = start + in->size();
   64|      0|  const unsigned char* current = start;
   65|      0|  for (; current != end; ++current) {
   66|      0|    const unsigned char ch = *current;
   67|      0|    if (ch < '0' || ch > '9') break;
   68|      0|
   69|      0|    // Overflow check.
   70|      0|    // kMaxUint64 / 10 is also constant and will be optimized away.
   71|      0|    if (value > kMaxUint64 / 10 ||
   72|      0|        (value == kMaxUint64 / 10 && ch > kLastDigitOfMaxUint64)) {
   73|      0|      return false;
   74|      0|    }
   75|      0|
   76|      0|    value = (value * 10) + (ch - '0');
   77|      0|  }
   78|      0|
   79|      0|  *val = value;
   80|      0|  const size_t digits_consumed = current - start;
   81|      0|  in->remove_prefix(digits_consumed);
   82|      0|  return digits_consumed != 0;
   83|      0|}
   84|       |
   85|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/mutexlock.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_
    6|       |#define STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_
    7|       |
    8|       |#include "port/port.h"
    9|       |#include "port/thread_annotations.h"
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|       |// Helper class that locks a mutex on construction and unlocks the mutex when
   14|       |// the destructor of the MutexLock object is invoked.
   15|       |//
   16|       |// Typical usage:
   17|       |//
   18|       |//   void MyClass::MyMethod() {
   19|       |//     MutexLock l(&mu_);       // mu_ is an instance variable
   20|       |//     ... some complex code, possibly with multiple return paths ...
   21|       |//   }
   22|       |
   23|       |class SCOPED_LOCKABLE MutexLock {
   24|       | public:
   25|      0|  explicit MutexLock(port::Mutex* mu) EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu) {
   26|      0|    this->mu_->Lock();
   27|      0|  }
   28|      0|  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }
   29|       |
   30|       |  MutexLock(const MutexLock&) = delete;
   31|       |  MutexLock& operator=(const MutexLock&) = delete;
   32|       |
   33|       | private:
   34|       |  port::Mutex* const mu_;
   35|       |};
   36|       |
   37|       |}  // namespace leveldb
   38|       |
   39|       |#endif  // STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/no_destructor.h:
    1|       |// Copyright (c) 2018 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_UTIL_NO_DESTRUCTOR_H_
    6|       |#define STORAGE_LEVELDB_UTIL_NO_DESTRUCTOR_H_
    7|       |
    8|       |#include <type_traits>
    9|       |#include <utility>
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|       |// Wraps an instance whose destructor is never called.
   14|       |//
   15|       |// This is intended for use with function-level static variables.
   16|       |template <typename InstanceType>
   17|       |class NoDestructor {
   18|       | public:
   19|       |  template <typename... ConstructorArgTypes>
   20|      0|  explicit NoDestructor(ConstructorArgTypes&&... constructor_args) {
   21|      0|    static_assert(sizeof(instance_storage_) >= sizeof(InstanceType),
   22|      0|                  "instance_storage_ is not large enough to hold the instance");
   23|      0|    static_assert(
   24|      0|        alignof(decltype(instance_storage_)) >= alignof(InstanceType),
   25|      0|        "instance_storage_ does not meet the instance's alignment requirement");
   26|      0|    new (&instance_storage_)
   27|      0|        InstanceType(std::forward<ConstructorArgTypes>(constructor_args)...);
   28|      0|  }
   29|       |
   30|       |  ~NoDestructor() = default;
   31|       |
   32|       |  NoDestructor(const NoDestructor&) = delete;
   33|       |  NoDestructor& operator=(const NoDestructor&) = delete;
   34|       |
   35|      0|  InstanceType* get() {
   36|      0|    return reinterpret_cast<InstanceType*>(&instance_storage_);
   37|      0|  }
   38|       |
   39|       | private:
   40|       |  typename std::aligned_storage<sizeof(InstanceType),
   41|       |                                alignof(InstanceType)>::type instance_storage_;
   42|       |};
   43|       |
   44|       |}  // namespace leveldb
   45|       |
   46|       |#endif  // STORAGE_LEVELDB_UTIL_NO_DESTRUCTOR_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/options.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/options.h"
    6|       |
    7|       |#include "leveldb/comparator.h"
    8|       |#include "leveldb/env.h"
    9|       |
   10|       |namespace leveldb {
   11|       |
   12|      0|Options::Options() : comparator(BytewiseComparator()), env(Env::Default()) {}
   13|       |
   14|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/posix_logger.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |//
    5|       |// Logger implementation that can be shared by all environments
    6|       |// where enough posix functionality is available.
    7|       |
    8|       |#ifndef STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_
    9|       |#define STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_
   10|       |
   11|       |#include <sys/time.h>
   12|       |
   13|       |#include <cassert>
   14|       |#include <cstdarg>
   15|       |#include <cstdio>
   16|       |#include <ctime>
   17|       |#include <sstream>
   18|       |#include <thread>
   19|       |
   20|       |#include "leveldb/env.h"
   21|       |
   22|       |namespace leveldb {
   23|       |
   24|       |class PosixLogger final : public Logger {
   25|       | public:
   26|       |  // Creates a logger that writes to the given file.
   27|       |  //
   28|       |  // The PosixLogger instance takes ownership of the file handle.
   29|      0|  explicit PosixLogger(std::FILE* fp) : fp_(fp) { assert(fp != nullptr); }
   30|       |
   31|      0|  ~PosixLogger() override { std::fclose(fp_); }
   32|       |
   33|      0|  void Logv(const char* format, va_list arguments) override {
   34|      0|    // Record the time as close to the Logv() call as possible.
   35|      0|    struct ::timeval now_timeval;
   36|      0|    ::gettimeofday(&now_timeval, nullptr);
   37|      0|    const std::time_t now_seconds = now_timeval.tv_sec;
   38|      0|    struct std::tm now_components;
   39|      0|    ::localtime_r(&now_seconds, &now_components);
   40|      0|
   41|      0|    // Record the thread ID.
   42|      0|    constexpr const int kMaxThreadIdSize = 32;
   43|      0|    std::ostringstream thread_stream;
   44|      0|    thread_stream << std::this_thread::get_id();
   45|      0|    std::string thread_id = thread_stream.str();
   46|      0|    if (thread_id.size() > kMaxThreadIdSize) {
   47|      0|      thread_id.resize(kMaxThreadIdSize);
   48|      0|    }
   49|      0|
   50|      0|    // We first attempt to print into a stack-allocated buffer. If this attempt
   51|      0|    // fails, we make a second attempt with a dynamically allocated buffer.
   52|      0|    constexpr const int kStackBufferSize = 512;
   53|      0|    char stack_buffer[kStackBufferSize];
   54|      0|    static_assert(sizeof(stack_buffer) == static_cast<size_t>(kStackBufferSize),
   55|      0|                  "sizeof(char) is expected to be 1 in C++");
   56|      0|
   57|      0|    int dynamic_buffer_size = 0;  // Computed in the first iteration.
   58|      0|    for (int iteration = 0; iteration < 2; ++iteration) {
   59|      0|      const int buffer_size =
   60|      0|          (iteration == 0) ? kStackBufferSize : dynamic_buffer_size;
   61|      0|      char* const buffer =
   62|      0|          (iteration == 0) ? stack_buffer : new char[dynamic_buffer_size];
   63|      0|
   64|      0|      // Print the header into the buffer.
   65|      0|      int buffer_offset = snprintf(
   66|      0|          buffer, buffer_size, "%04d/%02d/%02d-%02d:%02d:%02d.%06d %s ",
   67|      0|          now_components.tm_year + 1900, now_components.tm_mon + 1,
   68|      0|          now_components.tm_mday, now_components.tm_hour, now_components.tm_min,
   69|      0|          now_components.tm_sec, static_cast<int>(now_timeval.tv_usec),
   70|      0|          thread_id.c_str());
   71|      0|
   72|      0|      // The header can be at most 28 characters (10 date + 15 time +
   73|      0|      // 3 delimiters) plus the thread ID, which should fit comfortably into the
   74|      0|      // static buffer.
   75|      0|      assert(buffer_offset <= 28 + kMaxThreadIdSize);
   76|      0|      static_assert(28 + kMaxThreadIdSize < kStackBufferSize,
   77|      0|                    "stack-allocated buffer may not fit the message header");
   78|      0|      assert(buffer_offset < buffer_size);
   79|      0|
   80|      0|      // Print the message into the buffer.
   81|      0|      std::va_list arguments_copy;
   82|      0|      va_copy(arguments_copy, arguments);
   83|      0|      buffer_offset +=
   84|      0|          std::vsnprintf(buffer + buffer_offset, buffer_size - buffer_offset,
   85|      0|                         format, arguments_copy);
   86|      0|      va_end(arguments_copy);
   87|      0|
   88|      0|      // The code below may append a newline at the end of the buffer, which
   89|      0|      // requires an extra character.
   90|      0|      if (buffer_offset >= buffer_size - 1) {
   91|      0|        // The message did not fit into the buffer.
   92|      0|        if (iteration == 0) {
   93|      0|          // Re-run the loop and use a dynamically-allocated buffer. The buffer
   94|      0|          // will be large enough for the log message, an extra newline and a
   95|      0|          // null terminator.
   96|      0|          dynamic_buffer_size = buffer_offset + 2;
   97|      0|          continue;
   98|      0|        }
   99|      0|
  100|      0|        // The dynamically-allocated buffer was incorrectly sized. This should
  101|      0|        // not happen, assuming a correct implementation of (v)snprintf. Fail
  102|      0|        // in tests, recover by truncating the log message in production.
  103|      0|        assert(false);
  104|      0|        buffer_offset = buffer_size - 1;
  105|      0|      }
  106|      0|
  107|      0|      // Add a newline if necessary.
  108|      0|      if (buffer[buffer_offset - 1] != '\n') {
  109|      0|        buffer[buffer_offset] = '\n';
  110|      0|        ++buffer_offset;
  111|      0|      }
  112|      0|
  113|      0|      assert(buffer_offset <= buffer_size);
  114|      0|      std::fwrite(buffer, 1, buffer_offset, fp_);
  115|      0|      std::fflush(fp_);
  116|      0|
  117|      0|      if (iteration != 0) {
  118|      0|        delete[] buffer;
  119|      0|      }
  120|      0|      break;
  121|      0|    }
  122|      0|  }
  123|       |
  124|       | private:
  125|       |  std::FILE* const fp_;
  126|       |};
  127|       |
  128|       |}  // namespace leveldb
  129|       |
  130|       |#endif  // STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/random.h:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#ifndef STORAGE_LEVELDB_UTIL_RANDOM_H_
    6|       |#define STORAGE_LEVELDB_UTIL_RANDOM_H_
    7|       |
    8|       |#include <stdint.h>
    9|       |
   10|       |namespace leveldb {
   11|       |
   12|       |// A very simple random number generator.  Not especially good at
   13|       |// generating truly random bits, but good enough for our needs in this
   14|       |// package.
   15|       |class Random {
   16|       | private:
   17|       |  uint32_t seed_;
   18|       |
   19|       | public:
   20|      0|  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
   21|      0|    // Avoid bad seeds.
   22|      0|    if (seed_ == 0 || seed_ == 2147483647L) {
   23|      0|      seed_ = 1;
   24|      0|    }
   25|      0|  }
   26|      0|  uint32_t Next() {
   27|      0|    static const uint32_t M = 2147483647L;  // 2^31-1
   28|      0|    static const uint64_t A = 16807;        // bits 14, 8, 7, 5, 2, 1, 0
   29|      0|    // We are computing
   30|      0|    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
   31|      0|    //
   32|      0|    // seed_ must not be zero or M, or else all subsequent computed values
   33|      0|    // will be zero or M respectively.  For all other values, seed_ will end
   34|      0|    // up cycling through every number in [1,M-1]
   35|      0|    uint64_t product = seed_ * A;
   36|      0|
   37|      0|    // Compute (product % M) using the fact that ((x << 31) % M) == x.
   38|      0|    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
   39|      0|    // The first reduction may overflow by 1 bit, so we may need to
   40|      0|    // repeat.  mod == M is not possible; using > allows the faster
   41|      0|    // sign-bit-based test.
   42|      0|    if (seed_ > M) {
   43|      0|      seed_ -= M;
   44|      0|    }
   45|      0|    return seed_;
   46|      0|  }
   47|       |  // Returns a uniformly distributed value in the range [0..n-1]
   48|       |  // REQUIRES: n > 0
   49|      0|  uint32_t Uniform(int n) { return Next() % n; }
   50|       |
   51|       |  // Randomly returns true ~"1/n" of the time, and false otherwise.
   52|       |  // REQUIRES: n > 0
   53|      0|  bool OneIn(int n) { return (Next() % n) == 0; }
   54|       |
   55|       |  // Skewed: pick "base" uniformly from range [0,max_log] and then
   56|       |  // return "base" random bits.  The effect is to pick a number in the
   57|       |  // range [0,2^max_log-1] with exponential bias towards smaller numbers.
   58|      0|  uint32_t Skewed(int max_log) { return Uniform(1 << Uniform(max_log + 1)); }
   59|       |};
   60|       |
   61|       |}  // namespace leveldb
   62|       |
   63|       |#endif  // STORAGE_LEVELDB_UTIL_RANDOM_H_

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/leveldb-library/util/status.cc:
    1|       |// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
    2|       |// Use of this source code is governed by a BSD-style license that can be
    3|       |// found in the LICENSE file. See the AUTHORS file for names of contributors.
    4|       |
    5|       |#include "leveldb/status.h"
    6|       |
    7|       |#include <stdio.h>
    8|       |
    9|       |#include "port/port.h"
   10|       |
   11|       |namespace leveldb {
   12|       |
   13|      0|const char* Status::CopyState(const char* state) {
   14|      0|  uint32_t size;
   15|      0|  memcpy(&size, state, sizeof(size));
   16|      0|  char* result = new char[size + 5];
   17|      0|  memcpy(result, state, size + 5);
   18|      0|  return result;
   19|      0|}
   20|       |
   21|      0|Status::Status(Code code, const Slice& msg, const Slice& msg2) {
   22|      0|  assert(code != kOk);
   23|      0|  const uint32_t len1 = msg.size();
   24|      0|  const uint32_t len2 = msg2.size();
   25|      0|  const uint32_t size = len1 + (len2 ? (2 + len2) : 0);
   26|      0|  char* result = new char[size + 5];
   27|      0|  memcpy(result, &size, sizeof(size));
   28|      0|  result[4] = static_cast<char>(code);
   29|      0|  memcpy(result + 5, msg.data(), len1);
   30|      0|  if (len2) {
   31|      0|    result[5 + len1] = ':';
   32|      0|    result[6 + len1] = ' ';
   33|      0|    memcpy(result + 7 + len1, msg2.data(), len2);
   34|      0|  }
   35|      0|  state_ = result;
   36|      0|}
   37|       |
   38|      0|std::string Status::ToString() const {
   39|      0|  if (state_ == nullptr) {
   40|      0|    return "OK";
   41|      0|  } else {
   42|      0|    char tmp[30];
   43|      0|    const char* type;
   44|      0|    switch (code()) {
   45|      0|      case kOk:
   46|      0|        type = "OK";
   47|      0|        break;
   48|      0|      case kNotFound:
   49|      0|        type = "NotFound: ";
   50|      0|        break;
   51|      0|      case kCorruption:
   52|      0|        type = "Corruption: ";
   53|      0|        break;
   54|      0|      case kNotSupported:
   55|      0|        type = "Not implemented: ";
   56|      0|        break;
   57|      0|      case kInvalidArgument:
   58|      0|        type = "Invalid argument: ";
   59|      0|        break;
   60|      0|      case kIOError:
   61|      0|        type = "IO error: ";
   62|      0|        break;
   63|      0|      default:
   64|      0|        snprintf(tmp, sizeof(tmp),
   65|      0|                 "Unknown code(%d): ", static_cast<int>(code()));
   66|      0|        type = tmp;
   67|      0|        break;
   68|      0|    }
   69|      0|    std::string result(type);
   70|      0|    uint32_t length;
   71|      0|    memcpy(&length, state_, sizeof(length));
   72|      0|    result.append(state_ + 5, length);
   73|      0|    return result;
   74|      0|  }
   75|      0|}
   76|       |
   77|       |}  // namespace leveldb

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/nanopb/pb.h:
    1|       |/* Common parts of the nanopb library. Most of these are quite low-level
    2|       | * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.
    3|       | */
    4|       |
    5|       |#ifndef PB_H_INCLUDED
    6|       |#define PB_H_INCLUDED
    7|       |
    8|       |/*****************************************************************
    9|       | * Nanopb compilation time options. You can change these here by *
   10|       | * uncommenting the lines, or on the compiler command line.      *
   11|       | *****************************************************************/
   12|       |
   13|       |/* Enable support for dynamically allocated fields */
   14|       |/* #define PB_ENABLE_MALLOC 1 */
   15|       |
   16|       |/* Define this if your CPU / compiler combination does not support
   17|       | * unaligned memory access to packed structures. */
   18|       |/* #define PB_NO_PACKED_STRUCTS 1 */
   19|       |
   20|       |/* Increase the number of required fields that are tracked.
   21|       | * A compiler warning will tell if you need this. */
   22|       |/* #define PB_MAX_REQUIRED_FIELDS 256 */
   23|       |
   24|       |/* Add support for tag numbers > 255 and fields larger than 255 bytes. */
   25|       |/* #define PB_FIELD_16BIT 1 */
   26|       |
   27|       |/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */
   28|       |/* #define PB_FIELD_32BIT 1 */
   29|       |
   30|       |/* Disable support for error messages in order to save some code space. */
   31|       |/* #define PB_NO_ERRMSG 1 */
   32|       |
   33|       |/* Disable support for custom streams (support only memory buffers). */
   34|       |/* #define PB_BUFFER_ONLY 1 */
   35|       |
   36|       |/* Switch back to the old-style callback function signature.
   37|       | * This was the default until nanopb-0.2.1. */
   38|       |/* #define PB_OLD_CALLBACK_STYLE */
   39|       |
   40|       |
   41|       |/******************************************************************
   42|       | * You usually don't need to change anything below this line.     *
   43|       | * Feel free to look around and use the defined macros, though.   *
   44|       | ******************************************************************/
   45|       |
   46|       |
   47|       |/* Version of the nanopb library. Just in case you want to check it in
   48|       | * your own program. */
   49|       |#define NANOPB_VERSION nanopb-0.3.9.1
   50|       |
   51|       |/* Include all the system headers needed by nanopb. You will need the
   52|       | * definitions of the following:
   53|       | * - strlen, memcpy, memset functions
   54|       | * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t
   55|       | * - size_t
   56|       | * - bool
   57|       | *
   58|       | * If you don't have the standard header files, you can instead provide
   59|       | * a custom header that defines or includes all this. In that case,
   60|       | * define PB_SYSTEM_HEADER to the path of this file.
   61|       | */
   62|       |#ifdef PB_SYSTEM_HEADER
   63|       |#include PB_SYSTEM_HEADER
   64|       |#else
   65|       |#include <stdint.h>
   66|       |#include <stddef.h>
   67|       |#include <stdbool.h>
   68|       |#include <string.h>
   69|       |
   70|       |#ifdef PB_ENABLE_MALLOC
   71|       |#include <stdlib.h>
   72|       |#endif
   73|       |#endif
   74|       |
   75|       |/* Macro for defining packed structures (compiler dependent).
   76|       | * This just reduces memory requirements, but is not required.
   77|       | */
   78|       |#if defined(PB_NO_PACKED_STRUCTS)
   79|       |    /* Disable struct packing */
   80|       |#   define PB_PACKED_STRUCT_START
   81|       |#   define PB_PACKED_STRUCT_END
   82|       |#   define pb_packed
   83|       |#elif defined(__GNUC__) || defined(__clang__)
   84|       |    /* For GCC and clang */
   85|       |#   define PB_PACKED_STRUCT_START
   86|       |#   define PB_PACKED_STRUCT_END
   87|       |#   define pb_packed __attribute__((packed))
   88|       |#elif defined(__ICCARM__) || defined(__CC_ARM)
   89|       |    /* For IAR ARM and Keil MDK-ARM compilers */
   90|       |#   define PB_PACKED_STRUCT_START _Pragma("pack(push, 1)")
   91|       |#   define PB_PACKED_STRUCT_END _Pragma("pack(pop)")
   92|       |#   define pb_packed
   93|       |#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
   94|       |    /* For Microsoft Visual C++ */
   95|       |#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))
   96|       |#   define PB_PACKED_STRUCT_END __pragma(pack(pop))
   97|       |#   define pb_packed
   98|       |#else
   99|       |    /* Unknown compiler */
  100|       |#   define PB_PACKED_STRUCT_START
  101|       |#   define PB_PACKED_STRUCT_END
  102|       |#   define pb_packed
  103|       |#endif
  104|       |
  105|       |/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
  106|       |#ifndef PB_UNUSED
  107|      0|#define PB_UNUSED(x) (void)(x)
  108|       |#endif
  109|       |
  110|       |/* Compile-time assertion, used for checking compatible compilation options.
  111|       | * If this does not work properly on your compiler, use
  112|       | * #define PB_NO_STATIC_ASSERT to disable it.
  113|       | *
  114|       | * But before doing that, check carefully the error message / place where it
  115|       | * comes from to see if the error has a real cause. Unfortunately the error
  116|       | * message is not always very clear to read, but you can see the reason better
  117|       | * in the place where the PB_STATIC_ASSERT macro was called.
  118|       | */
  119|       |#ifndef PB_NO_STATIC_ASSERT
  120|       |#ifndef PB_STATIC_ASSERT
  121|       |#define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
  122|       |#define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
  123|       |#define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##LINE##COUNTER
  124|       |#endif
  125|       |#else
  126|       |#define PB_STATIC_ASSERT(COND,MSG)
  127|       |#endif
  128|       |
  129|       |/* Number of required fields to keep track of. */
  130|       |#ifndef PB_MAX_REQUIRED_FIELDS
  131|     18|#define PB_MAX_REQUIRED_FIELDS 64
  132|       |#endif
  133|       |
  134|       |#if PB_MAX_REQUIRED_FIELDS < 64
  135|       |#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).
  136|       |#endif
  137|       |
  138|       |/* List of possible field types. These are used in the autogenerated code.
  139|       | * Least-significant 4 bits tell the scalar type
  140|       | * Most-significant 4 bits specify repeated/required/packed etc.
  141|       | */
  142|       |
  143|       |typedef uint_least8_t pb_type_t;
  144|       |
  145|       |/**** Field data types ****/
  146|       |
  147|       |/* Numeric types */
  148|    105|#define PB_LTYPE_VARINT  0x00 /* int32, int64, enum, bool */
  149|    105|#define PB_LTYPE_UVARINT 0x01 /* uint32, uint64 */
  150|    105|#define PB_LTYPE_SVARINT 0x02 /* sint32, sint64 */
  151|      8|#define PB_LTYPE_FIXED32 0x03 /* fixed32, sfixed32, float */
  152|      8|#define PB_LTYPE_FIXED64 0x04 /* fixed64, sfixed64, double */
  153|       |
  154|       |/* Marker for last packable field type. */
  155|     13|#define PB_LTYPE_LAST_PACKABLE 0x04
  156|       |
  157|       |/* Byte array with pre-allocated buffer.
  158|       | * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
  159|    124|#define PB_LTYPE_BYTES 0x05
  160|       |
  161|       |/* String with pre-allocated buffer.
  162|       | * data_size is the maximum length. */
  163|    133|#define PB_LTYPE_STRING 0x06
  164|       |
  165|       |/* Submessage
  166|       | * submsg_fields is pointer to field descriptions */
  167|    209|#define PB_LTYPE_SUBMESSAGE 0x07
  168|       |
  169|       |/* Extension pseudo-field
  170|       | * The field contains a pointer to pb_extension_t */
  171|    436|#define PB_LTYPE_EXTENSION 0x08
  172|       |
  173|       |/* Byte array with inline, pre-allocated byffer.
  174|       | * data_size is the length of the inline, allocated buffer.
  175|       | * This differs from PB_LTYPE_BYTES by defining the element as
  176|       | * pb_byte_t[data_size] rather than pb_bytes_array_t. */
  177|    115|#define PB_LTYPE_FIXED_LENGTH_BYTES 0x09
  178|       |
  179|       |/* Number of declared LTYPES */
  180|       |#define PB_LTYPES_COUNT 0x0A
  181|  1.06k|#define PB_LTYPE_MASK 0x0F
  182|       |
  183|       |/**** Field repetition rules ****/
  184|       |
  185|    628|#define PB_HTYPE_REQUIRED 0x00
  186|    647|#define PB_HTYPE_OPTIONAL 0x10
  187|    505|#define PB_HTYPE_REPEATED 0x20
  188|  1.36k|#define PB_HTYPE_ONEOF    0x30
  189|  2.09k|#define PB_HTYPE_MASK     0x30
  190|       |
  191|       |/**** Field allocation types ****/
  192|       | 
  193|  1.41k|#define PB_ATYPE_STATIC   0x00
  194|  1.02k|#define PB_ATYPE_POINTER  0x80
  195|     71|#define PB_ATYPE_CALLBACK 0x40
  196|  1.75k|#define PB_ATYPE_MASK     0xC0
  197|       |
  198|  1.75k|#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)
  199|  2.09k|#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)
  200|  1.06k|#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)
  201|       |
  202|       |/* Data type used for storing sizes of struct fields
  203|       | * and array counts.
  204|       | */
  205|       |#if defined(PB_FIELD_32BIT)
  206|       |    typedef uint32_t pb_size_t;
  207|       |    typedef int32_t pb_ssize_t;
  208|       |#elif defined(PB_FIELD_16BIT)
  209|       |    typedef uint_least16_t pb_size_t;
  210|       |    typedef int_least16_t pb_ssize_t;
  211|       |#else
  212|       |    typedef uint_least8_t pb_size_t;
  213|       |    typedef int_least8_t pb_ssize_t;
  214|       |#endif
  215|      0|#define PB_SIZE_MAX ((pb_size_t)-1)
  216|       |
  217|       |/* Data type for storing encoded data and other byte streams.
  218|       | * This typedef exists to support platforms where uint8_t does not exist.
  219|       | * You can regard it as equivalent on uint8_t on other platforms.
  220|       | */
  221|       |typedef uint_least8_t pb_byte_t;
  222|       |
  223|       |/* This structure is used in auto-generated constants
  224|       | * to specify struct fields.
  225|       | * You can change field sizes if you need structures
  226|       | * larger than 256 bytes or field tags larger than 256.
  227|       | * The compiler should complain if your .proto has such
  228|       | * structures. Fix that by defining PB_FIELD_16BIT or
  229|       | * PB_FIELD_32BIT.
  230|       | */
  231|       |PB_PACKED_STRUCT_START
  232|       |typedef struct pb_field_s pb_field_t;
  233|       |struct pb_field_s {
  234|       |    pb_size_t tag;
  235|       |    pb_type_t type;
  236|       |    pb_size_t data_offset; /* Offset of field data, relative to previous field. */
  237|       |    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
  238|       |    pb_size_t data_size; /* Data size in bytes for a single item */
  239|       |    pb_size_t array_size; /* Maximum number of entries in array */
  240|       |    
  241|       |    /* Field definitions for submessage
  242|       |     * OR default value for all other non-array, non-callback types
  243|       |     * If null, then field will zeroed. */
  244|       |    const void *ptr;
  245|       |} pb_packed;
  246|       |PB_PACKED_STRUCT_END
  247|       |
  248|       |/* Make sure that the standard integer types are of the expected sizes.
  249|       | * Otherwise fixed32/fixed64 fields can break.
  250|       | *
  251|       | * If you get errors here, it probably means that your stdint.h is not
  252|       | * correct for your platform.
  253|       | */
  254|       |#ifndef PB_WITHOUT_64BIT
  255|       |PB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)
  256|       |PB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)
  257|       |#endif
  258|       |
  259|       |/* This structure is used for 'bytes' arrays.
  260|       | * It has the number of bytes in the beginning, and after that an array.
  261|       | * Note that actual structs used will have a different length of bytes array.
  262|       | */
  263|       |#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }
  264|      0|#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))
  265|       |
  266|       |struct pb_bytes_array_s {
  267|       |    pb_size_t size;
  268|       |    pb_byte_t bytes[1];
  269|       |};
  270|       |typedef struct pb_bytes_array_s pb_bytes_array_t;
  271|       |
  272|       |/* This structure is used for giving the callback function.
  273|       | * It is stored in the message structure and filled in by the method that
  274|       | * calls pb_decode.
  275|       | *
  276|       | * The decoding callback will be given a limited-length stream
  277|       | * If the wire type was string, the length is the length of the string.
  278|       | * If the wire type was a varint/fixed32/fixed64, the length is the length
  279|       | * of the actual value.
  280|       | * The function may be called multiple times (especially for repeated types,
  281|       | * but also otherwise if the message happens to contain the field multiple
  282|       | * times.)
  283|       | *
  284|       | * The encoding callback will receive the actual output stream.
  285|       | * It should write all the data in one call, including the field tag and
  286|       | * wire type. It can write multiple fields.
  287|       | *
  288|       | * The callback can be null if you want to skip a field.
  289|       | */
  290|       |typedef struct pb_istream_s pb_istream_t;
  291|       |typedef struct pb_ostream_s pb_ostream_t;
  292|       |typedef struct pb_callback_s pb_callback_t;
  293|       |struct pb_callback_s {
  294|       |#ifdef PB_OLD_CALLBACK_STYLE
  295|       |    /* Deprecated since nanopb-0.2.1 */
  296|       |    union {
  297|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
  298|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
  299|       |    } funcs;
  300|       |#else
  301|       |    /* New function signature, which allows modifying arg contents in callback. */
  302|       |    union {
  303|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
  304|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
  305|       |    } funcs;
  306|       |#endif    
  307|       |    
  308|       |    /* Free arg for use by callback */
  309|       |    void *arg;
  310|       |};
  311|       |
  312|       |/* Wire types. Library user needs these only in encoder callbacks. */
  313|       |typedef enum {
  314|       |    PB_WT_VARINT = 0,
  315|       |    PB_WT_64BIT  = 1,
  316|       |    PB_WT_STRING = 2,
  317|       |    PB_WT_32BIT  = 5
  318|       |} pb_wire_type_t;
  319|       |
  320|       |/* Structure for defining the handling of unknown/extension fields.
  321|       | * Usually the pb_extension_type_t structure is automatically generated,
  322|       | * while the pb_extension_t structure is created by the user. However,
  323|       | * if you want to catch all unknown fields, you can also create a custom
  324|       | * pb_extension_type_t with your own callback.
  325|       | */
  326|       |typedef struct pb_extension_type_s pb_extension_type_t;
  327|       |typedef struct pb_extension_s pb_extension_t;
  328|       |struct pb_extension_type_s {
  329|       |    /* Called for each unknown field in the message.
  330|       |     * If you handle the field, read off all of its data and return true.
  331|       |     * If you do not handle the field, do not read anything and return true.
  332|       |     * If you run into an error, return false.
  333|       |     * Set to NULL for default handler.
  334|       |     */
  335|       |    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
  336|       |                   uint32_t tag, pb_wire_type_t wire_type);
  337|       |    
  338|       |    /* Called once after all regular fields have been encoded.
  339|       |     * If you have something to write, do so and return true.
  340|       |     * If you do not have anything to write, just return true.
  341|       |     * If you run into an error, return false.
  342|       |     * Set to NULL for default handler.
  343|       |     */
  344|       |    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
  345|       |    
  346|       |    /* Free field for use by the callback. */
  347|       |    const void *arg;
  348|       |};
  349|       |
  350|       |struct pb_extension_s {
  351|       |    /* Type describing the extension field. Usually you'll initialize
  352|       |     * this to a pointer to the automatically generated structure. */
  353|       |    const pb_extension_type_t *type;
  354|       |    
  355|       |    /* Destination for the decoded data. This must match the datatype
  356|       |     * of the extension field. */
  357|       |    void *dest;
  358|       |    
  359|       |    /* Pointer to the next extension handler, or NULL.
  360|       |     * If this extension does not match a field, the next handler is
  361|       |     * automatically called. */
  362|       |    pb_extension_t *next;
  363|       |
  364|       |    /* The decoder sets this to true if the extension was found.
  365|       |     * Ignored for encoding. */
  366|       |    bool found;
  367|       |};
  368|       |
  369|       |/* Memory allocation functions to use. You can define pb_realloc and
  370|       | * pb_free to custom functions if you want. */
  371|       |#ifdef PB_ENABLE_MALLOC
  372|       |#   ifndef pb_realloc
  373|      0|#       define pb_realloc(ptr, size) realloc(ptr, size)
  374|       |#   endif
  375|       |#   ifndef pb_free
  376|     30|#       define pb_free(ptr) free(ptr)
  377|       |#   endif
  378|       |#endif
  379|       |
  380|       |/* This is used to inform about need to regenerate .pb.h/.pb.c files. */
  381|       |#define PB_PROTO_HEADER_VERSION 30
  382|       |
  383|       |/* These macros are used to declare pb_field_t's in the constant array. */
  384|       |/* Size of a structure member, in bytes. */
  385|       |#define pb_membersize(st, m) (sizeof ((st*)0)->m)
  386|       |/* Number of entries in an array. */
  387|       |#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
  388|       |/* Delta from start of one member to the start of another member. */
  389|       |#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
  390|       |/* Marks the end of the field list */
  391|       |#define PB_LAST_FIELD {0,(pb_type_t) 0,0,0,0,0,0}
  392|       |
  393|       |/* Macros for filling in the data_offset field */
  394|       |/* data_offset for first field in a message */
  395|       |#define PB_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
  396|       |/* data_offset for subsequent fields */
  397|       |#define PB_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))
  398|       |/* data offset for subsequent fields inside an union (oneof) */
  399|       |#define PB_DATAOFFSET_UNION(st, m1, m2) (PB_SIZE_MAX)
  400|       |/* Choose first/other based on m1 == m2 (deprecated, remains for backwards compatibility) */
  401|       |#define PB_DATAOFFSET_CHOOSE(st, m1, m2) (int)(offsetof(st, m1) == offsetof(st, m2) \
  402|       |                                  ? PB_DATAOFFSET_FIRST(st, m1, m2) \
  403|       |                                  : PB_DATAOFFSET_OTHER(st, m1, m2))
  404|       |
  405|       |/* Required fields are the simplest. They just have delta (padding) from
  406|       | * previous field end, and the size of the field. Pointer is used for
  407|       | * submessages and default values.
  408|       | */
  409|       |#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
  410|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  411|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  412|       |
  413|       |/* Optional fields add the delta to the has_ variable. */
  414|       |#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
  415|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  416|       |    fd, \
  417|       |    pb_delta(st, has_ ## m, m), \
  418|       |    pb_membersize(st, m), 0, ptr}
  419|       |
  420|       |#define PB_SINGULAR_STATIC(tag, st, m, fd, ltype, ptr) \
  421|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  422|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  423|       |
  424|       |/* Repeated fields have a _count field and also the maximum number of entries. */
  425|       |#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
  426|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, \
  427|       |    fd, \
  428|       |    pb_delta(st, m ## _count, m), \
  429|       |    pb_membersize(st, m[0]), \
  430|       |    pb_arraysize(st, m), ptr}
  431|       |
  432|       |/* Allocated fields carry the size of the actual data, not the pointer */
  433|       |#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
  434|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, \
  435|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  436|       |
  437|       |/* Optional fields don't need a has_ variable, as information would be redundant */
  438|       |#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
  439|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  440|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  441|       |
  442|       |/* Same as optional fields*/
  443|       |#define PB_SINGULAR_POINTER(tag, st, m, fd, ltype, ptr) \
  444|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  445|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  446|       |
  447|       |/* Repeated fields have a _count field and a pointer to array of pointers */
  448|       |#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
  449|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, \
  450|       |    fd, pb_delta(st, m ## _count, m), \
  451|       |    pb_membersize(st, m[0]), 0, ptr}
  452|       |
  453|       |/* Callbacks are much like required fields except with special datatype. */
  454|       |#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  455|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, \
  456|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  457|       |
  458|       |#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
  459|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  460|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  461|       |
  462|       |#define PB_SINGULAR_CALLBACK(tag, st, m, fd, ltype, ptr) \
  463|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  464|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  465|       |    
  466|       |#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  467|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, \
  468|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  469|       |
  470|       |/* Optional extensions don't have the has_ field, as that would be redundant.
  471|       | * Furthermore, the combination of OPTIONAL without has_ field is used
  472|       | * for indicating proto3 style fields. Extensions exist in proto2 mode only,
  473|       | * so they should be encoded according to proto2 rules. To avoid the conflict,
  474|       | * extensions are marked as REQUIRED instead.
  475|       | */
  476|       |#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
  477|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  478|       |    0, \
  479|       |    0, \
  480|       |    pb_membersize(st, m), 0, ptr}
  481|       |
  482|       |#define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
  483|       |    PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
  484|       |
  485|       |#define PB_OPTEXT_CALLBACK(tag, st, m, fd, ltype, ptr) \
  486|       |    PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)
  487|       |
  488|       |/* The mapping from protobuf types to LTYPEs is done using these macros. */
  489|       |#define PB_LTYPE_MAP_BOOL               PB_LTYPE_VARINT
  490|       |#define PB_LTYPE_MAP_BYTES              PB_LTYPE_BYTES
  491|       |#define PB_LTYPE_MAP_DOUBLE             PB_LTYPE_FIXED64
  492|       |#define PB_LTYPE_MAP_ENUM               PB_LTYPE_VARINT
  493|       |#define PB_LTYPE_MAP_UENUM              PB_LTYPE_UVARINT
  494|       |#define PB_LTYPE_MAP_FIXED32            PB_LTYPE_FIXED32
  495|       |#define PB_LTYPE_MAP_FIXED64            PB_LTYPE_FIXED64
  496|       |#define PB_LTYPE_MAP_FLOAT              PB_LTYPE_FIXED32
  497|       |#define PB_LTYPE_MAP_INT32              PB_LTYPE_VARINT
  498|       |#define PB_LTYPE_MAP_INT64              PB_LTYPE_VARINT
  499|       |#define PB_LTYPE_MAP_MESSAGE            PB_LTYPE_SUBMESSAGE
  500|       |#define PB_LTYPE_MAP_SFIXED32           PB_LTYPE_FIXED32
  501|       |#define PB_LTYPE_MAP_SFIXED64           PB_LTYPE_FIXED64
  502|       |#define PB_LTYPE_MAP_SINT32             PB_LTYPE_SVARINT
  503|       |#define PB_LTYPE_MAP_SINT64             PB_LTYPE_SVARINT
  504|       |#define PB_LTYPE_MAP_STRING             PB_LTYPE_STRING
  505|       |#define PB_LTYPE_MAP_UINT32             PB_LTYPE_UVARINT
  506|       |#define PB_LTYPE_MAP_UINT64             PB_LTYPE_UVARINT
  507|       |#define PB_LTYPE_MAP_EXTENSION          PB_LTYPE_EXTENSION
  508|       |#define PB_LTYPE_MAP_FIXED_LENGTH_BYTES PB_LTYPE_FIXED_LENGTH_BYTES
  509|       |
  510|       |/* This is the actual macro used in field descriptions.
  511|       | * It takes these arguments:
  512|       | * - Field tag number
  513|       | * - Field type:   BOOL, BYTES, DOUBLE, ENUM, UENUM, FIXED32, FIXED64,
  514|       | *                 FLOAT, INT32, INT64, MESSAGE, SFIXED32, SFIXED64
  515|       | *                 SINT32, SINT64, STRING, UINT32, UINT64 or EXTENSION
  516|       | * - Field rules:  REQUIRED, OPTIONAL or REPEATED
  517|       | * - Allocation:   STATIC, CALLBACK or POINTER
  518|       | * - Placement: FIRST or OTHER, depending on if this is the first field in structure.
  519|       | * - Message name
  520|       | * - Field name
  521|       | * - Previous field name (or field name again for first field)
  522|       | * - Pointer to default value or submsg fields.
  523|       | */
  524|       |
  525|       |#define PB_FIELD(tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  526|       |        PB_ ## rules ## _ ## allocation(tag, message, field, \
  527|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  528|       |        PB_LTYPE_MAP_ ## type, ptr)
  529|       |
  530|       |/* Field description for repeated static fixed count fields.*/
  531|       |#define PB_REPEATED_FIXED_COUNT(tag, type, placement, message, field, prevfield, ptr) \
  532|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | PB_LTYPE_MAP_ ## type, \
  533|       |    PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  534|       |    0, \
  535|       |    pb_membersize(message, field[0]), \
  536|       |    pb_arraysize(message, field), ptr}
  537|       |
  538|       |/* Field description for oneof fields. This requires taking into account the
  539|       | * union name also, that's why a separate set of macros is needed.
  540|       | */
  541|       |#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  542|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  543|       |    fd, pb_delta(st, which_ ## u, u.m), \
  544|       |    pb_membersize(st, u.m), 0, ptr}
  545|       |
  546|       |#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  547|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  548|       |    fd, pb_delta(st, which_ ## u, u.m), \
  549|       |    pb_membersize(st, u.m[0]), 0, ptr}
  550|       |
  551|       |#define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  552|       |        PB_ONEOF_ ## allocation(union_name, tag, message, field, \
  553|       |        PB_DATAOFFSET_ ## placement(message, union_name.field, prevfield), \
  554|       |        PB_LTYPE_MAP_ ## type, ptr)
  555|       |
  556|       |#define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  557|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  558|       |    fd, pb_delta(st, which_ ## u, m), \
  559|       |    pb_membersize(st, m), 0, ptr}
  560|       |
  561|       |#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  562|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  563|       |    fd, pb_delta(st, which_ ## u, m), \
  564|       |    pb_membersize(st, m[0]), 0, ptr}
  565|       |
  566|       |#define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  567|       |        PB_ANONYMOUS_ONEOF_ ## allocation(union_name, tag, message, field, \
  568|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  569|       |        PB_LTYPE_MAP_ ## type, ptr)
  570|       |
  571|       |/* These macros are used for giving out error messages.
  572|       | * They are mostly a debugging aid; the main error information
  573|       | * is the true/false return value from functions.
  574|       | * Some code space can be saved by disabling the error
  575|       | * messages if not used.
  576|       | *
  577|       | * PB_SET_ERROR() sets the error message if none has been set yet.
  578|       | *                msg must be a constant string literal.
  579|       | * PB_GET_ERROR() always returns a pointer to a string.
  580|       | * PB_RETURN_ERROR() sets the error and returns false from current
  581|       | *                   function.
  582|       | */
  583|       |#ifdef PB_NO_ERRMSG
  584|       |#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)
  585|       |#define PB_GET_ERROR(stream) "(errmsg disabled)"
  586|       |#else
  587|      0|#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))
  588|       |#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : "(none)")
  589|       |#endif
  590|       |
  591|      0|#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false
  592|       |
  593|       |#endif

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/nanopb/pb_common.c:
    1|       |/* pb_common.c: Common support functions for pb_encode.c and pb_decode.c.
    2|       | *
    3|       | * 2014 Petteri Aimonen <jpa@kapsi.fi>
    4|       | */
    5|       |
    6|       |#include "pb_common.h"
    7|       |
    8|       |bool pb_field_iter_begin(pb_field_iter_t *iter, const pb_field_t *fields, void *dest_struct)
    9|    140|{
   10|    140|    iter->start = fields;
   11|    140|    iter->pos = fields;
   12|    140|    iter->required_field_index = 0;
   13|    140|    iter->dest_struct = dest_struct;
   14|    140|    iter->pData = (char*)dest_struct + iter->pos->data_offset;
   15|    140|    iter->pSize = (char*)iter->pData + iter->pos->size_offset;
   16|    140|    
   17|    140|    return (iter->pos->tag != 0);
   18|    140|}
   19|       |
   20|       |bool pb_field_iter_next(pb_field_iter_t *iter)
   21|    447|{
   22|    447|    const pb_field_t *prev_field = iter->pos;
   23|    447|
   24|    447|    if (prev_field->tag == 0)
   25|      0|    {
   26|      0|        /* Handle empty message types, where the first field is already the terminator.
   27|      0|         * In other cases, the iter->pos never points to the terminator. */
   28|      0|        return false;
   29|      0|    }
   30|    447|    
   31|    447|    iter->pos++;
   32|    447|    
   33|    447|    if (iter->pos->tag == 0)
   34|     70|    {
   35|     70|        /* Wrapped back to beginning, reinitialize */
   36|     70|        (void)pb_field_iter_begin(iter, iter->start, iter->dest_struct);
   37|     70|        return false;
   38|     70|    }
   39|    377|    else
   40|    377|    {
   41|    377|        /* Increment the pointers based on previous field size */
   42|    377|        size_t prev_size = prev_field->data_size;
   43|    377|    
   44|    377|        if (PB_HTYPE(prev_field->type) == PB_HTYPE_ONEOF &&
   45|    377|            PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF &&
   46|    377|            iter->pos->data_offset == PB_SIZE_MAX)
   47|    377|        {
   48|      0|            /* Don't advance pointers inside unions */
   49|      0|            return true;
   50|      0|        }
   51|    377|        else if (PB_ATYPE(prev_field->type) == PB_ATYPE_STATIC &&
   52|    377|                 PB_HTYPE(prev_field->type) == PB_HTYPE_REPEATED)
   53|    377|        {
   54|      0|            /* In static arrays, the data_size tells the size of a single entry and
   55|      0|             * array_size is the number of entries */
   56|      0|            prev_size *= prev_field->array_size;
   57|      0|        }
   58|    377|        else if (PB_ATYPE(prev_field->type) == PB_ATYPE_POINTER)
   59|    377|        {
   60|    145|            /* Pointer fields always have a constant size in the main structure.
   61|    145|             * The data_size only applies to the dynamically allocated area. */
   62|    145|            prev_size = sizeof(void*);
   63|    145|        }
   64|    377|
   65|    377|        if (PB_HTYPE(prev_field->type) == PB_HTYPE_REQUIRED)
   66|    377|        {
   67|      0|            /* Count the required fields, in order to check their presence in the
   68|      0|             * decoder. */
   69|      0|            iter->required_field_index++;
   70|      0|        }
   71|    377|    
   72|    377|        iter->pData = (char*)iter->pData + prev_size + iter->pos->data_offset;
   73|    377|        iter->pSize = (char*)iter->pData + iter->pos->size_offset;
   74|    377|        return true;
   75|    377|    }
   76|    447|}
   77|       |
   78|       |bool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag)
   79|     52|{
   80|     52|    const pb_field_t *start = iter->pos;
   81|     52|    
   82|     94|    do {
   83|     94|        if (iter->pos->tag == tag &&
   84|     94|            PB_LTYPE(iter->pos->type) != PB_LTYPE_EXTENSION)
   85|     94|        {
   86|     52|            /* Found the wanted field */
   87|     52|            return true;
   88|     52|        }
   89|     42|        
   90|     42|        (void)pb_field_iter_next(iter);
   91|     42|    } while (iter->pos != start);
   92|     52|    
   93|     52|    /* Searched all the way back to start, and found nothing. */
   94|     52|    return false;
   95|     52|}
   96|       |
   97|       |

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/nanopb/pb_decode.c:
    1|       |/* pb_decode.c -- decode a protobuf using minimal resources
    2|       | *
    3|       | * 2011 Petteri Aimonen <jpa@kapsi.fi>
    4|       | */
    5|       |
    6|       |/* Use the GCC warn_unused_result attribute to check that all return values
    7|       | * are propagated correctly. On other compilers and gcc before 3.4.0 just
    8|       | * ignore the annotation.
    9|       | */
   10|       |#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
   11|       |    #define checkreturn
   12|       |#else
   13|       |    #define checkreturn __attribute__((warn_unused_result))
   14|       |#endif
   15|       |
   16|       |#include "pb.h"
   17|       |#include "pb_decode.h"
   18|       |#include "pb_common.h"
   19|       |
   20|       |/**************************************
   21|       | * Declarations internal to this file *
   22|       | **************************************/
   23|       |
   24|       |typedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;
   25|       |
   26|       |static bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);
   27|       |static bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);
   28|       |static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
   29|       |static bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
   30|       |static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
   31|       |static void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension);
   32|       |static bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);
   33|       |static bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);
   34|       |static bool checkreturn find_extension_field(pb_field_iter_t *iter);
   35|       |static void pb_field_set_to_default(pb_field_iter_t *iter);
   36|       |static void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);
   37|       |static bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);
   38|       |static bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof);
   39|       |static bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);
   40|       |static bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);
   41|       |static bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);
   42|       |static bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);
   43|       |static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);
   44|       |static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);
   45|       |static bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);
   46|       |static bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);
   47|       |static bool checkreturn pb_skip_varint(pb_istream_t *stream);
   48|       |static bool checkreturn pb_skip_string(pb_istream_t *stream);
   49|       |
   50|       |#ifdef PB_ENABLE_MALLOC
   51|       |static bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);
   52|       |static bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter);
   53|       |static void pb_release_single_field(const pb_field_iter_t *iter);
   54|       |#endif
   55|       |
   56|       |#ifdef PB_WITHOUT_64BIT
   57|       |#define pb_int64_t int32_t
   58|       |#define pb_uint64_t uint32_t
   59|       |#else
   60|     32|#define pb_int64_t int64_t
   61|     16|#define pb_uint64_t uint64_t
   62|       |#endif
   63|       |
   64|       |/* --- Function pointers to field decoders ---
   65|       | * Order in the array must match pb_action_t LTYPE numbering.
   66|       | */
   67|       |static const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {
   68|       |    &pb_dec_varint,
   69|       |    &pb_dec_uvarint,
   70|       |    &pb_dec_svarint,
   71|       |    &pb_dec_fixed32,
   72|       |    &pb_dec_fixed64,
   73|       |    
   74|       |    &pb_dec_bytes,
   75|       |    &pb_dec_string,
   76|       |    &pb_dec_submessage,
   77|       |    NULL, /* extensions */
   78|       |    &pb_dec_fixed_length_bytes
   79|       |};
   80|       |
   81|       |/*******************************
   82|       | * pb_istream_t implementation *
   83|       | *******************************/
   84|       |
   85|       |static bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)
   86|    160|{
   87|    160|    size_t i;
   88|    160|    const pb_byte_t *source = (const pb_byte_t*)stream->state;
   89|    160|    stream->state = (pb_byte_t*)stream->state + count;
   90|    160|    
   91|    160|    if (buf != NULL)
   92|    160|    {
   93|  1.01k|        for (i = 0; i < count; i++)
   94|    866|            buf[i] = source[i];
   95|    147|    }
   96|    160|    
   97|    160|    return true;
   98|    160|}
   99|       |
  100|       |bool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)
  101|     36|{
  102|     36|#ifndef PB_BUFFER_ONLY
  103|     36|	if (buf == NULL && stream->callback != buf_read)
  104|      0|	{
  105|      0|		/* Skip input bytes */
  106|      0|		pb_byte_t tmp[16];
  107|      0|		while (count > 16)
  108|      0|		{
  109|      0|			if (!pb_read(stream, tmp, 16))
  110|      0|				return false;
  111|      0|			
  112|      0|			count -= 16;
  113|      0|		}
  114|      0|		
  115|      0|		return pb_read(stream, tmp, count);
  116|     36|	}
  117|     36|#endif
  118|     36|
  119|     36|    if (stream->bytes_left < count)
  120|     36|        PB_RETURN_ERROR(stream, "end-of-stream");
  121|     36|    
  122|     36|#ifndef PB_BUFFER_ONLY
  123|     36|    if (!stream->callback(stream, buf, count))
  124|     36|        PB_RETURN_ERROR(stream, "io error");
  125|       |#else
  126|       |    if (!buf_read(stream, buf, count))
  127|       |        return false;
  128|       |#endif
  129|       |    
  130|     36|    stream->bytes_left -= count;
  131|     36|    return true;
  132|     36|}
  133|       |
  134|       |/* Read a single byte from input stream. buf may not be NULL.
  135|       | * This is an optimization for the varint decoding. */
  136|       |static bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)
  137|    124|{
  138|    124|    if (stream->bytes_left == 0)
  139|    124|        PB_RETURN_ERROR(stream, "end-of-stream");
  140|    124|
  141|    124|#ifndef PB_BUFFER_ONLY
  142|    124|    if (!stream->callback(stream, buf, 1))
  143|    124|        PB_RETURN_ERROR(stream, "io error");
  144|       |#else
  145|       |    *buf = *(const pb_byte_t*)stream->state;
  146|       |    stream->state = (pb_byte_t*)stream->state + 1;
  147|       |#endif
  148|       |
  149|    124|    stream->bytes_left--;
  150|    124|    
  151|    124|    return true;    
  152|    124|}
  153|       |
  154|       |pb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize)
  155|     18|{
  156|     18|    pb_istream_t stream;
  157|     18|    /* Cast away the const from buf without a compiler error.  We are
  158|     18|     * careful to use it only in a const manner in the callbacks.
  159|     18|     */
  160|     18|    union {
  161|     18|        void *state;
  162|     18|        const void *c_state;
  163|     18|    } state;
  164|       |#ifdef PB_BUFFER_ONLY
  165|       |    stream.callback = NULL;
  166|       |#else
  167|       |    stream.callback = &buf_read;
  168|     18|#endif
  169|     18|    state.c_state = buf;
  170|     18|    stream.state = state.state;
  171|     18|    stream.bytes_left = bufsize;
  172|     18|#ifndef PB_NO_ERRMSG
  173|     18|    stream.errmsg = NULL;
  174|     18|#endif
  175|     18|    return stream;
  176|     18|}
  177|       |
  178|       |/********************
  179|       | * Helper functions *
  180|       | ********************/
  181|       |
  182|       |static bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof)
  183|     88|{
  184|     88|    pb_byte_t byte;
  185|     88|    uint32_t result;
  186|     88|    
  187|     88|    if (!pb_readbyte(stream, &byte))
  188|      0|    {
  189|      0|        if (stream->bytes_left == 0)
  190|      0|        {
  191|      0|            if (eof)
  192|      0|            {
  193|      0|                *eof = true;
  194|      0|            }
  195|      0|        }
  196|      0|
  197|      0|        return false;
  198|      0|    }
  199|     88|    
  200|     88|    if ((byte & 0x80) == 0)
  201|     88|    {
  202|     88|        /* Quick case, 1 byte value */
  203|     88|        result = byte;
  204|     88|    }
  205|      0|    else
  206|      0|    {
  207|      0|        /* Multibyte case */
  208|      0|        uint_fast8_t bitpos = 7;
  209|      0|        result = byte & 0x7F;
  210|      0|        
  211|      0|        do
  212|      0|        {
  213|      0|            if (!pb_readbyte(stream, &byte))
  214|      0|                return false;
  215|      0|            
  216|      0|            if (bitpos >= 32)
  217|      0|            {
  218|      0|                /* Note: The varint could have trailing 0x80 bytes, or 0xFF for negative. */
  219|      0|                uint8_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;
  220|      0|                
  221|      0|                if ((byte & 0x7F) != 0x00 && ((result >> 31) == 0 || byte != sign_extension))
  222|      0|                {
  223|      0|                    PB_RETURN_ERROR(stream, "varint overflow");
  224|      0|                }
  225|      0|            }
  226|      0|            else
  227|      0|            {
  228|      0|                result |= (uint32_t)(byte & 0x7F) << bitpos;
  229|      0|            }
  230|      0|            bitpos = (uint_fast8_t)(bitpos + 7);
  231|      0|        } while (byte & 0x80);
  232|      0|        
  233|      0|        if (bitpos == 35 && (byte & 0x70) != 0)
  234|      0|        {
  235|      0|            /* The last byte was at bitpos=28, so only bottom 4 bits fit. */
  236|      0|            PB_RETURN_ERROR(stream, "varint overflow");
  237|      0|        }
  238|     88|   }
  239|     88|   
  240|     88|   *dest = result;
  241|     88|   return true;
  242|     88|}
  243|       |
  244|       |bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)
  245|     36|{
  246|     36|    return pb_decode_varint32_eof(stream, dest, NULL);
  247|     36|}
  248|       |
  249|       |#ifndef PB_WITHOUT_64BIT
  250|       |bool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)
  251|     16|{
  252|     16|    pb_byte_t byte;
  253|     16|    uint_fast8_t bitpos = 0;
  254|     16|    uint64_t result = 0;
  255|     16|    
  256|     16|    do
  257|     36|    {
  258|     36|        if (bitpos >= 64)
  259|     36|            PB_RETURN_ERROR(stream, "varint overflow");
  260|     36|        
  261|     36|        if (!pb_readbyte(stream, &byte))
  262|      0|            return false;
  263|     36|
  264|     36|        result |= (uint64_t)(byte & 0x7F) << bitpos;
  265|     36|        bitpos = (uint_fast8_t)(bitpos + 7);
  266|     36|    } while (byte & 0x80);
  267|     16|    
  268|     16|    *dest = result;
  269|     16|    return true;
  270|     16|}
  271|       |#endif
  272|       |
  273|       |bool checkreturn pb_skip_varint(pb_istream_t *stream)
  274|      0|{
  275|      0|    pb_byte_t byte;
  276|      0|    do
  277|      0|    {
  278|      0|        if (!pb_read(stream, &byte, 1))
  279|      0|            return false;
  280|      0|    } while (byte & 0x80);
  281|      0|    return true;
  282|      0|}
  283|       |
  284|       |bool checkreturn pb_skip_string(pb_istream_t *stream)
  285|      0|{
  286|      0|    uint32_t length;
  287|      0|    if (!pb_decode_varint32(stream, &length))
  288|      0|        return false;
  289|      0|    
  290|      0|    return pb_read(stream, NULL, length);
  291|      0|}
  292|       |
  293|       |bool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)
  294|     52|{
  295|     52|    uint32_t temp;
  296|     52|    *eof = false;
  297|     52|    *wire_type = (pb_wire_type_t) 0;
  298|     52|    *tag = 0;
  299|     52|    
  300|     52|    if (!pb_decode_varint32_eof(stream, &temp, eof))
  301|      0|    {
  302|      0|        return false;
  303|      0|    }
  304|     52|    
  305|     52|    if (temp == 0)
  306|      0|    {
  307|      0|        *eof = true; /* Special feature: allow 0-terminated messages. */
  308|      0|        return false;
  309|      0|    }
  310|     52|    
  311|     52|    *tag = temp >> 3;
  312|     52|    *wire_type = (pb_wire_type_t)(temp & 7);
  313|     52|    return true;
  314|     52|}
  315|       |
  316|       |bool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)
  317|      0|{
  318|      0|    switch (wire_type)
  319|      0|    {
  320|      0|        case PB_WT_VARINT: return pb_skip_varint(stream);
  321|      0|        case PB_WT_64BIT: return pb_read(stream, NULL, 8);
  322|      0|        case PB_WT_STRING: return pb_skip_string(stream);
  323|      0|        case PB_WT_32BIT: return pb_read(stream, NULL, 4);
  324|      0|        default: PB_RETURN_ERROR(stream, "invalid wire_type");
  325|      0|    }
  326|      0|}
  327|       |
  328|       |/* Read a raw value to buffer, for the purpose of passing it to callback as
  329|       | * a substream. Size is maximum size on call, and actual size on return.
  330|       | */
  331|       |static bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)
  332|      0|{
  333|      0|    size_t max_size = *size;
  334|      0|    switch (wire_type)
  335|      0|    {
  336|      0|        case PB_WT_VARINT:
  337|      0|            *size = 0;
  338|      0|            do
  339|      0|            {
  340|      0|                (*size)++;
  341|      0|                if (*size > max_size) return false;
  342|      0|                if (!pb_read(stream, buf, 1)) return false;
  343|      0|            } while (*buf++ & 0x80);
  344|      0|            return true;
  345|      0|            
  346|      0|        case PB_WT_64BIT:
  347|      0|            *size = 8;
  348|      0|            return pb_read(stream, buf, 8);
  349|      0|        
  350|      0|        case PB_WT_32BIT:
  351|      0|            *size = 4;
  352|      0|            return pb_read(stream, buf, 4);
  353|      0|        
  354|      0|        case PB_WT_STRING:
  355|      0|            /* Calling read_raw_value with a PB_WT_STRING is an error.
  356|      0|             * Explicitly handle this case and fallthrough to default to avoid
  357|      0|             * compiler warnings.
  358|      0|             */
  359|      0|
  360|      0|        default: PB_RETURN_ERROR(stream, "invalid wire_type");
  361|      0|    }
  362|      0|}
  363|       |
  364|       |/* Decode string length from stream and return a substream with limited length.
  365|       | * Remember to close the substream using pb_close_string_substream().
  366|       | */
  367|       |bool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)
  368|     36|{
  369|     36|    uint32_t size;
  370|     36|    if (!pb_decode_varint32(stream, &size))
  371|      0|        return false;
  372|     36|    
  373|     36|    *substream = *stream;
  374|     36|    if (substream->bytes_left < size)
  375|     36|        PB_RETURN_ERROR(stream, "parent stream too short");
  376|     36|    
  377|     36|    substream->bytes_left = size;
  378|     36|    stream->bytes_left -= size;
  379|     36|    return true;
  380|     36|}
  381|       |
  382|       |bool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)
  383|     36|{
  384|     36|    if (substream->bytes_left) {
  385|      0|        if (!pb_read(substream, NULL, substream->bytes_left))
  386|      0|            return false;
  387|     36|    }
  388|     36|
  389|     36|    stream->state = substream->state;
  390|     36|
  391|     36|#ifndef PB_NO_ERRMSG
  392|     36|    stream->errmsg = substream->errmsg;
  393|     36|#endif
  394|     36|    return true;
  395|     36|}
  396|       |
  397|       |/*************************
  398|       | * Decode a single field *
  399|       | *************************/
  400|       |
  401|       |static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
  402|     16|{
  403|     16|    pb_type_t type;
  404|     16|    pb_decoder_t func;
  405|     16|    
  406|     16|    type = iter->pos->type;
  407|     16|    func = PB_DECODERS[PB_LTYPE(type)];
  408|     16|
  409|     16|    switch (PB_HTYPE(type))
  410|     16|    {
  411|     16|        case PB_HTYPE_REQUIRED:
  412|      0|            return func(stream, iter->pos, iter->pData);
  413|     16|            
  414|     16|        case PB_HTYPE_OPTIONAL:
  415|     16|            if (iter->pSize != iter->pData)
  416|     16|                *(bool*)iter->pSize = true;
  417|     16|            return func(stream, iter->pos, iter->pData);
  418|     16|    
  419|     16|        case PB_HTYPE_REPEATED:
  420|      0|            if (wire_type == PB_WT_STRING
  421|      0|                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
  422|      0|            {
  423|      0|                /* Packed array */
  424|      0|                bool status = true;
  425|      0|                pb_size_t *size = (pb_size_t*)iter->pSize;
  426|      0|
  427|      0|                pb_istream_t substream;
  428|      0|                if (!pb_make_string_substream(stream, &substream))
  429|      0|                    return false;
  430|      0|
  431|      0|                while (substream.bytes_left > 0 && *size < iter->pos->array_size)
  432|      0|                {
  433|      0|                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);
  434|      0|                    if (!func(&substream, iter->pos, pItem))
  435|      0|                    {
  436|      0|                        status = false;
  437|      0|                        break;
  438|      0|                    }
  439|      0|                    (*size)++;
  440|      0|                }
  441|      0|
  442|      0|                if (substream.bytes_left != 0)
  443|      0|                    PB_RETURN_ERROR(stream, "array overflow");
  444|      0|                if (!pb_close_string_substream(stream, &substream))
  445|      0|                    return false;
  446|      0|
  447|      0|                return status;
  448|      0|            }
  449|      0|            else
  450|      0|            {
  451|      0|                /* Repeated field */
  452|      0|                pb_size_t *size = (pb_size_t*)iter->pSize;
  453|      0|                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);
  454|      0|
  455|      0|                if ((*size)++ >= iter->pos->array_size)
  456|      0|                    PB_RETURN_ERROR(stream, "array overflow");
  457|      0|
  458|      0|                return func(stream, iter->pos, pItem);
  459|      0|            }
  460|      0|
  461|      0|        case PB_HTYPE_ONEOF:
  462|      0|            *(pb_size_t*)iter->pSize = iter->pos->tag;
  463|      0|            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
  464|      0|            {
  465|      0|                /* We memset to zero so that any callbacks are set to NULL.
  466|      0|                 * Then set any default values. */
  467|      0|                memset(iter->pData, 0, iter->pos->data_size);
  468|      0|                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);
  469|      0|            }
  470|      0|            return func(stream, iter->pos, iter->pData);
  471|      0|
  472|      0|        default:
  473|      0|            PB_RETURN_ERROR(stream, "invalid field type");
  474|     16|    }
  475|     16|}
  476|       |
  477|       |#ifdef PB_ENABLE_MALLOC
  478|       |/* Allocate storage for the field and store the pointer at iter->pData.
  479|       | * array_size is the number of entries to reserve in an array.
  480|       | * Zero size is not allowed, use pb_free() for releasing.
  481|       | */
  482|       |static bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)
  483|      0|{    
  484|      0|    void *ptr = *(void**)pData;
  485|      0|    
  486|      0|    if (data_size == 0 || array_size == 0)
  487|      0|        PB_RETURN_ERROR(stream, "invalid size");
  488|      0|    
  489|      0|    /* Check for multiplication overflows.
  490|      0|     * This code avoids the costly division if the sizes are small enough.
  491|      0|     * Multiplication is safe as long as only half of bits are set
  492|      0|     * in either multiplicand.
  493|      0|     */
  494|      0|    {
  495|      0|        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);
  496|      0|        if (data_size >= check_limit || array_size >= check_limit)
  497|      0|        {
  498|      0|            const size_t size_max = (size_t)-1;
  499|      0|            if (size_max / array_size < data_size)
  500|      0|            {
  501|      0|                PB_RETURN_ERROR(stream, "size too large");
  502|      0|            }
  503|      0|        }
  504|      0|    }
  505|      0|    
  506|      0|    /* Allocate new or expand previous allocation */
  507|      0|    /* Note: on failure the old pointer will remain in the structure,
  508|      0|     * the message must be freed by caller also on error return. */
  509|      0|    ptr = pb_realloc(ptr, array_size * data_size);
  510|      0|    if (ptr == NULL)
  511|      0|        PB_RETURN_ERROR(stream, "realloc failed");
  512|      0|    
  513|      0|    *(void**)pData = ptr;
  514|      0|    return true;
  515|      0|}
  516|       |
  517|       |/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */
  518|       |static void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)
  519|      0|{
  520|      0|    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||
  521|      0|        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)
  522|      0|    {
  523|      0|        *(void**)pItem = NULL;
  524|      0|    }
  525|      0|    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)
  526|      0|    {
  527|      0|        /* We memset to zero so that any callbacks are set to NULL.
  528|      0|         * Then set any default values. */
  529|      0|        memset(pItem, 0, iter->pos->data_size);
  530|      0|        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);
  531|      0|    }
  532|      0|}
  533|       |#endif
  534|       |
  535|       |static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
  536|      0|{
  537|       |#ifndef PB_ENABLE_MALLOC
  538|       |    PB_UNUSED(wire_type);
  539|       |    PB_UNUSED(iter);
  540|       |    PB_RETURN_ERROR(stream, "no malloc support");
  541|       |#else
  542|       |    pb_type_t type;
  543|      0|    pb_decoder_t func;
  544|      0|    
  545|      0|    type = iter->pos->type;
  546|      0|    func = PB_DECODERS[PB_LTYPE(type)];
  547|      0|    
  548|      0|    switch (PB_HTYPE(type))
  549|      0|    {
  550|      0|        case PB_HTYPE_REQUIRED:
  551|      0|        case PB_HTYPE_OPTIONAL:
  552|      0|        case PB_HTYPE_ONEOF:
  553|      0|            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&
  554|      0|                *(void**)iter->pData != NULL)
  555|      0|            {
  556|      0|                /* Duplicate field, have to release the old allocation first. */
  557|      0|                pb_release_single_field(iter);
  558|      0|            }
  559|      0|        
  560|      0|            if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
  561|      0|            {
  562|      0|                *(pb_size_t*)iter->pSize = iter->pos->tag;
  563|      0|            }
  564|      0|
  565|      0|            if (PB_LTYPE(type) == PB_LTYPE_STRING ||
  566|      0|                PB_LTYPE(type) == PB_LTYPE_BYTES)
  567|      0|            {
  568|      0|                return func(stream, iter->pos, iter->pData);
  569|      0|            }
  570|      0|            else
  571|      0|            {
  572|      0|                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))
  573|      0|                    return false;
  574|      0|                
  575|      0|                initialize_pointer_field(*(void**)iter->pData, iter);
  576|      0|                return func(stream, iter->pos, *(void**)iter->pData);
  577|      0|            }
  578|      0|    
  579|      0|        case PB_HTYPE_REPEATED:
  580|      0|            if (wire_type == PB_WT_STRING
  581|      0|                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
  582|      0|            {
  583|      0|                /* Packed array, multiple items come in at once. */
  584|      0|                bool status = true;
  585|      0|                pb_size_t *size = (pb_size_t*)iter->pSize;
  586|      0|                size_t allocated_size = *size;
  587|      0|                void *pItem;
  588|      0|                pb_istream_t substream;
  589|      0|                
  590|      0|                if (!pb_make_string_substream(stream, &substream))
  591|      0|                    return false;
  592|      0|                
  593|      0|                while (substream.bytes_left)
  594|      0|                {
  595|      0|                    if ((size_t)*size + 1 > allocated_size)
  596|      0|                    {
  597|      0|                        /* Allocate more storage. This tries to guess the
  598|      0|                         * number of remaining entries. Round the division
  599|      0|                         * upwards. */
  600|      0|                        allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;
  601|      0|                        
  602|      0|                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))
  603|      0|                        {
  604|      0|                            status = false;
  605|      0|                            break;
  606|      0|                        }
  607|      0|                    }
  608|      0|
  609|      0|                    /* Decode the array entry */
  610|      0|                    pItem = *(char**)iter->pData + iter->pos->data_size * (*size);
  611|      0|                    initialize_pointer_field(pItem, iter);
  612|      0|                    if (!func(&substream, iter->pos, pItem))
  613|      0|                    {
  614|      0|                        status = false;
  615|      0|                        break;
  616|      0|                    }
  617|      0|                    
  618|      0|                    if (*size == PB_SIZE_MAX)
  619|      0|                    {
  620|      0|#ifndef PB_NO_ERRMSG
  621|      0|                        stream->errmsg = "too many array entries";
  622|      0|#endif
  623|      0|                        status = false;
  624|      0|                        break;
  625|      0|                    }
  626|      0|                    
  627|      0|                    (*size)++;
  628|      0|                }
  629|      0|                if (!pb_close_string_substream(stream, &substream))
  630|      0|                    return false;
  631|      0|                
  632|      0|                return status;
  633|      0|            }
  634|      0|            else
  635|      0|            {
  636|      0|                /* Normal repeated field, i.e. only one item at a time. */
  637|      0|                pb_size_t *size = (pb_size_t*)iter->pSize;
  638|      0|                void *pItem;
  639|      0|                
  640|      0|                if (*size == PB_SIZE_MAX)
  641|      0|                    PB_RETURN_ERROR(stream, "too many array entries");
  642|      0|                
  643|      0|                (*size)++;
  644|      0|                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))
  645|      0|                    return false;
  646|      0|            
  647|      0|                pItem = *(char**)iter->pData + iter->pos->data_size * (*size - 1);
  648|      0|                initialize_pointer_field(pItem, iter);
  649|      0|                return func(stream, iter->pos, pItem);
  650|      0|            }
  651|      0|
  652|      0|        default:
  653|      0|            PB_RETURN_ERROR(stream, "invalid field type");
  654|      0|    }
  655|      0|#endif
  656|      0|}
  657|       |
  658|       |static bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
  659|     36|{
  660|     36|    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;
  661|     36|    
  662|       |#ifdef PB_OLD_CALLBACK_STYLE
  663|       |    void *arg = pCallback->arg;
  664|       |#else
  665|       |    void **arg = &(pCallback->arg);
  666|     36|#endif
  667|     36|    
  668|     36|    if (pCallback == NULL || pCallback->funcs.decode == NULL)
  669|     36|        return pb_skip_field(stream, wire_type);
  670|     36|    
  671|     36|    if (wire_type == PB_WT_STRING)
  672|     36|    {
  673|     36|        pb_istream_t substream;
  674|     36|        
  675|     36|        if (!pb_make_string_substream(stream, &substream))
  676|      0|            return false;
  677|     36|        
  678|     36|        do
  679|     36|        {
  680|     36|            if (!pCallback->funcs.decode(&substream, iter->pos, arg))
  681|     36|                PB_RETURN_ERROR(stream, "callback failed");
  682|     36|        } while (substream.bytes_left);
  683|     36|        
  684|     36|        if (!pb_close_string_substream(stream, &substream))
  685|      0|            return false;
  686|     36|
  687|     36|        return true;
  688|     36|    }
  689|      0|    else
  690|      0|    {
  691|      0|        /* Copy the single scalar value to stack.
  692|      0|         * This is required so that we can limit the stream length,
  693|      0|         * which in turn allows to use same callback for packed and
  694|      0|         * not-packed fields. */
  695|      0|        pb_istream_t substream;
  696|      0|        pb_byte_t buffer[10];
  697|      0|        size_t size = sizeof(buffer);
  698|      0|        
  699|      0|        if (!read_raw_value(stream, wire_type, buffer, &size))
  700|      0|            return false;
  701|      0|        substream = pb_istream_from_buffer(buffer, size);
  702|      0|        
  703|      0|        return pCallback->funcs.decode(&substream, iter->pos, arg);
  704|      0|    }
  705|     36|}
  706|       |
  707|       |static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
  708|     52|{
  709|     52|#ifdef PB_ENABLE_MALLOC
  710|     52|    /* When decoding an oneof field, check if there is old data that must be
  711|     52|     * released first. */
  712|     52|    if (PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)
  713|     52|    {
  714|      0|        if (!pb_release_union_field(stream, iter))
  715|      0|            return false;
  716|     52|    }
  717|     52|#endif
  718|     52|
  719|     52|    switch (PB_ATYPE(iter->pos->type))
  720|     52|    {
  721|     52|        case PB_ATYPE_STATIC:
  722|     16|            return decode_static_field(stream, wire_type, iter);
  723|     52|        
  724|     52|        case PB_ATYPE_POINTER:
  725|      0|            return decode_pointer_field(stream, wire_type, iter);
  726|     52|        
  727|     52|        case PB_ATYPE_CALLBACK:
  728|     36|            return decode_callback_field(stream, wire_type, iter);
  729|     52|        
  730|     52|        default:
  731|      0|            PB_RETURN_ERROR(stream, "invalid field type");
  732|     52|    }
  733|     52|}
  734|       |
  735|       |static void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension)
  736|      0|{
  737|      0|    /* Fake a field iterator for the extension field.
  738|      0|     * It is not actually safe to advance this iterator, but decode_field
  739|      0|     * will not even try to. */
  740|      0|    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
  741|      0|    (void)pb_field_iter_begin(iter, field, extension->dest);
  742|      0|    iter->pData = extension->dest;
  743|      0|    iter->pSize = &extension->found;
  744|      0|    
  745|      0|    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
  746|      0|    {
  747|      0|        /* For pointer extensions, the pointer is stored directly
  748|      0|         * in the extension structure. This avoids having an extra
  749|      0|         * indirection. */
  750|      0|        iter->pData = &extension->dest;
  751|      0|    }
  752|      0|}
  753|       |
  754|       |/* Default handler for extension fields. Expects a pb_field_t structure
  755|       | * in extension->type->arg. */
  756|       |static bool checkreturn default_extension_decoder(pb_istream_t *stream,
  757|       |    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)
  758|      0|{
  759|      0|    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
  760|      0|    pb_field_iter_t iter;
  761|      0|    
  762|      0|    if (field->tag != tag)
  763|      0|        return true;
  764|      0|    
  765|      0|    iter_from_extension(&iter, extension);
  766|      0|    extension->found = true;
  767|      0|    return decode_field(stream, wire_type, &iter);
  768|      0|}
  769|       |
  770|       |/* Try to decode an unknown field as an extension field. Tries each extension
  771|       | * decoder in turn, until one of them handles the field or loop ends. */
  772|       |static bool checkreturn decode_extension(pb_istream_t *stream,
  773|       |    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)
  774|      0|{
  775|      0|    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;
  776|      0|    size_t pos = stream->bytes_left;
  777|      0|    
  778|      0|    while (extension != NULL && pos == stream->bytes_left)
  779|      0|    {
  780|      0|        bool status;
  781|      0|        if (extension->type->decode)
  782|      0|            status = extension->type->decode(stream, extension, tag, wire_type);
  783|      0|        else
  784|      0|            status = default_extension_decoder(stream, extension, tag, wire_type);
  785|      0|
  786|      0|        if (!status)
  787|      0|            return false;
  788|      0|        
  789|      0|        extension = extension->next;
  790|      0|    }
  791|      0|    
  792|      0|    return true;
  793|      0|}
  794|       |
  795|       |/* Step through the iterator until an extension field is found or until all
  796|       | * entries have been checked. There can be only one extension field per
  797|       | * message. Returns false if no extension field is found. */
  798|       |static bool checkreturn find_extension_field(pb_field_iter_t *iter)
  799|      0|{
  800|      0|    const pb_field_t *start = iter->pos;
  801|      0|    
  802|      0|    do {
  803|      0|        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)
  804|      0|            return true;
  805|      0|        (void)pb_field_iter_next(iter);
  806|      0|    } while (iter->pos != start);
  807|      0|    
  808|      0|    return false;
  809|      0|}
  810|       |
  811|       |/* Initialize message fields to default values, recursively */
  812|       |static void pb_field_set_to_default(pb_field_iter_t *iter)
  813|     63|{
  814|     63|    pb_type_t type;
  815|     63|    type = iter->pos->type;
  816|     63|    
  817|     63|    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)
  818|     63|    {
  819|      0|        pb_extension_t *ext = *(pb_extension_t* const *)iter->pData;
  820|      0|        while (ext != NULL)
  821|      0|        {
  822|      0|            pb_field_iter_t ext_iter;
  823|      0|            ext->found = false;
  824|      0|            iter_from_extension(&ext_iter, ext);
  825|      0|            pb_field_set_to_default(&ext_iter);
  826|      0|            ext = ext->next;
  827|      0|        }
  828|      0|    }
  829|     63|    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)
  830|     63|    {
  831|     28|        bool init_data = true;
  832|     28|        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && iter->pSize != iter->pData)
  833|     28|        {
  834|     28|            /* Set has_field to false. Still initialize the optional field
  835|     28|             * itself also. */
  836|     28|            *(bool*)iter->pSize = false;
  837|     28|        }
  838|      0|        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||
  839|      0|                 PB_HTYPE(type) == PB_HTYPE_ONEOF)
  840|      0|        {
  841|      0|            /* REPEATED: Set array count to 0, no need to initialize contents.
  842|      0|               ONEOF: Set which_field to 0. */
  843|      0|            *(pb_size_t*)iter->pSize = 0;
  844|      0|            init_data = false;
  845|      0|        }
  846|     28|
  847|     28|        if (init_data)
  848|     28|        {
  849|     28|            if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)
  850|     28|            {
  851|      0|                /* Initialize submessage to defaults */
  852|      0|                pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, iter->pData);
  853|      0|            }
  854|     28|            else if (iter->pos->ptr != NULL)
  855|     28|            {
  856|      2|                /* Initialize to default value */
  857|      2|                memcpy(iter->pData, iter->pos->ptr, iter->pos->data_size);
  858|      2|            }
  859|     26|            else
  860|     26|            {
  861|     26|                /* Initialize to zeros */
  862|     26|                memset(iter->pData, 0, iter->pos->data_size);
  863|     26|            }
  864|     28|        }
  865|     28|    }
  866|     35|    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)
  867|     35|    {
  868|      0|        /* Initialize the pointer to NULL. */
  869|      0|        *(void**)iter->pData = NULL;
  870|      0|        
  871|      0|        /* Initialize array count to 0. */
  872|      0|        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||
  873|      0|            PB_HTYPE(type) == PB_HTYPE_ONEOF)
  874|      0|        {
  875|      0|            *(pb_size_t*)iter->pSize = 0;
  876|      0|        }
  877|      0|    }
  878|     35|    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)
  879|     35|    {
  880|     35|        /* Don't overwrite callback */
  881|     35|    }
  882|     63|}
  883|       |
  884|       |static void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)
  885|     18|{
  886|     18|    pb_field_iter_t iter;
  887|     18|
  888|     18|    if (!pb_field_iter_begin(&iter, fields, dest_struct))
  889|      0|        return; /* Empty message type */
  890|     18|    
  891|     18|    do
  892|     63|    {
  893|     63|        pb_field_set_to_default(&iter);
  894|     63|    } while (pb_field_iter_next(&iter));
  895|     18|}
  896|       |
  897|       |/*********************
  898|       | * Decode all fields *
  899|       | *********************/
  900|       |
  901|       |bool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
  902|     18|{
  903|     18|    uint32_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 31) / 32] = {0, 0};
  904|     18|    const uint32_t allbits = ~(uint32_t)0;
  905|     18|    uint32_t extension_range_start = 0;
  906|     18|    pb_field_iter_t iter;
  907|     18|
  908|     18|    /* 'fixed_count_field' and 'fixed_count_size' track position of a repeated fixed
  909|     18|     * count field. This can only handle _one_ repeated fixed count field that
  910|     18|     * is unpacked and unordered among other (non repeated fixed count) fields.
  911|     18|     */
  912|     18|    const pb_field_t *fixed_count_field = NULL;
  913|     18|    pb_size_t fixed_count_size = 0;
  914|     18|
  915|     18|    /* Return value ignored, as empty message types will be correctly handled by
  916|     18|     * pb_field_iter_find() anyway. */
  917|     18|    (void)pb_field_iter_begin(&iter, fields, dest_struct);
  918|     18|
  919|     70|    while (stream->bytes_left)
  920|     52|    {
  921|     52|        uint32_t tag;
  922|     52|        pb_wire_type_t wire_type;
  923|     52|        bool eof;
  924|     52|
  925|     52|        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))
  926|      0|        {
  927|      0|            if (eof)
  928|      0|                break;
  929|      0|            else
  930|      0|                return false;
  931|     52|        }
  932|     52|
  933|     52|        if (!pb_field_iter_find(&iter, tag))
  934|      0|        {
  935|      0|            /* No match found, check if it matches an extension. */
  936|      0|            if (tag >= extension_range_start)
  937|      0|            {
  938|      0|                if (!find_extension_field(&iter))
  939|      0|                    extension_range_start = (uint32_t)-1;
  940|      0|                else
  941|      0|                    extension_range_start = iter.pos->tag;
  942|      0|
  943|      0|                if (tag >= extension_range_start)
  944|      0|                {
  945|      0|                    size_t pos = stream->bytes_left;
  946|      0|
  947|      0|                    if (!decode_extension(stream, tag, wire_type, &iter))
  948|      0|                        return false;
  949|      0|
  950|      0|                    if (pos != stream->bytes_left)
  951|      0|                    {
  952|      0|                        /* The field was handled */
  953|      0|                        continue;
  954|      0|                    }
  955|      0|                }
  956|      0|            }
  957|      0|
  958|      0|            /* No match found, skip data */
  959|      0|            if (!pb_skip_field(stream, wire_type))
  960|      0|                return false;
  961|      0|            continue;
  962|      0|        }
  963|     52|
  964|     52|        /* If a repeated fixed count field was found, get size from
  965|     52|         * 'fixed_count_field' as there is no counter contained in the struct.
  966|     52|         */
  967|     52|        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REPEATED
  968|     52|            && iter.pSize == iter.pData)
  969|     12|        {
  970|     12|            if (fixed_count_field != iter.pos) {
  971|     12|                /* If the new fixed count field does not match the previous one,
  972|     12|                 * check that the previous one is NULL or that it finished
  973|     12|                 * receiving all the expected data.
  974|     12|                 */
  975|     12|                if (fixed_count_field != NULL &&
  976|     12|                    fixed_count_size != fixed_count_field->array_size)
  977|      0|                {
  978|      0|                    PB_RETURN_ERROR(stream, "wrong size for fixed count field");
  979|      0|                }
  980|     12|
  981|     12|                fixed_count_field = iter.pos;
  982|     12|                fixed_count_size = 0;
  983|     12|            }
  984|     12|
  985|     12|            iter.pSize = &fixed_count_size;
  986|     12|        }
  987|     52|
  988|     52|        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED
  989|     52|            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)
  990|     52|        {
  991|      0|            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));
  992|      0|            fields_seen[iter.required_field_index >> 5] |= tmp;
  993|      0|        }
  994|     52|
  995|     52|        if (!decode_field(stream, wire_type, &iter))
  996|      0|            return false;
  997|     52|    }
  998|     18|
  999|     18|    /* Check that all elements of the last decoded fixed count field were present. */
 1000|     18|    if (fixed_count_field != NULL &&
 1001|     18|        fixed_count_size != fixed_count_field->array_size)
 1002|      0|    {
 1003|      0|        PB_RETURN_ERROR(stream, "wrong size for fixed count field");
 1004|      0|    }
 1005|     18|
 1006|     18|    /* Check that all required fields were present. */
 1007|     18|    {
 1008|     18|        /* First figure out the number of required fields by
 1009|     18|         * seeking to the end of the field array. Usually we
 1010|     18|         * are already close to end after decoding.
 1011|     18|         */
 1012|     18|        unsigned req_field_count;
 1013|     18|        pb_type_t last_type;
 1014|     18|        unsigned i;
 1015|     21|        do {
 1016|     21|            req_field_count = iter.required_field_index;
 1017|     21|            last_type = iter.pos->type;
 1018|     21|        } while (pb_field_iter_next(&iter));
 1019|     18|        
 1020|     18|        /* Fixup if last field was also required. */
 1021|     18|        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)
 1022|      0|            req_field_count++;
 1023|     18|        
 1024|     18|        if (req_field_count > PB_MAX_REQUIRED_FIELDS)
 1025|     18|            req_field_count = PB_MAX_REQUIRED_FIELDS;
 1026|     18|
 1027|     18|        if (req_field_count > 0)
 1028|      0|        {
 1029|      0|            /* Check the whole words */
 1030|      0|            for (i = 0; i < (req_field_count >> 5); i++)
 1031|      0|            {
 1032|      0|                if (fields_seen[i] != allbits)
 1033|      0|                    PB_RETURN_ERROR(stream, "missing required field");
 1034|      0|            }
 1035|      0|            
 1036|      0|            /* Check the remaining bits (if any) */
 1037|      0|            if ((req_field_count & 31) != 0)
 1038|      0|            {
 1039|      0|                if (fields_seen[req_field_count >> 5] !=
 1040|      0|                    (allbits >> (32 - (req_field_count & 31))))
 1041|      0|                {
 1042|      0|                    PB_RETURN_ERROR(stream, "missing required field");
 1043|      0|                }
 1044|     18|            }
 1045|      0|        }
 1046|     18|    }
 1047|     18|    
 1048|     18|    return true;
 1049|     18|}
 1050|       |
 1051|       |bool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
 1052|     18|{
 1053|     18|    bool status;
 1054|     18|    pb_message_set_to_defaults(fields, dest_struct);
 1055|     18|    status = pb_decode_noinit(stream, fields, dest_struct);
 1056|     18|    
 1057|     18|#ifdef PB_ENABLE_MALLOC
 1058|     18|    if (!status)
 1059|      0|        pb_release(fields, dest_struct);
 1060|     18|#endif
 1061|     18|    
 1062|     18|    return status;
 1063|     18|}
 1064|       |
 1065|       |bool pb_decode_delimited_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
 1066|      0|{
 1067|      0|    pb_istream_t substream;
 1068|      0|    bool status;
 1069|      0|
 1070|      0|    if (!pb_make_string_substream(stream, &substream))
 1071|      0|        return false;
 1072|      0|
 1073|      0|    status = pb_decode_noinit(&substream, fields, dest_struct);
 1074|      0|
 1075|      0|    if (!pb_close_string_substream(stream, &substream))
 1076|      0|        return false;
 1077|      0|    return status;
 1078|      0|}
 1079|       |
 1080|       |bool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
 1081|      0|{
 1082|      0|    pb_istream_t substream;
 1083|      0|    bool status;
 1084|      0|    
 1085|      0|    if (!pb_make_string_substream(stream, &substream))
 1086|      0|        return false;
 1087|      0|    
 1088|      0|    status = pb_decode(&substream, fields, dest_struct);
 1089|      0|
 1090|      0|    if (!pb_close_string_substream(stream, &substream))
 1091|      0|        return false;
 1092|      0|    return status;
 1093|      0|}
 1094|       |
 1095|       |bool pb_decode_nullterminated(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
 1096|      0|{
 1097|      0|    /* This behaviour will be separated in nanopb-0.4.0, see issue #278. */
 1098|      0|    return pb_decode(stream, fields, dest_struct);
 1099|      0|}
 1100|       |
 1101|       |#ifdef PB_ENABLE_MALLOC
 1102|       |/* Given an oneof field, if there has already been a field inside this oneof,
 1103|       | * release it before overwriting with a different one. */
 1104|       |static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter)
 1105|      0|{
 1106|      0|    pb_size_t old_tag = *(pb_size_t*)iter->pSize; /* Previous which_ value */
 1107|      0|    pb_size_t new_tag = iter->pos->tag; /* New which_ value */
 1108|      0|
 1109|      0|    if (old_tag == 0)
 1110|      0|        return true; /* Ok, no old data in union */
 1111|      0|
 1112|      0|    if (old_tag == new_tag)
 1113|      0|        return true; /* Ok, old data is of same type => merge */
 1114|      0|
 1115|      0|    /* Release old data. The find can fail if the message struct contains
 1116|      0|     * invalid data. */
 1117|      0|    if (!pb_field_iter_find(iter, old_tag))
 1118|      0|        PB_RETURN_ERROR(stream, "invalid union tag");
 1119|      0|
 1120|      0|    pb_release_single_field(iter);
 1121|      0|
 1122|      0|    /* Restore iterator to where it should be.
 1123|      0|     * This shouldn't fail unless the pb_field_t structure is corrupted. */
 1124|      0|    if (!pb_field_iter_find(iter, new_tag))
 1125|      0|        PB_RETURN_ERROR(stream, "iterator error");
 1126|      0|    
 1127|      0|    return true;
 1128|      0|}
 1129|       |
 1130|       |static void pb_release_single_field(const pb_field_iter_t *iter)
 1131|     66|{
 1132|     66|    pb_type_t type;
 1133|     66|    type = iter->pos->type;
 1134|     66|
 1135|     66|    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
 1136|     66|    {
 1137|      0|        if (*(pb_size_t*)iter->pSize != iter->pos->tag)
 1138|      0|            return; /* This is not the current field in the union */
 1139|     66|    }
 1140|     66|
 1141|     66|    /* Release anything contained inside an extension or submsg.
 1142|     66|     * This has to be done even if the submsg itself is statically
 1143|     66|     * allocated. */
 1144|     66|    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)
 1145|     66|    {
 1146|      0|        /* Release fields from all extensions in the linked list */
 1147|      0|        pb_extension_t *ext = *(pb_extension_t**)iter->pData;
 1148|      0|        while (ext != NULL)
 1149|      0|        {
 1150|      0|            pb_field_iter_t ext_iter;
 1151|      0|            iter_from_extension(&ext_iter, ext);
 1152|      0|            pb_release_single_field(&ext_iter);
 1153|      0|            ext = ext->next;
 1154|      0|        }
 1155|      0|    }
 1156|     66|    else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
 1157|     66|    {
 1158|      5|        /* Release fields in submessage or submsg array */
 1159|      5|        void *pItem = iter->pData;
 1160|      5|        pb_size_t count = 1;
 1161|      5|        
 1162|      5|        if (PB_ATYPE(type) == PB_ATYPE_POINTER)
 1163|      5|        {
 1164|      2|            pItem = *(void**)iter->pData;
 1165|      2|        }
 1166|      5|        
 1167|      5|        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
 1168|      5|        {
 1169|      2|            if (PB_ATYPE(type) == PB_ATYPE_STATIC && iter->pSize == iter->pData) {
 1170|      0|                /* No _count field so use size of the array */
 1171|      0|                count = iter->pos->array_size;
 1172|      2|            } else {
 1173|      2|                count = *(pb_size_t*)iter->pSize;
 1174|      2|            }
 1175|      2|
 1176|      2|            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > iter->pos->array_size)
 1177|      0|            {
 1178|      0|                /* Protect against corrupted _count fields */
 1179|      0|                count = iter->pos->array_size;
 1180|      0|            }
 1181|      2|        }
 1182|      5|        
 1183|      5|        if (pItem)
 1184|      5|        {
 1185|     10|            while (count--)
 1186|      5|            {
 1187|      5|                pb_release((const pb_field_t*)iter->pos->ptr, pItem);
 1188|      5|                pItem = (char*)pItem + iter->pos->data_size;
 1189|      5|            }
 1190|      5|        }
 1191|      5|    }
 1192|     66|    
 1193|     66|    if (PB_ATYPE(type) == PB_ATYPE_POINTER)
 1194|     66|    {
 1195|     30|        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&
 1196|     30|            (PB_LTYPE(type) == PB_LTYPE_STRING ||
 1197|      4|             PB_LTYPE(type) == PB_LTYPE_BYTES))
 1198|      0|        {
 1199|      0|            /* Release entries in repeated string or bytes array */
 1200|      0|            void **pItem = *(void***)iter->pData;
 1201|      0|            pb_size_t count = *(pb_size_t*)iter->pSize;
 1202|      0|            while (count--)
 1203|      0|            {
 1204|      0|                pb_free(*pItem);
 1205|      0|                *pItem++ = NULL;
 1206|      0|            }
 1207|      0|        }
 1208|     30|        
 1209|     30|        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
 1210|     30|        {
 1211|      4|            /* We are going to release the array, so set the size to 0 */
 1212|      4|            *(pb_size_t*)iter->pSize = 0;
 1213|      4|        }
 1214|     30|        
 1215|     30|        /* Release main item */
 1216|     30|        pb_free(*(void**)iter->pData);
 1217|     30|        *(void**)iter->pData = NULL;
 1218|     30|    }
 1219|     66|}
 1220|       |
 1221|       |void pb_release(const pb_field_t fields[], void *dest_struct)
 1222|      8|{
 1223|      8|    pb_field_iter_t iter;
 1224|      8|    
 1225|      8|    if (!dest_struct)
 1226|      0|        return; /* Ignore NULL pointers, similar to free() */
 1227|      8|
 1228|      8|    if (!pb_field_iter_begin(&iter, fields, dest_struct))
 1229|      0|        return; /* Empty message type */
 1230|      8|    
 1231|      8|    do
 1232|     66|    {
 1233|     66|        pb_release_single_field(&iter);
 1234|     66|    } while (pb_field_iter_next(&iter));
 1235|      8|}
 1236|       |#endif
 1237|       |
 1238|       |/* Field decoders */
 1239|       |
 1240|       |bool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)
 1241|      0|{
 1242|      0|    pb_uint64_t value;
 1243|      0|    if (!pb_decode_varint(stream, &value))
 1244|      0|        return false;
 1245|      0|    
 1246|      0|    if (value & 1)
 1247|      0|        *dest = (pb_int64_t)(~(value >> 1));
 1248|      0|    else
 1249|      0|        *dest = (pb_int64_t)(value >> 1);
 1250|      0|    
 1251|      0|    return true;
 1252|      0|}
 1253|       |
 1254|       |bool pb_decode_fixed32(pb_istream_t *stream, void *dest)
 1255|      0|{
 1256|      0|    pb_byte_t bytes[4];
 1257|      0|
 1258|      0|    if (!pb_read(stream, bytes, 4))
 1259|      0|        return false;
 1260|      0|    
 1261|      0|    *(uint32_t*)dest = ((uint32_t)bytes[0] << 0) |
 1262|      0|                       ((uint32_t)bytes[1] << 8) |
 1263|      0|                       ((uint32_t)bytes[2] << 16) |
 1264|      0|                       ((uint32_t)bytes[3] << 24);
 1265|      0|    return true;
 1266|      0|}
 1267|       |
 1268|       |#ifndef PB_WITHOUT_64BIT
 1269|       |bool pb_decode_fixed64(pb_istream_t *stream, void *dest)
 1270|      0|{
 1271|      0|    pb_byte_t bytes[8];
 1272|      0|
 1273|      0|    if (!pb_read(stream, bytes, 8))
 1274|      0|        return false;
 1275|      0|    
 1276|      0|    *(uint64_t*)dest = ((uint64_t)bytes[0] << 0) |
 1277|      0|                       ((uint64_t)bytes[1] << 8) |
 1278|      0|                       ((uint64_t)bytes[2] << 16) |
 1279|      0|                       ((uint64_t)bytes[3] << 24) |
 1280|      0|                       ((uint64_t)bytes[4] << 32) |
 1281|      0|                       ((uint64_t)bytes[5] << 40) |
 1282|      0|                       ((uint64_t)bytes[6] << 48) |
 1283|      0|                       ((uint64_t)bytes[7] << 56);
 1284|      0|    
 1285|      0|    return true;
 1286|      0|}
 1287|       |#endif
 1288|       |
 1289|       |static bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1290|     16|{
 1291|     16|    pb_uint64_t value;
 1292|     16|    pb_int64_t svalue;
 1293|     16|    pb_int64_t clamped;
 1294|     16|    if (!pb_decode_varint(stream, &value))
 1295|      0|        return false;
 1296|     16|    
 1297|     16|    /* See issue 97: Google's C++ protobuf allows negative varint values to
 1298|     16|     * be cast as int32_t, instead of the int64_t that should be used when
 1299|     16|     * encoding. Previous nanopb versions had a bug in encoding. In order to
 1300|     16|     * not break decoding of such messages, we cast <=32 bit fields to
 1301|     16|     * int32_t first to get the sign correct.
 1302|     16|     */
 1303|     16|    if (field->data_size == sizeof(pb_int64_t))
 1304|      2|        svalue = (pb_int64_t)value;
 1305|     14|    else
 1306|     14|        svalue = (int32_t)value;
 1307|     16|
 1308|     16|    /* Cast to the proper field size, while checking for overflows */
 1309|     16|    if (field->data_size == sizeof(pb_int64_t))
 1310|      2|        clamped = *(pb_int64_t*)dest = svalue;
 1311|     14|    else if (field->data_size == sizeof(int32_t))
 1312|      6|        clamped = *(int32_t*)dest = (int32_t)svalue;
 1313|      8|    else if (field->data_size == sizeof(int_least16_t))
 1314|      0|        clamped = *(int_least16_t*)dest = (int_least16_t)svalue;
 1315|      8|    else if (field->data_size == sizeof(int_least8_t))
 1316|      8|        clamped = *(int_least8_t*)dest = (int_least8_t)svalue;
 1317|      8|    else
 1318|      8|        PB_RETURN_ERROR(stream, "invalid data_size");
 1319|     16|
 1320|     16|    if (clamped != svalue)
 1321|     16|        PB_RETURN_ERROR(stream, "integer too large");
 1322|     16|    
 1323|     16|    return true;
 1324|     16|}
 1325|       |
 1326|       |static bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1327|      0|{
 1328|      0|    pb_uint64_t value, clamped;
 1329|      0|    if (!pb_decode_varint(stream, &value))
 1330|      0|        return false;
 1331|      0|    
 1332|      0|    /* Cast to the proper field size, while checking for overflows */
 1333|      0|    if (field->data_size == sizeof(pb_uint64_t))
 1334|      0|        clamped = *(pb_uint64_t*)dest = value;
 1335|      0|    else if (field->data_size == sizeof(uint32_t))
 1336|      0|        clamped = *(uint32_t*)dest = (uint32_t)value;
 1337|      0|    else if (field->data_size == sizeof(uint_least16_t))
 1338|      0|        clamped = *(uint_least16_t*)dest = (uint_least16_t)value;
 1339|      0|    else if (field->data_size == sizeof(uint_least8_t))
 1340|      0|        clamped = *(uint_least8_t*)dest = (uint_least8_t)value;
 1341|      0|    else
 1342|      0|        PB_RETURN_ERROR(stream, "invalid data_size");
 1343|      0|    
 1344|      0|    if (clamped != value)
 1345|      0|        PB_RETURN_ERROR(stream, "integer too large");
 1346|      0|
 1347|      0|    return true;
 1348|      0|}
 1349|       |
 1350|       |static bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1351|      0|{
 1352|      0|    pb_int64_t value, clamped;
 1353|      0|    if (!pb_decode_svarint(stream, &value))
 1354|      0|        return false;
 1355|      0|    
 1356|      0|    /* Cast to the proper field size, while checking for overflows */
 1357|      0|    if (field->data_size == sizeof(pb_int64_t))
 1358|      0|        clamped = *(pb_int64_t*)dest = value;
 1359|      0|    else if (field->data_size == sizeof(int32_t))
 1360|      0|        clamped = *(int32_t*)dest = (int32_t)value;
 1361|      0|    else if (field->data_size == sizeof(int_least16_t))
 1362|      0|        clamped = *(int_least16_t*)dest = (int_least16_t)value;
 1363|      0|    else if (field->data_size == sizeof(int_least8_t))
 1364|      0|        clamped = *(int_least8_t*)dest = (int_least8_t)value;
 1365|      0|    else
 1366|      0|        PB_RETURN_ERROR(stream, "invalid data_size");
 1367|      0|
 1368|      0|    if (clamped != value)
 1369|      0|        PB_RETURN_ERROR(stream, "integer too large");
 1370|      0|    
 1371|      0|    return true;
 1372|      0|}
 1373|       |
 1374|       |static bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1375|      0|{
 1376|      0|    PB_UNUSED(field);
 1377|      0|    return pb_decode_fixed32(stream, dest);
 1378|      0|}
 1379|       |
 1380|       |static bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1381|      0|{
 1382|      0|    PB_UNUSED(field);
 1383|      0|#ifndef PB_WITHOUT_64BIT
 1384|      0|    return pb_decode_fixed64(stream, dest);
 1385|       |#else
 1386|       |    PB_UNUSED(dest);
 1387|       |    PB_RETURN_ERROR(stream, "no 64bit support");
 1388|       |#endif
 1389|       |}
 1390|       |
 1391|       |static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1392|      0|{
 1393|      0|    uint32_t size;
 1394|      0|    size_t alloc_size;
 1395|      0|    pb_bytes_array_t *bdest;
 1396|      0|    
 1397|      0|    if (!pb_decode_varint32(stream, &size))
 1398|      0|        return false;
 1399|      0|    
 1400|      0|    if (size > PB_SIZE_MAX)
 1401|      0|        PB_RETURN_ERROR(stream, "bytes overflow");
 1402|      0|    
 1403|      0|    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);
 1404|      0|    if (size > alloc_size)
 1405|      0|        PB_RETURN_ERROR(stream, "size too large");
 1406|      0|    
 1407|      0|    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
 1408|      0|    {
 1409|       |#ifndef PB_ENABLE_MALLOC
 1410|       |        PB_RETURN_ERROR(stream, "no malloc support");
 1411|       |#else
 1412|      0|        if (!allocate_field(stream, dest, alloc_size, 1))
 1413|      0|            return false;
 1414|      0|        bdest = *(pb_bytes_array_t**)dest;
 1415|      0|#endif
 1416|      0|    }
 1417|      0|    else
 1418|      0|    {
 1419|      0|        if (alloc_size > field->data_size)
 1420|      0|            PB_RETURN_ERROR(stream, "bytes overflow");
 1421|      0|        bdest = (pb_bytes_array_t*)dest;
 1422|      0|    }
 1423|      0|
 1424|      0|    bdest->size = (pb_size_t)size;
 1425|      0|    return pb_read(stream, bdest->bytes, size);
 1426|      0|}
 1427|       |
 1428|       |static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1429|      0|{
 1430|      0|    uint32_t size;
 1431|      0|    size_t alloc_size;
 1432|      0|    bool status;
 1433|      0|    if (!pb_decode_varint32(stream, &size))
 1434|      0|        return false;
 1435|      0|    
 1436|      0|    /* Space for null terminator */
 1437|      0|    alloc_size = size + 1;
 1438|      0|    
 1439|      0|    if (alloc_size < size)
 1440|      0|        PB_RETURN_ERROR(stream, "size too large");
 1441|      0|    
 1442|      0|    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
 1443|      0|    {
 1444|       |#ifndef PB_ENABLE_MALLOC
 1445|       |        PB_RETURN_ERROR(stream, "no malloc support");
 1446|       |#else
 1447|      0|        if (!allocate_field(stream, dest, alloc_size, 1))
 1448|      0|            return false;
 1449|      0|        dest = *(void**)dest;
 1450|      0|#endif
 1451|      0|    }
 1452|      0|    else
 1453|      0|    {
 1454|      0|        if (alloc_size > field->data_size)
 1455|      0|            PB_RETURN_ERROR(stream, "string overflow");
 1456|      0|    }
 1457|      0|    
 1458|      0|    status = pb_read(stream, (pb_byte_t*)dest, size);
 1459|      0|    *((pb_byte_t*)dest + size) = 0;
 1460|      0|    return status;
 1461|      0|}
 1462|       |
 1463|       |static bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1464|      0|{
 1465|      0|    bool status;
 1466|      0|    pb_istream_t substream;
 1467|      0|    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;
 1468|      0|    
 1469|      0|    if (!pb_make_string_substream(stream, &substream))
 1470|      0|        return false;
 1471|      0|    
 1472|      0|    if (field->ptr == NULL)
 1473|      0|        PB_RETURN_ERROR(stream, "invalid field descriptor");
 1474|      0|    
 1475|      0|    /* New array entries need to be initialized, while required and optional
 1476|      0|     * submessages have already been initialized in the top-level pb_decode. */
 1477|      0|    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)
 1478|      0|        status = pb_decode(&substream, submsg_fields, dest);
 1479|      0|    else
 1480|      0|        status = pb_decode_noinit(&substream, submsg_fields, dest);
 1481|      0|    
 1482|      0|    if (!pb_close_string_substream(stream, &substream))
 1483|      0|        return false;
 1484|      0|    return status;
 1485|      0|}
 1486|       |
 1487|       |static bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)
 1488|      0|{
 1489|      0|    uint32_t size;
 1490|      0|
 1491|      0|    if (!pb_decode_varint32(stream, &size))
 1492|      0|        return false;
 1493|      0|
 1494|      0|    if (size > PB_SIZE_MAX)
 1495|      0|        PB_RETURN_ERROR(stream, "bytes overflow");
 1496|      0|
 1497|      0|    if (size == 0)
 1498|      0|    {
 1499|      0|        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */
 1500|      0|        memset(dest, 0, field->data_size);
 1501|      0|        return true;
 1502|      0|    }
 1503|      0|
 1504|      0|    if (size != field->data_size)
 1505|      0|        PB_RETURN_ERROR(stream, "incorrect fixed length bytes size");
 1506|      0|
 1507|      0|    return pb_read(stream, (pb_byte_t*)dest, field->data_size);
 1508|      0|}

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/nanopb/pb_encode.c:
    1|       |/* pb_encode.c -- encode a protobuf using minimal resources
    2|       | *
    3|       | * 2011 Petteri Aimonen <jpa@kapsi.fi>
    4|       | */
    5|       |
    6|       |#include "pb.h"
    7|       |#include "pb_encode.h"
    8|       |#include "pb_common.h"
    9|       |
   10|       |/* Use the GCC warn_unused_result attribute to check that all return values
   11|       | * are propagated correctly. On other compilers and gcc before 3.4.0 just
   12|       | * ignore the annotation.
   13|       | */
   14|       |#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
   15|       |    #define checkreturn
   16|       |#else
   17|       |    #define checkreturn __attribute__((warn_unused_result))
   18|       |#endif
   19|       |
   20|       |/**************************************
   21|       | * Declarations internal to this file *
   22|       | **************************************/
   23|       |typedef bool (*pb_encoder_t)(pb_ostream_t *stream, const pb_field_t *field, const void *src) checkreturn;
   24|       |
   25|       |static bool checkreturn buf_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
   26|       |static bool checkreturn encode_array(pb_ostream_t *stream, const pb_field_t *field, const void *pData, size_t count, pb_encoder_t func);
   27|       |static bool checkreturn encode_field(pb_ostream_t *stream, const pb_field_t *field, const void *pData);
   28|       |static bool checkreturn default_extension_encoder(pb_ostream_t *stream, const pb_extension_t *extension);
   29|       |static bool checkreturn encode_extension_field(pb_ostream_t *stream, const pb_field_t *field, const void *pData);
   30|       |static void *pb_const_cast(const void *p);
   31|       |static bool checkreturn pb_enc_varint(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   32|       |static bool checkreturn pb_enc_uvarint(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   33|       |static bool checkreturn pb_enc_svarint(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   34|       |static bool checkreturn pb_enc_fixed32(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   35|       |static bool checkreturn pb_enc_fixed64(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   36|       |static bool checkreturn pb_enc_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   37|       |static bool checkreturn pb_enc_string(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   38|       |static bool checkreturn pb_enc_submessage(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   39|       |static bool checkreturn pb_enc_fixed_length_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src);
   40|       |
   41|       |#ifdef PB_WITHOUT_64BIT
   42|       |#define pb_int64_t int32_t
   43|       |#define pb_uint64_t uint32_t
   44|       |
   45|       |static bool checkreturn pb_encode_negative_varint(pb_ostream_t *stream, pb_uint64_t value);
   46|       |#else
   47|     77|#define pb_int64_t int64_t
   48|    296|#define pb_uint64_t uint64_t
   49|       |#endif
   50|       |
   51|       |/* --- Function pointers to field encoders ---
   52|       | * Order in the array must match pb_action_t LTYPE numbering.
   53|       | */
   54|       |static const pb_encoder_t PB_ENCODERS[PB_LTYPES_COUNT] = {
   55|       |    &pb_enc_varint,
   56|       |    &pb_enc_uvarint,
   57|       |    &pb_enc_svarint,
   58|       |    &pb_enc_fixed32,
   59|       |    &pb_enc_fixed64,
   60|       |    
   61|       |    &pb_enc_bytes,
   62|       |    &pb_enc_string,
   63|       |    &pb_enc_submessage,
   64|       |    NULL, /* extensions */
   65|       |    &pb_enc_fixed_length_bytes
   66|       |};
   67|       |
   68|       |/*******************************
   69|       | * pb_ostream_t implementation *
   70|       | *******************************/
   71|       |
   72|       |static bool checkreturn buf_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count)
   73|    242|{
   74|    242|    size_t i;
   75|    242|    pb_byte_t *dest = (pb_byte_t*)stream->state;
   76|    242|    stream->state = dest + count;
   77|    242|    
   78|  1.71k|    for (i = 0; i < count; i++)
   79|  1.47k|        dest[i] = buf[i];
   80|    242|    
   81|    242|    return true;
   82|    242|}
   83|       |
   84|       |pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize)
   85|      5|{
   86|      5|    pb_ostream_t stream;
   87|       |#ifdef PB_BUFFER_ONLY
   88|       |    stream.callback = (void*)1; /* Just a marker value */
   89|       |#else
   90|       |    stream.callback = &buf_write;
   91|      5|#endif
   92|      5|    stream.state = buf;
   93|      5|    stream.max_size = bufsize;
   94|      5|    stream.bytes_written = 0;
   95|      5|#ifndef PB_NO_ERRMSG
   96|      5|    stream.errmsg = NULL;
   97|      5|#endif
   98|      5|    return stream;
   99|      5|}
  100|       |
  101|       |bool checkreturn pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count)
  102|    607|{
  103|    607|    if (stream->callback != NULL)
  104|    607|    {
  105|    242|        if (stream->bytes_written + count > stream->max_size)
  106|    242|            PB_RETURN_ERROR(stream, "stream full");
  107|    242|
  108|       |#ifdef PB_BUFFER_ONLY
  109|       |        if (!buf_write(stream, buf, count))
  110|       |            PB_RETURN_ERROR(stream, "io error");
  111|       |#else        
  112|    242|        if (!stream->callback(stream, buf, count))
  113|    242|            PB_RETURN_ERROR(stream, "io error");
  114|    242|#endif
  115|    242|    }
  116|    607|    
  117|    607|    stream->bytes_written += count;
  118|    607|    return true;
  119|    607|}
  120|       |
  121|       |/*************************
  122|       | * Encode a single field *
  123|       | *************************/
  124|       |
  125|       |/* Encode a static array. Handles the size calculations and possible packing. */
  126|       |static bool checkreturn encode_array(pb_ostream_t *stream, const pb_field_t *field,
  127|       |                         const void *pData, size_t count, pb_encoder_t func)
  128|     13|{
  129|     13|    size_t i;
  130|     13|    const void *p;
  131|     13|    size_t size;
  132|     13|    
  133|     13|    if (count == 0)
  134|      0|        return true;
  135|     13|
  136|     13|    if (PB_ATYPE(field->type) != PB_ATYPE_POINTER && count > field->array_size)
  137|     13|        PB_RETURN_ERROR(stream, "array max size exceeded");
  138|     13|    
  139|     13|    /* We always pack arrays if the datatype allows it. */
  140|     13|    if (PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)
  141|     13|    {
  142|      8|        if (!pb_encode_tag(stream, PB_WT_STRING, field->tag))
  143|      0|            return false;
  144|      8|        
  145|      8|        /* Determine the total size of packed array. */
  146|      8|        if (PB_LTYPE(field->type) == PB_LTYPE_FIXED32)
  147|      8|        {
  148|      0|            size = 4 * count;
  149|      0|        }
  150|      8|        else if (PB_LTYPE(field->type) == PB_LTYPE_FIXED64)
  151|      8|        {
  152|      0|            size = 8 * count;
  153|      0|        }
  154|      8|        else
  155|      8|        { 
  156|      8|            pb_ostream_t sizestream = PB_OSTREAM_SIZING;
  157|      8|            p = pData;
  158|     32|            for (i = 0; i < count; i++)
  159|     24|            {
  160|     24|                if (!func(&sizestream, field, p))
  161|      0|                    return false;
  162|     24|                p = (const char*)p + field->data_size;
  163|     24|            }
  164|      8|            size = sizestream.bytes_written;
  165|      8|        }
  166|      8|        
  167|      8|        if (!pb_encode_varint(stream, (pb_uint64_t)size))
  168|      0|            return false;
  169|      8|        
  170|      8|        if (stream->callback == NULL)
  171|      8|            return pb_write(stream, NULL, size); /* Just sizing.. */
  172|      4|        
  173|      4|        /* Write the data */
  174|      4|        p = pData;
  175|     16|        for (i = 0; i < count; i++)
  176|     12|        {
  177|     12|            if (!func(stream, field, p))
  178|      0|                return false;
  179|     12|            p = (const char*)p + field->data_size;
  180|     12|        }
  181|      4|    }
  182|      5|    else
  183|      5|    {
  184|      5|        p = pData;
  185|     10|        for (i = 0; i < count; i++)
  186|      5|        {
  187|      5|            if (!pb_encode_tag_for_field(stream, field))
  188|      0|                return false;
  189|      5|
  190|      5|            /* Normally the data is stored directly in the array entries, but
  191|      5|             * for pointer-type string and bytes fields, the array entries are
  192|      5|             * actually pointers themselves also. So we have to dereference once
  193|      5|             * more to get to the actual data. */
  194|      5|            if (PB_ATYPE(field->type) == PB_ATYPE_POINTER &&
  195|      5|                (PB_LTYPE(field->type) == PB_LTYPE_STRING ||
  196|      5|                 PB_LTYPE(field->type) == PB_LTYPE_BYTES))
  197|      0|            {
  198|      0|                if (!func(stream, field, *(const void* const*)p))
  199|      0|                    return false;
  200|      5|            }
  201|      5|            else
  202|      5|            {
  203|      5|                if (!func(stream, field, p))
  204|      0|                    return false;
  205|      5|            }
  206|      5|            p = (const char*)p + field->data_size;
  207|      5|        }
  208|      5|    }
  209|     13|    
  210|     13|    return true;
  211|     13|}
  212|       |
  213|       |/* In proto3, all fields are optional and are only encoded if their value is "non-zero".
  214|       | * This function implements the check for the zero value. */
  215|       |static bool pb_check_proto3_default_value(const pb_field_t *field, const void *pData)
  216|    111|{
  217|    111|    pb_type_t type = field->type;
  218|    111|    const void *pSize = (const char*)pData + field->size_offset;
  219|    111|
  220|    111|    if (PB_HTYPE(type) == PB_HTYPE_REQUIRED)
  221|    111|    {
  222|      0|        /* Required proto2 fields inside proto3 submessage, pretty rare case */
  223|      0|        return false;
  224|      0|    }
  225|    111|    else if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
  226|    111|    {
  227|      0|        /* Repeated fields inside proto3 submessage: present if count != 0 */
  228|      0|        return *(const pb_size_t*)pSize == 0;
  229|      0|    }
  230|    111|    else if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
  231|    111|    {
  232|      0|        /* Oneof fields */
  233|      0|        return *(const pb_size_t*)pSize == 0;
  234|      0|    }
  235|    111|    else if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && field->size_offset)
  236|      0|    {
  237|      0|        /* Proto2 optional fields inside proto3 submessage */
  238|      0|        return *(const bool*)pSize == false;
  239|      0|    }
  240|    111|
  241|    111|    /* Rest is proto3 singular fields */
  242|    111|
  243|    111|    if (PB_ATYPE(type) == PB_ATYPE_STATIC)
  244|    111|    {
  245|      0|        if (PB_LTYPE(type) == PB_LTYPE_BYTES)
  246|      0|        {
  247|      0|            const pb_bytes_array_t *bytes = (const pb_bytes_array_t*)pData;
  248|      0|            return bytes->size == 0;
  249|      0|        }
  250|      0|        else if (PB_LTYPE(type) == PB_LTYPE_STRING)
  251|      0|        {
  252|      0|            return *(const char*)pData == '\0';
  253|      0|        }
  254|      0|        else if (PB_LTYPE(type) == PB_LTYPE_FIXED_LENGTH_BYTES)
  255|      0|        {
  256|      0|            /* Fixed length bytes is only empty if its length is fixed
  257|      0|             * as 0. Which would be pretty strange, but we can check
  258|      0|             * it anyway. */
  259|      0|            return field->data_size == 0;
  260|      0|        }
  261|      0|        else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
  262|      0|        {
  263|      0|            /* Check all fields in the submessage to find if any of them
  264|      0|             * are non-zero. The comparison cannot be done byte-per-byte
  265|      0|             * because the C struct may contain padding bytes that must
  266|      0|             * be skipped.
  267|      0|             */
  268|      0|            pb_field_iter_t iter;
  269|      0|            if (pb_field_iter_begin(&iter, (const pb_field_t*)field->ptr, pb_const_cast(pData)))
  270|      0|            {
  271|      0|                do
  272|      0|                {
  273|      0|                    if (!pb_check_proto3_default_value(iter.pos, iter.pData))
  274|      0|                    {
  275|      0|                        return false;
  276|      0|                    }
  277|      0|                } while (pb_field_iter_next(&iter));
  278|      0|            }
  279|      0|            return true;
  280|    111|        }
  281|      0|    }
  282|    111|    
  283|    111|	{
  284|    111|	    /* Catch-all branch that does byte-per-byte comparison for zero value.
  285|    111|	     *
  286|    111|	     * This is for all pointer fields, and for static PB_LTYPE_VARINT,
  287|    111|	     * UVARINT, SVARINT, FIXED32, FIXED64, EXTENSION fields, and also
  288|    111|	     * callback fields. These all have integer or pointer value which
  289|    111|	     * can be compared with 0.
  290|    111|	     */
  291|    111|	    pb_size_t i;
  292|    111|	    const char *p = (const char*)pData;
  293|    179|	    for (i = 0; i < field->data_size; i++)
  294|    171|	    {
  295|    171|	        if (p[i] != 0)
  296|    103|	        {
  297|    103|	            return false;
  298|    103|	        }
  299|    171|	    }
  300|    111|
  301|    111|	    return true;
  302|    111|	}
  303|    111|}
  304|       |
  305|       |/* Encode a field with static or pointer allocation, i.e. one whose data
  306|       | * is available to the encoder directly. */
  307|       |static bool checkreturn encode_basic_field(pb_ostream_t *stream,
  308|       |    const pb_field_t *field, const void *pData)
  309|    255|{
  310|    255|    pb_encoder_t func;
  311|    255|    bool implicit_has;
  312|    255|    const void *pSize = &implicit_has;
  313|    255|    
  314|    255|    func = PB_ENCODERS[PB_LTYPE(field->type)];
  315|    255|    
  316|    255|    if (field->size_offset)
  317|    144|    {
  318|    144|        /* Static optional, repeated or oneof field */
  319|    144|        pSize = (const char*)pData + field->size_offset;
  320|    144|    }
  321|    111|    else if (PB_HTYPE(field->type) == PB_HTYPE_OPTIONAL)
  322|    111|    {
  323|    111|        /* Proto3 style field, optional but without explicit has_ field. */
  324|    111|        implicit_has = !pb_check_proto3_default_value(field, pData);
  325|    111|    }
  326|      0|    else
  327|      0|    {
  328|      0|        /* Required field, always present */
  329|      0|        implicit_has = true;
  330|      0|    }
  331|    255|
  332|    255|    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
  333|    255|    {
  334|    124|        /* pData is a pointer to the field, which contains pointer to
  335|    124|         * the data. If the 2nd pointer is NULL, it is interpreted as if
  336|    124|         * the has_field was false.
  337|    124|         */
  338|    124|        pData = *(const void* const*)pData;
  339|    124|        implicit_has = (pData != NULL);
  340|    124|    }
  341|    255|
  342|    255|    switch (PB_HTYPE(field->type))
  343|    255|    {
  344|    255|        case PB_HTYPE_REQUIRED:
  345|      0|            if (!pData)
  346|      0|                PB_RETURN_ERROR(stream, "missing required field");
  347|      0|            if (!pb_encode_tag_for_field(stream, field))
  348|      0|                return false;
  349|      0|            if (!func(stream, field, pData))
  350|      0|                return false;
  351|      0|            break;
  352|      0|        
  353|    242|        case PB_HTYPE_OPTIONAL:
  354|    242|            if (*(const bool*)pSize)
  355|    215|            {
  356|    215|                if (!pb_encode_tag_for_field(stream, field))
  357|      0|                    return false;
  358|    215|            
  359|    215|                if (!func(stream, field, pData))
  360|      0|                    return false;
  361|    242|            }
  362|    242|            break;
  363|    242|        
  364|    242|        case PB_HTYPE_REPEATED: {
  365|     13|            pb_size_t count;
  366|     13|            if (field->size_offset != 0) {
  367|     13|                count = *(const pb_size_t*)pSize;
  368|     13|            } else {
  369|      0|                count = field->array_size;
  370|      0|            }
  371|     13|            if (!encode_array(stream, field, pData, count, func))
  372|      0|                return false;
  373|     13|            break;
  374|     13|        }
  375|     13|        
  376|     13|        case PB_HTYPE_ONEOF:
  377|      0|            if (*(const pb_size_t*)pSize == field->tag)
  378|      0|            {
  379|      0|                if (!pb_encode_tag_for_field(stream, field))
  380|      0|                    return false;
  381|      0|
  382|      0|                if (!func(stream, field, pData))
  383|      0|                    return false;
  384|      0|            }
  385|      0|            break;
  386|      0|            
  387|      0|        default:
  388|      0|            PB_RETURN_ERROR(stream, "invalid field type");
  389|    255|    }
  390|    255|    
  391|    255|    return true;
  392|    255|}
  393|       |
  394|       |/* Encode a field with callback semantics. This means that a user function is
  395|       | * called to provide and encode the actual data. */
  396|       |static bool checkreturn encode_callback_field(pb_ostream_t *stream,
  397|       |    const pb_field_t *field, const void *pData)
  398|      0|{
  399|      0|    const pb_callback_t *callback = (const pb_callback_t*)pData;
  400|      0|    
  401|       |#ifdef PB_OLD_CALLBACK_STYLE
  402|       |    const void *arg = callback->arg;
  403|       |#else
  404|       |    void * const *arg = &(callback->arg);
  405|      0|#endif    
  406|      0|    
  407|      0|    if (callback->funcs.encode != NULL)
  408|      0|    {
  409|      0|        if (!callback->funcs.encode(stream, field, arg))
  410|      0|            PB_RETURN_ERROR(stream, "callback error");
  411|      0|    }
  412|      0|    return true;
  413|      0|}
  414|       |
  415|       |/* Encode a single field of any callback or static type. */
  416|       |static bool checkreturn encode_field(pb_ostream_t *stream,
  417|       |    const pb_field_t *field, const void *pData)
  418|    255|{
  419|    255|    switch (PB_ATYPE(field->type))
  420|    255|    {
  421|    255|        case PB_ATYPE_STATIC:
  422|    255|        case PB_ATYPE_POINTER:
  423|    255|            return encode_basic_field(stream, field, pData);
  424|    255|        
  425|    255|        case PB_ATYPE_CALLBACK:
  426|      0|            return encode_callback_field(stream, field, pData);
  427|    255|        
  428|    255|        default:
  429|      0|            PB_RETURN_ERROR(stream, "invalid field type");
  430|    255|    }
  431|    255|}
  432|       |
  433|       |/* Default handler for extension fields. Expects to have a pb_field_t
  434|       | * pointer in the extension->type->arg field. */
  435|       |static bool checkreturn default_extension_encoder(pb_ostream_t *stream,
  436|       |    const pb_extension_t *extension)
  437|      0|{
  438|      0|    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
  439|      0|    
  440|      0|    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
  441|      0|    {
  442|      0|        /* For pointer extensions, the pointer is stored directly
  443|      0|         * in the extension structure. This avoids having an extra
  444|      0|         * indirection. */
  445|      0|        return encode_field(stream, field, &extension->dest);
  446|      0|    }
  447|      0|    else
  448|      0|    {
  449|      0|        return encode_field(stream, field, extension->dest);
  450|      0|    }
  451|      0|}
  452|       |
  453|       |/* Walk through all the registered extensions and give them a chance
  454|       | * to encode themselves. */
  455|       |static bool checkreturn encode_extension_field(pb_ostream_t *stream,
  456|       |    const pb_field_t *field, const void *pData)
  457|      0|{
  458|      0|    const pb_extension_t *extension = *(const pb_extension_t* const *)pData;
  459|      0|    PB_UNUSED(field);
  460|      0|    
  461|      0|    while (extension)
  462|      0|    {
  463|      0|        bool status;
  464|      0|        if (extension->type->encode)
  465|      0|            status = extension->type->encode(stream, extension);
  466|      0|        else
  467|      0|            status = default_extension_encoder(stream, extension);
  468|      0|
  469|      0|        if (!status)
  470|      0|            return false;
  471|      0|        
  472|      0|        extension = extension->next;
  473|      0|    }
  474|      0|    
  475|      0|    return true;
  476|      0|}
  477|       |
  478|       |/*********************
  479|       | * Encode all fields *
  480|       | *********************/
  481|       |
  482|       |static void *pb_const_cast(const void *p)
  483|     26|{
  484|     26|    /* Note: this casts away const, in order to use the common field iterator
  485|     26|     * logic for both encoding and decoding. */
  486|     26|    union {
  487|     26|        void *p1;
  488|     26|        const void *p2;
  489|     26|    } t;
  490|     26|    t.p2 = p;
  491|     26|    return t.p1;
  492|     26|}
  493|       |
  494|       |bool checkreturn pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
  495|     26|{
  496|     26|    pb_field_iter_t iter;
  497|     26|    if (!pb_field_iter_begin(&iter, fields, pb_const_cast(src_struct)))
  498|      0|        return true; /* Empty message type */
  499|     26|    
  500|    255|    do {
  501|    255|        if (PB_LTYPE(iter.pos->type) == PB_LTYPE_EXTENSION)
  502|    255|        {
  503|      0|            /* Special case for the extension field placeholder */
  504|      0|            if (!encode_extension_field(stream, iter.pos, iter.pData))
  505|      0|                return false;
  506|    255|        }
  507|    255|        else
  508|    255|        {
  509|    255|            /* Regular field */
  510|    255|            if (!encode_field(stream, iter.pos, iter.pData))
  511|      0|                return false;
  512|    255|        }
  513|    255|    } while (pb_field_iter_next(&iter));
  514|     26|    
  515|     26|    return true;
  516|     26|}
  517|       |
  518|       |bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
  519|      0|{
  520|      0|    return pb_encode_submessage(stream, fields, src_struct);
  521|      0|}
  522|       |
  523|       |bool pb_encode_nullterminated(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
  524|      0|{
  525|      0|    const pb_byte_t zero = 0;
  526|      0|
  527|      0|    if (!pb_encode(stream, fields, src_struct))
  528|      0|        return false;
  529|      0|
  530|      0|    return pb_write(stream, &zero, 1);
  531|      0|}
  532|       |
  533|       |bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct)
  534|      0|{
  535|      0|    pb_ostream_t stream = PB_OSTREAM_SIZING;
  536|      0|    
  537|      0|    if (!pb_encode(&stream, fields, src_struct))
  538|      0|        return false;
  539|      0|    
  540|      0|    *size = stream.bytes_written;
  541|      0|    return true;
  542|      0|}
  543|       |
  544|       |/********************
  545|       | * Helper functions *
  546|       | ********************/
  547|       |
  548|       |#ifdef PB_WITHOUT_64BIT
  549|       |bool checkreturn pb_encode_negative_varint(pb_ostream_t *stream, pb_uint64_t value)
  550|       |{
  551|       |  pb_byte_t buffer[10];
  552|       |  size_t i = 0;
  553|       |  size_t compensation = 32;/* we need to compensate 32 bits all set to 1 */
  554|       |
  555|       |  while (value)
  556|       |  {
  557|       |    buffer[i] = (pb_byte_t)((value & 0x7F) | 0x80);
  558|       |    value >>= 7;
  559|       |    if (compensation)
  560|       |    {
  561|       |      /* re-set all the compensation bits we can or need */
  562|       |      size_t bits = compensation > 7 ? 7 : compensation;
  563|       |      value ^= (pb_uint64_t)((0xFFu >> (8 - bits)) << 25); /* set the number of bits needed on the lowest of the most significant 7 bits */
  564|       |      compensation -= bits;
  565|       |    }
  566|       |    i++;
  567|       |  }
  568|       |  buffer[i - 1] &= 0x7F; /* Unset top bit on last byte */
  569|       |
  570|       |  return pb_write(stream, buffer, i);
  571|       |}
  572|       |#endif
  573|       |
  574|       |bool checkreturn pb_encode_varint(pb_ostream_t *stream, pb_uint64_t value)
  575|    492|{
  576|    492|    pb_byte_t buffer[10];
  577|    492|    size_t i = 0;
  578|    492|    
  579|    492|    if (value <= 0x7F)
  580|    346|    {
  581|    346|        pb_byte_t v = (pb_byte_t)value;
  582|    346|        return pb_write(stream, &v, 1);
  583|    346|    }
  584|    146|    
  585|    494|    while (value)
  586|    348|    {
  587|    348|        buffer[i] = (pb_byte_t)((value & 0x7F) | 0x80);
  588|    348|        value >>= 7;
  589|    348|        i++;
  590|    348|    }
  591|    146|    buffer[i-1] &= 0x7F; /* Unset top bit on last byte */
  592|    146|    
  593|    146|    return pb_write(stream, buffer, i);
  594|    146|}
  595|       |
  596|       |bool checkreturn pb_encode_svarint(pb_ostream_t *stream, pb_int64_t value)
  597|      4|{
  598|      4|    pb_uint64_t zigzagged;
  599|      4|    if (value < 0)
  600|      0|        zigzagged = ~((pb_uint64_t)value << 1);
  601|      4|    else
  602|      4|        zigzagged = (pb_uint64_t)value << 1;
  603|      4|    
  604|      4|    return pb_encode_varint(stream, zigzagged);
  605|      4|}
  606|       |
  607|       |bool checkreturn pb_encode_fixed32(pb_ostream_t *stream, const void *value)
  608|      0|{
  609|      0|    uint32_t val = *(const uint32_t*)value;
  610|      0|    pb_byte_t bytes[4];
  611|      0|    bytes[0] = (pb_byte_t)(val & 0xFF);
  612|      0|    bytes[1] = (pb_byte_t)((val >> 8) & 0xFF);
  613|      0|    bytes[2] = (pb_byte_t)((val >> 16) & 0xFF);
  614|      0|    bytes[3] = (pb_byte_t)((val >> 24) & 0xFF);
  615|      0|    return pb_write(stream, bytes, 4);
  616|      0|}
  617|       |
  618|       |#ifndef PB_WITHOUT_64BIT
  619|       |bool checkreturn pb_encode_fixed64(pb_ostream_t *stream, const void *value)
  620|      0|{
  621|      0|    uint64_t val = *(const uint64_t*)value;
  622|      0|    pb_byte_t bytes[8];
  623|      0|    bytes[0] = (pb_byte_t)(val & 0xFF);
  624|      0|    bytes[1] = (pb_byte_t)((val >> 8) & 0xFF);
  625|      0|    bytes[2] = (pb_byte_t)((val >> 16) & 0xFF);
  626|      0|    bytes[3] = (pb_byte_t)((val >> 24) & 0xFF);
  627|      0|    bytes[4] = (pb_byte_t)((val >> 32) & 0xFF);
  628|      0|    bytes[5] = (pb_byte_t)((val >> 40) & 0xFF);
  629|      0|    bytes[6] = (pb_byte_t)((val >> 48) & 0xFF);
  630|      0|    bytes[7] = (pb_byte_t)((val >> 56) & 0xFF);
  631|      0|    return pb_write(stream, bytes, 8);
  632|      0|}
  633|       |#endif
  634|       |
  635|       |bool checkreturn pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number)
  636|    228|{
  637|    228|    pb_uint64_t tag = ((pb_uint64_t)field_number << 3) | wiretype;
  638|    228|    return pb_encode_varint(stream, tag);
  639|    228|}
  640|       |
  641|       |bool checkreturn pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field)
  642|    220|{
  643|    220|    pb_wire_type_t wiretype;
  644|    220|    switch (PB_LTYPE(field->type))
  645|    220|    {
  646|    220|        case PB_LTYPE_VARINT:
  647|    105|        case PB_LTYPE_UVARINT:
  648|    105|        case PB_LTYPE_SVARINT:
  649|    105|            wiretype = PB_WT_VARINT;
  650|    105|            break;
  651|    105|        
  652|    105|        case PB_LTYPE_FIXED32:
  653|      0|            wiretype = PB_WT_32BIT;
  654|      0|            break;
  655|    105|        
  656|    105|        case PB_LTYPE_FIXED64:
  657|      0|            wiretype = PB_WT_64BIT;
  658|      0|            break;
  659|    105|        
  660|    115|        case PB_LTYPE_BYTES:
  661|    115|        case PB_LTYPE_STRING:
  662|    115|        case PB_LTYPE_SUBMESSAGE:
  663|    115|        case PB_LTYPE_FIXED_LENGTH_BYTES:
  664|    115|            wiretype = PB_WT_STRING;
  665|    115|            break;
  666|    115|        
  667|    115|        default:
  668|      0|            PB_RETURN_ERROR(stream, "invalid field type");
  669|    220|    }
  670|    220|    
  671|    220|    return pb_encode_tag(stream, wiretype, field->tag);
  672|    220|}
  673|       |
  674|       |bool checkreturn pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size)
  675|    103|{
  676|    103|    if (!pb_encode_varint(stream, (pb_uint64_t)size))
  677|      0|        return false;
  678|    103|    
  679|    103|    return pb_write(stream, buffer, size);
  680|    103|}
  681|       |
  682|       |bool checkreturn pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
  683|     12|{
  684|     12|    /* First calculate the message size using a non-writing substream. */
  685|     12|    pb_ostream_t substream = PB_OSTREAM_SIZING;
  686|     12|    size_t size;
  687|     12|    bool status;
  688|     12|    
  689|     12|    if (!pb_encode(&substream, fields, src_struct))
  690|      0|    {
  691|      0|#ifndef PB_NO_ERRMSG
  692|      0|        stream->errmsg = substream.errmsg;
  693|      0|#endif
  694|      0|        return false;
  695|      0|    }
  696|     12|    
  697|     12|    size = substream.bytes_written;
  698|     12|    
  699|     12|    if (!pb_encode_varint(stream, (pb_uint64_t)size))
  700|      0|        return false;
  701|     12|    
  702|     12|    if (stream->callback == NULL)
  703|     12|        return pb_write(stream, NULL, size); /* Just sizing */
  704|      4|    
  705|      4|    if (stream->bytes_written + size > stream->max_size)
  706|      4|        PB_RETURN_ERROR(stream, "stream full");
  707|      4|        
  708|      4|    /* Use a substream to verify that a callback doesn't write more than
  709|      4|     * what it did the first time. */
  710|      4|    substream.callback = stream->callback;
  711|      4|    substream.state = stream->state;
  712|      4|    substream.max_size = size;
  713|      4|    substream.bytes_written = 0;
  714|      4|#ifndef PB_NO_ERRMSG
  715|      4|    substream.errmsg = NULL;
  716|      4|#endif
  717|      4|    
  718|      4|    status = pb_encode(&substream, fields, src_struct);
  719|      4|    
  720|      4|    stream->bytes_written += substream.bytes_written;
  721|      4|    stream->state = substream.state;
  722|      4|#ifndef PB_NO_ERRMSG
  723|      4|    stream->errmsg = substream.errmsg;
  724|      4|#endif
  725|      4|    
  726|      4|    if (substream.bytes_written != size)
  727|      4|        PB_RETURN_ERROR(stream, "submsg size changed");
  728|      4|    
  729|      4|    return status;
  730|      4|}
  731|       |
  732|       |/* Field encoders */
  733|       |
  734|       |static bool checkreturn pb_enc_varint(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  735|     73|{
  736|     73|    pb_int64_t value = 0;
  737|     73|    
  738|     73|    if (field->data_size == sizeof(int_least8_t))
  739|     40|        value = *(const int_least8_t*)src;
  740|     33|    else if (field->data_size == sizeof(int_least16_t))
  741|      0|        value = *(const int_least16_t*)src;
  742|     33|    else if (field->data_size == sizeof(int32_t))
  743|     19|        value = *(const int32_t*)src;
  744|     14|    else if (field->data_size == sizeof(pb_int64_t))
  745|     14|        value = *(const pb_int64_t*)src;
  746|     14|    else
  747|     14|        PB_RETURN_ERROR(stream, "invalid data_size");
  748|     73|    
  749|       |#ifdef PB_WITHOUT_64BIT
  750|       |    if (value < 0)
  751|       |      return pb_encode_negative_varint(stream, (pb_uint64_t)value);
  752|       |    else
  753|       |#endif
  754|     73|      return pb_encode_varint(stream, (pb_uint64_t)value);
  755|     73|}
  756|       |
  757|       |static bool checkreturn pb_enc_uvarint(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  758|     64|{
  759|     64|    pb_uint64_t value = 0;
  760|     64|    
  761|     64|    if (field->data_size == sizeof(uint_least8_t))
  762|      0|        value = *(const uint_least8_t*)src;
  763|     64|    else if (field->data_size == sizeof(uint_least16_t))
  764|      0|        value = *(const uint_least16_t*)src;
  765|     64|    else if (field->data_size == sizeof(uint32_t))
  766|     64|        value = *(const uint32_t*)src;
  767|      0|    else if (field->data_size == sizeof(pb_uint64_t))
  768|      0|        value = *(const pb_uint64_t*)src;
  769|      0|    else
  770|      0|        PB_RETURN_ERROR(stream, "invalid data_size");
  771|     64|    
  772|     64|    return pb_encode_varint(stream, value);
  773|     64|}
  774|       |
  775|       |static bool checkreturn pb_enc_svarint(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  776|      4|{
  777|      4|    pb_int64_t value = 0;
  778|      4|    
  779|      4|    if (field->data_size == sizeof(int_least8_t))
  780|      0|        value = *(const int_least8_t*)src;
  781|      4|    else if (field->data_size == sizeof(int_least16_t))
  782|      0|        value = *(const int_least16_t*)src;
  783|      4|    else if (field->data_size == sizeof(int32_t))
  784|      0|        value = *(const int32_t*)src;
  785|      4|    else if (field->data_size == sizeof(pb_int64_t))
  786|      4|        value = *(const pb_int64_t*)src;
  787|      4|    else
  788|      4|        PB_RETURN_ERROR(stream, "invalid data_size");
  789|      4|    
  790|      4|    return pb_encode_svarint(stream, value);
  791|      4|}
  792|       |
  793|       |static bool checkreturn pb_enc_fixed64(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  794|      0|{
  795|      0|    PB_UNUSED(field);
  796|      0|#ifndef PB_WITHOUT_64BIT
  797|      0|    return pb_encode_fixed64(stream, src);
  798|       |#else
  799|       |    PB_UNUSED(src);
  800|       |    PB_RETURN_ERROR(stream, "no 64bit support");
  801|       |#endif
  802|       |}
  803|       |
  804|       |static bool checkreturn pb_enc_fixed32(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  805|      0|{
  806|      0|    PB_UNUSED(field);
  807|      0|    return pb_encode_fixed32(stream, src);
  808|      0|}
  809|       |
  810|       |static bool checkreturn pb_enc_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  811|    103|{
  812|    103|    const pb_bytes_array_t *bytes = NULL;
  813|    103|
  814|    103|    bytes = (const pb_bytes_array_t*)src;
  815|    103|    
  816|    103|    if (src == NULL)
  817|    103|    {
  818|      0|        /* Treat null pointer as an empty bytes field */
  819|      0|        return pb_encode_string(stream, NULL, 0);
  820|      0|    }
  821|    103|    
  822|    103|    if (PB_ATYPE(field->type) == PB_ATYPE_STATIC &&
  823|    103|        PB_BYTES_ARRAY_T_ALLOCSIZE(bytes->size) > field->data_size)
  824|      0|    {
  825|      0|        PB_RETURN_ERROR(stream, "bytes size exceeded");
  826|      0|    }
  827|    103|    
  828|    103|    return pb_encode_string(stream, bytes->bytes, bytes->size);
  829|    103|}
  830|       |
  831|       |static bool checkreturn pb_enc_string(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  832|      0|{
  833|      0|    size_t size = 0;
  834|      0|    size_t max_size = field->data_size;
  835|      0|    const char *p = (const char*)src;
  836|      0|    
  837|      0|    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
  838|      0|        max_size = (size_t)-1;
  839|      0|
  840|      0|    if (src == NULL)
  841|      0|    {
  842|      0|        size = 0; /* Treat null pointer as an empty string */
  843|      0|    }
  844|      0|    else
  845|      0|    {
  846|      0|        /* strnlen() is not always available, so just use a loop */
  847|      0|        while (size < max_size && *p != '\0')
  848|      0|        {
  849|      0|            size++;
  850|      0|            p++;
  851|      0|        }
  852|      0|    }
  853|      0|
  854|      0|    return pb_encode_string(stream, (const pb_byte_t*)src, size);
  855|      0|}
  856|       |
  857|       |static bool checkreturn pb_enc_submessage(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  858|     12|{
  859|     12|    if (field->ptr == NULL)
  860|     12|        PB_RETURN_ERROR(stream, "invalid field descriptor");
  861|     12|    
  862|     12|    return pb_encode_submessage(stream, (const pb_field_t*)field->ptr, src);
  863|     12|}
  864|       |
  865|       |static bool checkreturn pb_enc_fixed_length_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src)
  866|      0|{
  867|      0|    return pb_encode_string(stream, (const pb_byte_t*)src, field->data_size);
  868|      0|}
  869|       |

/Users/bgouws/Desktop/PlayTimeRedux/PlayTime/Play Time/Pods/nanopb/pb_encode.h:
    1|       |/* pb_encode.h: Functions to encode protocol buffers. Depends on pb_encode.c.
    2|       | * The main function is pb_encode. You also need an output stream, and the
    3|       | * field descriptions created by nanopb_generator.py.
    4|       | */
    5|       |
    6|       |#ifndef PB_ENCODE_H_INCLUDED
    7|       |#define PB_ENCODE_H_INCLUDED
    8|       |
    9|       |#include "pb.h"
   10|       |
   11|       |#ifdef __cplusplus
   12|       |extern "C" {
   13|       |#endif
   14|       |
   15|       |/* Structure for defining custom output streams. You will need to provide
   16|       | * a callback function to write the bytes to your storage, which can be
   17|       | * for example a file or a network socket.
   18|       | *
   19|       | * The callback must conform to these rules:
   20|       | *
   21|       | * 1) Return false on IO errors. This will cause encoding to abort.
   22|       | * 2) You can use state to store your own data (e.g. buffer pointer).
   23|       | * 3) pb_write will update bytes_written after your callback runs.
   24|       | * 4) Substreams will modify max_size and bytes_written. Don't use them
   25|       | *    to calculate any pointers.
   26|       | */
   27|       |struct pb_ostream_s
   28|       |{
   29|       |#ifdef PB_BUFFER_ONLY
   30|       |    /* Callback pointer is not used in buffer-only configuration.
   31|       |     * Having an int pointer here allows binary compatibility but
   32|       |     * gives an error if someone tries to assign callback function.
   33|       |     * Also, NULL pointer marks a 'sizing stream' that does not
   34|       |     * write anything.
   35|       |     */
   36|       |    int *callback;
   37|       |#else
   38|       |    bool (*callback)(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
   39|       |#endif
   40|       |    void *state;          /* Free field for use by callback implementation. */
   41|       |    size_t max_size;      /* Limit number of output bytes written (or use SIZE_MAX). */
   42|       |    size_t bytes_written; /* Number of bytes written so far. */
   43|       |    
   44|       |#ifndef PB_NO_ERRMSG
   45|       |    const char *errmsg;
   46|       |#endif
   47|       |};
   48|       |
   49|       |/***************************
   50|       | * Main encoding functions *
   51|       | ***************************/
   52|       |
   53|       |/* Encode a single protocol buffers message from C structure into a stream.
   54|       | * Returns true on success, false on any failure.
   55|       | * The actual struct pointed to by src_struct must match the description in fields.
   56|       | * All required fields in the struct are assumed to have been filled in.
   57|       | *
   58|       | * Example usage:
   59|       | *    MyMessage msg = {};
   60|       | *    uint8_t buffer[64];
   61|       | *    pb_ostream_t stream;
   62|       | *
   63|       | *    msg.field1 = 42;
   64|       | *    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
   65|       | *    pb_encode(&stream, MyMessage_fields, &msg);
   66|       | */
   67|       |bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   68|       |
   69|       |/* Same as pb_encode, but prepends the length of the message as a varint.
   70|       | * Corresponds to writeDelimitedTo() in Google's protobuf API.
   71|       | */
   72|       |bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   73|       |
   74|       |/* Same as pb_encode, but appends a null byte to the message for termination.
   75|       | * NOTE: This behaviour is not supported in most other protobuf implementations, so pb_encode_delimited()
   76|       | * is a better option for compatibility.
   77|       | */
   78|       |bool pb_encode_nullterminated(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   79|       |
   80|       |/* Encode the message to get the size of the encoded data, but do not store
   81|       | * the data. */
   82|       |bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct);
   83|       |
   84|       |/**************************************
   85|       | * Functions for manipulating streams *
   86|       | **************************************/
   87|       |
   88|       |/* Create an output stream for writing into a memory buffer.
   89|       | * The number of bytes written can be found in stream.bytes_written after
   90|       | * encoding the message.
   91|       | *
   92|       | * Alternatively, you can use a custom stream that writes directly to e.g.
   93|       | * a file or a network socket.
   94|       | */
   95|       |pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
   96|       |
   97|       |/* Pseudo-stream for measuring the size of a message without actually storing
   98|       | * the encoded data.
   99|       | * 
  100|       | * Example usage:
  101|       | *    MyMessage msg = {};
  102|       | *    pb_ostream_t stream = PB_OSTREAM_SIZING;
  103|       | *    pb_encode(&stream, MyMessage_fields, &msg);
  104|       | *    printf("Message size is %d\n", stream.bytes_written);
  105|       | */
  106|       |#ifndef PB_NO_ERRMSG
  107|     20|#define PB_OSTREAM_SIZING {0,0,0,0,0}
  108|       |#else
  109|       |#define PB_OSTREAM_SIZING {0,0,0,0}
  110|       |#endif
  111|       |
  112|       |/* Function to write into a pb_ostream_t stream. You can use this if you need
  113|       | * to append or prepend some custom headers to the message.
  114|       | */
  115|       |bool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
  116|       |
  117|       |
  118|       |/************************************************
  119|       | * Helper functions for writing field callbacks *
  120|       | ************************************************/
  121|       |
  122|       |/* Encode field header based on type and field number defined in the field
  123|       | * structure. Call this from the callback before writing out field contents. */
  124|       |bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);
  125|       |
  126|       |/* Encode field header by manually specifing wire type. You need to use this
  127|       | * if you want to write out packed arrays from a callback field. */
  128|       |bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);
  129|       |
  130|       |/* Encode an integer in the varint format.
  131|       | * This works for bool, enum, int32, int64, uint32 and uint64 field types. */
  132|       |#ifndef PB_WITHOUT_64BIT
  133|       |bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);
  134|       |#else
  135|       |bool pb_encode_varint(pb_ostream_t *stream, uint32_t value);
  136|       |#endif
  137|       |
  138|       |/* Encode an integer in the zig-zagged svarint format.
  139|       | * This works for sint32 and sint64. */
  140|       |#ifndef PB_WITHOUT_64BIT
  141|       |bool pb_encode_svarint(pb_ostream_t *stream, int64_t value);
  142|       |#else
  143|       |bool pb_encode_svarint(pb_ostream_t *stream, int32_t value);
  144|       |#endif
  145|       |
  146|       |/* Encode a string or bytes type field. For strings, pass strlen(s) as size. */
  147|       |bool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);
  148|       |
  149|       |/* Encode a fixed32, sfixed32 or float value.
  150|       | * You need to pass a pointer to a 4-byte wide C variable. */
  151|       |bool pb_encode_fixed32(pb_ostream_t *stream, const void *value);
  152|       |
  153|       |#ifndef PB_WITHOUT_64BIT
  154|       |/* Encode a fixed64, sfixed64 or double value.
  155|       | * You need to pass a pointer to a 8-byte wide C variable. */
  156|       |bool pb_encode_fixed64(pb_ostream_t *stream, const void *value);
  157|       |#endif
  158|       |
  159|       |/* Encode a submessage field.
  160|       | * You need to pass the pb_field_t array and pointer to struct, just like
  161|       | * with pb_encode(). This internally encodes the submessage twice, first to
  162|       | * calculate message size and then to actually write it out.
  163|       | */
  164|       |bool pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
  165|       |
  166|       |#ifdef __cplusplus
  167|       |} /* extern "C" */
  168|       |#endif
  169|       |
  170|       |#endif

